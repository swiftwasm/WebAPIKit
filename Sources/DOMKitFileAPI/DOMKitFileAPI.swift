// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOMKitWebIDL
import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit

public class Blob: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Blob].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(blobParts: [BlobPart]? = nil, options: BlobPropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [blobParts?.jsValue ?? .undefined, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var size: UInt64

    @ReadonlyAttribute
    public var type: String

    @inlinable public func slice(start: Int64? = nil, end: Int64? = nil, contentType: String? = nil) -> Self {
        let this = jsObject
        return this[Strings.slice].function!(this: this, arguments: [start?.jsValue ?? .undefined, end?.jsValue ?? .undefined, contentType?.jsValue ?? .undefined]).fromJSValue()!
    }

    // XXX: member 'stream' is ignored

    @inlinable public func text() -> JSPromise {
        let this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BlobPropertyBag: BridgedDictionary {
    public convenience init(type: String, endings: EndingType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.endings] = endings.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _endings = ReadWriteAttribute(jsObject: object, name: Strings.endings)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var endings: EndingType
}

public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class File: Blob {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.File].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastModified)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(fileBits: [BlobPart], fileName: String, options: FilePropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [fileBits.jsValue, fileName.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var lastModified: Int64
}

public class FileList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.FileList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> File? {
        jsObject[key].fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32
}

public class FilePropertyBag: BridgedDictionary {
    public convenience init(lastModified: Int64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.lastModified] = lastModified.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lastModified = ReadWriteAttribute(jsObject: object, name: Strings.lastModified)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lastModified: Int64
}

public class FileReader: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.FileReader].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _result = ReadonlyAttribute(jsObject: jsObject, name: Strings.result)
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        _onloadstart = ReadWriteAttribute(jsObject: jsObject, name: Strings.onloadstart)
        _onprogress = ReadWriteAttribute(jsObject: jsObject, name: Strings.onprogress)
        _onload = ReadWriteAttribute(jsObject: jsObject, name: Strings.onload)
        _onabort = ReadWriteAttribute(jsObject: jsObject, name: Strings.onabort)
        _onerror = ReadWriteAttribute(jsObject: jsObject, name: Strings.onerror)
        _onloadend = ReadWriteAttribute(jsObject: jsObject, name: Strings.onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func readAsArrayBuffer(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsArrayBuffer].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsBinaryString(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsBinaryString].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsText(blob: Blob, encoding: String? = nil) {
        let this = jsObject
        _ = this[Strings.readAsText].function!(this: this, arguments: [blob.jsValue, encoding?.jsValue ?? .undefined])
    }

    @inlinable public func readAsDataURL(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsDataURL].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    public static let EMPTY: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let DONE: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var result: ArrayBuffer_or_String?

    @ReadonlyAttribute
    public var error: DOMException?

    @ReadWriteAttribute
    public var onloadstart: EventHandler

    @ReadWriteAttribute
    public var onprogress: EventHandler

    @ReadWriteAttribute
    public var onload: EventHandler

    @ReadWriteAttribute
    public var onabort: EventHandler

    @ReadWriteAttribute
    public var onerror: EventHandler

    @ReadWriteAttribute
    public var onloadend: EventHandler
}

public class URL: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.URL].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public static func createObjectURL(obj: Blob_or_MediaSource) -> String {
        let this = constructor
        return this[Strings.createObjectURL].function!(this: this, arguments: [obj.jsValue]).fromJSValue()!
    }

    @inlinable public static func revokeObjectURL(url: String) {
        let this = constructor
        _ = this[Strings.revokeObjectURL].function!(this: this, arguments: [url.jsValue])
    }
}

/* variadic generics please */

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let Blob: JSString = "Blob"
    @usableFromInline static let File: JSString = "File"
    @usableFromInline static let FileList: JSString = "FileList"
    @usableFromInline static let FileReader: JSString = "FileReader"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let URL: JSString = "URL"
    @usableFromInline static let abort: JSString = "abort"
    @usableFromInline static let arrayBuffer: JSString = "arrayBuffer"
    @usableFromInline static let createObjectURL: JSString = "createObjectURL"
    @usableFromInline static let endings: JSString = "endings"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let lastModified: JSString = "lastModified"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onload: JSString = "onload"
    @usableFromInline static let onloadend: JSString = "onloadend"
    @usableFromInline static let onloadstart: JSString = "onloadstart"
    @usableFromInline static let onprogress: JSString = "onprogress"
    @usableFromInline static let readAsArrayBuffer: JSString = "readAsArrayBuffer"
    @usableFromInline static let readAsBinaryString: JSString = "readAsBinaryString"
    @usableFromInline static let readAsDataURL: JSString = "readAsDataURL"
    @usableFromInline static let readAsText: JSString = "readAsText"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let result: JSString = "result"
    @usableFromInline static let revokeObjectURL: JSString = "revokeObjectURL"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let slice: JSString = "slice"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let type: JSString = "type"
}

public protocol Any_ArrayBuffer_or_String: ConvertibleToJSValue {}
extension ArrayBuffer: Any_ArrayBuffer_or_String {}
extension String: Any_ArrayBuffer_or_String {}

public enum ArrayBuffer_or_String: JSValueCompatible, Any_ArrayBuffer_or_String {
    case arrayBuffer(ArrayBuffer)
    case string(String)

    var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_BlobPart: ConvertibleToJSValue {}
extension Blob: Any_BlobPart {}
extension BufferSource: Any_BlobPart {}
extension String: Any_BlobPart {}

public enum BlobPart: JSValueCompatible, Any_BlobPart {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}
