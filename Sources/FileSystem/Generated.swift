// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public class DirectoryPickerOptions: BridgedDictionary {
    public convenience init(id: String, startIn: StartInDirectory, mode: FileSystemPermissionMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.id] = _toJSValue(id)
        object[Strings.startIn] = _toJSValue(startIn)
        object[Strings.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _id = ReadWriteAttribute(jsObject: object, name: Strings.id)
        _startIn = ReadWriteAttribute(jsObject: object, name: Strings.startIn)
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var startIn: StartInDirectory

    @ReadWriteAttribute
    public var mode: FileSystemPermissionMode
}

public class FilePickerAcceptType: BridgedDictionary {
    public convenience init(description: String, accept: [String: String_or_seq_of_String]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.description] = _toJSValue(description)
        object[Strings.accept] = _toJSValue(accept)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _description = ReadWriteAttribute(jsObject: object, name: Strings.description)
        _accept = ReadWriteAttribute(jsObject: object, name: Strings.accept)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var description: String

    @ReadWriteAttribute
    public var accept: [String: String_or_seq_of_String]
}

public class FilePickerOptions: BridgedDictionary {
    public convenience init(types: [FilePickerAcceptType], excludeAcceptAllOption: Bool, id: String, startIn: StartInDirectory) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.types] = _toJSValue(types)
        object[Strings.excludeAcceptAllOption] = _toJSValue(excludeAcceptAllOption)
        object[Strings.id] = _toJSValue(id)
        object[Strings.startIn] = _toJSValue(startIn)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _types = ReadWriteAttribute(jsObject: object, name: Strings.types)
        _excludeAcceptAllOption = ReadWriteAttribute(jsObject: object, name: Strings.excludeAcceptAllOption)
        _id = ReadWriteAttribute(jsObject: object, name: Strings.id)
        _startIn = ReadWriteAttribute(jsObject: object, name: Strings.startIn)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var types: [FilePickerAcceptType]

    @ReadWriteAttribute
    public var excludeAcceptAllOption: Bool

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var startIn: StartInDirectory
}

public class FileSystemCreateWritableOptions: BridgedDictionary {
    public convenience init(keepExistingData: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.keepExistingData] = _toJSValue(keepExistingData)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _keepExistingData = ReadWriteAttribute(jsObject: object, name: Strings.keepExistingData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var keepExistingData: Bool
}

public class FileSystemDirectoryHandle: FileSystemHandle, AsyncSequence {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.FileSystemDirectoryHandle].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    public typealias Element = String
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func makeAsyncIterator() -> ValueIterableAsyncIterator<FileSystemDirectoryHandle> {
        ValueIterableAsyncIterator(sequence: self)
    }

    @inlinable public func getFileHandle(name: String, options: FileSystemGetFileOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.getFileHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getFileHandle(name: String, options: FileSystemGetFileOptions? = nil) async throws -> FileSystemFileHandle {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getFileHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getDirectoryHandle(name: String, options: FileSystemGetDirectoryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.getDirectoryHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getDirectoryHandle(name: String, options: FileSystemGetDirectoryOptions? = nil) async throws -> FileSystemDirectoryHandle {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getDirectoryHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func removeEntry(name: String, options: FileSystemRemoveOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.removeEntry].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func removeEntry(name: String, options: FileSystemRemoveOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.removeEntry].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func resolve(possibleDescendant: FileSystemHandle) -> JSPromise {
        let this = jsObject
        return this[Strings.resolve].function!(this: this, arguments: [_toJSValue(possibleDescendant)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resolve(possibleDescendant: FileSystemHandle) async throws -> [String]? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.resolve].function!(this: this, arguments: [_toJSValue(possibleDescendant)]).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }
}

public class FileSystemFileHandle: FileSystemHandle {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.FileSystemFileHandle].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func getFile() -> JSPromise {
        let this = jsObject
        return this[Strings.getFile].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getFile() async throws -> File {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getFile].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createWritable(options: FileSystemCreateWritableOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.createWritable].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createWritable(options: FileSystemCreateWritableOptions? = nil) async throws -> FileSystemWritableFileStream {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createWritable].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    // XXX: member 'createSyncAccessHandle' is ignored

    // XXX: member 'createSyncAccessHandle' is ignored
}

public class FileSystemGetDirectoryOptions: BridgedDictionary {
    public convenience init(create: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.create] = _toJSValue(create)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _create = ReadWriteAttribute(jsObject: object, name: Strings.create)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var create: Bool
}

public class FileSystemGetFileOptions: BridgedDictionary {
    public convenience init(create: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.create] = _toJSValue(create)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _create = ReadWriteAttribute(jsObject: object, name: Strings.create)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var create: Bool
}

public class FileSystemHandle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.FileSystemHandle].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var kind: FileSystemHandleKind

    @ReadonlyAttribute
    public var name: String

    @inlinable public func isSameEntry(other: FileSystemHandle) -> JSPromise {
        let this = jsObject
        return this[Strings.isSameEntry].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func isSameEntry(other: FileSystemHandle) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[Strings.isSameEntry].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func queryPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.queryPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func queryPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) async throws -> PermissionState {
        let this = jsObject
        let _promise: JSPromise = this[Strings.queryPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func requestPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) async throws -> PermissionState {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum FileSystemHandleKind: JSString, JSValueCompatible {
    case file = "file"
    case directory = "directory"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class FileSystemHandlePermissionDescriptor: BridgedDictionary {
    public convenience init(mode: FileSystemPermissionMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: FileSystemPermissionMode
}

public class FileSystemPermissionDescriptor: BridgedDictionary {
    public convenience init(handle: FileSystemHandle, mode: FileSystemPermissionMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.handle] = _toJSValue(handle)
        object[Strings.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _handle = ReadWriteAttribute(jsObject: object, name: Strings.handle)
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var handle: FileSystemHandle

    @ReadWriteAttribute
    public var mode: FileSystemPermissionMode
}

public enum FileSystemPermissionMode: JSString, JSValueCompatible {
    case read = "read"
    case readwrite = "readwrite"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class FileSystemReadWriteOptions: BridgedDictionary {
    public convenience init(at: UInt64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.at] = _toJSValue(at)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _at = ReadWriteAttribute(jsObject: object, name: Strings.at)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var at: UInt64
}

public class FileSystemRemoveOptions: BridgedDictionary {
    public convenience init(recursive: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.recursive] = _toJSValue(recursive)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _recursive = ReadWriteAttribute(jsObject: object, name: Strings.recursive)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var recursive: Bool
}

public class FileSystemWritableFileStream: WritableStream {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.FileSystemWritableFileStream].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func write(data: FileSystemWriteChunkType) -> JSPromise {
        let this = jsObject
        return this[Strings.write].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func write(data: FileSystemWriteChunkType) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.write].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func seek(position: UInt64) -> JSPromise {
        let this = jsObject
        return this[Strings.seek].function!(this: this, arguments: [_toJSValue(position)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func seek(position: UInt64) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.seek].function!(this: this, arguments: [_toJSValue(position)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func truncate(size: UInt64) -> JSPromise {
        let this = jsObject
        return this[Strings.truncate].function!(this: this, arguments: [_toJSValue(size)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func truncate(size: UInt64) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.truncate].function!(this: this, arguments: [_toJSValue(size)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class OpenFilePickerOptions: BridgedDictionary {
    public convenience init(multiple: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.multiple] = _toJSValue(multiple)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _multiple = ReadWriteAttribute(jsObject: object, name: Strings.multiple)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var multiple: Bool
}

public class SaveFilePickerOptions: BridgedDictionary {
    public convenience init(suggestedName: String?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.suggestedName] = _toJSValue(suggestedName)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _suggestedName = ReadWriteAttribute(jsObject: object, name: Strings.suggestedName)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var suggestedName: String?
}

public enum WellKnownDirectory: JSString, JSValueCompatible {
    case desktop = "desktop"
    case documents = "documents"
    case downloads = "downloads"
    case music = "music"
    case pictures = "pictures"
    case videos = "videos"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum WriteCommandType: JSString, JSValueCompatible {
    case write = "write"
    case seek = "seek"
    case truncate = "truncate"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class WriteParams: BridgedDictionary {
    public convenience init(type: WriteCommandType, size: UInt64?, position: UInt64?, data: Blob_or_BufferSource_or_String?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.size] = _toJSValue(size)
        object[Strings.position] = _toJSValue(position)
        object[Strings.data] = _toJSValue(data)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        _position = ReadWriteAttribute(jsObject: object, name: Strings.position)
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: WriteCommandType

    @ReadWriteAttribute
    public var size: UInt64?

    @ReadWriteAttribute
    public var position: UInt64?

    @ReadWriteAttribute
    public var data: Blob_or_BufferSource_or_String?
}

@usableFromInline enum Strings {
    @usableFromInline static let _self: JSString = "self"
    @usableFromInline static let FileSystemDirectoryHandle: JSString = "FileSystemDirectoryHandle"
    @usableFromInline static let FileSystemFileHandle: JSString = "FileSystemFileHandle"
    @usableFromInline static let FileSystemHandle: JSString = "FileSystemHandle"
    @usableFromInline static let FileSystemWritableFileStream: JSString = "FileSystemWritableFileStream"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let accept: JSString = "accept"
    @usableFromInline static let at: JSString = "at"
    @usableFromInline static let create: JSString = "create"
    @usableFromInline static let createWritable: JSString = "createWritable"
    @usableFromInline static let data: JSString = "data"
    @usableFromInline static let description: JSString = "description"
    @usableFromInline static let excludeAcceptAllOption: JSString = "excludeAcceptAllOption"
    @usableFromInline static let getDirectoryHandle: JSString = "getDirectoryHandle"
    @usableFromInline static let getFile: JSString = "getFile"
    @usableFromInline static let getFileHandle: JSString = "getFileHandle"
    @usableFromInline static let handle: JSString = "handle"
    @usableFromInline static let id: JSString = "id"
    @usableFromInline static let isSameEntry: JSString = "isSameEntry"
    @usableFromInline static let keepExistingData: JSString = "keepExistingData"
    @usableFromInline static let kind: JSString = "kind"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let multiple: JSString = "multiple"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let position: JSString = "position"
    @usableFromInline static let queryPermission: JSString = "queryPermission"
    @usableFromInline static let recursive: JSString = "recursive"
    @usableFromInline static let removeEntry: JSString = "removeEntry"
    @usableFromInline static let requestPermission: JSString = "requestPermission"
    @usableFromInline static let resolve: JSString = "resolve"
    @usableFromInline static let seek: JSString = "seek"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let startIn: JSString = "startIn"
    @usableFromInline static let suggestedName: JSString = "suggestedName"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let truncate: JSString = "truncate"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let types: JSString = "types"
    @usableFromInline static let write: JSString = "write"
}

public protocol Any_Blob_or_BufferSource_or_String: ConvertibleToJSValue {}
extension Blob: Any_Blob_or_BufferSource_or_String {}
extension BufferSource: Any_Blob_or_BufferSource_or_String {}
extension String: Any_Blob_or_BufferSource_or_String {}

public enum Blob_or_BufferSource_or_String: JSValueCompatible, Any_Blob_or_BufferSource_or_String {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    init(_ blob: Blob) {
        let val: Blob_or_BufferSource_or_String = .blob(blob)
        self = val
    }

    init(_ bufferSource: BufferSource) {
        let val: Blob_or_BufferSource_or_String = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ string: String) {
        let val: Blob_or_BufferSource_or_String = .string(string)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_FileSystemWriteChunkType: ConvertibleToJSValue {}
extension Blob: Any_FileSystemWriteChunkType {}
extension BufferSource: Any_FileSystemWriteChunkType {}
extension String: Any_FileSystemWriteChunkType {}
extension WriteParams: Any_FileSystemWriteChunkType {}

public enum FileSystemWriteChunkType: JSValueCompatible, Any_FileSystemWriteChunkType {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)
    case writeParams(WriteParams)

    init(_ blob: Blob) {
        let val: FileSystemWriteChunkType = .blob(blob)
        self = val
    }

    init(_ bufferSource: BufferSource) {
        let val: FileSystemWriteChunkType = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ string: String) {
        let val: FileSystemWriteChunkType = .string(string)
        self = val
    }

    init(_ writeParams: WriteParams) {
        let val: FileSystemWriteChunkType = .writeParams(writeParams)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var writeParams: WriteParams? {
        switch self {
        case let .writeParams(writeParams): return writeParams
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let writeParams: WriteParams = value.fromJSValue() {
            return .writeParams(writeParams)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        case let .writeParams(writeParams):
            return writeParams.jsValue
        }
    }
}

public protocol Any_StartInDirectory: ConvertibleToJSValue {}
extension FileSystemHandle: Any_StartInDirectory {}
extension WellKnownDirectory: Any_StartInDirectory {}

public enum StartInDirectory: JSValueCompatible, Any_StartInDirectory {
    case fileSystemHandle(FileSystemHandle)
    case wellKnownDirectory(WellKnownDirectory)

    init(_ fileSystemHandle: FileSystemHandle) {
        let val: StartInDirectory = .fileSystemHandle(fileSystemHandle)
        self = val
    }

    init(_ wellKnownDirectory: WellKnownDirectory) {
        let val: StartInDirectory = .wellKnownDirectory(wellKnownDirectory)
        self = val
    }

    public var fileSystemHandle: FileSystemHandle? {
        switch self {
        case let .fileSystemHandle(fileSystemHandle): return fileSystemHandle
        default: return nil
        }
    }

    public var wellKnownDirectory: WellKnownDirectory? {
        switch self {
        case let .wellKnownDirectory(wellKnownDirectory): return wellKnownDirectory
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let fileSystemHandle: FileSystemHandle = value.fromJSValue() {
            return .fileSystemHandle(fileSystemHandle)
        }
        if let wellKnownDirectory: WellKnownDirectory = value.fromJSValue() {
            return .wellKnownDirectory(wellKnownDirectory)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .fileSystemHandle(fileSystemHandle):
            return fileSystemHandle.jsValue
        case let .wellKnownDirectory(wellKnownDirectory):
            return wellKnownDirectory.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    init(_ string: String) {
        let val: String_or_seq_of_String = .string(string)
        self = val
    }

    init(_ seq_of_String: [String]) {
        let val: String_or_seq_of_String = .seq_of_String(seq_of_String)
        self = val
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}
