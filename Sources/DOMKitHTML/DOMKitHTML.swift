// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public protocol AbstractWorker: JSBridgedClass {}
public extension AbstractWorker {
    @inlinable var onerror: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onerror, in: jsObject] = newValue }
    }
}

public protocol AnimationFrameProvider: JSBridgedClass {}
public extension AnimationFrameProvider {
    // XXX: method 'requestAnimationFrame' is ignored

    @inlinable func cancelAnimationFrame(handle: UInt32) {
        let this = jsObject
        _ = this[HTMLStrings.cancelAnimationFrame].function!(this: this, arguments: [handle.jsValue])
    }
}

public class AssignedNodesOptions: BridgedDictionary {
    public convenience init(flatten: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.flatten] = flatten.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _flatten = ReadWriteAttribute(jsObject: object, name: HTMLStrings.flatten)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var flatten: Bool
}

public class AudioTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.AudioTrack].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.language)
        _enabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.enabled)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var enabled: Bool
}

public class AudioTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.AudioTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> AudioTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> AudioTrack? {
        let this = jsObject
        return this[HTMLStrings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class BarProp: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.BarProp].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _visible = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.visible)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var visible: Bool
}

public class BeforeUnloadEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.BeforeUnloadEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    // XXX: member 'returnValue' is ignored
}

public class BroadcastChannel: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.BroadcastChannel].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(name: String) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [name.jsValue]))
    }

    @ReadonlyAttribute
    public var name: String

    @inlinable public func postMessage(message: JSValue) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public enum CanPlayTypeResult: JSString, JSValueCompatible {
    case _empty = ""
    case maybe = "maybe"
    case probably = "probably"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasCompositing: JSBridgedClass {}
public extension CanvasCompositing {
    @inlinable var globalAlpha: Double {
        get { ReadWriteAttribute[HTMLStrings.globalAlpha, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.globalAlpha, in: jsObject] = newValue }
    }

    @inlinable var globalCompositeOperation: String {
        get { ReadWriteAttribute[HTMLStrings.globalCompositeOperation, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.globalCompositeOperation, in: jsObject] = newValue }
    }
}

public enum CanvasDirection: JSString, JSValueCompatible {
    case ltr = "ltr"
    case rtl = "rtl"
    case inherit = "inherit"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasDrawImage: JSBridgedClass {}
public extension CanvasDrawImage {
    @inlinable func drawImage(image: CanvasImageSource, dx: Double, dy: Double) {
        let this = jsObject
        _ = this[HTMLStrings.drawImage].function!(this: this, arguments: [image.jsValue, dx.jsValue, dy.jsValue])
    }

    @inlinable func drawImage(image: CanvasImageSource, dx: Double, dy: Double, dw: Double, dh: Double) {
        let this = jsObject
        _ = this[HTMLStrings.drawImage].function!(this: this, arguments: [image.jsValue, dx.jsValue, dy.jsValue, dw.jsValue, dh.jsValue])
    }

    @inlinable func drawImage(image: CanvasImageSource, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double) {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = dx.jsValue
        let _arg6 = dy.jsValue
        let _arg7 = dw.jsValue
        let _arg8 = dh.jsValue
        let this = jsObject
        _ = this[HTMLStrings.drawImage].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }
}

public protocol CanvasDrawPath: JSBridgedClass {}
public extension CanvasDrawPath {
    @inlinable func beginPath() {
        let this = jsObject
        _ = this[HTMLStrings.beginPath].function!(this: this, arguments: [])
    }

    @inlinable func fill(fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.fill].function!(this: this, arguments: [fillRule?.jsValue ?? .undefined])
    }

    @inlinable func fill(path: Path2D, fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.fill].function!(this: this, arguments: [path.jsValue, fillRule?.jsValue ?? .undefined])
    }

    @inlinable func stroke() {
        let this = jsObject
        _ = this[HTMLStrings.stroke].function!(this: this, arguments: [])
    }

    @inlinable func stroke(path: Path2D) {
        let this = jsObject
        _ = this[HTMLStrings.stroke].function!(this: this, arguments: [path.jsValue])
    }

    @inlinable func clip(fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.clip].function!(this: this, arguments: [fillRule?.jsValue ?? .undefined])
    }

    @inlinable func clip(path: Path2D, fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.clip].function!(this: this, arguments: [path.jsValue, fillRule?.jsValue ?? .undefined])
    }

    @inlinable func isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule? = nil) -> Bool {
        let this = jsObject
        return this[HTMLStrings.isPointInPath].function!(this: this, arguments: [x.jsValue, y.jsValue, fillRule?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule? = nil) -> Bool {
        let this = jsObject
        return this[HTMLStrings.isPointInPath].function!(this: this, arguments: [path.jsValue, x.jsValue, y.jsValue, fillRule?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func isPointInStroke(x: Double, y: Double) -> Bool {
        let this = jsObject
        return this[HTMLStrings.isPointInStroke].function!(this: this, arguments: [x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable func isPointInStroke(path: Path2D, x: Double, y: Double) -> Bool {
        let this = jsObject
        return this[HTMLStrings.isPointInStroke].function!(this: this, arguments: [path.jsValue, x.jsValue, y.jsValue]).fromJSValue()!
    }
}

public enum CanvasFillRule: JSString, JSValueCompatible {
    case nonzero = "nonzero"
    case evenodd = "evenodd"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasFillStrokeStyles: JSBridgedClass {}
public extension CanvasFillStrokeStyles {
    @inlinable var strokeStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { ReadWriteAttribute[HTMLStrings.strokeStyle, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.strokeStyle, in: jsObject] = newValue }
    }

    @inlinable var fillStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { ReadWriteAttribute[HTMLStrings.fillStyle, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.fillStyle, in: jsObject] = newValue }
    }

    @inlinable func createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double) -> CanvasGradient {
        let this = jsObject
        return this[HTMLStrings.createLinearGradient].function!(this: this, arguments: [x0.jsValue, y0.jsValue, x1.jsValue, y1.jsValue]).fromJSValue()!
    }

    @inlinable func createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double) -> CanvasGradient {
        let _arg0 = x0.jsValue
        let _arg1 = y0.jsValue
        let _arg2 = r0.jsValue
        let _arg3 = x1.jsValue
        let _arg4 = y1.jsValue
        let _arg5 = r1.jsValue
        let this = jsObject
        return this[HTMLStrings.createRadialGradient].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @inlinable func createConicGradient(startAngle: Double, x: Double, y: Double) -> CanvasGradient {
        let this = jsObject
        return this[HTMLStrings.createConicGradient].function!(this: this, arguments: [startAngle.jsValue, x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable func createPattern(image: CanvasImageSource, repetition: String) -> CanvasPattern? {
        let this = jsObject
        return this[HTMLStrings.createPattern].function!(this: this, arguments: [image.jsValue, repetition.jsValue]).fromJSValue()!
    }
}

public class CanvasFilter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.CanvasFilter].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(filters: CanvasFilterInput_or_seq_of_CanvasFilterInput? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [filters?.jsValue ?? .undefined]))
    }
}

public protocol CanvasFilters: JSBridgedClass {}
public extension CanvasFilters {
    @inlinable var filter: CanvasFilter_or_String {
        get { ReadWriteAttribute[HTMLStrings.filter, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.filter, in: jsObject] = newValue }
    }
}

public enum CanvasFontKerning: JSString, JSValueCompatible {
    case auto = "auto"
    case normal = "normal"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasFontStretch: JSString, JSValueCompatible {
    case ultraCondensed = "ultra-condensed"
    case extraCondensed = "extra-condensed"
    case condensed = "condensed"
    case semiCondensed = "semi-condensed"
    case normal = "normal"
    case semiExpanded = "semi-expanded"
    case expanded = "expanded"
    case extraExpanded = "extra-expanded"
    case ultraExpanded = "ultra-expanded"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasFontVariantCaps: JSString, JSValueCompatible {
    case normal = "normal"
    case smallCaps = "small-caps"
    case allSmallCaps = "all-small-caps"
    case petiteCaps = "petite-caps"
    case allPetiteCaps = "all-petite-caps"
    case unicase = "unicase"
    case titlingCaps = "titling-caps"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CanvasGradient: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.CanvasGradient].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func addColorStop(offset: Double, color: String) {
        let this = jsObject
        _ = this[HTMLStrings.addColorStop].function!(this: this, arguments: [offset.jsValue, color.jsValue])
    }
}

public protocol CanvasImageData: JSBridgedClass {}
public extension CanvasImageData {
    @inlinable func createImageData(sw: Int32, sh: Int32, settings: ImageDataSettings? = nil) -> ImageData {
        let this = jsObject
        return this[HTMLStrings.createImageData].function!(this: this, arguments: [sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func createImageData(imagedata: ImageData) -> ImageData {
        let this = jsObject
        return this[HTMLStrings.createImageData].function!(this: this, arguments: [imagedata.jsValue]).fromJSValue()!
    }

    @inlinable func getImageData(sx: Int32, sy: Int32, sw: Int32, sh: Int32, settings: ImageDataSettings? = nil) -> ImageData {
        let this = jsObject
        return this[HTMLStrings.getImageData].function!(this: this, arguments: [sx.jsValue, sy.jsValue, sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func putImageData(imagedata: ImageData, dx: Int32, dy: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.putImageData].function!(this: this, arguments: [imagedata.jsValue, dx.jsValue, dy.jsValue])
    }

    @inlinable func putImageData(imagedata: ImageData, dx: Int32, dy: Int32, dirtyX: Int32, dirtyY: Int32, dirtyWidth: Int32, dirtyHeight: Int32) {
        let _arg0 = imagedata.jsValue
        let _arg1 = dx.jsValue
        let _arg2 = dy.jsValue
        let _arg3 = dirtyX.jsValue
        let _arg4 = dirtyY.jsValue
        let _arg5 = dirtyWidth.jsValue
        let _arg6 = dirtyHeight.jsValue
        let this = jsObject
        _ = this[HTMLStrings.putImageData].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }
}

public protocol CanvasImageSmoothing: JSBridgedClass {}
public extension CanvasImageSmoothing {
    @inlinable var imageSmoothingEnabled: Bool {
        get { ReadWriteAttribute[HTMLStrings.imageSmoothingEnabled, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.imageSmoothingEnabled, in: jsObject] = newValue }
    }

    @inlinable var imageSmoothingQuality: ImageSmoothingQuality {
        get { ReadWriteAttribute[HTMLStrings.imageSmoothingQuality, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.imageSmoothingQuality, in: jsObject] = newValue }
    }
}

public enum CanvasLineCap: JSString, JSValueCompatible {
    case butt = "butt"
    case round = "round"
    case square = "square"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasLineJoin: JSString, JSValueCompatible {
    case round = "round"
    case bevel = "bevel"
    case miter = "miter"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasPath: JSBridgedClass {}
public extension CanvasPath {
    @inlinable func closePath() {
        let this = jsObject
        _ = this[HTMLStrings.closePath].function!(this: this, arguments: [])
    }

    @inlinable func moveTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[HTMLStrings.moveTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func lineTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[HTMLStrings.lineTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double) {
        let this = jsObject
        _ = this[HTMLStrings.quadraticCurveTo].function!(this: this, arguments: [cpx.jsValue, cpy.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double) {
        let _arg0 = cp1x.jsValue
        let _arg1 = cp1y.jsValue
        let _arg2 = cp2x.jsValue
        let _arg3 = cp2y.jsValue
        let _arg4 = x.jsValue
        let _arg5 = y.jsValue
        let this = jsObject
        _ = this[HTMLStrings.bezierCurveTo].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double) {
        let this = jsObject
        _ = this[HTMLStrings.arcTo].function!(this: this, arguments: [x1.jsValue, y1.jsValue, x2.jsValue, y2.jsValue, radius.jsValue])
    }

    @inlinable func rect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[HTMLStrings.rect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func roundRect(x: Double, y: Double, w: Double, h: Double, radii: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.roundRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue, radii?.jsValue ?? .undefined])
    }

    @inlinable func arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, counterclockwise: Bool? = nil) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = radius.jsValue
        let _arg3 = startAngle.jsValue
        let _arg4 = endAngle.jsValue
        let _arg5 = counterclockwise?.jsValue ?? .undefined
        let this = jsObject
        _ = this[HTMLStrings.arc].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, counterclockwise: Bool? = nil) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = radiusX.jsValue
        let _arg3 = radiusY.jsValue
        let _arg4 = rotation.jsValue
        let _arg5 = startAngle.jsValue
        let _arg6 = endAngle.jsValue
        let _arg7 = counterclockwise?.jsValue ?? .undefined
        let this = jsObject
        _ = this[HTMLStrings.ellipse].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public protocol CanvasPathDrawingStyles: JSBridgedClass {}
public extension CanvasPathDrawingStyles {
    @inlinable var lineWidth: Double {
        get { ReadWriteAttribute[HTMLStrings.lineWidth, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.lineWidth, in: jsObject] = newValue }
    }

    @inlinable var lineCap: CanvasLineCap {
        get { ReadWriteAttribute[HTMLStrings.lineCap, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.lineCap, in: jsObject] = newValue }
    }

    @inlinable var lineJoin: CanvasLineJoin {
        get { ReadWriteAttribute[HTMLStrings.lineJoin, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.lineJoin, in: jsObject] = newValue }
    }

    @inlinable var miterLimit: Double {
        get { ReadWriteAttribute[HTMLStrings.miterLimit, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.miterLimit, in: jsObject] = newValue }
    }

    @inlinable func setLineDash(segments: [Double]) {
        let this = jsObject
        _ = this[HTMLStrings.setLineDash].function!(this: this, arguments: [segments.jsValue])
    }

    @inlinable func getLineDash() -> [Double] {
        let this = jsObject
        return this[HTMLStrings.getLineDash].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var lineDashOffset: Double {
        get { ReadWriteAttribute[HTMLStrings.lineDashOffset, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.lineDashOffset, in: jsObject] = newValue }
    }
}

public class CanvasPattern: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.CanvasPattern].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setTransform(transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setTransform].function!(this: this, arguments: [transform?.jsValue ?? .undefined])
    }
}

public protocol CanvasRect: JSBridgedClass {}
public extension CanvasRect {
    @inlinable func clearRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[HTMLStrings.clearRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func fillRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[HTMLStrings.fillRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func strokeRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[HTMLStrings.strokeRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }
}

public class CanvasRenderingContext2D: JSBridgedClass, CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.CanvasRenderingContext2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement

    @inlinable public func getContextAttributes() -> CanvasRenderingContext2DSettings {
        let this = jsObject
        return this[HTMLStrings.getContextAttributes].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class CanvasRenderingContext2DSettings: BridgedDictionary {
    public convenience init(alpha: Bool, desynchronized: Bool, colorSpace: PredefinedColorSpace, willReadFrequently: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.alpha] = alpha.jsValue
        object[HTMLStrings.desynchronized] = desynchronized.jsValue
        object[HTMLStrings.colorSpace] = colorSpace.jsValue
        object[HTMLStrings.willReadFrequently] = willReadFrequently.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: HTMLStrings.alpha)
        _desynchronized = ReadWriteAttribute(jsObject: object, name: HTMLStrings.desynchronized)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: HTMLStrings.colorSpace)
        _willReadFrequently = ReadWriteAttribute(jsObject: object, name: HTMLStrings.willReadFrequently)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool

    @ReadWriteAttribute
    public var desynchronized: Bool

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var willReadFrequently: Bool
}

public protocol CanvasShadowStyles: JSBridgedClass {}
public extension CanvasShadowStyles {
    @inlinable var shadowOffsetX: Double {
        get { ReadWriteAttribute[HTMLStrings.shadowOffsetX, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.shadowOffsetX, in: jsObject] = newValue }
    }

    @inlinable var shadowOffsetY: Double {
        get { ReadWriteAttribute[HTMLStrings.shadowOffsetY, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.shadowOffsetY, in: jsObject] = newValue }
    }

    @inlinable var shadowBlur: Double {
        get { ReadWriteAttribute[HTMLStrings.shadowBlur, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.shadowBlur, in: jsObject] = newValue }
    }

    @inlinable var shadowColor: String {
        get { ReadWriteAttribute[HTMLStrings.shadowColor, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.shadowColor, in: jsObject] = newValue }
    }
}

public protocol CanvasState: JSBridgedClass {}
public extension CanvasState {
    @inlinable func save() {
        let this = jsObject
        _ = this[HTMLStrings.save].function!(this: this, arguments: [])
    }

    @inlinable func restore() {
        let this = jsObject
        _ = this[HTMLStrings.restore].function!(this: this, arguments: [])
    }

    @inlinable func reset() {
        let this = jsObject
        _ = this[HTMLStrings.reset].function!(this: this, arguments: [])
    }

    @inlinable func isContextLost() -> Bool {
        let this = jsObject
        return this[HTMLStrings.isContextLost].function!(this: this, arguments: []).fromJSValue()!
    }
}

public protocol CanvasText: JSBridgedClass {}
public extension CanvasText {
    @inlinable func fillText(text: String, x: Double, y: Double, maxWidth: Double? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.fillText].function!(this: this, arguments: [text.jsValue, x.jsValue, y.jsValue, maxWidth?.jsValue ?? .undefined])
    }

    @inlinable func strokeText(text: String, x: Double, y: Double, maxWidth: Double? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.strokeText].function!(this: this, arguments: [text.jsValue, x.jsValue, y.jsValue, maxWidth?.jsValue ?? .undefined])
    }

    @inlinable func measureText(text: String) -> TextMetrics {
        let this = jsObject
        return this[HTMLStrings.measureText].function!(this: this, arguments: [text.jsValue]).fromJSValue()!
    }
}

public enum CanvasTextAlign: JSString, JSValueCompatible {
    case start = "start"
    case end = "end"
    case left = "left"
    case right = "right"
    case center = "center"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasTextBaseline: JSString, JSValueCompatible {
    case top = "top"
    case hanging = "hanging"
    case middle = "middle"
    case alphabetic = "alphabetic"
    case ideographic = "ideographic"
    case bottom = "bottom"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasTextDrawingStyles: JSBridgedClass {}
public extension CanvasTextDrawingStyles {
    @inlinable var font: String {
        get { ReadWriteAttribute[HTMLStrings.font, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.font, in: jsObject] = newValue }
    }

    @inlinable var textAlign: CanvasTextAlign {
        get { ReadWriteAttribute[HTMLStrings.textAlign, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.textAlign, in: jsObject] = newValue }
    }

    @inlinable var textBaseline: CanvasTextBaseline {
        get { ReadWriteAttribute[HTMLStrings.textBaseline, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.textBaseline, in: jsObject] = newValue }
    }

    @inlinable var direction: CanvasDirection {
        get { ReadWriteAttribute[HTMLStrings.direction, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.direction, in: jsObject] = newValue }
    }

    @inlinable var letterSpacing: String {
        get { ReadWriteAttribute[HTMLStrings.letterSpacing, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.letterSpacing, in: jsObject] = newValue }
    }

    @inlinable var fontKerning: CanvasFontKerning {
        get { ReadWriteAttribute[HTMLStrings.fontKerning, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.fontKerning, in: jsObject] = newValue }
    }

    @inlinable var fontStretch: CanvasFontStretch {
        get { ReadWriteAttribute[HTMLStrings.fontStretch, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.fontStretch, in: jsObject] = newValue }
    }

    @inlinable var fontVariantCaps: CanvasFontVariantCaps {
        get { ReadWriteAttribute[HTMLStrings.fontVariantCaps, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.fontVariantCaps, in: jsObject] = newValue }
    }

    @inlinable var textRendering: CanvasTextRendering {
        get { ReadWriteAttribute[HTMLStrings.textRendering, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.textRendering, in: jsObject] = newValue }
    }

    @inlinable var wordSpacing: String {
        get { ReadWriteAttribute[HTMLStrings.wordSpacing, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.wordSpacing, in: jsObject] = newValue }
    }
}

public enum CanvasTextRendering: JSString, JSValueCompatible {
    case auto = "auto"
    case optimizeSpeed = "optimizeSpeed"
    case optimizeLegibility = "optimizeLegibility"
    case geometricPrecision = "geometricPrecision"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasTransform: JSBridgedClass {}
public extension CanvasTransform {
    @inlinable func scale(x: Double, y: Double) {
        let this = jsObject
        _ = this[HTMLStrings.scale].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func rotate(angle: Double) {
        let this = jsObject
        _ = this[HTMLStrings.rotate].function!(this: this, arguments: [angle.jsValue])
    }

    @inlinable func translate(x: Double, y: Double) {
        let this = jsObject
        _ = this[HTMLStrings.translate].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        let _arg0 = a.jsValue
        let _arg1 = b.jsValue
        let _arg2 = c.jsValue
        let _arg3 = d.jsValue
        let _arg4 = e.jsValue
        let _arg5 = f.jsValue
        let this = jsObject
        _ = this[HTMLStrings.transform].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func getTransform() -> DOMMatrix {
        let this = jsObject
        return this[HTMLStrings.getTransform].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        let _arg0 = a.jsValue
        let _arg1 = b.jsValue
        let _arg2 = c.jsValue
        let _arg3 = d.jsValue
        let _arg4 = e.jsValue
        let _arg5 = f.jsValue
        let this = jsObject
        _ = this[HTMLStrings.setTransform].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func setTransform(transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setTransform].function!(this: this, arguments: [transform?.jsValue ?? .undefined])
    }

    @inlinable func resetTransform() {
        let this = jsObject
        _ = this[HTMLStrings.resetTransform].function!(this: this, arguments: [])
    }
}

public protocol CanvasUserInterface: JSBridgedClass {}
public extension CanvasUserInterface {
    @inlinable func drawFocusIfNeeded(element: Element) {
        let this = jsObject
        _ = this[HTMLStrings.drawFocusIfNeeded].function!(this: this, arguments: [element.jsValue])
    }

    @inlinable func drawFocusIfNeeded(path: Path2D, element: Element) {
        let this = jsObject
        _ = this[HTMLStrings.drawFocusIfNeeded].function!(this: this, arguments: [path.jsValue, element.jsValue])
    }

    @inlinable func scrollPathIntoView() {
        let this = jsObject
        _ = this[HTMLStrings.scrollPathIntoView].function!(this: this, arguments: [])
    }

    @inlinable func scrollPathIntoView(path: Path2D) {
        let this = jsObject
        _ = this[HTMLStrings.scrollPathIntoView].function!(this: this, arguments: [path.jsValue])
    }
}

public enum ColorSpaceConversion: JSString, JSValueCompatible {
    case none = "none"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CustomElementRegistry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.CustomElementRegistry].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func define(name: String, constructor: CustomElementConstructor, options: ElementDefinitionOptions? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.define].function!(this: this, arguments: [name.jsValue, constructor.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func get(name: String) -> CustomElementConstructor? {
        let this = jsObject
        return this[HTMLStrings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func whenDefined(name: String) -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.whenDefined].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func whenDefined(name: String) async throws -> CustomElementConstructor {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.whenDefined].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func upgrade(root: Node) {
        let this = jsObject
        _ = this[HTMLStrings.upgrade].function!(this: this, arguments: [root.jsValue])
    }
}

public class DOMParser: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DOMParser].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func parseFromString(string: String, type: DOMParserSupportedType) -> Document {
        let this = jsObject
        return this[HTMLStrings.parseFromString].function!(this: this, arguments: [string.jsValue, type.jsValue]).fromJSValue()!
    }
}

public enum DOMParserSupportedType: JSString, JSValueCompatible {
    case textHtml = "text/html"
    case textXml = "text/xml"
    case applicationXml = "application/xml"
    case applicationXhtmlXml = "application/xhtml+xml"
    case imageSvgXml = "image/svg+xml"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DOMStringList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DOMStringList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func contains(string: String) -> Bool {
        let this = jsObject
        return this[HTMLStrings.contains].function!(this: this, arguments: [string.jsValue]).fromJSValue()!
    }
}

public class DOMStringMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DOMStringMap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: String) -> String {
        jsObject[key].fromJSValue()!
    }

    // XXX: unsupported setter for keys of type String

    // XXX: unsupported deleter for keys of type String
}

public class DataTransfer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DataTransfer].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dropEffect = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dropEffect)
        _effectAllowed = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.effectAllowed)
        _items = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.items)
        _types = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.types)
        _files = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.files)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dropEffect: String

    @ReadWriteAttribute
    public var effectAllowed: String

    @ReadonlyAttribute
    public var items: DataTransferItemList

    @inlinable public func setDragImage(image: Element, x: Int32, y: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.setDragImage].function!(this: this, arguments: [image.jsValue, x.jsValue, y.jsValue])
    }

    @ReadonlyAttribute
    public var types: [String]

    @inlinable public func getData(format: String) -> String {
        let this = jsObject
        return this[HTMLStrings.getData].function!(this: this, arguments: [format.jsValue]).fromJSValue()!
    }

    @inlinable public func setData(format: String, data: String) {
        let this = jsObject
        _ = this[HTMLStrings.setData].function!(this: this, arguments: [format.jsValue, data.jsValue])
    }

    @inlinable public func clearData(format: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.clearData].function!(this: this, arguments: [format?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var files: FileList
}

public class DataTransferItem: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DataTransferItem].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.kind)
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var type: String

    // XXX: member 'getAsString' is ignored

    @inlinable public func getAsFile() -> File? {
        let this = jsObject
        return this[HTMLStrings.getAsFile].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DataTransferItemList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.DataTransferItemList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> DataTransferItem {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func add(data: String, type: String) -> DataTransferItem? {
        let this = jsObject
        return this[HTMLStrings.add].function!(this: this, arguments: [data.jsValue, type.jsValue]).fromJSValue()!
    }

    @inlinable public func add(data: File) -> DataTransferItem? {
        let this = jsObject
        return this[HTMLStrings.add].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func remove(index: UInt32) {
        let this = jsObject
        _ = this[HTMLStrings.remove].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable public func clear() {
        let this = jsObject
        _ = this[HTMLStrings.clear].function!(this: this, arguments: [])
    }
}

public protocol DocumentAndElementEventHandlers: JSBridgedClass {}
public extension DocumentAndElementEventHandlers {
    @inlinable var oncopy: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncopy, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncopy, in: jsObject] = newValue }
    }

    @inlinable var oncut: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncut, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncut, in: jsObject] = newValue }
    }

    @inlinable var onpaste: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onpaste, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onpaste, in: jsObject] = newValue }
    }
}

public extension DocumentOrShadowRoot {
    @inlinable var activeElement: Element? { ReadonlyAttribute[HTMLStrings.activeElement, in: jsObject] }
}

public enum DocumentReadyState: JSString, JSValueCompatible {
    case loading = "loading"
    case interactive = "interactive"
    case complete = "complete"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum DocumentVisibilityState: JSString, JSValueCompatible {
    case visible = "visible"
    case hidden = "hidden"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DragEvent: MouseEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.DragEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dataTransfer = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.dataTransfer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: DragEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var dataTransfer: DataTransfer?
}

public class DragEventInit: BridgedDictionary {
    public convenience init(dataTransfer: DataTransfer?) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.dataTransfer] = dataTransfer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _dataTransfer = ReadWriteAttribute(jsObject: object, name: HTMLStrings.dataTransfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var dataTransfer: DataTransfer?
}

public protocol ElementContentEditable: JSBridgedClass {}
public extension ElementContentEditable {
    @inlinable var contentEditable: String {
        get { ReadWriteAttribute[HTMLStrings.contentEditable, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.contentEditable, in: jsObject] = newValue }
    }

    @inlinable var enterKeyHint: String {
        get { ReadWriteAttribute[HTMLStrings.enterKeyHint, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.enterKeyHint, in: jsObject] = newValue }
    }

    @inlinable var isContentEditable: Bool { ReadonlyAttribute[HTMLStrings.isContentEditable, in: jsObject] }

    @inlinable var inputMode: String {
        get { ReadWriteAttribute[HTMLStrings.inputMode, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.inputMode, in: jsObject] = newValue }
    }
}

public class ElementDefinitionOptions: BridgedDictionary {
    public convenience init(extends: String) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.extends] = extends.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _extends = ReadWriteAttribute(jsObject: object, name: HTMLStrings.extends)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var extends: String
}

public class ElementInternals: JSBridgedClass, ARIAMixin {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.ElementInternals].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.shadowRoot)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func setFormValue(value: File_or_FormData_or_String?, state: File_or_FormData_or_String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setFormValue].function!(this: this, arguments: [value.jsValue, state?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @inlinable public func setValidity(flags: ValidityStateFlags? = nil, message: String? = nil, anchor: HTMLElement? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setValidity].function!(this: this, arguments: [flags?.jsValue ?? .undefined, message?.jsValue ?? .undefined, anchor?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class ErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.ErrorEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.message)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.filename)
        _lineno = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.lineno)
        _colno = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.colno)
        _error = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ErrorEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var lineno: UInt32

    @ReadonlyAttribute
    public var colno: UInt32

    @ReadonlyAttribute
    public var error: JSValue
}

public class ErrorEventInit: BridgedDictionary {
    public convenience init(message: String, filename: String, lineno: UInt32, colno: UInt32, error: JSValue) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.message] = message.jsValue
        object[HTMLStrings.filename] = filename.jsValue
        object[HTMLStrings.lineno] = lineno.jsValue
        object[HTMLStrings.colno] = colno.jsValue
        object[HTMLStrings.error] = error.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _message = ReadWriteAttribute(jsObject: object, name: HTMLStrings.message)
        _filename = ReadWriteAttribute(jsObject: object, name: HTMLStrings.filename)
        _lineno = ReadWriteAttribute(jsObject: object, name: HTMLStrings.lineno)
        _colno = ReadWriteAttribute(jsObject: object, name: HTMLStrings.colno)
        _error = ReadWriteAttribute(jsObject: object, name: HTMLStrings.error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var message: String

    @ReadWriteAttribute
    public var filename: String

    @ReadWriteAttribute
    public var lineno: UInt32

    @ReadWriteAttribute
    public var colno: UInt32

    @ReadWriteAttribute
    public var error: JSValue
}

public class EventSource: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.EventSource].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.url)
        _withCredentials = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.withCredentials)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.readyState)
        _onopen = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onopen)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessage)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(url: String, eventSourceInitDict: EventSourceInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [url.jsValue, eventSourceInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var withCredentials: Bool

    public static let CONNECTING: UInt16 = 0

    public static let OPEN: UInt16 = 1

    public static let CLOSED: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ClosureAttribute1Optional
    public var onopen: EventHandler

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @inlinable public func close() {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [])
    }
}

public class EventSourceInit: BridgedDictionary {
    public convenience init(withCredentials: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.withCredentials] = withCredentials.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _withCredentials = ReadWriteAttribute(jsObject: object, name: HTMLStrings.withCredentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var withCredentials: Bool
}

public class External: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.External].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func AddSearchProvider() {
        let this = jsObject
        _ = this[HTMLStrings.AddSearchProvider].function!(this: this, arguments: [])
    }

    @inlinable public func IsSearchProviderInstalled() {
        let this = jsObject
        _ = this[HTMLStrings.IsSearchProviderInstalled].function!(this: this, arguments: [])
    }
}

public class FocusOptions: BridgedDictionary {
    public convenience init(preventScroll: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.preventScroll] = preventScroll.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventScroll = ReadWriteAttribute(jsObject: object, name: HTMLStrings.preventScroll)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventScroll: Bool
}

public class FormDataEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.FormDataEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _formData = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.formData)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: FormDataEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var formData: FormData
}

public class FormDataEventInit: BridgedDictionary {
    public convenience init(formData: FormData) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.formData] = formData.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _formData = ReadWriteAttribute(jsObject: object, name: HTMLStrings.formData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var formData: FormData
}

public protocol GlobalEventHandlers: JSBridgedClass {}
public extension GlobalEventHandlers {
    @inlinable var onabort: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onabort, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onabort, in: jsObject] = newValue }
    }

    @inlinable var onauxclick: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onauxclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onauxclick, in: jsObject] = newValue }
    }

    @inlinable var onblur: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onblur, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onblur, in: jsObject] = newValue }
    }

    @inlinable var oncancel: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncancel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncancel, in: jsObject] = newValue }
    }

    @inlinable var oncanplay: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncanplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncanplay, in: jsObject] = newValue }
    }

    @inlinable var oncanplaythrough: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncanplaythrough, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncanplaythrough, in: jsObject] = newValue }
    }

    @inlinable var onchange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onchange, in: jsObject] = newValue }
    }

    @inlinable var onclick: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onclick, in: jsObject] = newValue }
    }

    @inlinable var onclose: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onclose, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onclose, in: jsObject] = newValue }
    }

    @inlinable var oncontextlost: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncontextlost, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncontextlost, in: jsObject] = newValue }
    }

    @inlinable var oncontextmenu: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncontextmenu, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncontextmenu, in: jsObject] = newValue }
    }

    @inlinable var oncontextrestored: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncontextrestored, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncontextrestored, in: jsObject] = newValue }
    }

    @inlinable var oncuechange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oncuechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oncuechange, in: jsObject] = newValue }
    }

    @inlinable var ondblclick: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondblclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondblclick, in: jsObject] = newValue }
    }

    @inlinable var ondrag: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondrag, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondrag, in: jsObject] = newValue }
    }

    @inlinable var ondragend: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondragend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondragend, in: jsObject] = newValue }
    }

    @inlinable var ondragenter: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondragenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondragenter, in: jsObject] = newValue }
    }

    @inlinable var ondragleave: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondragleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondragleave, in: jsObject] = newValue }
    }

    @inlinable var ondragover: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondragover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondragover, in: jsObject] = newValue }
    }

    @inlinable var ondragstart: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondragstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondragstart, in: jsObject] = newValue }
    }

    @inlinable var ondrop: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondrop, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondrop, in: jsObject] = newValue }
    }

    @inlinable var ondurationchange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ondurationchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ondurationchange, in: jsObject] = newValue }
    }

    @inlinable var onemptied: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onemptied, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onemptied, in: jsObject] = newValue }
    }

    @inlinable var onended: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onended, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onended, in: jsObject] = newValue }
    }

    @inlinable var onerror: OnErrorEventHandler {
        get { ClosureAttribute5Optional[HTMLStrings.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute5Optional[HTMLStrings.onerror, in: jsObject] = newValue }
    }

    @inlinable var onfocus: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onfocus, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onfocus, in: jsObject] = newValue }
    }

    @inlinable var onformdata: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onformdata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onformdata, in: jsObject] = newValue }
    }

    @inlinable var oninput: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oninput, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oninput, in: jsObject] = newValue }
    }

    @inlinable var oninvalid: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.oninvalid, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.oninvalid, in: jsObject] = newValue }
    }

    @inlinable var onkeydown: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onkeydown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onkeydown, in: jsObject] = newValue }
    }

    @inlinable var onkeypress: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onkeypress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onkeypress, in: jsObject] = newValue }
    }

    @inlinable var onkeyup: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onkeyup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onkeyup, in: jsObject] = newValue }
    }

    @inlinable var onload: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onload, in: jsObject] = newValue }
    }

    @inlinable var onloadeddata: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onloadeddata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onloadeddata, in: jsObject] = newValue }
    }

    @inlinable var onloadedmetadata: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onloadedmetadata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onloadedmetadata, in: jsObject] = newValue }
    }

    @inlinable var onloadstart: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onloadstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onloadstart, in: jsObject] = newValue }
    }

    @inlinable var onmousedown: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmousedown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmousedown, in: jsObject] = newValue }
    }

    @inlinable var onmouseenter: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmouseenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmouseenter, in: jsObject] = newValue }
    }

    @inlinable var onmouseleave: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmouseleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmouseleave, in: jsObject] = newValue }
    }

    @inlinable var onmousemove: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmousemove, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmousemove, in: jsObject] = newValue }
    }

    @inlinable var onmouseout: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmouseout, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmouseout, in: jsObject] = newValue }
    }

    @inlinable var onmouseover: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmouseover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmouseover, in: jsObject] = newValue }
    }

    @inlinable var onmouseup: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmouseup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmouseup, in: jsObject] = newValue }
    }

    @inlinable var onpause: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onpause, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onpause, in: jsObject] = newValue }
    }

    @inlinable var onplay: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onplay, in: jsObject] = newValue }
    }

    @inlinable var onplaying: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onplaying, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onplaying, in: jsObject] = newValue }
    }

    @inlinable var onprogress: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onprogress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onprogress, in: jsObject] = newValue }
    }

    @inlinable var onratechange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onratechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onratechange, in: jsObject] = newValue }
    }

    @inlinable var onreset: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onreset, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onreset, in: jsObject] = newValue }
    }

    @inlinable var onresize: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onresize, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onresize, in: jsObject] = newValue }
    }

    @inlinable var onscroll: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onscroll, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onscroll, in: jsObject] = newValue }
    }

    @inlinable var onsecuritypolicyviolation: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onsecuritypolicyviolation, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onsecuritypolicyviolation, in: jsObject] = newValue }
    }

    @inlinable var onseeked: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onseeked, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onseeked, in: jsObject] = newValue }
    }

    @inlinable var onseeking: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onseeking, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onseeking, in: jsObject] = newValue }
    }

    @inlinable var onselect: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onselect, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onselect, in: jsObject] = newValue }
    }

    @inlinable var onslotchange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onslotchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onslotchange, in: jsObject] = newValue }
    }

    @inlinable var onstalled: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onstalled, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onstalled, in: jsObject] = newValue }
    }

    @inlinable var onsubmit: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onsubmit, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onsubmit, in: jsObject] = newValue }
    }

    @inlinable var onsuspend: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onsuspend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onsuspend, in: jsObject] = newValue }
    }

    @inlinable var ontimeupdate: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ontimeupdate, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ontimeupdate, in: jsObject] = newValue }
    }

    @inlinable var ontoggle: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ontoggle, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ontoggle, in: jsObject] = newValue }
    }

    @inlinable var onvolumechange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onvolumechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onvolumechange, in: jsObject] = newValue }
    }

    @inlinable var onwaiting: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwaiting, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwaiting, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationend: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationend, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationiteration: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationiteration, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationiteration, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationstart: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwebkitanimationstart, in: jsObject] = newValue }
    }

    @inlinable var onwebkittransitionend: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwebkittransitionend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwebkittransitionend, in: jsObject] = newValue }
    }

    @inlinable var onwheel: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onwheel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onwheel, in: jsObject] = newValue }
    }
}

public class HTMLAllCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLAllCollection].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_HTMLCollection? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(nameOrIndex: String? = nil) -> Element_or_HTMLCollection? {
        let this = jsObject
        return this[HTMLStrings.item].function!(this: this, arguments: [nameOrIndex?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class HTMLAnchorElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLAnchorElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.relList)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _text = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.text)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.coords)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.charset)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rev)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.shape)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var shape: String
}

public class HTMLAreaElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLAreaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.alt)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.coords)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.shape)
        _target = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.relList)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _noHref = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noHref)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var shape: String

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var noHref: Bool
}

public class HTMLAudioElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLAudioElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLBRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLBRElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _clear = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.clear)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var clear: String
}

public class HTMLBaseElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLBaseElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.href)
        _target = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLBodyElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLBodyElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.text)
        _link = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.link)
        _vLink = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vLink)
        _aLink = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.aLink)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.bgColor)
        _background = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.background)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var link: String

    @ReadWriteAttribute
    public var vLink: String

    @ReadWriteAttribute
    public var aLink: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var background: String
}

public class HTMLButtonElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLButtonElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formTarget)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLCanvasElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLCanvasElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @inlinable public func getContext(contextId: String, options: JSValue? = nil) -> RenderingContext? {
        let this = jsObject
        return this[HTMLStrings.getContext].function!(this: this, arguments: [contextId.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func toDataURL(type: String? = nil, quality: JSValue? = nil) -> String {
        let this = jsObject
        return this[HTMLStrings.toDataURL].function!(this: this, arguments: [type?.jsValue ?? .undefined, quality?.jsValue ?? .undefined]).fromJSValue()!
    }

    // XXX: member 'toBlob' is ignored

    @inlinable public func transferControlToOffscreen() -> OffscreenCanvas {
        let this = jsObject
        return this[HTMLStrings.transferControlToOffscreen].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLDListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDataElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDataElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: String
}

public class HTMLDataListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDataListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _options = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.options)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var options: HTMLCollection
}

public class HTMLDetailsElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDetailsElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.open)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool
}

public class HTMLDialogElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDialogElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.open)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.returnValue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool

    @ReadWriteAttribute
    public var returnValue: String

    @inlinable public func show() {
        let this = jsObject
        _ = this[HTMLStrings.show].function!(this: this, arguments: [])
    }

    @inlinable public func showModal() {
        let this = jsObject
        _ = this[HTMLStrings.showModal].function!(this: this, arguments: [])
    }

    @inlinable public func close(returnValue: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [returnValue?.jsValue ?? .undefined])
    }
}

public class HTMLDirectoryElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDirectoryElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDivElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLDivElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLElement: Element, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable, HTMLOrSVGElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _title = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.title)
        _lang = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.lang)
        _translate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.translate)
        _dir = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dir)
        _hidden = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hidden)
        _inert = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.inert)
        _accessKey = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.accessKey)
        _accessKeyLabel = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.accessKeyLabel)
        _draggable = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.draggable)
        _spellcheck = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.spellcheck)
        _autocapitalize = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autocapitalize)
        _innerText = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.innerText)
        _outerText = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.outerText)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var title: String

    @ReadWriteAttribute
    public var lang: String

    @ReadWriteAttribute
    public var translate: Bool

    @ReadWriteAttribute
    public var dir: String

    @ReadWriteAttribute
    public var hidden: Bool

    @ReadWriteAttribute
    public var inert: Bool

    @inlinable public func click() {
        let this = jsObject
        _ = this[HTMLStrings.click].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var accessKey: String

    @ReadonlyAttribute
    public var accessKeyLabel: String

    @ReadWriteAttribute
    public var draggable: Bool

    @ReadWriteAttribute
    public var spellcheck: Bool

    @ReadWriteAttribute
    public var autocapitalize: String

    @ReadWriteAttribute
    public var innerText: String

    @ReadWriteAttribute
    public var outerText: String

    @inlinable public func attachInternals() -> ElementInternals {
        let this = jsObject
        return this[HTMLStrings.attachInternals].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLEmbedElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLEmbedElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[HTMLStrings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var name: String
}

public class HTMLFieldSetElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFieldSetElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.elements)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var elements: HTMLCollection

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }
}

public class HTMLFontElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFontElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _color = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.color)
        _face = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.face)
        _size = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.size)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var face: String

    @ReadWriteAttribute
    public var size: String
}

public class HTMLFormControlsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFormControlsCollection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList? {
        jsObject[key].fromJSValue()
    }
}

public class HTMLFormElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFormElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _acceptCharset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.acceptCharset)
        _action = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.action)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autocomplete)
        _enctype = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.enctype)
        _encoding = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.encoding)
        _method = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.method)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _noValidate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noValidate)
        _target = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.target)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.relList)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.elements)
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var acceptCharset: String

    @ReadWriteAttribute
    public var action: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var enctype: String

    @ReadWriteAttribute
    public var encoding: String

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var noValidate: Bool

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadonlyAttribute
    public var elements: HTMLFormControlsCollection

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func submit() {
        let this = jsObject
        _ = this[HTMLStrings.submit].function!(this: this, arguments: [])
    }

    @inlinable public func requestSubmit(submitter: HTMLElement? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.requestSubmit].function!(this: this, arguments: [submitter?.jsValue ?? .undefined])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[HTMLStrings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFrameElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scrolling)
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.longDesc)
        _noResize = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noResize)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentWindow)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var noResize: Bool

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLFrameSetElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLFrameSetElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cols = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cols)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rows)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cols: String

    @ReadWriteAttribute
    public var rows: String
}

public class HTMLHRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLHRElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _color = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.color)
        _noShade = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noShade)
        _size = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.size)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var noShade: Bool

    @ReadWriteAttribute
    public var size: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLHeadElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLHeadElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLHeadingElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLHeadingElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLHtmlElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLHtmlElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _version = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.version)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var version: String
}

public protocol HTMLHyperlinkElementUtils: JSBridgedClass {}
public extension HTMLHyperlinkElementUtils {
    @inlinable var href: String {
        get { ReadWriteAttribute[HTMLStrings.href, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.href, in: jsObject] = newValue }
    }

    @inlinable var origin: String { ReadonlyAttribute[HTMLStrings.origin, in: jsObject] }

    @inlinable var `protocol`: String {
        get { ReadWriteAttribute[HTMLStrings.protocol, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.protocol, in: jsObject] = newValue }
    }

    @inlinable var username: String {
        get { ReadWriteAttribute[HTMLStrings.username, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.username, in: jsObject] = newValue }
    }

    @inlinable var password: String {
        get { ReadWriteAttribute[HTMLStrings.password, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.password, in: jsObject] = newValue }
    }

    @inlinable var host: String {
        get { ReadWriteAttribute[HTMLStrings.host, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.host, in: jsObject] = newValue }
    }

    @inlinable var hostname: String {
        get { ReadWriteAttribute[HTMLStrings.hostname, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.hostname, in: jsObject] = newValue }
    }

    @inlinable var port: String {
        get { ReadWriteAttribute[HTMLStrings.port, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.port, in: jsObject] = newValue }
    }

    @inlinable var pathname: String {
        get { ReadWriteAttribute[HTMLStrings.pathname, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.pathname, in: jsObject] = newValue }
    }

    @inlinable var search: String {
        get { ReadWriteAttribute[HTMLStrings.search, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.search, in: jsObject] = newValue }
    }

    @inlinable var hash: String {
        get { ReadWriteAttribute[HTMLStrings.hash, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.hash, in: jsObject] = newValue }
    }
}

public class HTMLIFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLIFrameElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _srcdoc = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.srcdoc)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _sandbox = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.sandbox)
        _allow = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.allow)
        _allowFullscreen = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.allowFullscreen)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.loading)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentWindow)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scrolling)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.longDesc)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcdoc: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var sandbox: DOMTokenList

    @ReadWriteAttribute
    public var allow: String

    @ReadWriteAttribute
    public var allowFullscreen: Bool

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var loading: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[HTMLStrings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLImageElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLImageElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.alt)
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.sizes)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.crossOrigin)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.useMap)
        _isMap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.isMap)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _naturalWidth = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.naturalWidth)
        _naturalHeight = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.naturalHeight)
        _complete = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.complete)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.currentSrc)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _decoding = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.decoding)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.loading)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _lowsrc = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.lowsrc)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hspace)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vspace)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.longDesc)
        _border = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.border)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var isMap: Bool

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var naturalWidth: UInt32

    @ReadonlyAttribute
    public var naturalHeight: UInt32

    @ReadonlyAttribute
    public var complete: Bool

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var decoding: String

    @ReadWriteAttribute
    public var loading: String

    @inlinable public func decode() -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.decode].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decode() async throws {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.decode].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var lowsrc: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var border: String
}

public class HTMLInputElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLInputElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _accept = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.accept)
        _alt = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.alt)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autocomplete)
        _defaultChecked = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultChecked)
        _checked = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.checked)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _files = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.files)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.formTarget)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _indeterminate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.indeterminate)
        _list = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.list)
        _max = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.max)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.maxLength)
        _min = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.min)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.minLength)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _pattern = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.pattern)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.size)
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _step = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.step)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _valueAsDate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.valueAsDate)
        _valueAsNumber = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.valueAsNumber)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionDirection)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.useMap)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var accept: String

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var defaultChecked: Bool

    @ReadWriteAttribute
    public var checked: Bool

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var files: FileList?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var indeterminate: Bool

    @ReadonlyAttribute
    public var list: HTMLElement?

    @ReadWriteAttribute
    public var max: String

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var min: String

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var pattern: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var step: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var valueAsDate: JSObject?

    @ReadWriteAttribute
    public var valueAsNumber: Double

    @ReadWriteAttribute
    public var width: UInt32

    @inlinable public func stepUp(n: Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.stepUp].function!(this: this, arguments: [n?.jsValue ?? .undefined])
    }

    @inlinable public func stepDown(n: Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.stepDown].function!(this: this, arguments: [n?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList?

    @inlinable public func select() {
        let this = jsObject
        _ = this[HTMLStrings.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32?

    @ReadWriteAttribute
    public var selectionEnd: UInt32?

    @ReadWriteAttribute
    public var selectionDirection: String?

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[HTMLStrings.setRangeText].function!(this: this, arguments: [replacement.jsValue])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setRangeText].function!(this: this, arguments: [replacement.jsValue, start.jsValue, end.jsValue, selectionMode?.jsValue ?? .undefined])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setSelectionRange].function!(this: this, arguments: [start.jsValue, end.jsValue, direction?.jsValue ?? .undefined])
    }

    @inlinable public func showPicker() {
        let this = jsObject
        _ = this[HTMLStrings.showPicker].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var useMap: String
}

public class HTMLLIElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLLIElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Int32

    @ReadWriteAttribute
    public var type: String
}

public class HTMLLabelElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLLabelElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.htmlFor)
        _control = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.control)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var htmlFor: String

    @ReadonlyAttribute
    public var control: HTMLElement?
}

public class HTMLLegendElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLLegendElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var align: String
}

public class HTMLLinkElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLLinkElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.href)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.crossOrigin)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rel)
        _as = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.as)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.relList)
        _media = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.media)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.integrity)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _sizes = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.sizes)
        _imageSrcset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.imageSrcset)
        _imageSizes = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.imageSizes)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.blocking)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.charset)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rev)
        _target = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var rel: String

    @ReadWriteAttribute
    public var `as`: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadonlyAttribute
    public var sizes: DOMTokenList

    @ReadWriteAttribute
    public var imageSrcset: String

    @ReadWriteAttribute
    public var imageSizes: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLMapElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMapElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _areas = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.areas)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var areas: HTMLCollection
}

public class HTMLMarqueeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMarqueeElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _behavior = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.behavior)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.bgColor)
        _direction = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.direction)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hspace)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.loop)
        _scrollAmount = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scrollAmount)
        _scrollDelay = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scrollDelay)
        _trueSpeed = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.trueSpeed)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vspace)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var behavior: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var direction: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var loop: Int32

    @ReadWriteAttribute
    public var scrollAmount: UInt32

    @ReadWriteAttribute
    public var scrollDelay: UInt32

    @ReadWriteAttribute
    public var trueSpeed: Bool

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var width: String

    @inlinable public func start() {
        let this = jsObject
        _ = this[HTMLStrings.start].function!(this: this, arguments: [])
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[HTMLStrings.stop].function!(this: this, arguments: [])
    }
}

public class HTMLMediaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMediaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.error)
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.currentSrc)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.crossOrigin)
        _networkState = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.networkState)
        _preload = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.preload)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.buffered)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.readyState)
        _seeking = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.seeking)
        _currentTime = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.currentTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.duration)
        _paused = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.paused)
        _defaultPlaybackRate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultPlaybackRate)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.playbackRate)
        _preservesPitch = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.preservesPitch)
        _played = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.played)
        _seekable = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.seekable)
        _ended = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.ended)
        _autoplay = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autoplay)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.loop)
        _controls = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.controls)
        _volume = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.volume)
        _muted = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.muted)
        _defaultMuted = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultMuted)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.textTracks)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var error: MediaError?

    @ReadWriteAttribute
    public var src: String

    // XXX: member 'srcObject' is ignored

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    public static let NETWORK_EMPTY: UInt16 = 0

    public static let NETWORK_IDLE: UInt16 = 1

    public static let NETWORK_LOADING: UInt16 = 2

    public static let NETWORK_NO_SOURCE: UInt16 = 3

    @ReadonlyAttribute
    public var networkState: UInt16

    @ReadWriteAttribute
    public var preload: String

    @ReadonlyAttribute
    public var buffered: TimeRanges

    @inlinable public func load() {
        let this = jsObject
        _ = this[HTMLStrings.load].function!(this: this, arguments: [])
    }

    @inlinable public func canPlayType(type: String) -> CanPlayTypeResult {
        let this = jsObject
        return this[HTMLStrings.canPlayType].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    public static let HAVE_NOTHING: UInt16 = 0

    public static let HAVE_METADATA: UInt16 = 1

    public static let HAVE_CURRENT_DATA: UInt16 = 2

    public static let HAVE_FUTURE_DATA: UInt16 = 3

    public static let HAVE_ENOUGH_DATA: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var seeking: Bool

    @ReadWriteAttribute
    public var currentTime: Double

    @inlinable public func fastSeek(time: Double) {
        let this = jsObject
        _ = this[HTMLStrings.fastSeek].function!(this: this, arguments: [time.jsValue])
    }

    @ReadonlyAttribute
    public var duration: Double

    @inlinable public func getStartDate() -> JSObject {
        let this = jsObject
        return this[HTMLStrings.getStartDate].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var paused: Bool

    @ReadWriteAttribute
    public var defaultPlaybackRate: Double

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadWriteAttribute
    public var preservesPitch: Bool

    @ReadonlyAttribute
    public var played: TimeRanges

    @ReadonlyAttribute
    public var seekable: TimeRanges

    @ReadonlyAttribute
    public var ended: Bool

    @ReadWriteAttribute
    public var autoplay: Bool

    @ReadWriteAttribute
    public var loop: Bool

    @inlinable public func play() -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.play].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func play() async throws {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.play].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[HTMLStrings.pause].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var controls: Bool

    @ReadWriteAttribute
    public var volume: Double

    @ReadWriteAttribute
    public var muted: Bool

    @ReadWriteAttribute
    public var defaultMuted: Bool

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    @inlinable public func addTextTrack(kind: TextTrackKind, label: String? = nil, language: String? = nil) -> TextTrack {
        let this = jsObject
        return this[HTMLStrings.addTextTrack].function!(this: this, arguments: [kind.jsValue, label?.jsValue ?? .undefined, language?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class HTMLMenuElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMenuElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLMetaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMetaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _httpEquiv = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.httpEquiv)
        _content = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.content)
        _media = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.media)
        _scheme = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scheme)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var httpEquiv: String

    @ReadWriteAttribute
    public var content: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var scheme: String
}

public class HTMLMeterElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLMeterElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _min = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.min)
        _max = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.max)
        _low = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.low)
        _high = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.high)
        _optimum = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.optimum)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var min: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadWriteAttribute
    public var low: Double

    @ReadWriteAttribute
    public var high: Double

    @ReadWriteAttribute
    public var optimum: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLModElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLModElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cite)
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLOListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLOListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reversed = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.reversed)
        _start = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.start)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _compact = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var reversed: Bool

    @ReadWriteAttribute
    public var start: Int32

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLObjectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLObjectElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.data)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.contentWindow)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _archive = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.archive)
        _code = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.code)
        _declare = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.declare)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hspace)
        _standby = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.standby)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vspace)
        _codeBase = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.codeBase)
        _codeType = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.codeType)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.useMap)
        _border = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.border)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var data: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[HTMLStrings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var archive: String

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var declare: Bool

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var standby: String

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var codeBase: String

    @ReadWriteAttribute
    public var codeType: String

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var border: String
}

public class HTMLOptGroupElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLOptGroupElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _label = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.label)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var label: String
}

public class HTMLOptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLOptionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _label = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.label)
        _defaultSelected = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultSelected)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selected)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _text = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.text)
        _index = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.index)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var defaultSelected: Bool

    @ReadWriteAttribute
    public var selected: Bool

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var text: String

    @ReadonlyAttribute
    public var index: Int32
}

public class HTMLOptionsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLOptionsCollection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectedIndex)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var length: UInt32

    // XXX: unsupported setter for keys of type UInt32

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.add].function!(this: this, arguments: [element.jsValue, before?.jsValue ?? .undefined])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.remove].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var selectedIndex: Int32
}

public protocol HTMLOrSVGElement: JSBridgedClass {}
public extension HTMLOrSVGElement {
    @inlinable var dataset: DOMStringMap { ReadonlyAttribute[HTMLStrings.dataset, in: jsObject] }

    @inlinable var nonce: String {
        get { ReadWriteAttribute[HTMLStrings.nonce, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.nonce, in: jsObject] = newValue }
    }

    @inlinable var autofocus: Bool {
        get { ReadWriteAttribute[HTMLStrings.autofocus, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.autofocus, in: jsObject] = newValue }
    }

    @inlinable var tabIndex: Int32 {
        get { ReadWriteAttribute[HTMLStrings.tabIndex, in: jsObject] }
        nonmutating set { ReadWriteAttribute[HTMLStrings.tabIndex, in: jsObject] = newValue }
    }

    @inlinable func focus(options: FocusOptions? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.focus].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable func blur() {
        let this = jsObject
        _ = this[HTMLStrings.blur].function!(this: this, arguments: [])
    }
}

public class HTMLOutputElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLOutputElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _htmlFor = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.htmlFor)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var htmlFor: DOMTokenList

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLParagraphElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLParagraphElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLParamElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLParamElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _valueType = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.valueType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var valueType: String
}

public class HTMLPictureElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLPictureElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLPreElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLPreElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: Int32
}

public class HTMLProgressElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLProgressElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _max = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.max)
        _position = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.position)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadonlyAttribute
    public var position: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLQuoteElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLQuoteElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cite)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String
}

public class HTMLScriptElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLScriptElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _noModule = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noModule)
        _async = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.async)
        _defer = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defer)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.crossOrigin)
        _text = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.text)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.integrity)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.blocking)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.charset)
        _event = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.event)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.htmlFor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var noModule: Bool

    @ReadWriteAttribute
    public var async: Bool

    @ReadWriteAttribute
    public var `defer`: Bool

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @inlinable public static func supports(type: String) -> Bool {
        let this = constructor
        return this[HTMLStrings.supports].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var event: String

    @ReadWriteAttribute
    public var htmlFor: String
}

public class HTMLSelectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLSelectElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autocomplete)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _required = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _options = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.options)
        _length = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _selectedOptions = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.selectedOptions)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectedIndex)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var options: HTMLOptionsCollection

    @ReadWriteAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> HTMLOptionElement? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> HTMLOptionElement? {
        let this = jsObject
        return this[HTMLStrings.namedItem].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.add].function!(this: this, arguments: [element.jsValue, before?.jsValue ?? .undefined])
    }

    @inlinable public func remove() {
        let this = jsObject
        _ = this[HTMLStrings.remove].function!(this: this, arguments: [])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.remove].function!(this: this, arguments: [index.jsValue])
    }

    // XXX: unsupported setter for keys of type UInt32

    @ReadonlyAttribute
    public var selectedOptions: HTMLCollection

    @ReadWriteAttribute
    public var selectedIndex: Int32

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLSlotElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLSlotElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @inlinable public func assignedNodes(options: AssignedNodesOptions? = nil) -> [Node] {
        let this = jsObject
        return this[HTMLStrings.assignedNodes].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func assignedElements(options: AssignedNodesOptions? = nil) -> [Element] {
        let this = jsObject
        return this[HTMLStrings.assignedElements].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func assign(nodes: Element_or_Text...) {
        let this = jsObject
        _ = this[HTMLStrings.assign].function!(this: this, arguments: nodes.map(\.jsValue))
    }
}

public class HTMLSourceElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLSourceElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.sizes)
        _media = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.media)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32
}

public class HTMLSpanElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLSpanElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLStyleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLStyleElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.media)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.blocking)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var media: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var type: String
}

public class HTMLTableCaptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableCaptionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLTableCellElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableCellElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _colSpan = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.colSpan)
        _rowSpan = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rowSpan)
        _headers = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.headers)
        _cellIndex = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.cellIndex)
        _scope = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scope)
        _abbr = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.abbr)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _axis = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.axis)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.chOff)
        _noWrap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.noWrap)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var colSpan: UInt32

    @ReadWriteAttribute
    public var rowSpan: UInt32

    @ReadWriteAttribute
    public var headers: String

    @ReadonlyAttribute
    public var cellIndex: Int32

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var abbr: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var axis: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var noWrap: Bool

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableColElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableColElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _span = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.span)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vAlign)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var span: UInt32

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLTableElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _caption = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.caption)
        _tHead = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.tHead)
        _tFoot = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.tFoot)
        _tBodies = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.tBodies)
        _rows = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _border = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.border)
        _frame = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.frame)
        _rules = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rules)
        _summary = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.summary)
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.bgColor)
        _cellPadding = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cellPadding)
        _cellSpacing = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cellSpacing)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var caption: HTMLTableCaptionElement?

    @inlinable public func createCaption() -> HTMLTableCaptionElement {
        let this = jsObject
        return this[HTMLStrings.createCaption].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteCaption() {
        let this = jsObject
        _ = this[HTMLStrings.deleteCaption].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tHead: HTMLTableSectionElement?

    @inlinable public func createTHead() -> HTMLTableSectionElement {
        let this = jsObject
        return this[HTMLStrings.createTHead].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTHead() {
        let this = jsObject
        _ = this[HTMLStrings.deleteTHead].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tFoot: HTMLTableSectionElement?

    @inlinable public func createTFoot() -> HTMLTableSectionElement {
        let this = jsObject
        return this[HTMLStrings.createTFoot].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTFoot() {
        let this = jsObject
        _ = this[HTMLStrings.deleteTFoot].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var tBodies: HTMLCollection

    @inlinable public func createTBody() -> HTMLTableSectionElement {
        let this = jsObject
        return this[HTMLStrings.createTBody].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[HTMLStrings.insertRow].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.deleteRow].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var border: String

    @ReadWriteAttribute
    public var frame: String

    @ReadWriteAttribute
    public var rules: String

    @ReadWriteAttribute
    public var summary: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var cellPadding: String

    @ReadWriteAttribute
    public var cellSpacing: String
}

public class HTMLTableRowElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableRowElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rowIndex = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.rowIndex)
        _sectionRowIndex = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.sectionRowIndex)
        _cells = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.cells)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rowIndex: Int32

    @ReadonlyAttribute
    public var sectionRowIndex: Int32

    @ReadonlyAttribute
    public var cells: HTMLCollection

    @inlinable public func insertCell(index: Int32? = nil) -> HTMLTableCellElement {
        let this = jsObject
        return this[HTMLStrings.insertCell].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteCell(index: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.deleteCell].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableSectionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTableSectionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rows = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.vAlign)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[HTMLStrings.insertRow].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[HTMLStrings.deleteRow].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String
}

public class HTMLTemplateElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTemplateElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _content = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.content)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var content: DocumentFragment
}

public class HTMLTextAreaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTextAreaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.autocomplete)
        _cols = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.cols)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.form)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.maxLength)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.minLength)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.required)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.rows)
        _wrap = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.wrap)
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        _textLength = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.textLength)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selectionDirection)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var cols: UInt32

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var rows: UInt32

    @ReadWriteAttribute
    public var wrap: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var textLength: UInt32

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[HTMLStrings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[HTMLStrings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList

    @inlinable public func select() {
        let this = jsObject
        _ = this[HTMLStrings.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32

    @ReadWriteAttribute
    public var selectionEnd: UInt32

    @ReadWriteAttribute
    public var selectionDirection: String

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[HTMLStrings.setRangeText].function!(this: this, arguments: [replacement.jsValue])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setRangeText].function!(this: this, arguments: [replacement.jsValue, start.jsValue, end.jsValue, selectionMode?.jsValue ?? .undefined])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.setSelectionRange].function!(this: this, arguments: [start.jsValue, end.jsValue, direction?.jsValue ?? .undefined])
    }
}

public class HTMLTimeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTimeElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLTitleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTitleElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.text)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String
}

public class HTMLTrackElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLTrackElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.kind)
        _src = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.src)
        _srclang = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.srclang)
        _label = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.label)
        _default = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.default)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.readyState)
        _track = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var kind: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srclang: String

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var `default`: Bool

    public static let NONE: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let LOADED: UInt16 = 2

    public static let ERROR: UInt16 = 3

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var track: TextTrack
}

public class HTMLUListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLUListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.compact)
        _type = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool

    @ReadWriteAttribute
    public var type: String
}

public class HTMLUnknownElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLUnknownElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class HTMLVideoElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HTMLVideoElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _videoWidth = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.videoWidth)
        _videoHeight = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.videoHeight)
        _poster = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.poster)
        _playsInline = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.playsInline)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var videoWidth: UInt32

    @ReadonlyAttribute
    public var videoHeight: UInt32

    @ReadWriteAttribute
    public var poster: String

    @ReadWriteAttribute
    public var playsInline: Bool
}

public class HashChangeEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.HashChangeEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _oldURL = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.oldURL)
        _newURL = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.newURL)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: HashChangeEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var oldURL: String

    @ReadonlyAttribute
    public var newURL: String
}

public class HashChangeEventInit: BridgedDictionary {
    public convenience init(oldURL: String, newURL: String) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.oldURL] = oldURL.jsValue
        object[HTMLStrings.newURL] = newURL.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _oldURL = ReadWriteAttribute(jsObject: object, name: HTMLStrings.oldURL)
        _newURL = ReadWriteAttribute(jsObject: object, name: HTMLStrings.newURL)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var oldURL: String

    @ReadWriteAttribute
    public var newURL: String
}

public class History: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.History].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _scrollRestoration = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.scrollRestoration)
        _state = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.state)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var scrollRestoration: ScrollRestoration

    @ReadonlyAttribute
    public var state: JSValue

    @inlinable public func go(delta: Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.go].function!(this: this, arguments: [delta?.jsValue ?? .undefined])
    }

    @inlinable public func back() {
        let this = jsObject
        _ = this[HTMLStrings.back].function!(this: this, arguments: [])
    }

    @inlinable public func forward() {
        let this = jsObject
        _ = this[HTMLStrings.forward].function!(this: this, arguments: [])
    }

    @inlinable public func pushState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.pushState].function!(this: this, arguments: [data.jsValue, unused.jsValue, url?.jsValue ?? .undefined])
    }

    @inlinable public func replaceState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.replaceState].function!(this: this, arguments: [data.jsValue, unused.jsValue, url?.jsValue ?? .undefined])
    }
}

public class ImageBitmap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.ImageBitmap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.height)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @inlinable public func close() {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [])
    }
}

public class ImageBitmapOptions: BridgedDictionary {
    public convenience init(imageOrientation: ImageOrientation, premultiplyAlpha: PremultiplyAlpha, colorSpaceConversion: ColorSpaceConversion, resizeWidth: UInt32, resizeHeight: UInt32, resizeQuality: ResizeQuality) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.imageOrientation] = imageOrientation.jsValue
        object[HTMLStrings.premultiplyAlpha] = premultiplyAlpha.jsValue
        object[HTMLStrings.colorSpaceConversion] = colorSpaceConversion.jsValue
        object[HTMLStrings.resizeWidth] = resizeWidth.jsValue
        object[HTMLStrings.resizeHeight] = resizeHeight.jsValue
        object[HTMLStrings.resizeQuality] = resizeQuality.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _imageOrientation = ReadWriteAttribute(jsObject: object, name: HTMLStrings.imageOrientation)
        _premultiplyAlpha = ReadWriteAttribute(jsObject: object, name: HTMLStrings.premultiplyAlpha)
        _colorSpaceConversion = ReadWriteAttribute(jsObject: object, name: HTMLStrings.colorSpaceConversion)
        _resizeWidth = ReadWriteAttribute(jsObject: object, name: HTMLStrings.resizeWidth)
        _resizeHeight = ReadWriteAttribute(jsObject: object, name: HTMLStrings.resizeHeight)
        _resizeQuality = ReadWriteAttribute(jsObject: object, name: HTMLStrings.resizeQuality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var imageOrientation: ImageOrientation

    @ReadWriteAttribute
    public var premultiplyAlpha: PremultiplyAlpha

    @ReadWriteAttribute
    public var colorSpaceConversion: ColorSpaceConversion

    @ReadWriteAttribute
    public var resizeWidth: UInt32

    @ReadWriteAttribute
    public var resizeHeight: UInt32

    @ReadWriteAttribute
    public var resizeQuality: ResizeQuality
}

public class ImageBitmapRenderingContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.ImageBitmapRenderingContext].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement_or_OffscreenCanvas

    @inlinable public func transferFromImageBitmap(bitmap: ImageBitmap?) {
        let this = jsObject
        _ = this[HTMLStrings.transferFromImageBitmap].function!(this: this, arguments: [bitmap.jsValue])
    }
}

public class ImageBitmapRenderingContextSettings: BridgedDictionary {
    public convenience init(alpha: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.alpha] = alpha.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: HTMLStrings.alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool
}

public class ImageData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.ImageData].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _data = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.data)
        _colorSpace = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.colorSpace)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(sw: UInt32, sh: UInt32, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]))
    }

    @inlinable public convenience init(data: Uint8ClampedArray, sw: UInt32, sh: UInt32? = nil, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data.jsValue, sw.jsValue, sh?.jsValue ?? .undefined, settings?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var data: Uint8ClampedArray

    @ReadonlyAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageDataSettings: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.colorSpace] = colorSpace.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: HTMLStrings.colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageEncodeOptions: BridgedDictionary {
    public convenience init(type: String, quality: Double) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.type] = type.jsValue
        object[HTMLStrings.quality] = quality.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: HTMLStrings.type)
        _quality = ReadWriteAttribute(jsObject: object, name: HTMLStrings.quality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var quality: Double
}

public enum ImageOrientation: JSString, JSValueCompatible {
    case none = "none"
    case flipY = "flipY"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ImageSmoothingQuality: JSString, JSValueCompatible {
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Location: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Location].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.href)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.origin)
        _protocol = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.protocol)
        _host = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.host)
        _hostname = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hostname)
        _port = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.port)
        _pathname = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.pathname)
        _search = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.search)
        _hash = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.hash)
        _ancestorOrigins = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.ancestorOrigins)
        self.jsObject = jsObject
    }

    @ReadWriteAttribute
    public var href: String

    @ReadonlyAttribute
    public var origin: String

    @ReadWriteAttribute
    public var `protocol`: String

    @ReadWriteAttribute
    public var host: String

    @ReadWriteAttribute
    public var hostname: String

    @ReadWriteAttribute
    public var port: String

    @ReadWriteAttribute
    public var pathname: String

    @ReadWriteAttribute
    public var search: String

    @ReadWriteAttribute
    public var hash: String

    @inlinable public func assign(url: String) {
        let this = jsObject
        _ = this[HTMLStrings.assign].function!(this: this, arguments: [url.jsValue])
    }

    @inlinable public func replace(url: String) {
        let this = jsObject
        _ = this[HTMLStrings.replace].function!(this: this, arguments: [url.jsValue])
    }

    @inlinable public func reload() {
        let this = jsObject
        _ = this[HTMLStrings.reload].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var ancestorOrigins: DOMStringList
}

public class MediaError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.MediaError].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _code = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.code)
        _message = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.message)
        self.jsObject = jsObject
    }

    public static let MEDIA_ERR_ABORTED: UInt16 = 1

    public static let MEDIA_ERR_NETWORK: UInt16 = 2

    public static let MEDIA_ERR_DECODE: UInt16 = 3

    public static let MEDIA_ERR_SRC_NOT_SUPPORTED: UInt16 = 4

    @ReadonlyAttribute
    public var code: UInt16

    @ReadonlyAttribute
    public var message: String
}

public class MessageChannel: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.MessageChannel].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port1 = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.port1)
        _port2 = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.port2)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var port1: MessagePort

    @ReadonlyAttribute
    public var port2: MessagePort
}

public class MessageEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.MessageEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.data)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.origin)
        _lastEventId = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.lastEventId)
        _source = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.source)
        _ports = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.ports)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MessageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var data: JSValue

    @ReadonlyAttribute
    public var origin: String

    @ReadonlyAttribute
    public var lastEventId: String

    @ReadonlyAttribute
    public var source: MessageEventSource?

    @ReadonlyAttribute
    public var ports: [MessagePort]

    @inlinable public func initMessageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, data: JSValue? = nil, origin: String? = nil, lastEventId: String? = nil, source: MessageEventSource? = nil, ports: [MessagePort]? = nil) {
        let _arg0 = type.jsValue
        let _arg1 = bubbles?.jsValue ?? .undefined
        let _arg2 = cancelable?.jsValue ?? .undefined
        let _arg3 = data?.jsValue ?? .undefined
        let _arg4 = origin?.jsValue ?? .undefined
        let _arg5 = lastEventId?.jsValue ?? .undefined
        let _arg6 = source?.jsValue ?? .undefined
        let _arg7 = ports?.jsValue ?? .undefined
        let this = jsObject
        _ = this[HTMLStrings.initMessageEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class MessageEventInit: BridgedDictionary {
    public convenience init(data: JSValue, origin: String, lastEventId: String, source: MessageEventSource?, ports: [MessagePort]) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.data] = data.jsValue
        object[HTMLStrings.origin] = origin.jsValue
        object[HTMLStrings.lastEventId] = lastEventId.jsValue
        object[HTMLStrings.source] = source.jsValue
        object[HTMLStrings.ports] = ports.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: HTMLStrings.data)
        _origin = ReadWriteAttribute(jsObject: object, name: HTMLStrings.origin)
        _lastEventId = ReadWriteAttribute(jsObject: object, name: HTMLStrings.lastEventId)
        _source = ReadWriteAttribute(jsObject: object, name: HTMLStrings.source)
        _ports = ReadWriteAttribute(jsObject: object, name: HTMLStrings.ports)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: JSValue

    @ReadWriteAttribute
    public var origin: String

    @ReadWriteAttribute
    public var lastEventId: String

    @ReadWriteAttribute
    public var source: MessageEventSource?

    @ReadWriteAttribute
    public var ports: [MessagePort]
}

public class MessagePort: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.MessagePort].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func start() {
        let this = jsObject
        _ = this[HTMLStrings.start].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class MimeType: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.MimeType].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.type)
        _description = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.description)
        _suffixes = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.suffixes)
        _enabledPlugin = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.enabledPlugin)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var suffixes: String

    @ReadonlyAttribute
    public var enabledPlugin: Plugin
}

public class MimeTypeArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.MimeTypeArray].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
}

public class Navigator: JSBridgedClass, NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Navigator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public protocol NavigatorConcurrentHardware: JSBridgedClass {}
public extension NavigatorConcurrentHardware {
    @inlinable var hardwareConcurrency: UInt64 { ReadonlyAttribute[HTMLStrings.hardwareConcurrency, in: jsObject] }
}

public protocol NavigatorContentUtils: JSBridgedClass {}
public extension NavigatorContentUtils {
    @inlinable func registerProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[HTMLStrings.registerProtocolHandler].function!(this: this, arguments: [scheme.jsValue, url.jsValue])
    }

    @inlinable func unregisterProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[HTMLStrings.unregisterProtocolHandler].function!(this: this, arguments: [scheme.jsValue, url.jsValue])
    }
}

public protocol NavigatorCookies: JSBridgedClass {}
public extension NavigatorCookies {
    @inlinable var cookieEnabled: Bool { ReadonlyAttribute[HTMLStrings.cookieEnabled, in: jsObject] }
}

public protocol NavigatorID: JSBridgedClass {}
public extension NavigatorID {
    @inlinable var appCodeName: String { ReadonlyAttribute[HTMLStrings.appCodeName, in: jsObject] }

    @inlinable var appName: String { ReadonlyAttribute[HTMLStrings.appName, in: jsObject] }

    @inlinable var appVersion: String { ReadonlyAttribute[HTMLStrings.appVersion, in: jsObject] }

    @inlinable var platform: String { ReadonlyAttribute[HTMLStrings.platform, in: jsObject] }

    @inlinable var product: String { ReadonlyAttribute[HTMLStrings.product, in: jsObject] }

    @inlinable var productSub: String { ReadonlyAttribute[HTMLStrings.productSub, in: jsObject] }

    @inlinable var userAgent: String { ReadonlyAttribute[HTMLStrings.userAgent, in: jsObject] }

    @inlinable var vendor: String { ReadonlyAttribute[HTMLStrings.vendor, in: jsObject] }

    @inlinable var vendorSub: String { ReadonlyAttribute[HTMLStrings.vendorSub, in: jsObject] }

    @inlinable func taintEnabled() -> Bool {
        let this = jsObject
        return this[HTMLStrings.taintEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var oscpu: String { ReadonlyAttribute[HTMLStrings.oscpu, in: jsObject] }
}

public protocol NavigatorLanguage: JSBridgedClass {}
public extension NavigatorLanguage {
    @inlinable var language: String { ReadonlyAttribute[HTMLStrings.language, in: jsObject] }

    @inlinable var languages: [String] { ReadonlyAttribute[HTMLStrings.languages, in: jsObject] }
}

public protocol NavigatorOnLine: JSBridgedClass {}
public extension NavigatorOnLine {
    @inlinable var onLine: Bool { ReadonlyAttribute[HTMLStrings.onLine, in: jsObject] }
}

public protocol NavigatorPlugins: JSBridgedClass {}
public extension NavigatorPlugins {
    @inlinable var plugins: PluginArray { ReadonlyAttribute[HTMLStrings.plugins, in: jsObject] }

    @inlinable var mimeTypes: MimeTypeArray { ReadonlyAttribute[HTMLStrings.mimeTypes, in: jsObject] }

    @inlinable func javaEnabled() -> Bool {
        let this = jsObject
        return this[HTMLStrings.javaEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var pdfViewerEnabled: Bool { ReadonlyAttribute[HTMLStrings.pdfViewerEnabled, in: jsObject] }
}

public class OffscreenCanvas: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.OffscreenCanvas].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.height)
        _oncontextlost = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.oncontextlost)
        _oncontextrestored = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.oncontextrestored)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(width: UInt64, height: UInt64) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [width.jsValue, height.jsValue]))
    }

    @ReadWriteAttribute
    public var width: UInt64

    @ReadWriteAttribute
    public var height: UInt64

    @inlinable public func getContext(contextId: OffscreenRenderingContextId, options: JSValue? = nil) -> OffscreenRenderingContext? {
        let this = jsObject
        return this[HTMLStrings.getContext].function!(this: this, arguments: [contextId.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func transferToImageBitmap() -> ImageBitmap {
        let this = jsObject
        return this[HTMLStrings.transferToImageBitmap].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.convertToBlob].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.convertToBlob].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var oncontextlost: EventHandler

    @ClosureAttribute1Optional
    public var oncontextrestored: EventHandler
}

public class OffscreenCanvasRenderingContext2D: JSBridgedClass, CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.OffscreenCanvasRenderingContext2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.canvas)
        self.jsObject = jsObject
    }

    @inlinable public func commit() {
        let this = jsObject
        _ = this[HTMLStrings.commit].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var canvas: OffscreenCanvas
}

public enum OffscreenRenderingContextId: JSString, JSValueCompatible {
    case _2d = "2d"
    case bitmaprenderer = "bitmaprenderer"
    case webgl = "webgl"
    case webgl2 = "webgl2"
    case webgpu = "webgpu"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PageTransitionEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.PageTransitionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _persisted = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.persisted)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PageTransitionEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var persisted: Bool
}

public class PageTransitionEventInit: BridgedDictionary {
    public convenience init(persisted: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.persisted] = persisted.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _persisted = ReadWriteAttribute(jsObject: object, name: HTMLStrings.persisted)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var persisted: Bool
}

public class Path2D: JSBridgedClass, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Path2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(path: Path2D_or_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [path?.jsValue ?? .undefined]))
    }

    @inlinable public func addPath(path: Path2D, transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.addPath].function!(this: this, arguments: [path.jsValue, transform?.jsValue ?? .undefined])
    }
}

public class Plugin: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Plugin].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _description = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.description)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.filename)
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
}

public class PluginArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.PluginArray].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @inlinable public func refresh() {
        let this = jsObject
        _ = this[HTMLStrings.refresh].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Plugin? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Plugin? {
        jsObject[key].fromJSValue()
    }
}

public class PopStateEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.PopStateEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.state)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PopStateEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var state: JSValue
}

public class PopStateEventInit: BridgedDictionary {
    public convenience init(state: JSValue) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.state] = state.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: HTMLStrings.state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue
}

public enum PredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"
    case displayP3 = "display-p3"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum PremultiplyAlpha: JSString, JSValueCompatible {
    case none = "none"
    case premultiply = "premultiply"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PromiseRejectionEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.PromiseRejectionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _promise = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.promise)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PromiseRejectionEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var promise: JSPromise

    @ReadonlyAttribute
    public var reason: JSValue
}

public class PromiseRejectionEventInit: BridgedDictionary {
    public convenience init(promise: JSPromise, reason: JSValue) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.promise] = promise.jsValue
        object[HTMLStrings.reason] = reason.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _promise = ReadWriteAttribute(jsObject: object, name: HTMLStrings.promise)
        _reason = ReadWriteAttribute(jsObject: object, name: HTMLStrings.reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var promise: JSPromise

    @ReadWriteAttribute
    public var reason: JSValue
}

public class RadioNodeList: NodeList {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.RadioNodeList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.value)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var value: String
}

public enum ResizeQuality: JSString, JSValueCompatible {
    case pixelated = "pixelated"
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ScrollRestoration: JSString, JSValueCompatible {
    case auto = "auto"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum SelectionMode: JSString, JSValueCompatible {
    case select = "select"
    case start = "start"
    case end = "end"
    case preserve = "preserve"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class SharedWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.SharedWorker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.port)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: String_or_WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var port: MessagePort
}

public class Storage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Storage].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func key(index: UInt32) -> String? {
        let this = jsObject
        return this[HTMLStrings.key].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }

    @inlinable public subscript(key: String) -> String? {
        jsObject[key].fromJSValue()
    }

    // XXX: unsupported setter for keys of type String

    // XXX: unsupported deleter for keys of type String

    @inlinable public func clear() {
        let this = jsObject
        _ = this[HTMLStrings.clear].function!(this: this, arguments: [])
    }
}

public class StorageEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.StorageEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _key = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.key)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.oldValue)
        _newValue = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.newValue)
        _url = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.url)
        _storageArea = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.storageArea)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: StorageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var key: String?

    @ReadonlyAttribute
    public var oldValue: String?

    @ReadonlyAttribute
    public var newValue: String?

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var storageArea: Storage?

    @inlinable public func initStorageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, key: String? = nil, oldValue: String? = nil, newValue: String? = nil, url: String? = nil, storageArea: Storage? = nil) {
        let _arg0 = type.jsValue
        let _arg1 = bubbles?.jsValue ?? .undefined
        let _arg2 = cancelable?.jsValue ?? .undefined
        let _arg3 = key?.jsValue ?? .undefined
        let _arg4 = oldValue?.jsValue ?? .undefined
        let _arg5 = newValue?.jsValue ?? .undefined
        let _arg6 = url?.jsValue ?? .undefined
        let _arg7 = storageArea?.jsValue ?? .undefined
        let this = jsObject
        _ = this[HTMLStrings.initStorageEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class StorageEventInit: BridgedDictionary {
    public convenience init(key: String?, oldValue: String?, newValue: String?, url: String, storageArea: Storage?) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.key] = key.jsValue
        object[HTMLStrings.oldValue] = oldValue.jsValue
        object[HTMLStrings.newValue] = newValue.jsValue
        object[HTMLStrings.url] = url.jsValue
        object[HTMLStrings.storageArea] = storageArea.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _key = ReadWriteAttribute(jsObject: object, name: HTMLStrings.key)
        _oldValue = ReadWriteAttribute(jsObject: object, name: HTMLStrings.oldValue)
        _newValue = ReadWriteAttribute(jsObject: object, name: HTMLStrings.newValue)
        _url = ReadWriteAttribute(jsObject: object, name: HTMLStrings.url)
        _storageArea = ReadWriteAttribute(jsObject: object, name: HTMLStrings.storageArea)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var key: String?

    @ReadWriteAttribute
    public var oldValue: String?

    @ReadWriteAttribute
    public var newValue: String?

    @ReadWriteAttribute
    public var url: String

    @ReadWriteAttribute
    public var storageArea: Storage?
}

public class StructuredSerializeOptions: BridgedDictionary {
    public convenience init(transfer: [JSObject]) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.transfer] = transfer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _transfer = ReadWriteAttribute(jsObject: object, name: HTMLStrings.transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var transfer: [JSObject]
}

public class SubmitEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.SubmitEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _submitter = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.submitter)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: SubmitEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var submitter: HTMLElement?
}

public class SubmitEventInit: BridgedDictionary {
    public convenience init(submitter: HTMLElement?) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.submitter] = submitter.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _submitter = ReadWriteAttribute(jsObject: object, name: HTMLStrings.submitter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var submitter: HTMLElement?
}

public class TextMetrics: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.TextMetrics].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.width)
        _actualBoundingBoxLeft = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.actualBoundingBoxLeft)
        _actualBoundingBoxRight = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.actualBoundingBoxRight)
        _fontBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.fontBoundingBoxAscent)
        _fontBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.fontBoundingBoxDescent)
        _actualBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.actualBoundingBoxAscent)
        _actualBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.actualBoundingBoxDescent)
        _emHeightAscent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.emHeightAscent)
        _emHeightDescent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.emHeightDescent)
        _hangingBaseline = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.hangingBaseline)
        _alphabeticBaseline = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.alphabeticBaseline)
        _ideographicBaseline = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.ideographicBaseline)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var actualBoundingBoxLeft: Double

    @ReadonlyAttribute
    public var actualBoundingBoxRight: Double

    @ReadonlyAttribute
    public var fontBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var fontBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var emHeightAscent: Double

    @ReadonlyAttribute
    public var emHeightDescent: Double

    @ReadonlyAttribute
    public var hangingBaseline: Double

    @ReadonlyAttribute
    public var alphabeticBaseline: Double

    @ReadonlyAttribute
    public var ideographicBaseline: Double
}

public class TextTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.TextTrack].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.language)
        _id = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.id)
        _inBandMetadataTrackDispatchType = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.inBandMetadataTrackDispatchType)
        _mode = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.mode)
        _cues = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.cues)
        _activeCues = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.activeCues)
        _oncuechange = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.oncuechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var kind: TextTrackKind

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var inBandMetadataTrackDispatchType: String

    @ReadWriteAttribute
    public var mode: TextTrackMode

    @ReadonlyAttribute
    public var cues: TextTrackCueList?

    @ReadonlyAttribute
    public var activeCues: TextTrackCueList?

    @inlinable public func addCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[HTMLStrings.addCue].function!(this: this, arguments: [cue.jsValue])
    }

    @inlinable public func removeCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[HTMLStrings.removeCue].function!(this: this, arguments: [cue.jsValue])
    }

    @ClosureAttribute1Optional
    public var oncuechange: EventHandler
}

public class TextTrackCue: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.TextTrackCue].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.track)
        _id = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.id)
        _startTime = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.startTime)
        _endTime = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.endTime)
        _pauseOnExit = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.pauseOnExit)
        _onenter = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onenter)
        _onexit = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onexit)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var track: TextTrack?

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var startTime: Double

    @ReadWriteAttribute
    public var endTime: Double

    @ReadWriteAttribute
    public var pauseOnExit: Bool

    @ClosureAttribute1Optional
    public var onenter: EventHandler

    @ClosureAttribute1Optional
    public var onexit: EventHandler
}

public class TextTrackCueList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.TextTrackCueList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrackCue {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getCueById(id: String) -> TextTrackCue? {
        let this = jsObject
        return this[HTMLStrings.getCueById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }
}

public enum TextTrackKind: JSString, JSValueCompatible {
    case subtitles = "subtitles"
    case captions = "captions"
    case descriptions = "descriptions"
    case chapters = "chapters"
    case metadata = "metadata"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TextTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.TextTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> TextTrack? {
        let this = jsObject
        return this[HTMLStrings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public enum TextTrackMode: JSString, JSValueCompatible {
    case disabled = "disabled"
    case hidden = "hidden"
    case showing = "showing"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TimeRanges: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.TimeRanges].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func start(index: UInt32) -> Double {
        let this = jsObject
        return this[HTMLStrings.start].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }

    @inlinable public func end(index: UInt32) -> Double {
        let this = jsObject
        return this[HTMLStrings.end].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }
}

public class TrackEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.TrackEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: TrackEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public class TrackEventInit: BridgedDictionary {
    public convenience init(track: AudioTrack_or_TextTrack_or_VideoTrack?) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.track] = track.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _track = ReadWriteAttribute(jsObject: object, name: HTMLStrings.track)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public typealias CanvasFilterInput = [String: JSValue]

public typealias EventHandler = EventHandlerNonNull?
public typealias OnErrorEventHandler = OnErrorEventHandlerNonNull?
public typealias OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?

public typealias BlobCallback = (Blob?) -> Void
public typealias FunctionStringCallback = (String) -> Void
public typealias EventHandlerNonNull = (Event) -> JSValue
public typealias OnErrorEventHandlerNonNull = (Event_or_String, String, UInt32, UInt32, JSValue) -> JSValue
public typealias OnBeforeUnloadEventHandlerNonNull = (Event) -> String?
public typealias FrameRequestCallback = (DOMHighResTimeStamp) -> Void
public class ValidityState: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.ValidityState].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _valueMissing = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.valueMissing)
        _typeMismatch = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.typeMismatch)
        _patternMismatch = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.patternMismatch)
        _tooLong = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.tooLong)
        _tooShort = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.tooShort)
        _rangeUnderflow = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.rangeUnderflow)
        _rangeOverflow = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.rangeOverflow)
        _stepMismatch = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.stepMismatch)
        _badInput = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.badInput)
        _customError = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.customError)
        _valid = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.valid)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var valueMissing: Bool

    @ReadonlyAttribute
    public var typeMismatch: Bool

    @ReadonlyAttribute
    public var patternMismatch: Bool

    @ReadonlyAttribute
    public var tooLong: Bool

    @ReadonlyAttribute
    public var tooShort: Bool

    @ReadonlyAttribute
    public var rangeUnderflow: Bool

    @ReadonlyAttribute
    public var rangeOverflow: Bool

    @ReadonlyAttribute
    public var stepMismatch: Bool

    @ReadonlyAttribute
    public var badInput: Bool

    @ReadonlyAttribute
    public var customError: Bool

    @ReadonlyAttribute
    public var valid: Bool
}

public class ValidityStateFlags: BridgedDictionary {
    public convenience init(valueMissing: Bool, typeMismatch: Bool, patternMismatch: Bool, tooLong: Bool, tooShort: Bool, rangeUnderflow: Bool, rangeOverflow: Bool, stepMismatch: Bool, badInput: Bool, customError: Bool) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.valueMissing] = valueMissing.jsValue
        object[HTMLStrings.typeMismatch] = typeMismatch.jsValue
        object[HTMLStrings.patternMismatch] = patternMismatch.jsValue
        object[HTMLStrings.tooLong] = tooLong.jsValue
        object[HTMLStrings.tooShort] = tooShort.jsValue
        object[HTMLStrings.rangeUnderflow] = rangeUnderflow.jsValue
        object[HTMLStrings.rangeOverflow] = rangeOverflow.jsValue
        object[HTMLStrings.stepMismatch] = stepMismatch.jsValue
        object[HTMLStrings.badInput] = badInput.jsValue
        object[HTMLStrings.customError] = customError.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _valueMissing = ReadWriteAttribute(jsObject: object, name: HTMLStrings.valueMissing)
        _typeMismatch = ReadWriteAttribute(jsObject: object, name: HTMLStrings.typeMismatch)
        _patternMismatch = ReadWriteAttribute(jsObject: object, name: HTMLStrings.patternMismatch)
        _tooLong = ReadWriteAttribute(jsObject: object, name: HTMLStrings.tooLong)
        _tooShort = ReadWriteAttribute(jsObject: object, name: HTMLStrings.tooShort)
        _rangeUnderflow = ReadWriteAttribute(jsObject: object, name: HTMLStrings.rangeUnderflow)
        _rangeOverflow = ReadWriteAttribute(jsObject: object, name: HTMLStrings.rangeOverflow)
        _stepMismatch = ReadWriteAttribute(jsObject: object, name: HTMLStrings.stepMismatch)
        _badInput = ReadWriteAttribute(jsObject: object, name: HTMLStrings.badInput)
        _customError = ReadWriteAttribute(jsObject: object, name: HTMLStrings.customError)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var valueMissing: Bool

    @ReadWriteAttribute
    public var typeMismatch: Bool

    @ReadWriteAttribute
    public var patternMismatch: Bool

    @ReadWriteAttribute
    public var tooLong: Bool

    @ReadWriteAttribute
    public var tooShort: Bool

    @ReadWriteAttribute
    public var rangeUnderflow: Bool

    @ReadWriteAttribute
    public var rangeOverflow: Bool

    @ReadWriteAttribute
    public var stepMismatch: Bool

    @ReadWriteAttribute
    public var badInput: Bool

    @ReadWriteAttribute
    public var customError: Bool
}

public class VideoTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.VideoTrack].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.language)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.selected)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var selected: Bool
}

public class VideoTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.VideoTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _selectedIndex = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.selectedIndex)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> VideoTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> VideoTrack? {
        let this = jsObject
        return this[HTMLStrings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var selectedIndex: Int32

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class Window: EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, AnimationFrameProvider, WindowSessionStorage, WindowLocalStorage {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.Window].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _window = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.window)
        _self = ReadonlyAttribute(jsObject: jsObject, name: Strings._self)
        _document = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.document)
        _name = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.name)
        _location = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.location)
        _history = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.history)
        _customElements = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.customElements)
        _locationbar = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.locationbar)
        _menubar = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.menubar)
        _personalbar = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.personalbar)
        _scrollbars = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.scrollbars)
        _statusbar = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.statusbar)
        _toolbar = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.toolbar)
        _status = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.status)
        _closed = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.closed)
        _frames = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.frames)
        _length = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.length)
        _top = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.top)
        _opener = ReadWriteAttribute(jsObject: jsObject, name: HTMLStrings.opener)
        _parent = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.parent)
        _frameElement = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.frameElement)
        _navigator = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.navigator)
        _clientInformation = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.clientInformation)
        _originAgentCluster = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.originAgentCluster)
        _external = ReadonlyAttribute(jsObject: jsObject, name: HTMLStrings.external)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var window: WindowProxy

    @ReadonlyAttribute
    public var `self`: WindowProxy

    @ReadonlyAttribute
    public var document: Document

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var location: Location

    @ReadonlyAttribute
    public var history: History

    @ReadonlyAttribute
    public var customElements: CustomElementRegistry

    @ReadonlyAttribute
    public var locationbar: BarProp

    @ReadonlyAttribute
    public var menubar: BarProp

    @ReadonlyAttribute
    public var personalbar: BarProp

    @ReadonlyAttribute
    public var scrollbars: BarProp

    @ReadonlyAttribute
    public var statusbar: BarProp

    @ReadonlyAttribute
    public var toolbar: BarProp

    @ReadWriteAttribute
    public var status: String

    @inlinable public func close() {
        let this = jsObject
        _ = this[HTMLStrings.close].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var closed: Bool

    @inlinable public func stop() {
        let this = jsObject
        _ = this[HTMLStrings.stop].function!(this: this, arguments: [])
    }

    @inlinable public func focus() {
        let this = jsObject
        _ = this[HTMLStrings.focus].function!(this: this, arguments: [])
    }

    @inlinable public func blur() {
        let this = jsObject
        _ = this[HTMLStrings.blur].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var frames: WindowProxy

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var top: WindowProxy?

    @ReadWriteAttribute
    public var opener: JSValue

    @ReadonlyAttribute
    public var parent: WindowProxy?

    @ReadonlyAttribute
    public var frameElement: Element?

    @inlinable public func open(url: String? = nil, target: String? = nil, features: String? = nil) -> WindowProxy? {
        let this = jsObject
        return this[HTMLStrings.open].function!(this: this, arguments: [url?.jsValue ?? .undefined, target?.jsValue ?? .undefined, features?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public subscript(key: String) -> JSObject {
        jsObject[key].fromJSValue()!
    }

    @ReadonlyAttribute
    public var navigator: Navigator

    @ReadonlyAttribute
    public var clientInformation: Navigator

    @ReadonlyAttribute
    public var originAgentCluster: Bool

    @inlinable public func alert() {
        let this = jsObject
        _ = this[HTMLStrings.alert].function!(this: this, arguments: [])
    }

    @inlinable public func alert(message: String) {
        let this = jsObject
        _ = this[HTMLStrings.alert].function!(this: this, arguments: [message.jsValue])
    }

    @inlinable public func confirm(message: String? = nil) -> Bool {
        let this = jsObject
        return this[HTMLStrings.confirm].function!(this: this, arguments: [message?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func prompt(message: String? = nil, default: String? = nil) -> String? {
        let this = jsObject
        return this[HTMLStrings.prompt].function!(this: this, arguments: [message?.jsValue ?? .undefined, `default`?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func print() {
        let this = jsObject
        _ = this[HTMLStrings.print].function!(this: this, arguments: [])
    }

    @inlinable public func postMessage(message: JSValue, targetOrigin: String, transfer: [JSObject]? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, targetOrigin.jsValue, transfer?.jsValue ?? .undefined])
    }

    @inlinable public func postMessage(message: JSValue, options: WindowPostMessageOptions? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func captureEvents() {
        let this = jsObject
        _ = this[HTMLStrings.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable public func releaseEvents() {
        let this = jsObject
        _ = this[HTMLStrings.releaseEvents].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var external: External
}

public protocol WindowEventHandlers: JSBridgedClass {}
public extension WindowEventHandlers {
    @inlinable var onafterprint: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onafterprint, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onafterprint, in: jsObject] = newValue }
    }

    @inlinable var onbeforeprint: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onbeforeprint, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onbeforeprint, in: jsObject] = newValue }
    }

    @inlinable var onbeforeunload: OnBeforeUnloadEventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onbeforeunload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onbeforeunload, in: jsObject] = newValue }
    }

    @inlinable var onhashchange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onhashchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onhashchange, in: jsObject] = newValue }
    }

    @inlinable var onlanguagechange: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onlanguagechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onlanguagechange, in: jsObject] = newValue }
    }

    @inlinable var onmessage: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmessage, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmessage, in: jsObject] = newValue }
    }

    @inlinable var onmessageerror: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onmessageerror, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onmessageerror, in: jsObject] = newValue }
    }

    @inlinable var onoffline: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onoffline, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onoffline, in: jsObject] = newValue }
    }

    @inlinable var ononline: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.ononline, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.ononline, in: jsObject] = newValue }
    }

    @inlinable var onpagehide: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onpagehide, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onpagehide, in: jsObject] = newValue }
    }

    @inlinable var onpageshow: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onpageshow, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onpageshow, in: jsObject] = newValue }
    }

    @inlinable var onpopstate: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onpopstate, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onpopstate, in: jsObject] = newValue }
    }

    @inlinable var onrejectionhandled: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onrejectionhandled, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onrejectionhandled, in: jsObject] = newValue }
    }

    @inlinable var onstorage: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onstorage, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onstorage, in: jsObject] = newValue }
    }

    @inlinable var onunhandledrejection: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onunhandledrejection, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onunhandledrejection, in: jsObject] = newValue }
    }

    @inlinable var onunload: EventHandler {
        get { ClosureAttribute1Optional[HTMLStrings.onunload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[HTMLStrings.onunload, in: jsObject] = newValue }
    }
}

public protocol WindowLocalStorage: JSBridgedClass {}
public extension WindowLocalStorage {
    @inlinable var localStorage: Storage { ReadonlyAttribute[HTMLStrings.localStorage, in: jsObject] }
}

public protocol WindowOrWorkerGlobalScope: JSBridgedClass {}
public extension WindowOrWorkerGlobalScope {
    @inlinable var origin: String { ReadonlyAttribute[HTMLStrings.origin, in: jsObject] }

    @inlinable var isSecureContext: Bool { ReadonlyAttribute[HTMLStrings.isSecureContext, in: jsObject] }

    @inlinable var crossOriginIsolated: Bool { ReadonlyAttribute[HTMLStrings.crossOriginIsolated, in: jsObject] }

    @inlinable func reportError(e: JSValue) {
        let this = jsObject
        _ = this[HTMLStrings.reportError].function!(this: this, arguments: [e.jsValue])
    }

    @inlinable func btoa(data: String) -> String {
        let this = jsObject
        return this[HTMLStrings.btoa].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable func atob(data: String) -> String {
        let this = jsObject
        return this[HTMLStrings.atob].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable func setTimeout(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        let this = jsObject
        return this[HTMLStrings.setTimeout].function!(this: this, arguments: [handler.jsValue, timeout?.jsValue ?? .undefined] + arguments.map(\.jsValue)).fromJSValue()!
    }

    @inlinable func clearTimeout(id: Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.clearTimeout].function!(this: this, arguments: [id?.jsValue ?? .undefined])
    }

    @inlinable func setInterval(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        let this = jsObject
        return this[HTMLStrings.setInterval].function!(this: this, arguments: [handler.jsValue, timeout?.jsValue ?? .undefined] + arguments.map(\.jsValue)).fromJSValue()!
    }

    @inlinable func clearInterval(id: Int32? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.clearInterval].function!(this: this, arguments: [id?.jsValue ?? .undefined])
    }

    // XXX: method 'queueMicrotask' is ignored

    @inlinable func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.createImageBitmap].function!(this: this, arguments: [image.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.createImageBitmap].function!(this: this, arguments: [image.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) -> JSPromise {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = options?.jsValue ?? .undefined
        let this = jsObject
        return this[HTMLStrings.createImageBitmap].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = options?.jsValue ?? .undefined
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.createImageBitmap].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func structuredClone(value: JSValue, options: StructuredSerializeOptions? = nil) -> JSValue {
        let this = jsObject
        return this[HTMLStrings.structuredClone].function!(this: this, arguments: [value.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class WindowPostMessageOptions: BridgedDictionary {
    public convenience init(targetOrigin: String) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.targetOrigin] = targetOrigin.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _targetOrigin = ReadWriteAttribute(jsObject: object, name: HTMLStrings.targetOrigin)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var targetOrigin: String
}

public protocol WindowSessionStorage: JSBridgedClass {}
public extension WindowSessionStorage {
    @inlinable var sessionStorage: Storage { ReadonlyAttribute[HTMLStrings.sessionStorage, in: jsObject] }
}

public class Worker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[HTMLStrings.Worker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: HTMLStrings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]))
    }

    @inlinable public func terminate() {
        let this = jsObject
        _ = this[HTMLStrings.terminate].function!(this: this, arguments: [])
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[HTMLStrings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class WorkerOptions: BridgedDictionary {
    public convenience init(type: WorkerType, credentials: RequestCredentials, name: String) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.type] = type.jsValue
        object[HTMLStrings.credentials] = credentials.jsValue
        object[HTMLStrings.name] = name.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: HTMLStrings.type)
        _credentials = ReadWriteAttribute(jsObject: object, name: HTMLStrings.credentials)
        _name = ReadWriteAttribute(jsObject: object, name: HTMLStrings.name)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var name: String
}

public enum WorkerType: JSString, JSValueCompatible {
    case classic = "classic"
    case module = "module"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Worklet: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[HTMLStrings.Worklet].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[HTMLStrings.addModule].function!(this: this, arguments: [moduleURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[HTMLStrings.addModule].function!(this: this, arguments: [moduleURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class WorkletOptions: BridgedDictionary {
    public convenience init(credentials: RequestCredentials) {
        let object = JSObject.global[HTMLStrings.Object].function!.new()
        object[HTMLStrings.credentials] = credentials.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _credentials = ReadWriteAttribute(jsObject: object, name: HTMLStrings.credentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var credentials: RequestCredentials
}

/* variadic generics please */
@propertyWrapper public final class ClosureAttribute1<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> ReturnType {
        get { ClosureAttribute1[name, in: jsObject] }
        set { ClosureAttribute1[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Optional<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> ReturnType)? {
        get { ClosureAttribute1Optional[name, in: jsObject] }
        set { ClosureAttribute1Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1OptionalVoid<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> Void)? {
        get { ClosureAttribute1OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute1OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Void<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> Void {
        get { ClosureAttribute1Void[name, in: jsObject] }
        set { ClosureAttribute1Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute5<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1, A2, A3, A4) -> ReturnType {
        get { ClosureAttribute5[name, in: jsObject] }
        set { ClosureAttribute5[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1, A2, A3, A4) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute5Optional<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get { ClosureAttribute5Optional[name, in: jsObject] }
        set { ClosureAttribute5Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@usableFromInline enum HTMLStrings {
    static let _self: JSString = "self"
    @usableFromInline static let AddSearchProvider: JSString = "AddSearchProvider"
    @usableFromInline static let AudioTrack: JSString = "AudioTrack"
    @usableFromInline static let AudioTrackList: JSString = "AudioTrackList"
    @usableFromInline static let BarProp: JSString = "BarProp"
    @usableFromInline static let BeforeUnloadEvent: JSString = "BeforeUnloadEvent"
    @usableFromInline static let BroadcastChannel: JSString = "BroadcastChannel"
    @usableFromInline static let CanvasFilter: JSString = "CanvasFilter"
    @usableFromInline static let CanvasGradient: JSString = "CanvasGradient"
    @usableFromInline static let CanvasPattern: JSString = "CanvasPattern"
    @usableFromInline static let CanvasRenderingContext2D: JSString = "CanvasRenderingContext2D"
    @usableFromInline static let CustomElementRegistry: JSString = "CustomElementRegistry"
    @usableFromInline static let DOMParser: JSString = "DOMParser"
    @usableFromInline static let DOMStringList: JSString = "DOMStringList"
    @usableFromInline static let DOMStringMap: JSString = "DOMStringMap"
    @usableFromInline static let DataTransfer: JSString = "DataTransfer"
    @usableFromInline static let DataTransferItem: JSString = "DataTransferItem"
    @usableFromInline static let DataTransferItemList: JSString = "DataTransferItemList"
    @usableFromInline static let DragEvent: JSString = "DragEvent"
    @usableFromInline static let ElementInternals: JSString = "ElementInternals"
    @usableFromInline static let ErrorEvent: JSString = "ErrorEvent"
    @usableFromInline static let EventSource: JSString = "EventSource"
    @usableFromInline static let External: JSString = "External"
    @usableFromInline static let FormDataEvent: JSString = "FormDataEvent"
    @usableFromInline static let HTMLAllCollection: JSString = "HTMLAllCollection"
    @usableFromInline static let HTMLAnchorElement: JSString = "HTMLAnchorElement"
    @usableFromInline static let HTMLAreaElement: JSString = "HTMLAreaElement"
    @usableFromInline static let HTMLAudioElement: JSString = "HTMLAudioElement"
    @usableFromInline static let HTMLBRElement: JSString = "HTMLBRElement"
    @usableFromInline static let HTMLBaseElement: JSString = "HTMLBaseElement"
    @usableFromInline static let HTMLBodyElement: JSString = "HTMLBodyElement"
    @usableFromInline static let HTMLButtonElement: JSString = "HTMLButtonElement"
    @usableFromInline static let HTMLCanvasElement: JSString = "HTMLCanvasElement"
    @usableFromInline static let HTMLDListElement: JSString = "HTMLDListElement"
    @usableFromInline static let HTMLDataElement: JSString = "HTMLDataElement"
    @usableFromInline static let HTMLDataListElement: JSString = "HTMLDataListElement"
    @usableFromInline static let HTMLDetailsElement: JSString = "HTMLDetailsElement"
    @usableFromInline static let HTMLDialogElement: JSString = "HTMLDialogElement"
    @usableFromInline static let HTMLDirectoryElement: JSString = "HTMLDirectoryElement"
    @usableFromInline static let HTMLDivElement: JSString = "HTMLDivElement"
    @usableFromInline static let HTMLElement: JSString = "HTMLElement"
    @usableFromInline static let HTMLEmbedElement: JSString = "HTMLEmbedElement"
    @usableFromInline static let HTMLFieldSetElement: JSString = "HTMLFieldSetElement"
    @usableFromInline static let HTMLFontElement: JSString = "HTMLFontElement"
    @usableFromInline static let HTMLFormControlsCollection: JSString = "HTMLFormControlsCollection"
    @usableFromInline static let HTMLFormElement: JSString = "HTMLFormElement"
    @usableFromInline static let HTMLFrameElement: JSString = "HTMLFrameElement"
    @usableFromInline static let HTMLFrameSetElement: JSString = "HTMLFrameSetElement"
    @usableFromInline static let HTMLHRElement: JSString = "HTMLHRElement"
    @usableFromInline static let HTMLHeadElement: JSString = "HTMLHeadElement"
    @usableFromInline static let HTMLHeadingElement: JSString = "HTMLHeadingElement"
    @usableFromInline static let HTMLHtmlElement: JSString = "HTMLHtmlElement"
    @usableFromInline static let HTMLIFrameElement: JSString = "HTMLIFrameElement"
    @usableFromInline static let HTMLImageElement: JSString = "HTMLImageElement"
    @usableFromInline static let HTMLInputElement: JSString = "HTMLInputElement"
    @usableFromInline static let HTMLLIElement: JSString = "HTMLLIElement"
    @usableFromInline static let HTMLLabelElement: JSString = "HTMLLabelElement"
    @usableFromInline static let HTMLLegendElement: JSString = "HTMLLegendElement"
    @usableFromInline static let HTMLLinkElement: JSString = "HTMLLinkElement"
    @usableFromInline static let HTMLMapElement: JSString = "HTMLMapElement"
    @usableFromInline static let HTMLMarqueeElement: JSString = "HTMLMarqueeElement"
    @usableFromInline static let HTMLMediaElement: JSString = "HTMLMediaElement"
    @usableFromInline static let HTMLMenuElement: JSString = "HTMLMenuElement"
    @usableFromInline static let HTMLMetaElement: JSString = "HTMLMetaElement"
    @usableFromInline static let HTMLMeterElement: JSString = "HTMLMeterElement"
    @usableFromInline static let HTMLModElement: JSString = "HTMLModElement"
    @usableFromInline static let HTMLOListElement: JSString = "HTMLOListElement"
    @usableFromInline static let HTMLObjectElement: JSString = "HTMLObjectElement"
    @usableFromInline static let HTMLOptGroupElement: JSString = "HTMLOptGroupElement"
    @usableFromInline static let HTMLOptionElement: JSString = "HTMLOptionElement"
    @usableFromInline static let HTMLOptionsCollection: JSString = "HTMLOptionsCollection"
    @usableFromInline static let HTMLOutputElement: JSString = "HTMLOutputElement"
    @usableFromInline static let HTMLParagraphElement: JSString = "HTMLParagraphElement"
    @usableFromInline static let HTMLParamElement: JSString = "HTMLParamElement"
    @usableFromInline static let HTMLPictureElement: JSString = "HTMLPictureElement"
    @usableFromInline static let HTMLPreElement: JSString = "HTMLPreElement"
    @usableFromInline static let HTMLProgressElement: JSString = "HTMLProgressElement"
    @usableFromInline static let HTMLQuoteElement: JSString = "HTMLQuoteElement"
    @usableFromInline static let HTMLScriptElement: JSString = "HTMLScriptElement"
    @usableFromInline static let HTMLSelectElement: JSString = "HTMLSelectElement"
    @usableFromInline static let HTMLSlotElement: JSString = "HTMLSlotElement"
    @usableFromInline static let HTMLSourceElement: JSString = "HTMLSourceElement"
    @usableFromInline static let HTMLSpanElement: JSString = "HTMLSpanElement"
    @usableFromInline static let HTMLStyleElement: JSString = "HTMLStyleElement"
    @usableFromInline static let HTMLTableCaptionElement: JSString = "HTMLTableCaptionElement"
    @usableFromInline static let HTMLTableCellElement: JSString = "HTMLTableCellElement"
    @usableFromInline static let HTMLTableColElement: JSString = "HTMLTableColElement"
    @usableFromInline static let HTMLTableElement: JSString = "HTMLTableElement"
    @usableFromInline static let HTMLTableRowElement: JSString = "HTMLTableRowElement"
    @usableFromInline static let HTMLTableSectionElement: JSString = "HTMLTableSectionElement"
    @usableFromInline static let HTMLTemplateElement: JSString = "HTMLTemplateElement"
    @usableFromInline static let HTMLTextAreaElement: JSString = "HTMLTextAreaElement"
    @usableFromInline static let HTMLTimeElement: JSString = "HTMLTimeElement"
    @usableFromInline static let HTMLTitleElement: JSString = "HTMLTitleElement"
    @usableFromInline static let HTMLTrackElement: JSString = "HTMLTrackElement"
    @usableFromInline static let HTMLUListElement: JSString = "HTMLUListElement"
    @usableFromInline static let HTMLUnknownElement: JSString = "HTMLUnknownElement"
    @usableFromInline static let HTMLVideoElement: JSString = "HTMLVideoElement"
    @usableFromInline static let HashChangeEvent: JSString = "HashChangeEvent"
    @usableFromInline static let History: JSString = "History"
    @usableFromInline static let ImageBitmap: JSString = "ImageBitmap"
    @usableFromInline static let ImageBitmapRenderingContext: JSString = "ImageBitmapRenderingContext"
    @usableFromInline static let ImageData: JSString = "ImageData"
    @usableFromInline static let IsSearchProviderInstalled: JSString = "IsSearchProviderInstalled"
    @usableFromInline static let Location: JSString = "Location"
    @usableFromInline static let MediaError: JSString = "MediaError"
    @usableFromInline static let MessageChannel: JSString = "MessageChannel"
    @usableFromInline static let MessageEvent: JSString = "MessageEvent"
    @usableFromInline static let MessagePort: JSString = "MessagePort"
    @usableFromInline static let MimeType: JSString = "MimeType"
    @usableFromInline static let MimeTypeArray: JSString = "MimeTypeArray"
    @usableFromInline static let Navigator: JSString = "Navigator"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let OffscreenCanvas: JSString = "OffscreenCanvas"
    @usableFromInline static let OffscreenCanvasRenderingContext2D: JSString = "OffscreenCanvasRenderingContext2D"
    @usableFromInline static let PageTransitionEvent: JSString = "PageTransitionEvent"
    @usableFromInline static let Path2D: JSString = "Path2D"
    @usableFromInline static let Plugin: JSString = "Plugin"
    @usableFromInline static let PluginArray: JSString = "PluginArray"
    @usableFromInline static let PopStateEvent: JSString = "PopStateEvent"
    @usableFromInline static let PromiseRejectionEvent: JSString = "PromiseRejectionEvent"
    @usableFromInline static let RadioNodeList: JSString = "RadioNodeList"
    @usableFromInline static let SharedWorker: JSString = "SharedWorker"
    @usableFromInline static let Storage: JSString = "Storage"
    @usableFromInline static let StorageEvent: JSString = "StorageEvent"
    @usableFromInline static let SubmitEvent: JSString = "SubmitEvent"
    @usableFromInline static let TextMetrics: JSString = "TextMetrics"
    @usableFromInline static let TextTrack: JSString = "TextTrack"
    @usableFromInline static let TextTrackCue: JSString = "TextTrackCue"
    @usableFromInline static let TextTrackCueList: JSString = "TextTrackCueList"
    @usableFromInline static let TextTrackList: JSString = "TextTrackList"
    @usableFromInline static let TimeRanges: JSString = "TimeRanges"
    @usableFromInline static let TrackEvent: JSString = "TrackEvent"
    @usableFromInline static let ValidityState: JSString = "ValidityState"
    @usableFromInline static let VideoTrack: JSString = "VideoTrack"
    @usableFromInline static let VideoTrackList: JSString = "VideoTrackList"
    @usableFromInline static let Window: JSString = "Window"
    @usableFromInline static let Worker: JSString = "Worker"
    @usableFromInline static let Worklet: JSString = "Worklet"
    @usableFromInline static let aLink: JSString = "aLink"
    @usableFromInline static let abbr: JSString = "abbr"
    @usableFromInline static let accept: JSString = "accept"
    @usableFromInline static let acceptCharset: JSString = "acceptCharset"
    @usableFromInline static let accessKey: JSString = "accessKey"
    @usableFromInline static let accessKeyLabel: JSString = "accessKeyLabel"
    @usableFromInline static let action: JSString = "action"
    @usableFromInline static let activeCues: JSString = "activeCues"
    @usableFromInline static let activeElement: JSString = "activeElement"
    @usableFromInline static let actualBoundingBoxAscent: JSString = "actualBoundingBoxAscent"
    @usableFromInline static let actualBoundingBoxDescent: JSString = "actualBoundingBoxDescent"
    @usableFromInline static let actualBoundingBoxLeft: JSString = "actualBoundingBoxLeft"
    @usableFromInline static let actualBoundingBoxRight: JSString = "actualBoundingBoxRight"
    @usableFromInline static let add: JSString = "add"
    @usableFromInline static let addColorStop: JSString = "addColorStop"
    @usableFromInline static let addCue: JSString = "addCue"
    @usableFromInline static let addModule: JSString = "addModule"
    @usableFromInline static let addPath: JSString = "addPath"
    @usableFromInline static let addTextTrack: JSString = "addTextTrack"
    @usableFromInline static let alert: JSString = "alert"
    @usableFromInline static let align: JSString = "align"
    @usableFromInline static let allow: JSString = "allow"
    @usableFromInline static let allowFullscreen: JSString = "allowFullscreen"
    @usableFromInline static let alpha: JSString = "alpha"
    @usableFromInline static let alphabeticBaseline: JSString = "alphabeticBaseline"
    @usableFromInline static let alt: JSString = "alt"
    @usableFromInline static let ancestorOrigins: JSString = "ancestorOrigins"
    @usableFromInline static let appCodeName: JSString = "appCodeName"
    @usableFromInline static let appName: JSString = "appName"
    @usableFromInline static let appVersion: JSString = "appVersion"
    @usableFromInline static let arc: JSString = "arc"
    @usableFromInline static let arcTo: JSString = "arcTo"
    @usableFromInline static let archive: JSString = "archive"
    @usableFromInline static let areas: JSString = "areas"
    @usableFromInline static let `as`: JSString = "as"
    @usableFromInline static let assign: JSString = "assign"
    @usableFromInline static let assignedElements: JSString = "assignedElements"
    @usableFromInline static let assignedNodes: JSString = "assignedNodes"
    @usableFromInline static let async: JSString = "async"
    @usableFromInline static let atob: JSString = "atob"
    @usableFromInline static let attachInternals: JSString = "attachInternals"
    @usableFromInline static let audioTracks: JSString = "audioTracks"
    @usableFromInline static let autocapitalize: JSString = "autocapitalize"
    @usableFromInline static let autocomplete: JSString = "autocomplete"
    @usableFromInline static let autofocus: JSString = "autofocus"
    @usableFromInline static let autoplay: JSString = "autoplay"
    @usableFromInline static let axis: JSString = "axis"
    @usableFromInline static let back: JSString = "back"
    @usableFromInline static let background: JSString = "background"
    @usableFromInline static let badInput: JSString = "badInput"
    @usableFromInline static let beginPath: JSString = "beginPath"
    @usableFromInline static let behavior: JSString = "behavior"
    @usableFromInline static let bezierCurveTo: JSString = "bezierCurveTo"
    @usableFromInline static let bgColor: JSString = "bgColor"
    @usableFromInline static let blocking: JSString = "blocking"
    @usableFromInline static let blur: JSString = "blur"
    @usableFromInline static let border: JSString = "border"
    @usableFromInline static let btoa: JSString = "btoa"
    @usableFromInline static let buffered: JSString = "buffered"
    @usableFromInline static let canPlayType: JSString = "canPlayType"
    @usableFromInline static let cancelAnimationFrame: JSString = "cancelAnimationFrame"
    @usableFromInline static let canvas: JSString = "canvas"
    @usableFromInline static let caption: JSString = "caption"
    @usableFromInline static let captureEvents: JSString = "captureEvents"
    @usableFromInline static let cellIndex: JSString = "cellIndex"
    @usableFromInline static let cellPadding: JSString = "cellPadding"
    @usableFromInline static let cellSpacing: JSString = "cellSpacing"
    @usableFromInline static let cells: JSString = "cells"
    @usableFromInline static let ch: JSString = "ch"
    @usableFromInline static let chOff: JSString = "chOff"
    @usableFromInline static let charset: JSString = "charset"
    @usableFromInline static let checkValidity: JSString = "checkValidity"
    @usableFromInline static let checked: JSString = "checked"
    @usableFromInline static let cite: JSString = "cite"
    @usableFromInline static let clear: JSString = "clear"
    @usableFromInline static let clearData: JSString = "clearData"
    @usableFromInline static let clearInterval: JSString = "clearInterval"
    @usableFromInline static let clearRect: JSString = "clearRect"
    @usableFromInline static let clearTimeout: JSString = "clearTimeout"
    @usableFromInline static let click: JSString = "click"
    @usableFromInline static let clientInformation: JSString = "clientInformation"
    @usableFromInline static let clip: JSString = "clip"
    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let closePath: JSString = "closePath"
    @usableFromInline static let closed: JSString = "closed"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let codeBase: JSString = "codeBase"
    @usableFromInline static let codeType: JSString = "codeType"
    @usableFromInline static let colSpan: JSString = "colSpan"
    @usableFromInline static let colno: JSString = "colno"
    @usableFromInline static let color: JSString = "color"
    @usableFromInline static let colorSpace: JSString = "colorSpace"
    @usableFromInline static let colorSpaceConversion: JSString = "colorSpaceConversion"
    @usableFromInline static let cols: JSString = "cols"
    @usableFromInline static let commit: JSString = "commit"
    @usableFromInline static let compact: JSString = "compact"
    @usableFromInline static let complete: JSString = "complete"
    @usableFromInline static let confirm: JSString = "confirm"
    @usableFromInline static let contains: JSString = "contains"
    @usableFromInline static let content: JSString = "content"
    @usableFromInline static let contentDocument: JSString = "contentDocument"
    @usableFromInline static let contentEditable: JSString = "contentEditable"
    @usableFromInline static let contentWindow: JSString = "contentWindow"
    @usableFromInline static let control: JSString = "control"
    @usableFromInline static let controls: JSString = "controls"
    @usableFromInline static let convertToBlob: JSString = "convertToBlob"
    @usableFromInline static let cookieEnabled: JSString = "cookieEnabled"
    @usableFromInline static let coords: JSString = "coords"
    @usableFromInline static let createCaption: JSString = "createCaption"
    @usableFromInline static let createConicGradient: JSString = "createConicGradient"
    @usableFromInline static let createImageBitmap: JSString = "createImageBitmap"
    @usableFromInline static let createImageData: JSString = "createImageData"
    @usableFromInline static let createLinearGradient: JSString = "createLinearGradient"
    @usableFromInline static let createPattern: JSString = "createPattern"
    @usableFromInline static let createRadialGradient: JSString = "createRadialGradient"
    @usableFromInline static let createTBody: JSString = "createTBody"
    @usableFromInline static let createTFoot: JSString = "createTFoot"
    @usableFromInline static let createTHead: JSString = "createTHead"
    @usableFromInline static let credentials: JSString = "credentials"
    @usableFromInline static let crossOrigin: JSString = "crossOrigin"
    @usableFromInline static let crossOriginIsolated: JSString = "crossOriginIsolated"
    @usableFromInline static let cues: JSString = "cues"
    @usableFromInline static let currentSrc: JSString = "currentSrc"
    @usableFromInline static let currentTime: JSString = "currentTime"
    @usableFromInline static let customElements: JSString = "customElements"
    @usableFromInline static let customError: JSString = "customError"
    @usableFromInline static let data: JSString = "data"
    @usableFromInline static let dataTransfer: JSString = "dataTransfer"
    @usableFromInline static let dataset: JSString = "dataset"
    @usableFromInline static let dateTime: JSString = "dateTime"
    @usableFromInline static let declare: JSString = "declare"
    @usableFromInline static let decode: JSString = "decode"
    @usableFromInline static let decoding: JSString = "decoding"
    @usableFromInline static let `default`: JSString = "default"
    @usableFromInline static let defaultChecked: JSString = "defaultChecked"
    @usableFromInline static let defaultMuted: JSString = "defaultMuted"
    @usableFromInline static let defaultPlaybackRate: JSString = "defaultPlaybackRate"
    @usableFromInline static let defaultSelected: JSString = "defaultSelected"
    @usableFromInline static let defaultValue: JSString = "defaultValue"
    @usableFromInline static let `defer`: JSString = "defer"
    @usableFromInline static let define: JSString = "define"
    @usableFromInline static let deleteCaption: JSString = "deleteCaption"
    @usableFromInline static let deleteCell: JSString = "deleteCell"
    @usableFromInline static let deleteRow: JSString = "deleteRow"
    @usableFromInline static let deleteTFoot: JSString = "deleteTFoot"
    @usableFromInline static let deleteTHead: JSString = "deleteTHead"
    @usableFromInline static let description: JSString = "description"
    @usableFromInline static let desynchronized: JSString = "desynchronized"
    @usableFromInline static let dir: JSString = "dir"
    @usableFromInline static let dirName: JSString = "dirName"
    @usableFromInline static let direction: JSString = "direction"
    @usableFromInline static let disabled: JSString = "disabled"
    @usableFromInline static let document: JSString = "document"
    @usableFromInline static let download: JSString = "download"
    @usableFromInline static let draggable: JSString = "draggable"
    @usableFromInline static let drawFocusIfNeeded: JSString = "drawFocusIfNeeded"
    @usableFromInline static let drawImage: JSString = "drawImage"
    @usableFromInline static let dropEffect: JSString = "dropEffect"
    @usableFromInline static let duration: JSString = "duration"
    @usableFromInline static let effectAllowed: JSString = "effectAllowed"
    @usableFromInline static let elements: JSString = "elements"
    @usableFromInline static let ellipse: JSString = "ellipse"
    @usableFromInline static let emHeightAscent: JSString = "emHeightAscent"
    @usableFromInline static let emHeightDescent: JSString = "emHeightDescent"
    @usableFromInline static let enabled: JSString = "enabled"
    @usableFromInline static let enabledPlugin: JSString = "enabledPlugin"
    @usableFromInline static let encoding: JSString = "encoding"
    @usableFromInline static let enctype: JSString = "enctype"
    @usableFromInline static let end: JSString = "end"
    @usableFromInline static let endTime: JSString = "endTime"
    @usableFromInline static let ended: JSString = "ended"
    @usableFromInline static let enterKeyHint: JSString = "enterKeyHint"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let event: JSString = "event"
    @usableFromInline static let extends: JSString = "extends"
    @usableFromInline static let external: JSString = "external"
    @usableFromInline static let face: JSString = "face"
    @usableFromInline static let fastSeek: JSString = "fastSeek"
    @usableFromInline static let filename: JSString = "filename"
    @usableFromInline static let files: JSString = "files"
    @usableFromInline static let fill: JSString = "fill"
    @usableFromInline static let fillRect: JSString = "fillRect"
    @usableFromInline static let fillStyle: JSString = "fillStyle"
    @usableFromInline static let fillText: JSString = "fillText"
    @usableFromInline static let filter: JSString = "filter"
    @usableFromInline static let flatten: JSString = "flatten"
    @usableFromInline static let focus: JSString = "focus"
    @usableFromInline static let font: JSString = "font"
    @usableFromInline static let fontBoundingBoxAscent: JSString = "fontBoundingBoxAscent"
    @usableFromInline static let fontBoundingBoxDescent: JSString = "fontBoundingBoxDescent"
    @usableFromInline static let fontKerning: JSString = "fontKerning"
    @usableFromInline static let fontStretch: JSString = "fontStretch"
    @usableFromInline static let fontVariantCaps: JSString = "fontVariantCaps"
    @usableFromInline static let form: JSString = "form"
    @usableFromInline static let formAction: JSString = "formAction"
    @usableFromInline static let formData: JSString = "formData"
    @usableFromInline static let formEnctype: JSString = "formEnctype"
    @usableFromInline static let formMethod: JSString = "formMethod"
    @usableFromInline static let formNoValidate: JSString = "formNoValidate"
    @usableFromInline static let formTarget: JSString = "formTarget"
    @usableFromInline static let forward: JSString = "forward"
    @usableFromInline static let frame: JSString = "frame"
    @usableFromInline static let frameBorder: JSString = "frameBorder"
    @usableFromInline static let frameElement: JSString = "frameElement"
    @usableFromInline static let frames: JSString = "frames"
    @usableFromInline static let get: JSString = "get"
    @usableFromInline static let getAsFile: JSString = "getAsFile"
    @usableFromInline static let getContext: JSString = "getContext"
    @usableFromInline static let getContextAttributes: JSString = "getContextAttributes"
    @usableFromInline static let getCueById: JSString = "getCueById"
    @usableFromInline static let getData: JSString = "getData"
    @usableFromInline static let getImageData: JSString = "getImageData"
    @usableFromInline static let getLineDash: JSString = "getLineDash"
    @usableFromInline static let getSVGDocument: JSString = "getSVGDocument"
    @usableFromInline static let getStartDate: JSString = "getStartDate"
    @usableFromInline static let getTrackById: JSString = "getTrackById"
    @usableFromInline static let getTransform: JSString = "getTransform"
    @usableFromInline static let globalAlpha: JSString = "globalAlpha"
    @usableFromInline static let globalCompositeOperation: JSString = "globalCompositeOperation"
    @usableFromInline static let go: JSString = "go"
    @usableFromInline static let hangingBaseline: JSString = "hangingBaseline"
    @usableFromInline static let hardwareConcurrency: JSString = "hardwareConcurrency"
    @usableFromInline static let hash: JSString = "hash"
    @usableFromInline static let headers: JSString = "headers"
    @usableFromInline static let height: JSString = "height"
    @usableFromInline static let hidden: JSString = "hidden"
    @usableFromInline static let high: JSString = "high"
    @usableFromInline static let history: JSString = "history"
    @usableFromInline static let host: JSString = "host"
    @usableFromInline static let hostname: JSString = "hostname"
    @usableFromInline static let href: JSString = "href"
    @usableFromInline static let hreflang: JSString = "hreflang"
    @usableFromInline static let hspace: JSString = "hspace"
    @usableFromInline static let htmlFor: JSString = "htmlFor"
    @usableFromInline static let httpEquiv: JSString = "httpEquiv"
    @usableFromInline static let id: JSString = "id"
    @usableFromInline static let ideographicBaseline: JSString = "ideographicBaseline"
    @usableFromInline static let imageOrientation: JSString = "imageOrientation"
    @usableFromInline static let imageSizes: JSString = "imageSizes"
    @usableFromInline static let imageSmoothingEnabled: JSString = "imageSmoothingEnabled"
    @usableFromInline static let imageSmoothingQuality: JSString = "imageSmoothingQuality"
    @usableFromInline static let imageSrcset: JSString = "imageSrcset"
    @usableFromInline static let inBandMetadataTrackDispatchType: JSString = "inBandMetadataTrackDispatchType"
    @usableFromInline static let indeterminate: JSString = "indeterminate"
    @usableFromInline static let index: JSString = "index"
    @usableFromInline static let inert: JSString = "inert"
    @usableFromInline static let initMessageEvent: JSString = "initMessageEvent"
    @usableFromInline static let initStorageEvent: JSString = "initStorageEvent"
    @usableFromInline static let innerText: JSString = "innerText"
    @usableFromInline static let inputMode: JSString = "inputMode"
    @usableFromInline static let insertCell: JSString = "insertCell"
    @usableFromInline static let insertRow: JSString = "insertRow"
    @usableFromInline static let integrity: JSString = "integrity"
    @usableFromInline static let isContentEditable: JSString = "isContentEditable"
    @usableFromInline static let isContextLost: JSString = "isContextLost"
    @usableFromInline static let isMap: JSString = "isMap"
    @usableFromInline static let isPointInPath: JSString = "isPointInPath"
    @usableFromInline static let isPointInStroke: JSString = "isPointInStroke"
    @usableFromInline static let isSecureContext: JSString = "isSecureContext"
    @usableFromInline static let item: JSString = "item"
    @usableFromInline static let items: JSString = "items"
    @usableFromInline static let javaEnabled: JSString = "javaEnabled"
    @usableFromInline static let key: JSString = "key"
    @usableFromInline static let kind: JSString = "kind"
    @usableFromInline static let label: JSString = "label"
    @usableFromInline static let labels: JSString = "labels"
    @usableFromInline static let lang: JSString = "lang"
    @usableFromInline static let language: JSString = "language"
    @usableFromInline static let languages: JSString = "languages"
    @usableFromInline static let lastEventId: JSString = "lastEventId"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let letterSpacing: JSString = "letterSpacing"
    @usableFromInline static let lineCap: JSString = "lineCap"
    @usableFromInline static let lineDashOffset: JSString = "lineDashOffset"
    @usableFromInline static let lineJoin: JSString = "lineJoin"
    @usableFromInline static let lineTo: JSString = "lineTo"
    @usableFromInline static let lineWidth: JSString = "lineWidth"
    @usableFromInline static let lineno: JSString = "lineno"
    @usableFromInline static let link: JSString = "link"
    @usableFromInline static let list: JSString = "list"
    @usableFromInline static let load: JSString = "load"
    @usableFromInline static let loading: JSString = "loading"
    @usableFromInline static let localStorage: JSString = "localStorage"
    @usableFromInline static let location: JSString = "location"
    @usableFromInline static let locationbar: JSString = "locationbar"
    @usableFromInline static let longDesc: JSString = "longDesc"
    @usableFromInline static let loop: JSString = "loop"
    @usableFromInline static let low: JSString = "low"
    @usableFromInline static let lowsrc: JSString = "lowsrc"
    @usableFromInline static let marginHeight: JSString = "marginHeight"
    @usableFromInline static let marginWidth: JSString = "marginWidth"
    @usableFromInline static let max: JSString = "max"
    @usableFromInline static let maxLength: JSString = "maxLength"
    @usableFromInline static let measureText: JSString = "measureText"
    @usableFromInline static let media: JSString = "media"
    @usableFromInline static let menubar: JSString = "menubar"
    @usableFromInline static let message: JSString = "message"
    @usableFromInline static let method: JSString = "method"
    @usableFromInline static let mimeTypes: JSString = "mimeTypes"
    @usableFromInline static let min: JSString = "min"
    @usableFromInline static let minLength: JSString = "minLength"
    @usableFromInline static let miterLimit: JSString = "miterLimit"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let moveTo: JSString = "moveTo"
    @usableFromInline static let multiple: JSString = "multiple"
    @usableFromInline static let muted: JSString = "muted"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let namedItem: JSString = "namedItem"
    @usableFromInline static let naturalHeight: JSString = "naturalHeight"
    @usableFromInline static let naturalWidth: JSString = "naturalWidth"
    @usableFromInline static let navigator: JSString = "navigator"
    @usableFromInline static let networkState: JSString = "networkState"
    @usableFromInline static let newURL: JSString = "newURL"
    @usableFromInline static let newValue: JSString = "newValue"
    @usableFromInline static let noHref: JSString = "noHref"
    @usableFromInline static let noModule: JSString = "noModule"
    @usableFromInline static let noResize: JSString = "noResize"
    @usableFromInline static let noShade: JSString = "noShade"
    @usableFromInline static let noValidate: JSString = "noValidate"
    @usableFromInline static let noWrap: JSString = "noWrap"
    @usableFromInline static let nonce: JSString = "nonce"
    @usableFromInline static let oldURL: JSString = "oldURL"
    @usableFromInline static let oldValue: JSString = "oldValue"
    @usableFromInline static let onLine: JSString = "onLine"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let onaddtrack: JSString = "onaddtrack"
    @usableFromInline static let onafterprint: JSString = "onafterprint"
    @usableFromInline static let onauxclick: JSString = "onauxclick"
    @usableFromInline static let onbeforeprint: JSString = "onbeforeprint"
    @usableFromInline static let onbeforeunload: JSString = "onbeforeunload"
    @usableFromInline static let onblur: JSString = "onblur"
    @usableFromInline static let oncancel: JSString = "oncancel"
    @usableFromInline static let oncanplay: JSString = "oncanplay"
    @usableFromInline static let oncanplaythrough: JSString = "oncanplaythrough"
    @usableFromInline static let onchange: JSString = "onchange"
    @usableFromInline static let onclick: JSString = "onclick"
    @usableFromInline static let onclose: JSString = "onclose"
    @usableFromInline static let oncontextlost: JSString = "oncontextlost"
    @usableFromInline static let oncontextmenu: JSString = "oncontextmenu"
    @usableFromInline static let oncontextrestored: JSString = "oncontextrestored"
    @usableFromInline static let oncopy: JSString = "oncopy"
    @usableFromInline static let oncuechange: JSString = "oncuechange"
    @usableFromInline static let oncut: JSString = "oncut"
    @usableFromInline static let ondblclick: JSString = "ondblclick"
    @usableFromInline static let ondrag: JSString = "ondrag"
    @usableFromInline static let ondragend: JSString = "ondragend"
    @usableFromInline static let ondragenter: JSString = "ondragenter"
    @usableFromInline static let ondragleave: JSString = "ondragleave"
    @usableFromInline static let ondragover: JSString = "ondragover"
    @usableFromInline static let ondragstart: JSString = "ondragstart"
    @usableFromInline static let ondrop: JSString = "ondrop"
    @usableFromInline static let ondurationchange: JSString = "ondurationchange"
    @usableFromInline static let onemptied: JSString = "onemptied"
    @usableFromInline static let onended: JSString = "onended"
    @usableFromInline static let onenter: JSString = "onenter"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onexit: JSString = "onexit"
    @usableFromInline static let onfocus: JSString = "onfocus"
    @usableFromInline static let onformdata: JSString = "onformdata"
    @usableFromInline static let onhashchange: JSString = "onhashchange"
    @usableFromInline static let oninput: JSString = "oninput"
    @usableFromInline static let oninvalid: JSString = "oninvalid"
    @usableFromInline static let onkeydown: JSString = "onkeydown"
    @usableFromInline static let onkeypress: JSString = "onkeypress"
    @usableFromInline static let onkeyup: JSString = "onkeyup"
    @usableFromInline static let onlanguagechange: JSString = "onlanguagechange"
    @usableFromInline static let onload: JSString = "onload"
    @usableFromInline static let onloadeddata: JSString = "onloadeddata"
    @usableFromInline static let onloadedmetadata: JSString = "onloadedmetadata"
    @usableFromInline static let onloadstart: JSString = "onloadstart"
    @usableFromInline static let onmessage: JSString = "onmessage"
    @usableFromInline static let onmessageerror: JSString = "onmessageerror"
    @usableFromInline static let onmousedown: JSString = "onmousedown"
    @usableFromInline static let onmouseenter: JSString = "onmouseenter"
    @usableFromInline static let onmouseleave: JSString = "onmouseleave"
    @usableFromInline static let onmousemove: JSString = "onmousemove"
    @usableFromInline static let onmouseout: JSString = "onmouseout"
    @usableFromInline static let onmouseover: JSString = "onmouseover"
    @usableFromInline static let onmouseup: JSString = "onmouseup"
    @usableFromInline static let onoffline: JSString = "onoffline"
    @usableFromInline static let ononline: JSString = "ononline"
    @usableFromInline static let onopen: JSString = "onopen"
    @usableFromInline static let onpagehide: JSString = "onpagehide"
    @usableFromInline static let onpageshow: JSString = "onpageshow"
    @usableFromInline static let onpaste: JSString = "onpaste"
    @usableFromInline static let onpause: JSString = "onpause"
    @usableFromInline static let onplay: JSString = "onplay"
    @usableFromInline static let onplaying: JSString = "onplaying"
    @usableFromInline static let onpopstate: JSString = "onpopstate"
    @usableFromInline static let onprogress: JSString = "onprogress"
    @usableFromInline static let onratechange: JSString = "onratechange"
    @usableFromInline static let onrejectionhandled: JSString = "onrejectionhandled"
    @usableFromInline static let onremovetrack: JSString = "onremovetrack"
    @usableFromInline static let onreset: JSString = "onreset"
    @usableFromInline static let onresize: JSString = "onresize"
    @usableFromInline static let onscroll: JSString = "onscroll"
    @usableFromInline static let onsecuritypolicyviolation: JSString = "onsecuritypolicyviolation"
    @usableFromInline static let onseeked: JSString = "onseeked"
    @usableFromInline static let onseeking: JSString = "onseeking"
    @usableFromInline static let onselect: JSString = "onselect"
    @usableFromInline static let onslotchange: JSString = "onslotchange"
    @usableFromInline static let onstalled: JSString = "onstalled"
    @usableFromInline static let onstorage: JSString = "onstorage"
    @usableFromInline static let onsubmit: JSString = "onsubmit"
    @usableFromInline static let onsuspend: JSString = "onsuspend"
    @usableFromInline static let ontimeupdate: JSString = "ontimeupdate"
    @usableFromInline static let ontoggle: JSString = "ontoggle"
    @usableFromInline static let onunhandledrejection: JSString = "onunhandledrejection"
    @usableFromInline static let onunload: JSString = "onunload"
    @usableFromInline static let onvolumechange: JSString = "onvolumechange"
    @usableFromInline static let onwaiting: JSString = "onwaiting"
    @usableFromInline static let onwebkitanimationend: JSString = "onwebkitanimationend"
    @usableFromInline static let onwebkitanimationiteration: JSString = "onwebkitanimationiteration"
    @usableFromInline static let onwebkitanimationstart: JSString = "onwebkitanimationstart"
    @usableFromInline static let onwebkittransitionend: JSString = "onwebkittransitionend"
    @usableFromInline static let onwheel: JSString = "onwheel"
    @usableFromInline static let open: JSString = "open"
    @usableFromInline static let opener: JSString = "opener"
    @usableFromInline static let optimum: JSString = "optimum"
    @usableFromInline static let options: JSString = "options"
    @usableFromInline static let origin: JSString = "origin"
    @usableFromInline static let originAgentCluster: JSString = "originAgentCluster"
    @usableFromInline static let oscpu: JSString = "oscpu"
    @usableFromInline static let outerText: JSString = "outerText"
    @usableFromInline static let parent: JSString = "parent"
    @usableFromInline static let parseFromString: JSString = "parseFromString"
    @usableFromInline static let password: JSString = "password"
    @usableFromInline static let pathname: JSString = "pathname"
    @usableFromInline static let pattern: JSString = "pattern"
    @usableFromInline static let patternMismatch: JSString = "patternMismatch"
    @usableFromInline static let pause: JSString = "pause"
    @usableFromInline static let pauseOnExit: JSString = "pauseOnExit"
    @usableFromInline static let paused: JSString = "paused"
    @usableFromInline static let pdfViewerEnabled: JSString = "pdfViewerEnabled"
    @usableFromInline static let persisted: JSString = "persisted"
    @usableFromInline static let personalbar: JSString = "personalbar"
    @usableFromInline static let ping: JSString = "ping"
    @usableFromInline static let placeholder: JSString = "placeholder"
    @usableFromInline static let platform: JSString = "platform"
    @usableFromInline static let play: JSString = "play"
    @usableFromInline static let playbackRate: JSString = "playbackRate"
    @usableFromInline static let played: JSString = "played"
    @usableFromInline static let playsInline: JSString = "playsInline"
    @usableFromInline static let plugins: JSString = "plugins"
    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let port1: JSString = "port1"
    @usableFromInline static let port2: JSString = "port2"
    @usableFromInline static let ports: JSString = "ports"
    @usableFromInline static let position: JSString = "position"
    @usableFromInline static let postMessage: JSString = "postMessage"
    @usableFromInline static let poster: JSString = "poster"
    @usableFromInline static let preload: JSString = "preload"
    @usableFromInline static let premultiplyAlpha: JSString = "premultiplyAlpha"
    @usableFromInline static let preservesPitch: JSString = "preservesPitch"
    @usableFromInline static let preventScroll: JSString = "preventScroll"
    @usableFromInline static let print: JSString = "print"
    @usableFromInline static let product: JSString = "product"
    @usableFromInline static let productSub: JSString = "productSub"
    @usableFromInline static let promise: JSString = "promise"
    @usableFromInline static let prompt: JSString = "prompt"
    @usableFromInline static let `protocol`: JSString = "protocol"
    @usableFromInline static let pushState: JSString = "pushState"
    @usableFromInline static let putImageData: JSString = "putImageData"
    @usableFromInline static let quadraticCurveTo: JSString = "quadraticCurveTo"
    @usableFromInline static let quality: JSString = "quality"
    @usableFromInline static let rangeOverflow: JSString = "rangeOverflow"
    @usableFromInline static let rangeUnderflow: JSString = "rangeUnderflow"
    @usableFromInline static let readOnly: JSString = "readOnly"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let rect: JSString = "rect"
    @usableFromInline static let referrerPolicy: JSString = "referrerPolicy"
    @usableFromInline static let refresh: JSString = "refresh"
    @usableFromInline static let registerProtocolHandler: JSString = "registerProtocolHandler"
    @usableFromInline static let rel: JSString = "rel"
    @usableFromInline static let relList: JSString = "relList"
    @usableFromInline static let releaseEvents: JSString = "releaseEvents"
    @usableFromInline static let reload: JSString = "reload"
    @usableFromInline static let remove: JSString = "remove"
    @usableFromInline static let removeCue: JSString = "removeCue"
    @usableFromInline static let replace: JSString = "replace"
    @usableFromInline static let replaceState: JSString = "replaceState"
    @usableFromInline static let reportError: JSString = "reportError"
    @usableFromInline static let reportValidity: JSString = "reportValidity"
    @usableFromInline static let requestSubmit: JSString = "requestSubmit"
    @usableFromInline static let required: JSString = "required"
    @usableFromInline static let reset: JSString = "reset"
    @usableFromInline static let resetTransform: JSString = "resetTransform"
    @usableFromInline static let resizeHeight: JSString = "resizeHeight"
    @usableFromInline static let resizeQuality: JSString = "resizeQuality"
    @usableFromInline static let resizeWidth: JSString = "resizeWidth"
    @usableFromInline static let restore: JSString = "restore"
    @usableFromInline static let returnValue: JSString = "returnValue"
    @usableFromInline static let rev: JSString = "rev"
    @usableFromInline static let reversed: JSString = "reversed"
    @usableFromInline static let rotate: JSString = "rotate"
    @usableFromInline static let roundRect: JSString = "roundRect"
    @usableFromInline static let rowIndex: JSString = "rowIndex"
    @usableFromInline static let rowSpan: JSString = "rowSpan"
    @usableFromInline static let rows: JSString = "rows"
    @usableFromInline static let rules: JSString = "rules"
    @usableFromInline static let sandbox: JSString = "sandbox"
    @usableFromInline static let save: JSString = "save"
    @usableFromInline static let scale: JSString = "scale"
    @usableFromInline static let scheme: JSString = "scheme"
    @usableFromInline static let scope: JSString = "scope"
    @usableFromInline static let scrollAmount: JSString = "scrollAmount"
    @usableFromInline static let scrollDelay: JSString = "scrollDelay"
    @usableFromInline static let scrollPathIntoView: JSString = "scrollPathIntoView"
    @usableFromInline static let scrollRestoration: JSString = "scrollRestoration"
    @usableFromInline static let scrollbars: JSString = "scrollbars"
    @usableFromInline static let scrolling: JSString = "scrolling"
    @usableFromInline static let search: JSString = "search"
    @usableFromInline static let sectionRowIndex: JSString = "sectionRowIndex"
    @usableFromInline static let seekable: JSString = "seekable"
    @usableFromInline static let seeking: JSString = "seeking"
    @usableFromInline static let select: JSString = "select"
    @usableFromInline static let selected: JSString = "selected"
    @usableFromInline static let selectedIndex: JSString = "selectedIndex"
    @usableFromInline static let selectedOptions: JSString = "selectedOptions"
    @usableFromInline static let selectionDirection: JSString = "selectionDirection"
    @usableFromInline static let selectionEnd: JSString = "selectionEnd"
    @usableFromInline static let selectionStart: JSString = "selectionStart"
    @usableFromInline static let sessionStorage: JSString = "sessionStorage"
    @usableFromInline static let setCustomValidity: JSString = "setCustomValidity"
    @usableFromInline static let setData: JSString = "setData"
    @usableFromInline static let setDragImage: JSString = "setDragImage"
    @usableFromInline static let setFormValue: JSString = "setFormValue"
    @usableFromInline static let setInterval: JSString = "setInterval"
    @usableFromInline static let setLineDash: JSString = "setLineDash"
    @usableFromInline static let setRangeText: JSString = "setRangeText"
    @usableFromInline static let setSelectionRange: JSString = "setSelectionRange"
    @usableFromInline static let setTimeout: JSString = "setTimeout"
    @usableFromInline static let setTransform: JSString = "setTransform"
    @usableFromInline static let setValidity: JSString = "setValidity"
    @usableFromInline static let shadowBlur: JSString = "shadowBlur"
    @usableFromInline static let shadowColor: JSString = "shadowColor"
    @usableFromInline static let shadowOffsetX: JSString = "shadowOffsetX"
    @usableFromInline static let shadowOffsetY: JSString = "shadowOffsetY"
    @usableFromInline static let shadowRoot: JSString = "shadowRoot"
    @usableFromInline static let shape: JSString = "shape"
    @usableFromInline static let show: JSString = "show"
    @usableFromInline static let showModal: JSString = "showModal"
    @usableFromInline static let showPicker: JSString = "showPicker"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let sizes: JSString = "sizes"
    @usableFromInline static let source: JSString = "source"
    @usableFromInline static let span: JSString = "span"
    @usableFromInline static let spellcheck: JSString = "spellcheck"
    @usableFromInline static let src: JSString = "src"
    @usableFromInline static let srcdoc: JSString = "srcdoc"
    @usableFromInline static let srclang: JSString = "srclang"
    @usableFromInline static let srcset: JSString = "srcset"
    @usableFromInline static let standby: JSString = "standby"
    @usableFromInline static let start: JSString = "start"
    @usableFromInline static let startTime: JSString = "startTime"
    @usableFromInline static let state: JSString = "state"
    @usableFromInline static let status: JSString = "status"
    @usableFromInline static let statusbar: JSString = "statusbar"
    @usableFromInline static let step: JSString = "step"
    @usableFromInline static let stepDown: JSString = "stepDown"
    @usableFromInline static let stepMismatch: JSString = "stepMismatch"
    @usableFromInline static let stepUp: JSString = "stepUp"
    @usableFromInline static let stop: JSString = "stop"
    @usableFromInline static let storageArea: JSString = "storageArea"
    @usableFromInline static let stroke: JSString = "stroke"
    @usableFromInline static let strokeRect: JSString = "strokeRect"
    @usableFromInline static let strokeStyle: JSString = "strokeStyle"
    @usableFromInline static let strokeText: JSString = "strokeText"
    @usableFromInline static let structuredClone: JSString = "structuredClone"
    @usableFromInline static let submit: JSString = "submit"
    @usableFromInline static let submitter: JSString = "submitter"
    @usableFromInline static let suffixes: JSString = "suffixes"
    @usableFromInline static let summary: JSString = "summary"
    @usableFromInline static let supports: JSString = "supports"
    @usableFromInline static let tBodies: JSString = "tBodies"
    @usableFromInline static let tFoot: JSString = "tFoot"
    @usableFromInline static let tHead: JSString = "tHead"
    @usableFromInline static let tabIndex: JSString = "tabIndex"
    @usableFromInline static let taintEnabled: JSString = "taintEnabled"
    @usableFromInline static let target: JSString = "target"
    @usableFromInline static let targetOrigin: JSString = "targetOrigin"
    @usableFromInline static let terminate: JSString = "terminate"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let textAlign: JSString = "textAlign"
    @usableFromInline static let textBaseline: JSString = "textBaseline"
    @usableFromInline static let textLength: JSString = "textLength"
    @usableFromInline static let textRendering: JSString = "textRendering"
    @usableFromInline static let textTracks: JSString = "textTracks"
    @usableFromInline static let title: JSString = "title"
    @usableFromInline static let toDataURL: JSString = "toDataURL"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let tooLong: JSString = "tooLong"
    @usableFromInline static let tooShort: JSString = "tooShort"
    @usableFromInline static let toolbar: JSString = "toolbar"
    @usableFromInline static let top: JSString = "top"
    @usableFromInline static let track: JSString = "track"
    @usableFromInline static let transfer: JSString = "transfer"
    @usableFromInline static let transferControlToOffscreen: JSString = "transferControlToOffscreen"
    @usableFromInline static let transferFromImageBitmap: JSString = "transferFromImageBitmap"
    @usableFromInline static let transferToImageBitmap: JSString = "transferToImageBitmap"
    @usableFromInline static let transform: JSString = "transform"
    @usableFromInline static let translate: JSString = "translate"
    @usableFromInline static let trueSpeed: JSString = "trueSpeed"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let typeMismatch: JSString = "typeMismatch"
    @usableFromInline static let types: JSString = "types"
    @usableFromInline static let unregisterProtocolHandler: JSString = "unregisterProtocolHandler"
    @usableFromInline static let upgrade: JSString = "upgrade"
    @usableFromInline static let url: JSString = "url"
    @usableFromInline static let useMap: JSString = "useMap"
    @usableFromInline static let userAgent: JSString = "userAgent"
    @usableFromInline static let username: JSString = "username"
    @usableFromInline static let vAlign: JSString = "vAlign"
    @usableFromInline static let vLink: JSString = "vLink"
    @usableFromInline static let valid: JSString = "valid"
    @usableFromInline static let validationMessage: JSString = "validationMessage"
    @usableFromInline static let validity: JSString = "validity"
    @usableFromInline static let value: JSString = "value"
    @usableFromInline static let valueAsDate: JSString = "valueAsDate"
    @usableFromInline static let valueAsNumber: JSString = "valueAsNumber"
    @usableFromInline static let valueMissing: JSString = "valueMissing"
    @usableFromInline static let valueType: JSString = "valueType"
    @usableFromInline static let vendor: JSString = "vendor"
    @usableFromInline static let vendorSub: JSString = "vendorSub"
    @usableFromInline static let version: JSString = "version"
    @usableFromInline static let videoHeight: JSString = "videoHeight"
    @usableFromInline static let videoTracks: JSString = "videoTracks"
    @usableFromInline static let videoWidth: JSString = "videoWidth"
    @usableFromInline static let visible: JSString = "visible"
    @usableFromInline static let volume: JSString = "volume"
    @usableFromInline static let vspace: JSString = "vspace"
    @usableFromInline static let whenDefined: JSString = "whenDefined"
    @usableFromInline static let width: JSString = "width"
    @usableFromInline static let willReadFrequently: JSString = "willReadFrequently"
    @usableFromInline static let willValidate: JSString = "willValidate"
    @usableFromInline static let window: JSString = "window"
    @usableFromInline static let withCredentials: JSString = "withCredentials"
    @usableFromInline static let wordSpacing: JSString = "wordSpacing"
    @usableFromInline static let wrap: JSString = "wrap"
}

public protocol Any_AudioTrack_or_TextTrack_or_VideoTrack: ConvertibleToJSValue {}
extension AudioTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension TextTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension VideoTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}

public enum AudioTrack_or_TextTrack_or_VideoTrack: JSValueCompatible, Any_AudioTrack_or_TextTrack_or_VideoTrack {
    case audioTrack(AudioTrack)
    case textTrack(TextTrack)
    case videoTrack(VideoTrack)

    var audioTrack: AudioTrack? {
        switch self {
        case let .audioTrack(audioTrack): return audioTrack
        default: return nil
        }
    }

    var textTrack: TextTrack? {
        switch self {
        case let .textTrack(textTrack): return textTrack
        default: return nil
        }
    }

    var videoTrack: VideoTrack? {
        switch self {
        case let .videoTrack(videoTrack): return videoTrack
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioTrack: AudioTrack = value.fromJSValue() {
            return .audioTrack(audioTrack)
        }
        if let textTrack: TextTrack = value.fromJSValue() {
            return .textTrack(textTrack)
        }
        if let videoTrack: VideoTrack = value.fromJSValue() {
            return .videoTrack(videoTrack)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioTrack(audioTrack):
            return audioTrack.jsValue
        case let .textTrack(textTrack):
            return textTrack.jsValue
        case let .videoTrack(videoTrack):
            return videoTrack.jsValue
        }
    }
}

public protocol Any_CanvasFilterInput_or_seq_of_CanvasFilterInput: ConvertibleToJSValue {}
extension CanvasFilterInput: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {}
extension Array: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput where Element == CanvasFilterInput {}

public enum CanvasFilterInput_or_seq_of_CanvasFilterInput: JSValueCompatible, Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {
    case canvasFilterInput(CanvasFilterInput)
    case seq_of_CanvasFilterInput([CanvasFilterInput])

    var canvasFilterInput: CanvasFilterInput? {
        switch self {
        case let .canvasFilterInput(canvasFilterInput): return canvasFilterInput
        default: return nil
        }
    }

    var seq_of_CanvasFilterInput: [CanvasFilterInput]? {
        switch self {
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput): return seq_of_CanvasFilterInput
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilterInput: CanvasFilterInput = value.fromJSValue() {
            return .canvasFilterInput(canvasFilterInput)
        }
        if let seq_of_CanvasFilterInput: [CanvasFilterInput] = value.fromJSValue() {
            return .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilterInput(canvasFilterInput):
            return canvasFilterInput.jsValue
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput):
            return seq_of_CanvasFilterInput.jsValue
        }
    }
}

public protocol Any_CanvasFilter_or_String: ConvertibleToJSValue {}
extension CanvasFilter: Any_CanvasFilter_or_String {}
extension String: Any_CanvasFilter_or_String {}

public enum CanvasFilter_or_String: JSValueCompatible, Any_CanvasFilter_or_String {
    case canvasFilter(CanvasFilter)
    case string(String)

    var canvasFilter: CanvasFilter? {
        switch self {
        case let .canvasFilter(canvasFilter): return canvasFilter
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilter: CanvasFilter = value.fromJSValue() {
            return .canvasFilter(canvasFilter)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilter(canvasFilter):
            return canvasFilter.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CanvasGradient_or_CanvasPattern_or_String: ConvertibleToJSValue {}
extension CanvasGradient: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension CanvasPattern: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension String: Any_CanvasGradient_or_CanvasPattern_or_String {}

public enum CanvasGradient_or_CanvasPattern_or_String: JSValueCompatible, Any_CanvasGradient_or_CanvasPattern_or_String {
    case canvasGradient(CanvasGradient)
    case canvasPattern(CanvasPattern)
    case string(String)

    var canvasGradient: CanvasGradient? {
        switch self {
        case let .canvasGradient(canvasGradient): return canvasGradient
        default: return nil
        }
    }

    var canvasPattern: CanvasPattern? {
        switch self {
        case let .canvasPattern(canvasPattern): return canvasPattern
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasGradient: CanvasGradient = value.fromJSValue() {
            return .canvasGradient(canvasGradient)
        }
        if let canvasPattern: CanvasPattern = value.fromJSValue() {
            return .canvasPattern(canvasPattern)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasGradient(canvasGradient):
            return canvasGradient.jsValue
        case let .canvasPattern(canvasPattern):
            return canvasPattern.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)

    var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Array: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double where Element == DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)
    case seq_of_DOMPointInit_or_Double([DOMPointInit_or_Double])

    var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    var seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]? {
        switch self {
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double): return seq_of_DOMPointInit_or_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double] = value.fromJSValue() {
            return .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double):
            return seq_of_DOMPointInit_or_Double.jsValue
        }
    }
}

public protocol Any_Element_or_HTMLCollection: ConvertibleToJSValue {}
extension Element: Any_Element_or_HTMLCollection {}
extension HTMLCollection: Any_Element_or_HTMLCollection {}

public enum Element_or_HTMLCollection: JSValueCompatible, Any_Element_or_HTMLCollection {
    case element(Element)
    case htmlCollection(HTMLCollection)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var htmlCollection: HTMLCollection? {
        switch self {
        case let .htmlCollection(htmlCollection): return htmlCollection
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let htmlCollection: HTMLCollection = value.fromJSValue() {
            return .htmlCollection(htmlCollection)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .htmlCollection(htmlCollection):
            return htmlCollection.jsValue
        }
    }
}

public protocol Any_Element_or_RadioNodeList: ConvertibleToJSValue {}
extension Element: Any_Element_or_RadioNodeList {}
extension RadioNodeList: Any_Element_or_RadioNodeList {}

public enum Element_or_RadioNodeList: JSValueCompatible, Any_Element_or_RadioNodeList {
    case element(Element)
    case radioNodeList(RadioNodeList)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var radioNodeList: RadioNodeList? {
        switch self {
        case let .radioNodeList(radioNodeList): return radioNodeList
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let radioNodeList: RadioNodeList = value.fromJSValue() {
            return .radioNodeList(radioNodeList)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .radioNodeList(radioNodeList):
            return radioNodeList.jsValue
        }
    }
}

public protocol Any_Element_or_Text: ConvertibleToJSValue {}
extension Element: Any_Element_or_Text {}
extension Text: Any_Element_or_Text {}

public enum Element_or_Text: JSValueCompatible, Any_Element_or_Text {
    case element(Element)
    case text(Text)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_Event_or_String: ConvertibleToJSValue {}
extension Event: Any_Event_or_String {}
extension String: Any_Event_or_String {}

public enum Event_or_String: JSValueCompatible, Any_Event_or_String {
    case event(Event)
    case string(String)

    var event: Event? {
        switch self {
        case let .event(event): return event
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let event: Event = value.fromJSValue() {
            return .event(event)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .event(event):
            return event.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_File_or_FormData_or_String: ConvertibleToJSValue {}
extension File: Any_File_or_FormData_or_String {}
extension FormData: Any_File_or_FormData_or_String {}
extension String: Any_File_or_FormData_or_String {}

public enum File_or_FormData_or_String: JSValueCompatible, Any_File_or_FormData_or_String {
    case file(File)
    case formData(FormData)
    case string(String)

    var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLElement_or_Int32: ConvertibleToJSValue {}
extension HTMLElement: Any_HTMLElement_or_Int32 {}
extension Int32: Any_HTMLElement_or_Int32 {}

public enum HTMLElement_or_Int32: JSValueCompatible, Any_HTMLElement_or_Int32 {
    case htmlElement(HTMLElement)
    case int32(Int32)

    var htmlElement: HTMLElement? {
        switch self {
        case let .htmlElement(htmlElement): return htmlElement
        default: return nil
        }
    }

    var int32: Int32? {
        switch self {
        case let .int32(int32): return int32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlElement: HTMLElement = value.fromJSValue() {
            return .htmlElement(htmlElement)
        }
        if let int32: Int32 = value.fromJSValue() {
            return .int32(int32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlElement(htmlElement):
            return htmlElement.jsValue
        case let .int32(int32):
            return int32.jsValue
        }
    }
}

public protocol Any_HTMLOptGroupElement_or_HTMLOptionElement: ConvertibleToJSValue {}
extension HTMLOptGroupElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}
extension HTMLOptionElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}

public enum HTMLOptGroupElement_or_HTMLOptionElement: JSValueCompatible, Any_HTMLOptGroupElement_or_HTMLOptionElement {
    case htmlOptGroupElement(HTMLOptGroupElement)
    case htmlOptionElement(HTMLOptionElement)

    var htmlOptGroupElement: HTMLOptGroupElement? {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement
        default: return nil
        }
    }

    var htmlOptionElement: HTMLOptionElement? {
        switch self {
        case let .htmlOptionElement(htmlOptionElement): return htmlOptionElement
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlOptGroupElement: HTMLOptGroupElement = value.fromJSValue() {
            return .htmlOptGroupElement(htmlOptGroupElement)
        }
        if let htmlOptionElement: HTMLOptionElement = value.fromJSValue() {
            return .htmlOptionElement(htmlOptionElement)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement):
            return htmlOptGroupElement.jsValue
        case let .htmlOptionElement(htmlOptionElement):
            return htmlOptionElement.jsValue
        }
    }
}

public protocol Any_ImageBitmapSource: ConvertibleToJSValue {}
extension Blob: Any_ImageBitmapSource {}
extension CanvasImageSource: Any_ImageBitmapSource {}
extension ImageData: Any_ImageBitmapSource {}

public enum ImageBitmapSource: JSValueCompatible, Any_ImageBitmapSource {
    case blob(Blob)
    case canvasImageSource(CanvasImageSource)
    case imageData(ImageData)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var canvasImageSource: CanvasImageSource? {
        switch self {
        case let .canvasImageSource(canvasImageSource): return canvasImageSource
        default: return nil
        }
    }

    var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let canvasImageSource: CanvasImageSource = value.fromJSValue() {
            return .canvasImageSource(canvasImageSource)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .canvasImageSource(canvasImageSource):
            return canvasImageSource.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        }
    }
}

public protocol Any_MessageEventSource: ConvertibleToJSValue {}
extension MessagePort: Any_MessageEventSource {}
extension ServiceWorker: Any_MessageEventSource {}
extension WindowProxy: Any_MessageEventSource {}

public enum MessageEventSource: JSValueCompatible, Any_MessageEventSource {
    case messagePort(MessagePort)
    case serviceWorker(ServiceWorker)
    case windowProxy(WindowProxy)

    var messagePort: MessagePort? {
        switch self {
        case let .messagePort(messagePort): return messagePort
        default: return nil
        }
    }

    var serviceWorker: ServiceWorker? {
        switch self {
        case let .serviceWorker(serviceWorker): return serviceWorker
        default: return nil
        }
    }

    var windowProxy: WindowProxy? {
        switch self {
        case let .windowProxy(windowProxy): return windowProxy
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let messagePort: MessagePort = value.fromJSValue() {
            return .messagePort(messagePort)
        }
        if let serviceWorker: ServiceWorker = value.fromJSValue() {
            return .serviceWorker(serviceWorker)
        }
        if let windowProxy: WindowProxy = value.fromJSValue() {
            return .windowProxy(windowProxy)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .messagePort(messagePort):
            return messagePort.jsValue
        case let .serviceWorker(serviceWorker):
            return serviceWorker.jsValue
        case let .windowProxy(windowProxy):
            return windowProxy.jsValue
        }
    }
}

public protocol Any_Path2D_or_String: ConvertibleToJSValue {}
extension Path2D: Any_Path2D_or_String {}
extension String: Any_Path2D_or_String {}

public enum Path2D_or_String: JSValueCompatible, Any_Path2D_or_String {
    case path2D(Path2D)
    case string(String)

    var path2D: Path2D? {
        switch self {
        case let .path2D(path2D): return path2D
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let path2D: Path2D = value.fromJSValue() {
            return .path2D(path2D)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .path2D(path2D):
            return path2D.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_String_or_WorkerOptions: ConvertibleToJSValue {}
extension String: Any_String_or_WorkerOptions {}
extension WorkerOptions: Any_String_or_WorkerOptions {}

public enum String_or_WorkerOptions: JSValueCompatible, Any_String_or_WorkerOptions {
    case string(String)
    case workerOptions(WorkerOptions)

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var workerOptions: WorkerOptions? {
        switch self {
        case let .workerOptions(workerOptions): return workerOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let workerOptions: WorkerOptions = value.fromJSValue() {
            return .workerOptions(workerOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .workerOptions(workerOptions):
            return workerOptions.jsValue
        }
    }
}

public protocol Any_TimerHandler: ConvertibleToJSValue {}
extension JSFunction: Any_TimerHandler {}
extension String: Any_TimerHandler {}

public enum TimerHandler: JSValueCompatible, Any_TimerHandler {
    case jsFunction(JSFunction)
    case string(String)

    var jsFunction: JSFunction? {
        switch self {
        case let .jsFunction(jsFunction): return jsFunction
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let jsFunction: JSFunction = value.fromJSValue() {
            return .jsFunction(jsFunction)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .jsFunction(jsFunction):
            return jsFunction.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}
