// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public class AbortController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.AbortController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _signal = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.signal)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func abort(reason: JSValue? = nil) {
        let this = jsObject
        _ = this[DOMStrings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined])
    }
}

public class AbortSignal: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.AbortSignal].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _aborted = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.aborted)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.reason)
        _onabort = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.onabort)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public static func abort(reason: JSValue? = nil) -> Self {
        let this = constructor
        return this[DOMStrings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public static func timeout(milliseconds: UInt64) -> Self {
        let this = constructor
        return this[DOMStrings.timeout].function!(this: this, arguments: [milliseconds.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var aborted: Bool

    @ReadonlyAttribute
    public var reason: JSValue

    @inlinable public func throwIfAborted() {
        let this = jsObject
        _ = this[DOMStrings.throwIfAborted].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var onabort: EventHandler
}

public class AbstractRange: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.AbstractRange].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _startContainer = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.startContainer)
        _startOffset = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.startOffset)
        _endContainer = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.endContainer)
        _endOffset = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.endOffset)
        _collapsed = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.collapsed)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var startContainer: Node

    @ReadonlyAttribute
    public var startOffset: UInt32

    @ReadonlyAttribute
    public var endContainer: Node

    @ReadonlyAttribute
    public var endOffset: UInt32

    @ReadonlyAttribute
    public var collapsed: Bool
}

public class AddEventListenerOptions: BridgedDictionary {
    public convenience init(passive: Bool, once: Bool, signal: AbortSignal) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.passive] = passive.jsValue
        object[DOMStrings.once] = once.jsValue
        object[DOMStrings.signal] = signal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _passive = ReadWriteAttribute(jsObject: object, name: DOMStrings.passive)
        _once = ReadWriteAttribute(jsObject: object, name: DOMStrings.once)
        _signal = ReadWriteAttribute(jsObject: object, name: DOMStrings.signal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var passive: Bool

    @ReadWriteAttribute
    public var once: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal
}

public class Attr: Node {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Attr].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.localName)
        _name = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.value)
        _ownerElement = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.ownerElement)
        _specified = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.specified)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var ownerElement: Element?

    @ReadonlyAttribute
    public var specified: Bool
}

public class CDATASection: Text {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.CDATASection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class CharacterData: Node, NonDocumentTypeChildNode, ChildNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.CharacterData].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.data)
        _length = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.length)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var data: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func substringData(offset: UInt32, count: UInt32) -> String {
        let this = jsObject
        return this[DOMStrings.substringData].function!(this: this, arguments: [offset.jsValue, count.jsValue]).fromJSValue()!
    }

    @inlinable public func appendData(data: String) {
        let this = jsObject
        _ = this[DOMStrings.appendData].function!(this: this, arguments: [data.jsValue])
    }

    @inlinable public func insertData(offset: UInt32, data: String) {
        let this = jsObject
        _ = this[DOMStrings.insertData].function!(this: this, arguments: [offset.jsValue, data.jsValue])
    }

    @inlinable public func deleteData(offset: UInt32, count: UInt32) {
        let this = jsObject
        _ = this[DOMStrings.deleteData].function!(this: this, arguments: [offset.jsValue, count.jsValue])
    }

    @inlinable public func replaceData(offset: UInt32, count: UInt32, data: String) {
        let this = jsObject
        _ = this[DOMStrings.replaceData].function!(this: this, arguments: [offset.jsValue, count.jsValue, data.jsValue])
    }
}

public protocol ChildNode: JSBridgedClass {}
public extension ChildNode {
    @inlinable func before(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.before].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func after(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.after].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func replaceWith(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.replaceWith].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func remove() {
        let this = jsObject
        _ = this[DOMStrings.remove].function!(this: this, arguments: [])
    }
}

public class Comment: CharacterData {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Comment].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data?.jsValue ?? .undefined]))
    }
}

public class CustomEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.CustomEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _detail = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.detail)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CustomEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var detail: JSValue

    @inlinable public func initCustomEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, detail: JSValue? = nil) {
        let this = jsObject
        _ = this[DOMStrings.initCustomEvent].function!(this: this, arguments: [type.jsValue, bubbles?.jsValue ?? .undefined, cancelable?.jsValue ?? .undefined, detail?.jsValue ?? .undefined])
    }
}

public class CustomEventInit: BridgedDictionary {
    public convenience init(detail: JSValue) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.detail] = detail.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _detail = ReadWriteAttribute(jsObject: object, name: DOMStrings.detail)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var detail: JSValue
}

public class DOMImplementation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.DOMImplementation].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func createDocumentType(qualifiedName: String, publicId: String, systemId: String) -> DocumentType {
        let this = jsObject
        return this[DOMStrings.createDocumentType].function!(this: this, arguments: [qualifiedName.jsValue, publicId.jsValue, systemId.jsValue]).fromJSValue()!
    }

    @inlinable public func createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = nil) -> XMLDocument {
        let this = jsObject
        return this[DOMStrings.createDocument].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, doctype?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createHTMLDocument(title: String? = nil) -> Document {
        let this = jsObject
        return this[DOMStrings.createHTMLDocument].function!(this: this, arguments: [title?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func hasFeature() -> Bool {
        let this = jsObject
        return this[DOMStrings.hasFeature].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMTokenList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.DOMTokenList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.length)
        _value = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.value)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func contains(token: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.contains].function!(this: this, arguments: [token.jsValue]).fromJSValue()!
    }

    @inlinable public func add(tokens: String...) {
        let this = jsObject
        _ = this[DOMStrings.add].function!(this: this, arguments: tokens.map(\.jsValue))
    }

    @inlinable public func remove(tokens: String...) {
        let this = jsObject
        _ = this[DOMStrings.remove].function!(this: this, arguments: tokens.map(\.jsValue))
    }

    @inlinable public func toggle(token: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[DOMStrings.toggle].function!(this: this, arguments: [token.jsValue, force?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func replace(token: String, newToken: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.replace].function!(this: this, arguments: [token.jsValue, newToken.jsValue]).fromJSValue()!
    }

    @inlinable public func supports(token: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.supports].function!(this: this, arguments: [token.jsValue]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var value: String

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<DOMTokenList> {
        ValueIterableIterator(sequence: self)
    }
}

public class Document: Node, NonElementParentNode, DocumentOrShadowRoot, ParentNode, XPathEvaluatorBase {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Document].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _implementation = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.implementation)
        _URL = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.URL)
        _documentURI = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.documentURI)
        _compatMode = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.compatMode)
        _characterSet = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.characterSet)
        _charset = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.charset)
        _inputEncoding = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.inputEncoding)
        _contentType = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.contentType)
        _doctype = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.doctype)
        _documentElement = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.documentElement)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var implementation: DOMImplementation

    @ReadonlyAttribute
    public var URL: String

    @ReadonlyAttribute
    public var documentURI: String

    @ReadonlyAttribute
    public var compatMode: String

    @ReadonlyAttribute
    public var characterSet: String

    @ReadonlyAttribute
    public var charset: String

    @ReadonlyAttribute
    public var inputEncoding: String

    @ReadonlyAttribute
    public var contentType: String

    @ReadonlyAttribute
    public var doctype: DocumentType?

    @ReadonlyAttribute
    public var documentElement: Element?

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByTagName].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByTagNameNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByClassName].function!(this: this, arguments: [classNames.jsValue]).fromJSValue()!
    }

    @inlinable public func createElement(localName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[DOMStrings.createElement].function!(this: this, arguments: [localName.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[DOMStrings.createElementNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createDocumentFragment() -> DocumentFragment {
        let this = jsObject
        return this[DOMStrings.createDocumentFragment].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createTextNode(data: String) -> Text {
        let this = jsObject
        return this[DOMStrings.createTextNode].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createCDATASection(data: String) -> CDATASection {
        let this = jsObject
        return this[DOMStrings.createCDATASection].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createComment(data: String) -> Comment {
        let this = jsObject
        return this[DOMStrings.createComment].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createProcessingInstruction(target: String, data: String) -> ProcessingInstruction {
        let this = jsObject
        return this[DOMStrings.createProcessingInstruction].function!(this: this, arguments: [target.jsValue, data.jsValue]).fromJSValue()!
    }

    @inlinable public func importNode(node: Node, deep: Bool? = nil) -> Node {
        let this = jsObject
        return this[DOMStrings.importNode].function!(this: this, arguments: [node.jsValue, deep?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func adoptNode(node: Node) -> Node {
        let this = jsObject
        return this[DOMStrings.adoptNode].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public func createAttribute(localName: String) -> Attr {
        let this = jsObject
        return this[DOMStrings.createAttribute].function!(this: this, arguments: [localName.jsValue]).fromJSValue()!
    }

    @inlinable public func createAttributeNS(namespace: String?, qualifiedName: String) -> Attr {
        let this = jsObject
        return this[DOMStrings.createAttributeNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func createEvent(interface: String) -> Event {
        let this = jsObject
        return this[DOMStrings.createEvent].function!(this: this, arguments: [interface.jsValue]).fromJSValue()!
    }

    @inlinable public func createRange() -> Range {
        let this = jsObject
        return this[DOMStrings.createRange].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'createNodeIterator' is ignored

    // XXX: member 'createTreeWalker' is ignored
}

public class DocumentFragment: Node, NonElementParentNode, ParentNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.DocumentFragment].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public protocol DocumentOrShadowRoot: JSBridgedClass {}
public extension DocumentOrShadowRoot {}

public class DocumentType: Node, ChildNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.DocumentType].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.name)
        _publicId = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.publicId)
        _systemId = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.systemId)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var publicId: String

    @ReadonlyAttribute
    public var systemId: String
}

public class Element: Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slottable {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Element].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.localName)
        _tagName = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.tagName)
        _id = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.id)
        _className = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.className)
        _classList = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.classList)
        _slot = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.slot)
        _attributes = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.attributes)
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.shadowRoot)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var tagName: String

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var className: String

    @ReadonlyAttribute
    public var classList: DOMTokenList

    @ReadWriteAttribute
    public var slot: String

    @inlinable public func hasAttributes() -> Bool {
        let this = jsObject
        return this[DOMStrings.hasAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var attributes: NamedNodeMap

    @inlinable public func getAttributeNames() -> [String] {
        let this = jsObject
        return this[DOMStrings.getAttributeNames].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getAttribute(qualifiedName: String) -> String? {
        let this = jsObject
        return this[DOMStrings.getAttribute].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNS(namespace: String?, localName: String) -> String? {
        let this = jsObject
        return this[DOMStrings.getAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttribute(qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[DOMStrings.setAttribute].function!(this: this, arguments: [qualifiedName.jsValue, value.jsValue])
    }

    @inlinable public func setAttributeNS(namespace: String?, qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[DOMStrings.setAttributeNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, value.jsValue])
    }

    @inlinable public func removeAttribute(qualifiedName: String) {
        let this = jsObject
        _ = this[DOMStrings.removeAttribute].function!(this: this, arguments: [qualifiedName.jsValue])
    }

    @inlinable public func removeAttributeNS(namespace: String?, localName: String) {
        let this = jsObject
        _ = this[DOMStrings.removeAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue])
    }

    @inlinable public func toggleAttribute(qualifiedName: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[DOMStrings.toggleAttribute].function!(this: this, arguments: [qualifiedName.jsValue, force?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func hasAttribute(qualifiedName: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.hasAttribute].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func hasAttributeNS(namespace: String?, localName: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.hasAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNode(qualifiedName: String) -> Attr? {
        let this = jsObject
        return this[DOMStrings.getAttributeNode].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNodeNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[DOMStrings.getAttributeNodeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttributeNode(attr: Attr) -> Attr? {
        let this = jsObject
        return this[DOMStrings.setAttributeNode].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttributeNodeNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[DOMStrings.setAttributeNodeNS].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func removeAttributeNode(attr: Attr) -> Attr {
        let this = jsObject
        return this[DOMStrings.removeAttributeNode].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func attachShadow(init: ShadowRootInit) -> ShadowRoot {
        let this = jsObject
        return this[DOMStrings.attachShadow].function!(this: this, arguments: [`init`.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func closest(selectors: String) -> Element? {
        let this = jsObject
        return this[DOMStrings.closest].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func matches(selectors: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.matches].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func webkitMatchesSelector(selectors: String) -> Bool {
        let this = jsObject
        return this[DOMStrings.webkitMatchesSelector].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByTagName].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByTagNameNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[DOMStrings.getElementsByClassName].function!(this: this, arguments: [classNames.jsValue]).fromJSValue()!
    }

    @inlinable public func insertAdjacentElement(where: String, element: Element) -> Element? {
        let this = jsObject
        return this[DOMStrings.insertAdjacentElement].function!(this: this, arguments: [`where`.jsValue, element.jsValue]).fromJSValue()!
    }

    @inlinable public func insertAdjacentText(where: String, data: String) {
        let this = jsObject
        _ = this[DOMStrings.insertAdjacentText].function!(this: this, arguments: [`where`.jsValue, data.jsValue])
    }
}

public class ElementCreationOptions: BridgedDictionary {
    public convenience init(is: String) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.is] = `is`.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _is = ReadWriteAttribute(jsObject: object, name: DOMStrings.is)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var `is`: String
}

public class Event: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.Event].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.target)
        _srcElement = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.srcElement)
        _currentTarget = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.currentTarget)
        _eventPhase = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.eventPhase)
        _cancelBubble = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.cancelBubble)
        _bubbles = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.bubbles)
        _cancelable = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.cancelable)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.returnValue)
        _defaultPrevented = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.defaultPrevented)
        _composed = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.composed)
        _isTrusted = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.isTrusted)
        _timeStamp = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.timeStamp)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(type: String, eventInitDict: EventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: EventTarget?

    @ReadonlyAttribute
    public var srcElement: EventTarget?

    @ReadonlyAttribute
    public var currentTarget: EventTarget?

    @inlinable public func composedPath() -> [EventTarget] {
        let this = jsObject
        return this[DOMStrings.composedPath].function!(this: this, arguments: []).fromJSValue()!
    }

    public static let NONE: UInt16 = 0

    public static let CAPTURING_PHASE: UInt16 = 1

    public static let AT_TARGET: UInt16 = 2

    public static let BUBBLING_PHASE: UInt16 = 3

    @ReadonlyAttribute
    public var eventPhase: UInt16

    @inlinable public func stopPropagation() {
        let this = jsObject
        _ = this[DOMStrings.stopPropagation].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var cancelBubble: Bool

    @inlinable public func stopImmediatePropagation() {
        let this = jsObject
        _ = this[DOMStrings.stopImmediatePropagation].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var bubbles: Bool

    @ReadonlyAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var returnValue: Bool

    @inlinable public func preventDefault() {
        let this = jsObject
        _ = this[DOMStrings.preventDefault].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var defaultPrevented: Bool

    @ReadonlyAttribute
    public var composed: Bool

    @ReadonlyAttribute
    public var isTrusted: Bool

    @ReadonlyAttribute
    public var timeStamp: DOMHighResTimeStamp

    @inlinable public func initEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil) {
        let this = jsObject
        _ = this[DOMStrings.initEvent].function!(this: this, arguments: [type.jsValue, bubbles?.jsValue ?? .undefined, cancelable?.jsValue ?? .undefined])
    }
}

public class EventInit: BridgedDictionary {
    public convenience init(bubbles: Bool, cancelable: Bool, composed: Bool) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.bubbles] = bubbles.jsValue
        object[DOMStrings.cancelable] = cancelable.jsValue
        object[DOMStrings.composed] = composed.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bubbles = ReadWriteAttribute(jsObject: object, name: DOMStrings.bubbles)
        _cancelable = ReadWriteAttribute(jsObject: object, name: DOMStrings.cancelable)
        _composed = ReadWriteAttribute(jsObject: object, name: DOMStrings.composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bubbles: Bool

    @ReadWriteAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var composed: Bool
}

public class EventListenerOptions: BridgedDictionary {
    public convenience init(capture: Bool) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.capture] = capture.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _capture = ReadWriteAttribute(jsObject: object, name: DOMStrings.capture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var capture: Bool
}

public class EventTarget: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.EventTarget].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    // XXX: member 'addEventListener' is ignored

    // XXX: member 'removeEventListener' is ignored

    @inlinable public func dispatchEvent(event: Event) -> Bool {
        let this = jsObject
        return this[DOMStrings.dispatchEvent].function!(this: this, arguments: [event.jsValue]).fromJSValue()!
    }
}

public class GetRootNodeOptions: BridgedDictionary {
    public convenience init(composed: Bool) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.composed] = composed.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _composed = ReadWriteAttribute(jsObject: object, name: DOMStrings.composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var composed: Bool
}

public class HTMLCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.HTMLCollection].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Element? {
        jsObject[key].fromJSValue()
    }
}

public class MutationObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.MutationObserver].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: constructor is ignored

    @inlinable public func observe(target: Node, options: MutationObserverInit? = nil) {
        let this = jsObject
        _ = this[DOMStrings.observe].function!(this: this, arguments: [target.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[DOMStrings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func takeRecords() -> [MutationRecord] {
        let this = jsObject
        return this[DOMStrings.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class MutationObserverInit: BridgedDictionary {
    public convenience init(childList: Bool, attributes: Bool, characterData: Bool, subtree: Bool, attributeOldValue: Bool, characterDataOldValue: Bool, attributeFilter: [String]) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.childList] = childList.jsValue
        object[DOMStrings.attributes] = attributes.jsValue
        object[DOMStrings.characterData] = characterData.jsValue
        object[DOMStrings.subtree] = subtree.jsValue
        object[DOMStrings.attributeOldValue] = attributeOldValue.jsValue
        object[DOMStrings.characterDataOldValue] = characterDataOldValue.jsValue
        object[DOMStrings.attributeFilter] = attributeFilter.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _childList = ReadWriteAttribute(jsObject: object, name: DOMStrings.childList)
        _attributes = ReadWriteAttribute(jsObject: object, name: DOMStrings.attributes)
        _characterData = ReadWriteAttribute(jsObject: object, name: DOMStrings.characterData)
        _subtree = ReadWriteAttribute(jsObject: object, name: DOMStrings.subtree)
        _attributeOldValue = ReadWriteAttribute(jsObject: object, name: DOMStrings.attributeOldValue)
        _characterDataOldValue = ReadWriteAttribute(jsObject: object, name: DOMStrings.characterDataOldValue)
        _attributeFilter = ReadWriteAttribute(jsObject: object, name: DOMStrings.attributeFilter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var childList: Bool

    @ReadWriteAttribute
    public var attributes: Bool

    @ReadWriteAttribute
    public var characterData: Bool

    @ReadWriteAttribute
    public var subtree: Bool

    @ReadWriteAttribute
    public var attributeOldValue: Bool

    @ReadWriteAttribute
    public var characterDataOldValue: Bool

    @ReadWriteAttribute
    public var attributeFilter: [String]
}

public class MutationRecord: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.MutationRecord].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.target)
        _addedNodes = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.addedNodes)
        _removedNodes = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.removedNodes)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.nextSibling)
        _attributeName = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.attributeName)
        _attributeNamespace = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.attributeNamespace)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.oldValue)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: Node

    @ReadonlyAttribute
    public var addedNodes: NodeList

    @ReadonlyAttribute
    public var removedNodes: NodeList

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadonlyAttribute
    public var attributeName: String?

    @ReadonlyAttribute
    public var attributeNamespace: String?

    @ReadonlyAttribute
    public var oldValue: String?
}

public class NamedNodeMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.NamedNodeMap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func getNamedItemNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[DOMStrings.getNamedItemNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setNamedItem(attr: Attr) -> Attr? {
        let this = jsObject
        return this[DOMStrings.setNamedItem].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func setNamedItemNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[DOMStrings.setNamedItemNS].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func removeNamedItem(qualifiedName: String) -> Attr {
        let this = jsObject
        return this[DOMStrings.removeNamedItem].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func removeNamedItemNS(namespace: String?, localName: String) -> Attr {
        let this = jsObject
        return this[DOMStrings.removeNamedItemNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }
}

public class Node: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Node].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _nodeType = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.nodeType)
        _nodeName = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.nodeName)
        _baseURI = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.baseURI)
        _isConnected = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.isConnected)
        _ownerDocument = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.ownerDocument)
        _parentNode = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.parentNode)
        _parentElement = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.parentElement)
        _childNodes = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.childNodes)
        _firstChild = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.firstChild)
        _lastChild = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.lastChild)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.nextSibling)
        _nodeValue = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.nodeValue)
        _textContent = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.textContent)
        super.init(unsafelyWrapping: jsObject)
    }

    public static let ELEMENT_NODE: UInt16 = 1

    public static let ATTRIBUTE_NODE: UInt16 = 2

    public static let TEXT_NODE: UInt16 = 3

    public static let CDATA_SECTION_NODE: UInt16 = 4

    public static let ENTITY_REFERENCE_NODE: UInt16 = 5

    public static let ENTITY_NODE: UInt16 = 6

    public static let PROCESSING_INSTRUCTION_NODE: UInt16 = 7

    public static let COMMENT_NODE: UInt16 = 8

    public static let DOCUMENT_NODE: UInt16 = 9

    public static let DOCUMENT_TYPE_NODE: UInt16 = 10

    public static let DOCUMENT_FRAGMENT_NODE: UInt16 = 11

    public static let NOTATION_NODE: UInt16 = 12

    @ReadonlyAttribute
    public var nodeType: UInt16

    @ReadonlyAttribute
    public var nodeName: String

    @ReadonlyAttribute
    public var baseURI: String

    @ReadonlyAttribute
    public var isConnected: Bool

    @ReadonlyAttribute
    public var ownerDocument: Document?

    @inlinable public func getRootNode(options: GetRootNodeOptions? = nil) -> Self {
        let this = jsObject
        return this[DOMStrings.getRootNode].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var parentNode: Node?

    @ReadonlyAttribute
    public var parentElement: Element?

    @inlinable public func hasChildNodes() -> Bool {
        let this = jsObject
        return this[DOMStrings.hasChildNodes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var childNodes: NodeList

    @ReadonlyAttribute
    public var firstChild: Node?

    @ReadonlyAttribute
    public var lastChild: Node?

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadWriteAttribute
    public var nodeValue: String?

    @ReadWriteAttribute
    public var textContent: String?

    @inlinable public func normalize() {
        let this = jsObject
        _ = this[DOMStrings.normalize].function!(this: this, arguments: [])
    }

    @inlinable public func cloneNode(deep: Bool? = nil) -> Self {
        let this = jsObject
        return this[DOMStrings.cloneNode].function!(this: this, arguments: [deep?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func isEqualNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[DOMStrings.isEqualNode].function!(this: this, arguments: [otherNode.jsValue]).fromJSValue()!
    }

    @inlinable public func isSameNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[DOMStrings.isSameNode].function!(this: this, arguments: [otherNode.jsValue]).fromJSValue()!
    }

    public static let DOCUMENT_POSITION_DISCONNECTED: UInt16 = 0x01

    public static let DOCUMENT_POSITION_PRECEDING: UInt16 = 0x02

    public static let DOCUMENT_POSITION_FOLLOWING: UInt16 = 0x04

    public static let DOCUMENT_POSITION_CONTAINS: UInt16 = 0x08

    public static let DOCUMENT_POSITION_CONTAINED_BY: UInt16 = 0x10

    public static let DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: UInt16 = 0x20

    @inlinable public func compareDocumentPosition(other: Node) -> UInt16 {
        let this = jsObject
        return this[DOMStrings.compareDocumentPosition].function!(this: this, arguments: [other.jsValue]).fromJSValue()!
    }

    @inlinable public func contains(other: Node?) -> Bool {
        let this = jsObject
        return this[DOMStrings.contains].function!(this: this, arguments: [other.jsValue]).fromJSValue()!
    }

    @inlinable public func lookupPrefix(namespace: String?) -> String? {
        let this = jsObject
        return this[DOMStrings.lookupPrefix].function!(this: this, arguments: [namespace.jsValue]).fromJSValue()!
    }

    @inlinable public func lookupNamespaceURI(prefix: String?) -> String? {
        let this = jsObject
        return this[DOMStrings.lookupNamespaceURI].function!(this: this, arguments: [prefix.jsValue]).fromJSValue()!
    }

    @inlinable public func isDefaultNamespace(namespace: String?) -> Bool {
        let this = jsObject
        return this[DOMStrings.isDefaultNamespace].function!(this: this, arguments: [namespace.jsValue]).fromJSValue()!
    }

    @inlinable public func insertBefore(node: Node, child: Node?) -> Self {
        let this = jsObject
        return this[DOMStrings.insertBefore].function!(this: this, arguments: [node.jsValue, child.jsValue]).fromJSValue()!
    }

    @inlinable public func appendChild(node: Node) -> Self {
        let this = jsObject
        return this[DOMStrings.appendChild].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public func replaceChild(node: Node, child: Node) -> Self {
        let this = jsObject
        return this[DOMStrings.replaceChild].function!(this: this, arguments: [node.jsValue, child.jsValue]).fromJSValue()!
    }

    @inlinable public func removeChild(child: Node) -> Self {
        let this = jsObject
        return this[DOMStrings.removeChild].function!(this: this, arguments: [child.jsValue]).fromJSValue()!
    }
}

public class NodeIterator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.NodeIterator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.root)
        _referenceNode = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.referenceNode)
        _pointerBeforeReferenceNode = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.pointerBeforeReferenceNode)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.whatToShow)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var referenceNode: Node

    @ReadonlyAttribute
    public var pointerBeforeReferenceNode: Bool

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[DOMStrings.nextNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[DOMStrings.previousNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[DOMStrings.detach].function!(this: this, arguments: [])
    }
}

public class NodeList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.NodeList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> Node? {
        jsObject[key].fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32

    public typealias Element = Node
    public func makeIterator() -> ValueIterableIterator<NodeList> {
        ValueIterableIterator(sequence: self)
    }
}

public protocol NonDocumentTypeChildNode: JSBridgedClass {}
public extension NonDocumentTypeChildNode {
    @inlinable var previousElementSibling: Element? { ReadonlyAttribute[DOMStrings.previousElementSibling, in: jsObject] }

    @inlinable var nextElementSibling: Element? { ReadonlyAttribute[DOMStrings.nextElementSibling, in: jsObject] }
}

public protocol NonElementParentNode: JSBridgedClass {}
public extension NonElementParentNode {
    @inlinable func getElementById(elementId: String) -> Element? {
        let this = jsObject
        return this[DOMStrings.getElementById].function!(this: this, arguments: [elementId.jsValue]).fromJSValue()!
    }
}

public protocol ParentNode: JSBridgedClass {}
public extension ParentNode {
    @inlinable var children: HTMLCollection { ReadonlyAttribute[DOMStrings.children, in: jsObject] }

    @inlinable var firstElementChild: Element? { ReadonlyAttribute[DOMStrings.firstElementChild, in: jsObject] }

    @inlinable var lastElementChild: Element? { ReadonlyAttribute[DOMStrings.lastElementChild, in: jsObject] }

    @inlinable var childElementCount: UInt32 { ReadonlyAttribute[DOMStrings.childElementCount, in: jsObject] }

    @inlinable func prepend(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.prepend].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func append(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.append].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func replaceChildren(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[DOMStrings.replaceChildren].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func querySelector(selectors: String) -> Element? {
        let this = jsObject
        return this[DOMStrings.querySelector].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable func querySelectorAll(selectors: String) -> NodeList {
        let this = jsObject
        return this[DOMStrings.querySelectorAll].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }
}

public class ProcessingInstruction: CharacterData {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.ProcessingInstruction].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var target: String
}

public class Range: AbstractRange {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Range].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _commonAncestorContainer = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.commonAncestorContainer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var commonAncestorContainer: Node

    @inlinable public func setStart(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[DOMStrings.setStart].function!(this: this, arguments: [node.jsValue, offset.jsValue])
    }

    @inlinable public func setEnd(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[DOMStrings.setEnd].function!(this: this, arguments: [node.jsValue, offset.jsValue])
    }

    @inlinable public func setStartBefore(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.setStartBefore].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setStartAfter(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.setStartAfter].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setEndBefore(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.setEndBefore].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setEndAfter(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.setEndAfter].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func collapse(toStart: Bool? = nil) {
        let this = jsObject
        _ = this[DOMStrings.collapse].function!(this: this, arguments: [toStart?.jsValue ?? .undefined])
    }

    @inlinable public func selectNode(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.selectNode].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func selectNodeContents(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.selectNodeContents].function!(this: this, arguments: [node.jsValue])
    }

    public static let START_TO_START: UInt16 = 0

    public static let START_TO_END: UInt16 = 1

    public static let END_TO_END: UInt16 = 2

    public static let END_TO_START: UInt16 = 3

    @inlinable public func compareBoundaryPoints(how: UInt16, sourceRange: Range) -> Int16 {
        let this = jsObject
        return this[DOMStrings.compareBoundaryPoints].function!(this: this, arguments: [how.jsValue, sourceRange.jsValue]).fromJSValue()!
    }

    @inlinable public func deleteContents() {
        let this = jsObject
        _ = this[DOMStrings.deleteContents].function!(this: this, arguments: [])
    }

    @inlinable public func extractContents() -> DocumentFragment {
        let this = jsObject
        return this[DOMStrings.extractContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func cloneContents() -> DocumentFragment {
        let this = jsObject
        return this[DOMStrings.cloneContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func insertNode(node: Node) {
        let this = jsObject
        _ = this[DOMStrings.insertNode].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func surroundContents(newParent: Node) {
        let this = jsObject
        _ = this[DOMStrings.surroundContents].function!(this: this, arguments: [newParent.jsValue])
    }

    @inlinable public func cloneRange() -> Self {
        let this = jsObject
        return this[DOMStrings.cloneRange].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[DOMStrings.detach].function!(this: this, arguments: [])
    }

    @inlinable public func isPointInRange(node: Node, offset: UInt32) -> Bool {
        let this = jsObject
        return this[DOMStrings.isPointInRange].function!(this: this, arguments: [node.jsValue, offset.jsValue]).fromJSValue()!
    }

    @inlinable public func comparePoint(node: Node, offset: UInt32) -> Int16 {
        let this = jsObject
        return this[DOMStrings.comparePoint].function!(this: this, arguments: [node.jsValue, offset.jsValue]).fromJSValue()!
    }

    @inlinable public func intersectsNode(node: Node) -> Bool {
        let this = jsObject
        return this[DOMStrings.intersectsNode].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public var description: String {
        jsObject[Strings.toString]!().fromJSValue()!
    }
}

public class ShadowRoot: DocumentFragment, DocumentOrShadowRoot {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.ShadowRoot].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mode = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.mode)
        _delegatesFocus = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.delegatesFocus)
        _slotAssignment = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.slotAssignment)
        _host = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.host)
        _onslotchange = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.onslotchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var mode: ShadowRootMode

    @ReadonlyAttribute
    public var delegatesFocus: Bool

    @ReadonlyAttribute
    public var slotAssignment: SlotAssignmentMode

    @ReadonlyAttribute
    public var host: Element

    @ReadWriteAttribute
    public var onslotchange: EventHandler
}

public class ShadowRootInit: BridgedDictionary {
    public convenience init(mode: ShadowRootMode, delegatesFocus: Bool, slotAssignment: SlotAssignmentMode) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.mode] = mode.jsValue
        object[DOMStrings.delegatesFocus] = delegatesFocus.jsValue
        object[DOMStrings.slotAssignment] = slotAssignment.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: DOMStrings.mode)
        _delegatesFocus = ReadWriteAttribute(jsObject: object, name: DOMStrings.delegatesFocus)
        _slotAssignment = ReadWriteAttribute(jsObject: object, name: DOMStrings.slotAssignment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: ShadowRootMode

    @ReadWriteAttribute
    public var delegatesFocus: Bool

    @ReadWriteAttribute
    public var slotAssignment: SlotAssignmentMode
}

public enum ShadowRootMode: JSString, JSValueCompatible {
    case open = "open"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum SlotAssignmentMode: JSString, JSValueCompatible {
    case manual = "manual"
    case named = "named"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol Slottable: JSBridgedClass {}
public extension Slottable {
    @inlinable var assignedSlot: HTMLSlotElement? { ReadonlyAttribute[DOMStrings.assignedSlot, in: jsObject] }
}

public class StaticRange: AbstractRange {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.StaticRange].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: StaticRangeInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }
}

public class StaticRangeInit: BridgedDictionary {
    public convenience init(startContainer: Node, startOffset: UInt32, endContainer: Node, endOffset: UInt32) {
        let object = JSObject.global[DOMStrings.Object].function!.new()
        object[DOMStrings.startContainer] = startContainer.jsValue
        object[DOMStrings.startOffset] = startOffset.jsValue
        object[DOMStrings.endContainer] = endContainer.jsValue
        object[DOMStrings.endOffset] = endOffset.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _startContainer = ReadWriteAttribute(jsObject: object, name: DOMStrings.startContainer)
        _startOffset = ReadWriteAttribute(jsObject: object, name: DOMStrings.startOffset)
        _endContainer = ReadWriteAttribute(jsObject: object, name: DOMStrings.endContainer)
        _endOffset = ReadWriteAttribute(jsObject: object, name: DOMStrings.endOffset)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var startContainer: Node

    @ReadWriteAttribute
    public var startOffset: UInt32

    @ReadWriteAttribute
    public var endContainer: Node

    @ReadWriteAttribute
    public var endOffset: UInt32
}

public class Text: CharacterData, Slottable {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.Text].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wholeText = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.wholeText)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data?.jsValue ?? .undefined]))
    }

    @inlinable public func splitText(offset: UInt32) -> Self {
        let this = jsObject
        return this[DOMStrings.splitText].function!(this: this, arguments: [offset.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var wholeText: String
}

public class TreeWalker: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.TreeWalker].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.root)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.whatToShow)
        _currentNode = ReadWriteAttribute(jsObject: jsObject, name: DOMStrings.currentNode)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @ReadWriteAttribute
    public var currentNode: Node

    @inlinable public func parentNode() -> Node? {
        let this = jsObject
        return this[DOMStrings.parentNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func firstChild() -> Node? {
        let this = jsObject
        return this[DOMStrings.firstChild].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func lastChild() -> Node? {
        let this = jsObject
        return this[DOMStrings.lastChild].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousSibling() -> Node? {
        let this = jsObject
        return this[DOMStrings.previousSibling].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func nextSibling() -> Node? {
        let this = jsObject
        return this[DOMStrings.nextSibling].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[DOMStrings.previousNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[DOMStrings.nextNode].function!(this: this, arguments: []).fromJSValue()!
    }
}

public typealias MutationCallback = ([MutationRecord], MutationObserver) -> Void
public class XMLDocument: Document {
    @inlinable override public class var constructor: JSFunction { JSObject.global[DOMStrings.XMLDocument].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class XPathEvaluator: JSBridgedClass, XPathEvaluatorBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.XPathEvaluator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public protocol XPathEvaluatorBase: JSBridgedClass {}
public extension XPathEvaluatorBase {
    // XXX: method 'createExpression' is ignored

    // XXX: method 'createNSResolver' is ignored

    // XXX: method 'evaluate' is ignored
}

public class XPathExpression: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.XPathExpression].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func evaluate(contextNode: Node, type: UInt16? = nil, result: XPathResult? = nil) -> XPathResult {
        let this = jsObject
        return this[DOMStrings.evaluate].function!(this: this, arguments: [contextNode.jsValue, type?.jsValue ?? .undefined, result?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class XPathResult: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.XPathResult].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _resultType = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.resultType)
        _numberValue = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.numberValue)
        _stringValue = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.stringValue)
        _booleanValue = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.booleanValue)
        _singleNodeValue = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.singleNodeValue)
        _invalidIteratorState = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.invalidIteratorState)
        _snapshotLength = ReadonlyAttribute(jsObject: jsObject, name: DOMStrings.snapshotLength)
        self.jsObject = jsObject
    }

    public static let ANY_TYPE: UInt16 = 0

    public static let NUMBER_TYPE: UInt16 = 1

    public static let STRING_TYPE: UInt16 = 2

    public static let BOOLEAN_TYPE: UInt16 = 3

    public static let UNORDERED_NODE_ITERATOR_TYPE: UInt16 = 4

    public static let ORDERED_NODE_ITERATOR_TYPE: UInt16 = 5

    public static let UNORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 6

    public static let ORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 7

    public static let ANY_UNORDERED_NODE_TYPE: UInt16 = 8

    public static let FIRST_ORDERED_NODE_TYPE: UInt16 = 9

    @ReadonlyAttribute
    public var resultType: UInt16

    @ReadonlyAttribute
    public var numberValue: Double

    @ReadonlyAttribute
    public var stringValue: String

    @ReadonlyAttribute
    public var booleanValue: Bool

    @ReadonlyAttribute
    public var singleNodeValue: Node?

    @ReadonlyAttribute
    public var invalidIteratorState: Bool

    @ReadonlyAttribute
    public var snapshotLength: UInt32

    @inlinable public func iterateNext() -> Node? {
        let this = jsObject
        return this[DOMStrings.iterateNext].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func snapshotItem(index: UInt32) -> Node? {
        let this = jsObject
        return this[DOMStrings.snapshotItem].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }
}

public class XSLTProcessor: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[DOMStrings.XSLTProcessor].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func importStylesheet(style: Node) {
        let this = jsObject
        _ = this[DOMStrings.importStylesheet].function!(this: this, arguments: [style.jsValue])
    }

    @inlinable public func transformToFragment(source: Node, output: Document) -> DocumentFragment {
        let this = jsObject
        return this[DOMStrings.transformToFragment].function!(this: this, arguments: [source.jsValue, output.jsValue]).fromJSValue()!
    }

    @inlinable public func transformToDocument(source: Node) -> Document {
        let this = jsObject
        return this[DOMStrings.transformToDocument].function!(this: this, arguments: [source.jsValue]).fromJSValue()!
    }

    @inlinable public func setParameter(namespaceURI: String, localName: String, value: JSValue) {
        let this = jsObject
        _ = this[DOMStrings.setParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue, value.jsValue])
    }

    @inlinable public func getParameter(namespaceURI: String, localName: String) -> JSValue {
        let this = jsObject
        return this[DOMStrings.getParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func removeParameter(namespaceURI: String, localName: String) {
        let this = jsObject
        _ = this[DOMStrings.removeParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue])
    }

    @inlinable public func clearParameters() {
        let this = jsObject
        _ = this[DOMStrings.clearParameters].function!(this: this, arguments: [])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[DOMStrings.reset].function!(this: this, arguments: [])
    }
}

/* variadic generics please */
@propertyWrapper public final class ClosureAttribute2OptionalVoid<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1) -> Void)? {
        get { ClosureAttribute2OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute2OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute2Void<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1) -> Void {
        get { ClosureAttribute2Void[name, in: jsObject] }
        set { ClosureAttribute2Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@usableFromInline enum DOMStrings {
    static let _self: JSString = "self"
    @usableFromInline static let AbortController: JSString = "AbortController"
    @usableFromInline static let AbortSignal: JSString = "AbortSignal"
    @usableFromInline static let AbstractRange: JSString = "AbstractRange"
    @usableFromInline static let Attr: JSString = "Attr"
    @usableFromInline static let CDATASection: JSString = "CDATASection"
    @usableFromInline static let CharacterData: JSString = "CharacterData"
    @usableFromInline static let Comment: JSString = "Comment"
    @usableFromInline static let CustomEvent: JSString = "CustomEvent"
    @usableFromInline static let DOMImplementation: JSString = "DOMImplementation"
    @usableFromInline static let DOMTokenList: JSString = "DOMTokenList"
    @usableFromInline static let Document: JSString = "Document"
    @usableFromInline static let DocumentFragment: JSString = "DocumentFragment"
    @usableFromInline static let DocumentType: JSString = "DocumentType"
    @usableFromInline static let Element: JSString = "Element"
    @usableFromInline static let Event: JSString = "Event"
    @usableFromInline static let EventTarget: JSString = "EventTarget"
    @usableFromInline static let HTMLCollection: JSString = "HTMLCollection"
    @usableFromInline static let MutationObserver: JSString = "MutationObserver"
    @usableFromInline static let MutationRecord: JSString = "MutationRecord"
    @usableFromInline static let NamedNodeMap: JSString = "NamedNodeMap"
    @usableFromInline static let Node: JSString = "Node"
    @usableFromInline static let NodeIterator: JSString = "NodeIterator"
    @usableFromInline static let NodeList: JSString = "NodeList"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let ProcessingInstruction: JSString = "ProcessingInstruction"
    @usableFromInline static let Range: JSString = "Range"
    @usableFromInline static let ShadowRoot: JSString = "ShadowRoot"
    @usableFromInline static let StaticRange: JSString = "StaticRange"
    @usableFromInline static let Text: JSString = "Text"
    @usableFromInline static let TreeWalker: JSString = "TreeWalker"
    @usableFromInline static let URL: JSString = "URL"
    @usableFromInline static let XMLDocument: JSString = "XMLDocument"
    @usableFromInline static let XPathEvaluator: JSString = "XPathEvaluator"
    @usableFromInline static let XPathExpression: JSString = "XPathExpression"
    @usableFromInline static let XPathResult: JSString = "XPathResult"
    @usableFromInline static let XSLTProcessor: JSString = "XSLTProcessor"
    @usableFromInline static let abort: JSString = "abort"
    @usableFromInline static let aborted: JSString = "aborted"
    @usableFromInline static let add: JSString = "add"
    @usableFromInline static let addedNodes: JSString = "addedNodes"
    @usableFromInline static let adoptNode: JSString = "adoptNode"
    @usableFromInline static let after: JSString = "after"
    @usableFromInline static let append: JSString = "append"
    @usableFromInline static let appendChild: JSString = "appendChild"
    @usableFromInline static let appendData: JSString = "appendData"
    @usableFromInline static let assignedSlot: JSString = "assignedSlot"
    @usableFromInline static let attachShadow: JSString = "attachShadow"
    @usableFromInline static let attributeFilter: JSString = "attributeFilter"
    @usableFromInline static let attributeName: JSString = "attributeName"
    @usableFromInline static let attributeNamespace: JSString = "attributeNamespace"
    @usableFromInline static let attributeOldValue: JSString = "attributeOldValue"
    @usableFromInline static let attributes: JSString = "attributes"
    @usableFromInline static let baseURI: JSString = "baseURI"
    @usableFromInline static let before: JSString = "before"
    @usableFromInline static let booleanValue: JSString = "booleanValue"
    @usableFromInline static let bubbles: JSString = "bubbles"
    @usableFromInline static let cancelBubble: JSString = "cancelBubble"
    @usableFromInline static let cancelable: JSString = "cancelable"
    @usableFromInline static let capture: JSString = "capture"
    @usableFromInline static let characterData: JSString = "characterData"
    @usableFromInline static let characterDataOldValue: JSString = "characterDataOldValue"
    @usableFromInline static let characterSet: JSString = "characterSet"
    @usableFromInline static let charset: JSString = "charset"
    @usableFromInline static let childElementCount: JSString = "childElementCount"
    @usableFromInline static let childList: JSString = "childList"
    @usableFromInline static let childNodes: JSString = "childNodes"
    @usableFromInline static let children: JSString = "children"
    @usableFromInline static let classList: JSString = "classList"
    @usableFromInline static let className: JSString = "className"
    @usableFromInline static let clearParameters: JSString = "clearParameters"
    @usableFromInline static let cloneContents: JSString = "cloneContents"
    @usableFromInline static let cloneNode: JSString = "cloneNode"
    @usableFromInline static let cloneRange: JSString = "cloneRange"
    @usableFromInline static let closest: JSString = "closest"
    @usableFromInline static let collapse: JSString = "collapse"
    @usableFromInline static let collapsed: JSString = "collapsed"
    @usableFromInline static let commonAncestorContainer: JSString = "commonAncestorContainer"
    @usableFromInline static let compareBoundaryPoints: JSString = "compareBoundaryPoints"
    @usableFromInline static let compareDocumentPosition: JSString = "compareDocumentPosition"
    @usableFromInline static let comparePoint: JSString = "comparePoint"
    @usableFromInline static let compatMode: JSString = "compatMode"
    @usableFromInline static let composed: JSString = "composed"
    @usableFromInline static let composedPath: JSString = "composedPath"
    @usableFromInline static let contains: JSString = "contains"
    @usableFromInline static let contentType: JSString = "contentType"
    @usableFromInline static let createAttribute: JSString = "createAttribute"
    @usableFromInline static let createAttributeNS: JSString = "createAttributeNS"
    @usableFromInline static let createCDATASection: JSString = "createCDATASection"
    @usableFromInline static let createComment: JSString = "createComment"
    @usableFromInline static let createDocument: JSString = "createDocument"
    @usableFromInline static let createDocumentFragment: JSString = "createDocumentFragment"
    @usableFromInline static let createDocumentType: JSString = "createDocumentType"
    @usableFromInline static let createElement: JSString = "createElement"
    @usableFromInline static let createElementNS: JSString = "createElementNS"
    @usableFromInline static let createEvent: JSString = "createEvent"
    @usableFromInline static let createHTMLDocument: JSString = "createHTMLDocument"
    @usableFromInline static let createProcessingInstruction: JSString = "createProcessingInstruction"
    @usableFromInline static let createRange: JSString = "createRange"
    @usableFromInline static let createTextNode: JSString = "createTextNode"
    @usableFromInline static let currentNode: JSString = "currentNode"
    @usableFromInline static let currentTarget: JSString = "currentTarget"
    @usableFromInline static let data: JSString = "data"
    @usableFromInline static let defaultPrevented: JSString = "defaultPrevented"
    @usableFromInline static let delegatesFocus: JSString = "delegatesFocus"
    @usableFromInline static let deleteContents: JSString = "deleteContents"
    @usableFromInline static let deleteData: JSString = "deleteData"
    @usableFromInline static let detach: JSString = "detach"
    @usableFromInline static let detail: JSString = "detail"
    @usableFromInline static let disconnect: JSString = "disconnect"
    @usableFromInline static let dispatchEvent: JSString = "dispatchEvent"
    @usableFromInline static let doctype: JSString = "doctype"
    @usableFromInline static let documentElement: JSString = "documentElement"
    @usableFromInline static let documentURI: JSString = "documentURI"
    @usableFromInline static let endContainer: JSString = "endContainer"
    @usableFromInline static let endOffset: JSString = "endOffset"
    @usableFromInline static let evaluate: JSString = "evaluate"
    @usableFromInline static let eventPhase: JSString = "eventPhase"
    @usableFromInline static let extractContents: JSString = "extractContents"
    @usableFromInline static let firstChild: JSString = "firstChild"
    @usableFromInline static let firstElementChild: JSString = "firstElementChild"
    @usableFromInline static let getAttribute: JSString = "getAttribute"
    @usableFromInline static let getAttributeNS: JSString = "getAttributeNS"
    @usableFromInline static let getAttributeNames: JSString = "getAttributeNames"
    @usableFromInline static let getAttributeNode: JSString = "getAttributeNode"
    @usableFromInline static let getAttributeNodeNS: JSString = "getAttributeNodeNS"
    @usableFromInline static let getElementById: JSString = "getElementById"
    @usableFromInline static let getElementsByClassName: JSString = "getElementsByClassName"
    @usableFromInline static let getElementsByTagName: JSString = "getElementsByTagName"
    @usableFromInline static let getElementsByTagNameNS: JSString = "getElementsByTagNameNS"
    @usableFromInline static let getNamedItemNS: JSString = "getNamedItemNS"
    @usableFromInline static let getParameter: JSString = "getParameter"
    @usableFromInline static let getRootNode: JSString = "getRootNode"
    @usableFromInline static let hasAttribute: JSString = "hasAttribute"
    @usableFromInline static let hasAttributeNS: JSString = "hasAttributeNS"
    @usableFromInline static let hasAttributes: JSString = "hasAttributes"
    @usableFromInline static let hasChildNodes: JSString = "hasChildNodes"
    @usableFromInline static let hasFeature: JSString = "hasFeature"
    @usableFromInline static let host: JSString = "host"
    @usableFromInline static let id: JSString = "id"
    @usableFromInline static let implementation: JSString = "implementation"
    @usableFromInline static let importNode: JSString = "importNode"
    @usableFromInline static let importStylesheet: JSString = "importStylesheet"
    @usableFromInline static let initCustomEvent: JSString = "initCustomEvent"
    @usableFromInline static let initEvent: JSString = "initEvent"
    @usableFromInline static let inputEncoding: JSString = "inputEncoding"
    @usableFromInline static let insertAdjacentElement: JSString = "insertAdjacentElement"
    @usableFromInline static let insertAdjacentText: JSString = "insertAdjacentText"
    @usableFromInline static let insertBefore: JSString = "insertBefore"
    @usableFromInline static let insertData: JSString = "insertData"
    @usableFromInline static let insertNode: JSString = "insertNode"
    @usableFromInline static let intersectsNode: JSString = "intersectsNode"
    @usableFromInline static let invalidIteratorState: JSString = "invalidIteratorState"
    @usableFromInline static let `is`: JSString = "is"
    @usableFromInline static let isConnected: JSString = "isConnected"
    @usableFromInline static let isDefaultNamespace: JSString = "isDefaultNamespace"
    @usableFromInline static let isEqualNode: JSString = "isEqualNode"
    @usableFromInline static let isPointInRange: JSString = "isPointInRange"
    @usableFromInline static let isSameNode: JSString = "isSameNode"
    @usableFromInline static let isTrusted: JSString = "isTrusted"
    @usableFromInline static let iterateNext: JSString = "iterateNext"
    @usableFromInline static let lastChild: JSString = "lastChild"
    @usableFromInline static let lastElementChild: JSString = "lastElementChild"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let localName: JSString = "localName"
    @usableFromInline static let lookupNamespaceURI: JSString = "lookupNamespaceURI"
    @usableFromInline static let lookupPrefix: JSString = "lookupPrefix"
    @usableFromInline static let matches: JSString = "matches"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let namespaceURI: JSString = "namespaceURI"
    @usableFromInline static let nextElementSibling: JSString = "nextElementSibling"
    @usableFromInline static let nextNode: JSString = "nextNode"
    @usableFromInline static let nextSibling: JSString = "nextSibling"
    @usableFromInline static let nodeName: JSString = "nodeName"
    @usableFromInline static let nodeType: JSString = "nodeType"
    @usableFromInline static let nodeValue: JSString = "nodeValue"
    @usableFromInline static let normalize: JSString = "normalize"
    @usableFromInline static let numberValue: JSString = "numberValue"
    @usableFromInline static let observe: JSString = "observe"
    @usableFromInline static let oldValue: JSString = "oldValue"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let once: JSString = "once"
    @usableFromInline static let onslotchange: JSString = "onslotchange"
    @usableFromInline static let ownerDocument: JSString = "ownerDocument"
    @usableFromInline static let ownerElement: JSString = "ownerElement"
    @usableFromInline static let parentElement: JSString = "parentElement"
    @usableFromInline static let parentNode: JSString = "parentNode"
    @usableFromInline static let passive: JSString = "passive"
    @usableFromInline static let pointerBeforeReferenceNode: JSString = "pointerBeforeReferenceNode"
    @usableFromInline static let prefix: JSString = "prefix"
    @usableFromInline static let prepend: JSString = "prepend"
    @usableFromInline static let preventDefault: JSString = "preventDefault"
    @usableFromInline static let previousElementSibling: JSString = "previousElementSibling"
    @usableFromInline static let previousNode: JSString = "previousNode"
    @usableFromInline static let previousSibling: JSString = "previousSibling"
    @usableFromInline static let publicId: JSString = "publicId"
    @usableFromInline static let querySelector: JSString = "querySelector"
    @usableFromInline static let querySelectorAll: JSString = "querySelectorAll"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let referenceNode: JSString = "referenceNode"
    @usableFromInline static let remove: JSString = "remove"
    @usableFromInline static let removeAttribute: JSString = "removeAttribute"
    @usableFromInline static let removeAttributeNS: JSString = "removeAttributeNS"
    @usableFromInline static let removeAttributeNode: JSString = "removeAttributeNode"
    @usableFromInline static let removeChild: JSString = "removeChild"
    @usableFromInline static let removeNamedItem: JSString = "removeNamedItem"
    @usableFromInline static let removeNamedItemNS: JSString = "removeNamedItemNS"
    @usableFromInline static let removeParameter: JSString = "removeParameter"
    @usableFromInline static let removedNodes: JSString = "removedNodes"
    @usableFromInline static let replace: JSString = "replace"
    @usableFromInline static let replaceChild: JSString = "replaceChild"
    @usableFromInline static let replaceChildren: JSString = "replaceChildren"
    @usableFromInline static let replaceData: JSString = "replaceData"
    @usableFromInline static let replaceWith: JSString = "replaceWith"
    @usableFromInline static let reset: JSString = "reset"
    @usableFromInline static let resultType: JSString = "resultType"
    @usableFromInline static let returnValue: JSString = "returnValue"
    @usableFromInline static let root: JSString = "root"
    @usableFromInline static let selectNode: JSString = "selectNode"
    @usableFromInline static let selectNodeContents: JSString = "selectNodeContents"
    @usableFromInline static let setAttribute: JSString = "setAttribute"
    @usableFromInline static let setAttributeNS: JSString = "setAttributeNS"
    @usableFromInline static let setAttributeNode: JSString = "setAttributeNode"
    @usableFromInline static let setAttributeNodeNS: JSString = "setAttributeNodeNS"
    @usableFromInline static let setEnd: JSString = "setEnd"
    @usableFromInline static let setEndAfter: JSString = "setEndAfter"
    @usableFromInline static let setEndBefore: JSString = "setEndBefore"
    @usableFromInline static let setNamedItem: JSString = "setNamedItem"
    @usableFromInline static let setNamedItemNS: JSString = "setNamedItemNS"
    @usableFromInline static let setParameter: JSString = "setParameter"
    @usableFromInline static let setStart: JSString = "setStart"
    @usableFromInline static let setStartAfter: JSString = "setStartAfter"
    @usableFromInline static let setStartBefore: JSString = "setStartBefore"
    @usableFromInline static let shadowRoot: JSString = "shadowRoot"
    @usableFromInline static let signal: JSString = "signal"
    @usableFromInline static let singleNodeValue: JSString = "singleNodeValue"
    @usableFromInline static let slot: JSString = "slot"
    @usableFromInline static let slotAssignment: JSString = "slotAssignment"
    @usableFromInline static let snapshotItem: JSString = "snapshotItem"
    @usableFromInline static let snapshotLength: JSString = "snapshotLength"
    @usableFromInline static let specified: JSString = "specified"
    @usableFromInline static let splitText: JSString = "splitText"
    @usableFromInline static let srcElement: JSString = "srcElement"
    @usableFromInline static let startContainer: JSString = "startContainer"
    @usableFromInline static let startOffset: JSString = "startOffset"
    @usableFromInline static let stopImmediatePropagation: JSString = "stopImmediatePropagation"
    @usableFromInline static let stopPropagation: JSString = "stopPropagation"
    @usableFromInline static let stringValue: JSString = "stringValue"
    @usableFromInline static let substringData: JSString = "substringData"
    @usableFromInline static let subtree: JSString = "subtree"
    @usableFromInline static let supports: JSString = "supports"
    @usableFromInline static let surroundContents: JSString = "surroundContents"
    @usableFromInline static let systemId: JSString = "systemId"
    @usableFromInline static let tagName: JSString = "tagName"
    @usableFromInline static let takeRecords: JSString = "takeRecords"
    @usableFromInline static let target: JSString = "target"
    @usableFromInline static let textContent: JSString = "textContent"
    @usableFromInline static let throwIfAborted: JSString = "throwIfAborted"
    @usableFromInline static let timeStamp: JSString = "timeStamp"
    @usableFromInline static let timeout: JSString = "timeout"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let toggle: JSString = "toggle"
    @usableFromInline static let toggleAttribute: JSString = "toggleAttribute"
    @usableFromInline static let transformToDocument: JSString = "transformToDocument"
    @usableFromInline static let transformToFragment: JSString = "transformToFragment"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let value: JSString = "value"
    @usableFromInline static let webkitMatchesSelector: JSString = "webkitMatchesSelector"
    @usableFromInline static let whatToShow: JSString = "whatToShow"
    @usableFromInline static let wholeText: JSString = "wholeText"
}

public protocol Any_ElementCreationOptions_or_String: ConvertibleToJSValue {}
extension ElementCreationOptions: Any_ElementCreationOptions_or_String {}
extension String: Any_ElementCreationOptions_or_String {}

public enum ElementCreationOptions_or_String: JSValueCompatible, Any_ElementCreationOptions_or_String {
    case elementCreationOptions(ElementCreationOptions)
    case string(String)

    var elementCreationOptions: ElementCreationOptions? {
        switch self {
        case let .elementCreationOptions(elementCreationOptions): return elementCreationOptions
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let elementCreationOptions: ElementCreationOptions = value.fromJSValue() {
            return .elementCreationOptions(elementCreationOptions)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .elementCreationOptions(elementCreationOptions):
            return elementCreationOptions.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Node_or_String: ConvertibleToJSValue {}
extension Node: Any_Node_or_String {}
extension String: Any_Node_or_String {}

public enum Node_or_String: JSValueCompatible, Any_Node_or_String {
    case node(Node)
    case string(String)

    var node: Node? {
        switch self {
        case let .node(node): return node
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let node: Node = value.fromJSValue() {
            return .node(node)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .node(node):
            return node.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}
