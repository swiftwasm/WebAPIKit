// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public class Cache: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.Cache].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.matchAll].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Response] {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.matchAll].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func add(request: RequestInfo) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.add].function!(this: this, arguments: [request.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func add(request: RequestInfo) async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.add].function!(this: this, arguments: [request.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func addAll(requests: [RequestInfo]) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.addAll].function!(this: this, arguments: [requests.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addAll(requests: [RequestInfo]) async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.addAll].function!(this: this, arguments: [requests.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func put(request: RequestInfo, response: Response) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.put].function!(this: this, arguments: [request.jsValue, response.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func put(request: RequestInfo, response: Response) async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.put].function!(this: this, arguments: [request.jsValue, response.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.delete].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.delete].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.keys].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Request] {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.keys].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class CacheQueryOptions: BridgedDictionary {
    public convenience init(ignoreSearch: Bool, ignoreMethod: Bool, ignoreVary: Bool) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.ignoreSearch] = ignoreSearch.jsValue
        object[ServiceWorkerStrings.ignoreMethod] = ignoreMethod.jsValue
        object[ServiceWorkerStrings.ignoreVary] = ignoreVary.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _ignoreSearch = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.ignoreSearch)
        _ignoreMethod = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.ignoreMethod)
        _ignoreVary = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.ignoreVary)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var ignoreSearch: Bool

    @ReadWriteAttribute
    public var ignoreMethod: Bool

    @ReadWriteAttribute
    public var ignoreVary: Bool
}

public class CacheStorage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.CacheStorage].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func has(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.has].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func has(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.has].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func open(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.open].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func open(cacheName: String) async throws -> Cache {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.open].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func delete(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.delete].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.delete].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.keys].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys() async throws -> [String] {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.keys].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class ClientQueryOptions: BridgedDictionary {
    public convenience init(includeUncontrolled: Bool, type: ClientType) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.includeUncontrolled] = includeUncontrolled.jsValue
        object[ServiceWorkerStrings.type] = type.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _includeUncontrolled = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.includeUncontrolled)
        _type = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var includeUncontrolled: Bool

    @ReadWriteAttribute
    public var type: ClientType
}

public enum ClientType: JSString, JSValueCompatible {
    case window = "window"
    case worker = "worker"
    case sharedworker = "sharedworker"
    case all = "all"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ExtendableEventInit: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class FetchEventInit: BridgedDictionary {
    public convenience init(request: Request, preloadResponse: JSPromise, clientId: String, resultingClientId: String, replacesClientId: String, handled: JSPromise) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.request] = request.jsValue
        object[ServiceWorkerStrings.preloadResponse] = preloadResponse.jsValue
        object[ServiceWorkerStrings.clientId] = clientId.jsValue
        object[ServiceWorkerStrings.resultingClientId] = resultingClientId.jsValue
        object[ServiceWorkerStrings.replacesClientId] = replacesClientId.jsValue
        object[ServiceWorkerStrings.handled] = handled.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _request = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.request)
        _preloadResponse = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.preloadResponse)
        _clientId = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.clientId)
        _resultingClientId = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.resultingClientId)
        _replacesClientId = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.replacesClientId)
        _handled = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.handled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var request: Request

    @ReadWriteAttribute
    public var preloadResponse: JSPromise

    @ReadWriteAttribute
    public var clientId: String

    @ReadWriteAttribute
    public var resultingClientId: String

    @ReadWriteAttribute
    public var replacesClientId: String

    @ReadWriteAttribute
    public var handled: JSPromise
}

public enum FrameType: JSString, JSValueCompatible {
    case auxiliary = "auxiliary"
    case topLevel = "top-level"
    case nested = "nested"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class MultiCacheQueryOptions: BridgedDictionary {
    public convenience init(cacheName: String) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.cacheName] = cacheName.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _cacheName = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.cacheName)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var cacheName: String
}

public class NavigationPreloadManager: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.NavigationPreloadManager].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func enable() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.enable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func enable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.enable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func disable() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.disable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func disable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.disable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func setHeaderValue(value: String) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.setHeaderValue].function!(this: this, arguments: [value.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func setHeaderValue(value: String) async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.setHeaderValue].function!(this: this, arguments: [value.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getState() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getState() async throws -> NavigationPreloadState {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.getState].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class NavigationPreloadState: BridgedDictionary {
    public convenience init(enabled: Bool, headerValue: String) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.enabled] = enabled.jsValue
        object[ServiceWorkerStrings.headerValue] = headerValue.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _enabled = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.enabled)
        _headerValue = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.headerValue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadWriteAttribute
    public var headerValue: String
}

public class RegistrationOptions: BridgedDictionary {
    public convenience init(scope: String, type: WorkerType, updateViaCache: ServiceWorkerUpdateViaCache) {
        let object = JSObject.global[ServiceWorkerStrings.Object].function!.new()
        object[ServiceWorkerStrings.scope] = scope.jsValue
        object[ServiceWorkerStrings.type] = type.jsValue
        object[ServiceWorkerStrings.updateViaCache] = updateViaCache.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _scope = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.scope)
        _type = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.type)
        _updateViaCache = ReadWriteAttribute(jsObject: object, name: ServiceWorkerStrings.updateViaCache)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache
}

public class ServiceWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.ServiceWorker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _scriptURL = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.scriptURL)
        _state = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.state)
        _onstatechange = ReadWriteAttribute(jsObject: jsObject, name: ServiceWorkerStrings.onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var scriptURL: String

    @ReadonlyAttribute
    public var state: ServiceWorkerState

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[ServiceWorkerStrings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[ServiceWorkerStrings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @ReadWriteAttribute
    public var onstatechange: EventHandler
}

public class ServiceWorkerContainer: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.ServiceWorkerContainer].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _controller = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.controller)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.ready)
        _oncontrollerchange = ReadWriteAttribute(jsObject: jsObject, name: ServiceWorkerStrings.oncontrollerchange)
        _onmessage = ReadWriteAttribute(jsObject: jsObject, name: ServiceWorkerStrings.onmessage)
        _onmessageerror = ReadWriteAttribute(jsObject: jsObject, name: ServiceWorkerStrings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var controller: ServiceWorker?

    @ReadonlyAttribute
    public var ready: JSPromise

    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.register].function!(this: this, arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) async throws -> ServiceWorkerRegistration {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.register].function!(this: this, arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistration(clientURL: String? = nil) -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.getRegistration].function!(this: this, arguments: [clientURL?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistration(clientURL: String? = nil) async throws -> ServiceWorkerRegistration? {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.getRegistration].function!(this: this, arguments: [clientURL?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistrations() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistrations() async throws -> [ServiceWorkerRegistration] {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func startMessages() {
        let this = jsObject
        _ = this[ServiceWorkerStrings.startMessages].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var oncontrollerchange: EventHandler

    @ReadWriteAttribute
    public var onmessage: EventHandler

    @ReadWriteAttribute
    public var onmessageerror: EventHandler
}

public class ServiceWorkerRegistration: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[ServiceWorkerStrings.ServiceWorkerRegistration].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _installing = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.installing)
        _waiting = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.waiting)
        _active = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.active)
        _navigationPreload = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.navigationPreload)
        _scope = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.scope)
        _updateViaCache = ReadonlyAttribute(jsObject: jsObject, name: ServiceWorkerStrings.updateViaCache)
        _onupdatefound = ReadWriteAttribute(jsObject: jsObject, name: ServiceWorkerStrings.onupdatefound)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var installing: ServiceWorker?

    @ReadonlyAttribute
    public var waiting: ServiceWorker?

    @ReadonlyAttribute
    public var active: ServiceWorker?

    @ReadonlyAttribute
    public var navigationPreload: NavigationPreloadManager

    @ReadonlyAttribute
    public var scope: String

    @ReadonlyAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache

    @inlinable public func update() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.update].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func update() async throws {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.update].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func unregister() -> JSPromise {
        let this = jsObject
        return this[ServiceWorkerStrings.unregister].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func unregister() async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[ServiceWorkerStrings.unregister].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ReadWriteAttribute
    public var onupdatefound: EventHandler
}

public enum ServiceWorkerState: JSString, JSValueCompatible {
    case parsed = "parsed"
    case installing = "installing"
    case installed = "installed"
    case activating = "activating"
    case activated = "activated"
    case redundant = "redundant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ServiceWorkerUpdateViaCache: JSString, JSValueCompatible {
    case imports = "imports"
    case all = "all"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public extension WindowOrWorkerGlobalScope {
    @inlinable var caches: CacheStorage { ReadonlyAttribute[ServiceWorkerStrings.caches, in: jsObject] }
}

/* variadic generics please */

@usableFromInline enum ServiceWorkerStrings {
    static let _self: JSString = "self"
    @usableFromInline static let Cache: JSString = "Cache"
    @usableFromInline static let CacheStorage: JSString = "CacheStorage"
    @usableFromInline static let NavigationPreloadManager: JSString = "NavigationPreloadManager"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let ServiceWorker: JSString = "ServiceWorker"
    @usableFromInline static let ServiceWorkerContainer: JSString = "ServiceWorkerContainer"
    @usableFromInline static let ServiceWorkerRegistration: JSString = "ServiceWorkerRegistration"
    @usableFromInline static let active: JSString = "active"
    @usableFromInline static let add: JSString = "add"
    @usableFromInline static let addAll: JSString = "addAll"
    @usableFromInline static let cacheName: JSString = "cacheName"
    @usableFromInline static let caches: JSString = "caches"
    @usableFromInline static let clientId: JSString = "clientId"
    @usableFromInline static let controller: JSString = "controller"
    @usableFromInline static let delete: JSString = "delete"
    @usableFromInline static let disable: JSString = "disable"
    @usableFromInline static let enable: JSString = "enable"
    @usableFromInline static let enabled: JSString = "enabled"
    @usableFromInline static let getRegistration: JSString = "getRegistration"
    @usableFromInline static let getRegistrations: JSString = "getRegistrations"
    @usableFromInline static let getState: JSString = "getState"
    @usableFromInline static let handled: JSString = "handled"
    @usableFromInline static let has: JSString = "has"
    @usableFromInline static let headerValue: JSString = "headerValue"
    @usableFromInline static let ignoreMethod: JSString = "ignoreMethod"
    @usableFromInline static let ignoreSearch: JSString = "ignoreSearch"
    @usableFromInline static let ignoreVary: JSString = "ignoreVary"
    @usableFromInline static let includeUncontrolled: JSString = "includeUncontrolled"
    @usableFromInline static let installing: JSString = "installing"
    @usableFromInline static let keys: JSString = "keys"
    @usableFromInline static let match: JSString = "match"
    @usableFromInline static let matchAll: JSString = "matchAll"
    @usableFromInline static let navigationPreload: JSString = "navigationPreload"
    @usableFromInline static let oncontrollerchange: JSString = "oncontrollerchange"
    @usableFromInline static let onmessage: JSString = "onmessage"
    @usableFromInline static let onmessageerror: JSString = "onmessageerror"
    @usableFromInline static let onstatechange: JSString = "onstatechange"
    @usableFromInline static let onupdatefound: JSString = "onupdatefound"
    @usableFromInline static let open: JSString = "open"
    @usableFromInline static let postMessage: JSString = "postMessage"
    @usableFromInline static let preloadResponse: JSString = "preloadResponse"
    @usableFromInline static let put: JSString = "put"
    @usableFromInline static let ready: JSString = "ready"
    @usableFromInline static let register: JSString = "register"
    @usableFromInline static let replacesClientId: JSString = "replacesClientId"
    @usableFromInline static let request: JSString = "request"
    @usableFromInline static let resultingClientId: JSString = "resultingClientId"
    @usableFromInline static let scope: JSString = "scope"
    @usableFromInline static let scriptURL: JSString = "scriptURL"
    @usableFromInline static let setHeaderValue: JSString = "setHeaderValue"
    @usableFromInline static let startMessages: JSString = "startMessages"
    @usableFromInline static let state: JSString = "state"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let unregister: JSString = "unregister"
    @usableFromInline static let update: JSString = "update"
    @usableFromInline static let updateViaCache: JSString = "updateViaCache"
    @usableFromInline static let waiting: JSString = "waiting"
}
