// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public enum BinaryType: JSString, JSValueCompatible {
    case blob = "blob"
    case arraybuffer = "arraybuffer"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CloseEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.CloseEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wasClean = ReadonlyAttribute(jsObject: jsObject, name: Strings.wasClean)
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CloseEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var wasClean: Bool

    @ReadonlyAttribute
    public var code: UInt16

    @ReadonlyAttribute
    public var reason: String
}

public class CloseEventInit: BridgedDictionary {
    public convenience init(wasClean: Bool, code: UInt16, reason: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.wasClean] = _toJSValue(wasClean)
        object[Strings.code] = _toJSValue(code)
        object[Strings.reason] = _toJSValue(reason)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _wasClean = ReadWriteAttribute(jsObject: object, name: Strings.wasClean)
        _code = ReadWriteAttribute(jsObject: object, name: Strings.code)
        _reason = ReadWriteAttribute(jsObject: object, name: Strings.reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var wasClean: Bool

    @ReadWriteAttribute
    public var code: UInt16

    @ReadWriteAttribute
    public var reason: String
}

public class WebSocket: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebSocket].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _bufferedAmount = ReadonlyAttribute(jsObject: jsObject, name: Strings.bufferedAmount)
        _onopen = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onopen)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        _onclose = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onclose)
        _extensions = ReadonlyAttribute(jsObject: jsObject, name: Strings.extensions)
        _protocol = ReadonlyAttribute(jsObject: jsObject, name: Strings.protocol)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _binaryType = ReadWriteAttribute(jsObject: jsObject, name: Strings.binaryType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(url: String, protocols: String_or_seq_of_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(url), _toJSValue(protocols)]))
    }

    @ReadonlyAttribute
    public var url: String

    public static let CONNECTING: UInt16 = 0

    public static let OPEN: UInt16 = 1

    public static let CLOSING: UInt16 = 2

    public static let CLOSED: UInt16 = 3

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var bufferedAmount: UInt64

    @ClosureAttribute1Optional
    public var onopen: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onclose: EventHandler

    @ReadonlyAttribute
    public var extensions: String

    @ReadonlyAttribute
    public var `protocol`: String

    @inlinable public func close(code: UInt16? = nil, reason: String? = nil) {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [_toJSValue(code), _toJSValue(reason)])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ReadWriteAttribute
    public var binaryType: BinaryType

    @inlinable public func send(data: Blob_or_BufferSource_or_String) {
        let this = jsObject
        _ = this[Strings.send].function!(this: this, arguments: [_toJSValue(data)])
    }
}

@usableFromInline enum Strings {
    @usableFromInline static let _self: JSString = "self"
    @usableFromInline static let CloseEvent: JSString = "CloseEvent"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let WebSocket: JSString = "WebSocket"
    @usableFromInline static let binaryType: JSString = "binaryType"
    @usableFromInline static let bufferedAmount: JSString = "bufferedAmount"
    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let extensions: JSString = "extensions"
    @usableFromInline static let onclose: JSString = "onclose"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onmessage: JSString = "onmessage"
    @usableFromInline static let onopen: JSString = "onopen"
    @usableFromInline static let `protocol`: JSString = "protocol"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let send: JSString = "send"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let url: JSString = "url"
    @usableFromInline static let wasClean: JSString = "wasClean"
}

public protocol Any_Blob_or_BufferSource_or_String: ConvertibleToJSValue {}
extension Blob: Any_Blob_or_BufferSource_or_String {}
extension BufferSource: Any_Blob_or_BufferSource_or_String {}
extension String: Any_Blob_or_BufferSource_or_String {}

public enum Blob_or_BufferSource_or_String: JSValueCompatible, Any_Blob_or_BufferSource_or_String {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    init(_ blob: Blob) {
        let val: Blob_or_BufferSource_or_String = .blob(blob)
        self = val
    }

    init(_ bufferSource: BufferSource) {
        let val: Blob_or_BufferSource_or_String = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ string: String) {
        let val: Blob_or_BufferSource_or_String = .string(string)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    init(_ string: String) {
        let val: String_or_seq_of_String = .string(string)
        self = val
    }

    init(_ seq_of_String: [String]) {
        let val: String_or_seq_of_String = .seq_of_String(seq_of_String)
        self = val
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}
