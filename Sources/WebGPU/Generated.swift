// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAnimations
import WebAPIBase
import WebAudio
import WebGL1

public class GPU: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPU].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wgslLanguageFeatures = ReadonlyAttribute(jsObject: jsObject, name: Strings.wgslLanguageFeatures)
        self.jsObject = jsObject
    }

    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) async throws -> GPUAdapter? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @inlinable public func getPreferredCanvasFormat() -> GPUTextureFormat {
        let this = jsObject
        return this[Strings.getPreferredCanvasFormat].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var wgslLanguageFeatures: WGSLLanguageFeatures
}

public class GPUAdapter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUAdapter].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _features = ReadonlyAttribute(jsObject: jsObject, name: Strings.features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: Strings.limits)
        _isFallbackAdapter = ReadonlyAttribute(jsObject: jsObject, name: Strings.isFallbackAdapter)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var isFallbackAdapter: Bool

    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) async throws -> GPUDevice {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) async throws -> GPUAdapterInfo {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUAdapterInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUAdapterInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _vendor = ReadonlyAttribute(jsObject: jsObject, name: Strings.vendor)
        _architecture = ReadonlyAttribute(jsObject: jsObject, name: Strings.architecture)
        _device = ReadonlyAttribute(jsObject: jsObject, name: Strings.device)
        _description = ReadonlyAttribute(jsObject: jsObject, name: Strings.description)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var vendor: String

    @ReadonlyAttribute
    public var architecture: String

    @ReadonlyAttribute
    public var device: String

    @ReadonlyAttribute
    public var description: String
}

public enum GPUAddressMode: JSString, JSValueCompatible {
    case clampToEdge = "clamp-to-edge"
    case `repeat` = "repeat"
    case mirrorRepeat = "mirror-repeat"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUAutoLayoutMode: JSString, JSValueCompatible {
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBindGroup: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBindGroup].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupDescriptor: BridgedDictionary {
    public convenience init(layout: GPUBindGroupLayout, entries: [GPUBindGroupEntry]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        _entries = ReadWriteAttribute(jsObject: object, name: Strings.entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUBindGroupLayout

    @ReadWriteAttribute
    public var entries: [GPUBindGroupEntry]
}

public class GPUBindGroupEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, resource: GPUBindingResource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = _toJSValue(binding)
        object[Strings.resource] = _toJSValue(resource)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: Strings.binding)
        _resource = ReadWriteAttribute(jsObject: object, name: Strings.resource)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var resource: GPUBindingResource
}

public class GPUBindGroupLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBindGroupLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupLayoutDescriptor: BridgedDictionary {
    public convenience init(entries: [GPUBindGroupLayoutEntry]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _entries = ReadWriteAttribute(jsObject: object, name: Strings.entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var entries: [GPUBindGroupLayoutEntry]
}

public class GPUBindGroupLayoutEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, visibility: GPUShaderStageFlags, buffer: GPUBufferBindingLayout, sampler: GPUSamplerBindingLayout, texture: GPUTextureBindingLayout, storageTexture: GPUStorageTextureBindingLayout, externalTexture: GPUExternalTextureBindingLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = _toJSValue(binding)
        object[Strings.visibility] = _toJSValue(visibility)
        object[Strings.buffer] = _toJSValue(buffer)
        object[Strings.sampler] = _toJSValue(sampler)
        object[Strings.texture] = _toJSValue(texture)
        object[Strings.storageTexture] = _toJSValue(storageTexture)
        object[Strings.externalTexture] = _toJSValue(externalTexture)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: Strings.binding)
        _visibility = ReadWriteAttribute(jsObject: object, name: Strings.visibility)
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _sampler = ReadWriteAttribute(jsObject: object, name: Strings.sampler)
        _texture = ReadWriteAttribute(jsObject: object, name: Strings.texture)
        _storageTexture = ReadWriteAttribute(jsObject: object, name: Strings.storageTexture)
        _externalTexture = ReadWriteAttribute(jsObject: object, name: Strings.externalTexture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var visibility: GPUShaderStageFlags

    @ReadWriteAttribute
    public var buffer: GPUBufferBindingLayout

    @ReadWriteAttribute
    public var sampler: GPUSamplerBindingLayout

    @ReadWriteAttribute
    public var texture: GPUTextureBindingLayout

    @ReadWriteAttribute
    public var storageTexture: GPUStorageTextureBindingLayout

    @ReadWriteAttribute
    public var externalTexture: GPUExternalTextureBindingLayout
}

public protocol GPUBindingCommandsMixin: JSBridgedClass {}
public extension GPUBindingCommandsMixin {
    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsets: [GPUBufferDynamicOffset]? = nil) {
        let this = jsObject
        _ = this[Strings.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsets)])
    }

    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32) {
        let this = jsObject
        _ = this[Strings.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsetsData), _toJSValue(dynamicOffsetsDataStart), _toJSValue(dynamicOffsetsDataLength)])
    }
}

public class GPUBlendComponent: BridgedDictionary {
    public convenience init(operation: GPUBlendOperation, srcFactor: GPUBlendFactor, dstFactor: GPUBlendFactor) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.operation] = _toJSValue(operation)
        object[Strings.srcFactor] = _toJSValue(srcFactor)
        object[Strings.dstFactor] = _toJSValue(dstFactor)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _operation = ReadWriteAttribute(jsObject: object, name: Strings.operation)
        _srcFactor = ReadWriteAttribute(jsObject: object, name: Strings.srcFactor)
        _dstFactor = ReadWriteAttribute(jsObject: object, name: Strings.dstFactor)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var operation: GPUBlendOperation

    @ReadWriteAttribute
    public var srcFactor: GPUBlendFactor

    @ReadWriteAttribute
    public var dstFactor: GPUBlendFactor
}

public enum GPUBlendFactor: JSString, JSValueCompatible {
    case zero = "zero"
    case one = "one"
    case src = "src"
    case oneMinusSrc = "one-minus-src"
    case srcAlpha = "src-alpha"
    case oneMinusSrcAlpha = "one-minus-src-alpha"
    case dst = "dst"
    case oneMinusDst = "one-minus-dst"
    case dstAlpha = "dst-alpha"
    case oneMinusDstAlpha = "one-minus-dst-alpha"
    case srcAlphaSaturated = "src-alpha-saturated"
    case constant = "constant"
    case oneMinusConstant = "one-minus-constant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBlendOperation: JSString, JSValueCompatible {
    case add = "add"
    case subtract = "subtract"
    case reverseSubtract = "reverse-subtract"
    case min = "min"
    case max = "max"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBlendState: BridgedDictionary {
    public convenience init(color: GPUBlendComponent, alpha: GPUBlendComponent) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.color] = _toJSValue(color)
        object[Strings.alpha] = _toJSValue(alpha)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _color = ReadWriteAttribute(jsObject: object, name: Strings.color)
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var color: GPUBlendComponent

    @ReadWriteAttribute
    public var alpha: GPUBlendComponent
}

public class GPUBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _usage = ReadonlyAttribute(jsObject: jsObject, name: Strings.usage)
        _mapState = ReadonlyAttribute(jsObject: jsObject, name: Strings.mapState)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var size: GPUSize64Out

    @ReadonlyAttribute
    public var usage: GPUFlagsConstant

    @ReadonlyAttribute
    public var mapState: GPUBufferMapState

    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getMappedRange(offset: GPUSize64? = nil, size: GPUSize64? = nil) -> ArrayBuffer {
        let this = jsObject
        return this[Strings.getMappedRange].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @inlinable public func unmap() {
        let this = jsObject
        _ = this[Strings.unmap].function!(this: this, arguments: [])
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }
}

public class GPUBufferBinding: BridgedDictionary {
    public convenience init(buffer: GPUBuffer, offset: GPUSize64, size: GPUSize64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = _toJSValue(buffer)
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.size] = _toJSValue(size)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var size: GPUSize64
}

public class GPUBufferBindingLayout: BridgedDictionary {
    public convenience init(type: GPUBufferBindingType, hasDynamicOffset: Bool, minBindingSize: GPUSize64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.hasDynamicOffset] = _toJSValue(hasDynamicOffset)
        object[Strings.minBindingSize] = _toJSValue(minBindingSize)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _hasDynamicOffset = ReadWriteAttribute(jsObject: object, name: Strings.hasDynamicOffset)
        _minBindingSize = ReadWriteAttribute(jsObject: object, name: Strings.minBindingSize)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUBufferBindingType

    @ReadWriteAttribute
    public var hasDynamicOffset: Bool

    @ReadWriteAttribute
    public var minBindingSize: GPUSize64
}

public enum GPUBufferBindingType: JSString, JSValueCompatible {
    case uniform = "uniform"
    case storage = "storage"
    case readOnlyStorage = "read-only-storage"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBufferDescriptor: BridgedDictionary {
    public convenience init(size: GPUSize64, usage: GPUBufferUsageFlags, mappedAtCreation: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.size] = _toJSValue(size)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.mappedAtCreation] = _toJSValue(mappedAtCreation)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _mappedAtCreation = ReadWriteAttribute(jsObject: object, name: Strings.mappedAtCreation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUSize64

    @ReadWriteAttribute
    public var usage: GPUBufferUsageFlags

    @ReadWriteAttribute
    public var mappedAtCreation: Bool
}

public enum GPUBufferMapState: JSString, JSValueCompatible {
    case unmapped = "unmapped"
    case pending = "pending"
    case mapped = "mapped"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBufferUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUBufferUsage].object!
    }

    public static let MAP_READ: GPUFlagsConstant = 0x0001

    public static let MAP_WRITE: GPUFlagsConstant = 0x0002

    public static let COPY_SRC: GPUFlagsConstant = 0x0004

    public static let COPY_DST: GPUFlagsConstant = 0x0008

    public static let INDEX: GPUFlagsConstant = 0x0010

    public static let VERTEX: GPUFlagsConstant = 0x0020

    public static let UNIFORM: GPUFlagsConstant = 0x0040

    public static let STORAGE: GPUFlagsConstant = 0x0080

    public static let INDIRECT: GPUFlagsConstant = 0x0100

    public static let QUERY_RESOLVE: GPUFlagsConstant = 0x0200
}

public enum GPUCanvasAlphaMode: JSString, JSValueCompatible {
    case opaque = "opaque"
    case premultiplied = "premultiplied"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCanvasConfiguration: BridgedDictionary {
    public convenience init(device: GPUDevice, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat], colorSpace: PredefinedColorSpace, alphaMode: GPUCanvasAlphaMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.device] = _toJSValue(device)
        object[Strings.format] = _toJSValue(format)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.viewFormats] = _toJSValue(viewFormats)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.alphaMode] = _toJSValue(alphaMode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _device = ReadWriteAttribute(jsObject: object, name: Strings.device)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: Strings.viewFormats)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _alphaMode = ReadWriteAttribute(jsObject: object, name: Strings.alphaMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var device: GPUDevice

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var alphaMode: GPUCanvasAlphaMode
}

public class GPUCanvasContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCanvasContext].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: Strings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement_or_OffscreenCanvas

    @inlinable public func configure(configuration: GPUCanvasConfiguration) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(configuration)])
    }

    @inlinable public func unconfigure() {
        let this = jsObject
        _ = this[Strings.unconfigure].function!(this: this, arguments: [])
    }

    @inlinable public func getCurrentTexture() -> GPUTexture {
        let this = jsObject
        return this[Strings.getCurrentTexture].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class GPUColorDict: BridgedDictionary {
    public convenience init(r: Double, g: Double, b: Double, a: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.r] = _toJSValue(r)
        object[Strings.g] = _toJSValue(g)
        object[Strings.b] = _toJSValue(b)
        object[Strings.a] = _toJSValue(a)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _r = ReadWriteAttribute(jsObject: object, name: Strings.r)
        _g = ReadWriteAttribute(jsObject: object, name: Strings.g)
        _b = ReadWriteAttribute(jsObject: object, name: Strings.b)
        _a = ReadWriteAttribute(jsObject: object, name: Strings.a)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var r: Double

    @ReadWriteAttribute
    public var g: Double

    @ReadWriteAttribute
    public var b: Double

    @ReadWriteAttribute
    public var a: Double
}

public class GPUColorTargetState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, blend: GPUBlendState, writeMask: GPUColorWriteFlags) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.blend] = _toJSValue(blend)
        object[Strings.writeMask] = _toJSValue(writeMask)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _blend = ReadWriteAttribute(jsObject: object, name: Strings.blend)
        _writeMask = ReadWriteAttribute(jsObject: object, name: Strings.writeMask)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var blend: GPUBlendState

    @ReadWriteAttribute
    public var writeMask: GPUColorWriteFlags
}

public enum GPUColorWrite {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUColorWrite].object!
    }

    public static let RED: GPUFlagsConstant = 0x1

    public static let GREEN: GPUFlagsConstant = 0x2

    public static let BLUE: GPUFlagsConstant = 0x4

    public static let ALPHA: GPUFlagsConstant = 0x8

    public static let ALL: GPUFlagsConstant = 0xF
}

public class GPUCommandBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCommandBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUCommandBufferDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUCommandEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCommandEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func beginRenderPass(descriptor: GPURenderPassDescriptor) -> GPURenderPassEncoder {
        let this = jsObject
        return this[Strings.beginRenderPass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func beginComputePass(descriptor: GPUComputePassDescriptor? = nil) -> GPUComputePassEncoder {
        let this = jsObject
        return this[Strings.beginComputePass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func copyBufferToBuffer(source: GPUBuffer, sourceOffset: GPUSize64, destination: GPUBuffer, destinationOffset: GPUSize64, size: GPUSize64) {
        let this = jsObject
        _ = this[Strings.copyBufferToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(sourceOffset), _toJSValue(destination), _toJSValue(destinationOffset), _toJSValue(size)])
    }

    @inlinable public func copyBufferToTexture(source: GPUImageCopyBuffer, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyBufferToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToBuffer(source: GPUImageCopyTexture, destination: GPUImageCopyBuffer, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyTextureToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToTexture(source: GPUImageCopyTexture, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyTextureToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func clearBuffer(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.clearBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable public func writeTimestamp(querySet: GPUQuerySet, queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[Strings.writeTimestamp].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(queryIndex)])
    }

    @inlinable public func resolveQuerySet(querySet: GPUQuerySet, firstQuery: GPUSize32, queryCount: GPUSize32, destination: GPUBuffer, destinationOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.resolveQuerySet].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(firstQuery), _toJSValue(queryCount), _toJSValue(destination), _toJSValue(destinationOffset)])
    }

    @inlinable public func finish(descriptor: GPUCommandBufferDescriptor? = nil) -> GPUCommandBuffer {
        let this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPUCommandEncoderDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public protocol GPUCommandsMixin: JSBridgedClass {}
public extension GPUCommandsMixin {}

public enum GPUCompareFunction: JSString, JSValueCompatible {
    case never = "never"
    case less = "less"
    case equal = "equal"
    case lessEqual = "less-equal"
    case greater = "greater"
    case notEqual = "not-equal"
    case greaterEqual = "greater-equal"
    case always = "always"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCompilationInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCompilationInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _messages = ReadonlyAttribute(jsObject: jsObject, name: Strings.messages)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var messages: [GPUCompilationMessage]
}

public class GPUCompilationMessage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCompilationMessage].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _lineNum = ReadonlyAttribute(jsObject: jsObject, name: Strings.lineNum)
        _linePos = ReadonlyAttribute(jsObject: jsObject, name: Strings.linePos)
        _offset = ReadonlyAttribute(jsObject: jsObject, name: Strings.offset)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var type: GPUCompilationMessageType

    @ReadonlyAttribute
    public var lineNum: UInt64

    @ReadonlyAttribute
    public var linePos: UInt64

    @ReadonlyAttribute
    public var offset: UInt64

    @ReadonlyAttribute
    public var length: UInt64
}

public enum GPUCompilationMessageType: JSString, JSValueCompatible {
    case error = "error"
    case warning = "warning"
    case info = "info"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUComputePassDescriptor: BridgedDictionary {
    public convenience init(timestampWrites: GPUComputePassTimestampWrites) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.timestampWrites] = _toJSValue(timestampWrites)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: Strings.timestampWrites)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var timestampWrites: GPUComputePassTimestampWrites
}

public class GPUComputePassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUComputePassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setPipeline(pipeline: GPUComputePipeline) {
        let this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable public func dispatchWorkgroups(workgroupCountX: GPUSize32, workgroupCountY: GPUSize32? = nil, workgroupCountZ: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.dispatchWorkgroups].function!(this: this, arguments: [_toJSValue(workgroupCountX), _toJSValue(workgroupCountY), _toJSValue(workgroupCountZ)])
    }

    @inlinable public func dispatchWorkgroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.dispatchWorkgroupsIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

public class GPUComputePassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = _toJSValue(querySet)
        object[Strings.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[Strings.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: Strings.querySet)
        _beginningOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: Strings.beginningOfPassWriteIndex)
        _endOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: Strings.endOfPassWriteIndex)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var beginningOfPassWriteIndex: GPUSize32

    @ReadWriteAttribute
    public var endOfPassWriteIndex: GPUSize32
}

public class GPUComputePipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUComputePipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUComputePipelineDescriptor: BridgedDictionary {
    public convenience init(compute: GPUProgrammableStage) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.compute] = _toJSValue(compute)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compute = ReadWriteAttribute(jsObject: object, name: Strings.compute)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compute: GPUProgrammableStage
}

public enum GPUCullMode: JSString, JSValueCompatible {
    case none = "none"
    case front = "front"
    case back = "back"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GPUDebugCommandsMixin: JSBridgedClass {}
public extension GPUDebugCommandsMixin {
    @inlinable func pushDebugGroup(groupLabel: String) {
        let this = jsObject
        _ = this[Strings.pushDebugGroup].function!(this: this, arguments: [_toJSValue(groupLabel)])
    }

    @inlinable func popDebugGroup() {
        let this = jsObject
        _ = this[Strings.popDebugGroup].function!(this: this, arguments: [])
    }

    @inlinable func insertDebugMarker(markerLabel: String) {
        let this = jsObject
        _ = this[Strings.insertDebugMarker].function!(this: this, arguments: [_toJSValue(markerLabel)])
    }
}

public class GPUDepthStencilState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, depthWriteEnabled: Bool, depthCompare: GPUCompareFunction, stencilFront: GPUStencilFaceState, stencilBack: GPUStencilFaceState, stencilReadMask: GPUStencilValue, stencilWriteMask: GPUStencilValue, depthBias: GPUDepthBias, depthBiasSlopeScale: Float, depthBiasClamp: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.depthWriteEnabled] = _toJSValue(depthWriteEnabled)
        object[Strings.depthCompare] = _toJSValue(depthCompare)
        object[Strings.stencilFront] = _toJSValue(stencilFront)
        object[Strings.stencilBack] = _toJSValue(stencilBack)
        object[Strings.stencilReadMask] = _toJSValue(stencilReadMask)
        object[Strings.stencilWriteMask] = _toJSValue(stencilWriteMask)
        object[Strings.depthBias] = _toJSValue(depthBias)
        object[Strings.depthBiasSlopeScale] = _toJSValue(depthBiasSlopeScale)
        object[Strings.depthBiasClamp] = _toJSValue(depthBiasClamp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _depthWriteEnabled = ReadWriteAttribute(jsObject: object, name: Strings.depthWriteEnabled)
        _depthCompare = ReadWriteAttribute(jsObject: object, name: Strings.depthCompare)
        _stencilFront = ReadWriteAttribute(jsObject: object, name: Strings.stencilFront)
        _stencilBack = ReadWriteAttribute(jsObject: object, name: Strings.stencilBack)
        _stencilReadMask = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadMask)
        _stencilWriteMask = ReadWriteAttribute(jsObject: object, name: Strings.stencilWriteMask)
        _depthBias = ReadWriteAttribute(jsObject: object, name: Strings.depthBias)
        _depthBiasSlopeScale = ReadWriteAttribute(jsObject: object, name: Strings.depthBiasSlopeScale)
        _depthBiasClamp = ReadWriteAttribute(jsObject: object, name: Strings.depthBiasClamp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var depthWriteEnabled: Bool

    @ReadWriteAttribute
    public var depthCompare: GPUCompareFunction

    @ReadWriteAttribute
    public var stencilFront: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilBack: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilReadMask: GPUStencilValue

    @ReadWriteAttribute
    public var stencilWriteMask: GPUStencilValue

    @ReadWriteAttribute
    public var depthBias: GPUDepthBias

    @ReadWriteAttribute
    public var depthBiasSlopeScale: Float

    @ReadWriteAttribute
    public var depthBiasClamp: Float
}

public class GPUDevice: EventTarget, GPUObjectBase {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUDevice].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _features = ReadonlyAttribute(jsObject: jsObject, name: Strings.features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: Strings.limits)
        _queue = ReadonlyAttribute(jsObject: jsObject, name: Strings.queue)
        _lost = ReadonlyAttribute(jsObject: jsObject, name: Strings.lost)
        _onuncapturederror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onuncapturederror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var queue: GPUQueue

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable public func createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createTexture(descriptor: GPUTextureDescriptor) -> GPUTexture {
        let this = jsObject
        return this[Strings.createTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createSampler(descriptor: GPUSamplerDescriptor? = nil) -> GPUSampler {
        let this = jsObject
        return this[Strings.createSampler].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func importExternalTexture(descriptor: GPUExternalTextureDescriptor) -> GPUExternalTexture {
        let this = jsObject
        return this[Strings.importExternalTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor) -> GPUBindGroupLayout {
        let this = jsObject
        return this[Strings.createBindGroupLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor) -> GPUPipelineLayout {
        let this = jsObject
        return this[Strings.createPipelineLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroup(descriptor: GPUBindGroupDescriptor) -> GPUBindGroup {
        let this = jsObject
        return this[Strings.createBindGroup].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createShaderModule(descriptor: GPUShaderModuleDescriptor) -> GPUShaderModule {
        let this = jsObject
        return this[Strings.createShaderModule].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipeline(descriptor: GPUComputePipelineDescriptor) -> GPUComputePipeline {
        let this = jsObject
        return this[Strings.createComputePipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderPipeline(descriptor: GPURenderPipelineDescriptor) -> GPURenderPipeline {
        let this = jsObject
        return this[Strings.createRenderPipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[Strings.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) async throws -> GPUComputePipeline {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[Strings.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) async throws -> GPURenderPipeline {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createCommandEncoder(descriptor: GPUCommandEncoderDescriptor? = nil) -> GPUCommandEncoder {
        let this = jsObject
        return this[Strings.createCommandEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor) -> GPURenderBundleEncoder {
        let this = jsObject
        return this[Strings.createRenderBundleEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createQuerySet(descriptor: GPUQuerySetDescriptor) -> GPUQuerySet {
        let this = jsObject
        return this[Strings.createQuerySet].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var lost: JSPromise

    @inlinable public func pushErrorScope(filter: GPUErrorFilter) {
        let this = jsObject
        _ = this[Strings.pushErrorScope].function!(this: this, arguments: [_toJSValue(filter)])
    }

    @inlinable public func popErrorScope() -> JSPromise {
        let this = jsObject
        return this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func popErrorScope() async throws -> GPUError? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @ClosureAttribute1Optional
    public var onuncapturederror: EventHandler
}

public class GPUDeviceDescriptor: BridgedDictionary {
    public convenience init(requiredFeatures: [GPUFeatureName], requiredLimits: [String: GPUSize64], defaultQueue: GPUQueueDescriptor) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.requiredFeatures] = _toJSValue(requiredFeatures)
        object[Strings.requiredLimits] = _toJSValue(requiredLimits)
        object[Strings.defaultQueue] = _toJSValue(defaultQueue)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _requiredFeatures = ReadWriteAttribute(jsObject: object, name: Strings.requiredFeatures)
        _requiredLimits = ReadWriteAttribute(jsObject: object, name: Strings.requiredLimits)
        _defaultQueue = ReadWriteAttribute(jsObject: object, name: Strings.defaultQueue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var requiredFeatures: [GPUFeatureName]

    @ReadWriteAttribute
    public var requiredLimits: [String: GPUSize64]

    @ReadWriteAttribute
    public var defaultQueue: GPUQueueDescriptor
}

public class GPUDeviceLostInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUDeviceLostInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var reason: GPUDeviceLostReason

    @ReadonlyAttribute
    public var message: String
}

public enum GPUDeviceLostReason: JSString, JSValueCompatible {
    case unknown = "unknown"
    case destroyed = "destroyed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUError].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var message: String
}

public enum GPUErrorFilter: JSString, JSValueCompatible {
    case validation = "validation"
    case outOfMemory = "out-of-memory"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUExtent3DDict: BridgedDictionary {
    public convenience init(width: GPUIntegerCoordinate, height: GPUIntegerCoordinate, depthOrArrayLayers: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.depthOrArrayLayers] = _toJSValue(depthOrArrayLayers)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _depthOrArrayLayers = ReadWriteAttribute(jsObject: object, name: Strings.depthOrArrayLayers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var height: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var depthOrArrayLayers: GPUIntegerCoordinate
}

public class GPUExternalTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUExternalTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUExternalTextureBindingLayout: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUExternalTextureDescriptor: BridgedDictionary {
    public convenience init(source: HTMLVideoElement_or_VideoFrame, colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = _toJSValue(source)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: Strings.source)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: HTMLVideoElement_or_VideoFrame

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace
}

public enum GPUFeatureName: JSString, JSValueCompatible {
    case depthClipControl = "depth-clip-control"
    case depth32floatStencil8 = "depth32float-stencil8"
    case textureCompressionBc = "texture-compression-bc"
    case textureCompressionEtc2 = "texture-compression-etc2"
    case textureCompressionAstc = "texture-compression-astc"
    case timestampQuery = "timestamp-query"
    case indirectFirstInstance = "indirect-first-instance"
    case shaderF16 = "shader-f16"
    case rg11b10ufloatRenderable = "rg11b10ufloat-renderable"
    case bgra8unormStorage = "bgra8unorm-storage"
    case float32Filterable = "float32-filterable"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUFragmentState: BridgedDictionary {
    public convenience init(targets: [GPUColorTargetState?]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.targets] = _toJSValue(targets)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _targets = ReadWriteAttribute(jsObject: object, name: Strings.targets)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var targets: [GPUColorTargetState?]
}

public enum GPUFrontFace: JSString, JSValueCompatible {
    case ccw = "ccw"
    case cw = "cw"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUImageCopyBuffer: BridgedDictionary {
    public convenience init(buffer: GPUBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = _toJSValue(buffer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer
}

public class GPUImageCopyExternalImage: BridgedDictionary {
    public convenience init(source: GPUImageCopyExternalImageSource, origin: GPUOrigin2D, flipY: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = _toJSValue(source)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.flipY] = _toJSValue(flipY)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: Strings.source)
        _origin = ReadWriteAttribute(jsObject: object, name: Strings.origin)
        _flipY = ReadWriteAttribute(jsObject: object, name: Strings.flipY)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: GPUImageCopyExternalImageSource

    @ReadWriteAttribute
    public var origin: GPUOrigin2D

    @ReadWriteAttribute
    public var flipY: Bool
}

public class GPUImageCopyTexture: BridgedDictionary {
    public convenience init(texture: GPUTexture, mipLevel: GPUIntegerCoordinate, origin: GPUOrigin3D, aspect: GPUTextureAspect) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.texture] = _toJSValue(texture)
        object[Strings.mipLevel] = _toJSValue(mipLevel)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.aspect] = _toJSValue(aspect)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _texture = ReadWriteAttribute(jsObject: object, name: Strings.texture)
        _mipLevel = ReadWriteAttribute(jsObject: object, name: Strings.mipLevel)
        _origin = ReadWriteAttribute(jsObject: object, name: Strings.origin)
        _aspect = ReadWriteAttribute(jsObject: object, name: Strings.aspect)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var texture: GPUTexture

    @ReadWriteAttribute
    public var mipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var origin: GPUOrigin3D

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect
}

public class GPUImageCopyTextureTagged: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace, premultipliedAlpha: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.premultipliedAlpha] = _toJSValue(premultipliedAlpha)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _premultipliedAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultipliedAlpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var premultipliedAlpha: Bool
}

public class GPUImageDataLayout: BridgedDictionary {
    public convenience init(offset: GPUSize64, bytesPerRow: GPUSize32, rowsPerImage: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.bytesPerRow] = _toJSValue(bytesPerRow)
        object[Strings.rowsPerImage] = _toJSValue(rowsPerImage)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _bytesPerRow = ReadWriteAttribute(jsObject: object, name: Strings.bytesPerRow)
        _rowsPerImage = ReadWriteAttribute(jsObject: object, name: Strings.rowsPerImage)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var bytesPerRow: GPUSize32

    @ReadWriteAttribute
    public var rowsPerImage: GPUSize32
}

public enum GPUIndexFormat: JSString, JSValueCompatible {
    case uint16 = "uint16"
    case uint32 = "uint32"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUInternalError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUInternalError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public enum GPULoadOp: JSString, JSValueCompatible {
    case load = "load"
    case clear = "clear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUMapMode {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUMapMode].object!
    }

    public static let READ: GPUFlagsConstant = 0x0001

    public static let WRITE: GPUFlagsConstant = 0x0002
}

public enum GPUMipmapFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUMultisampleState: BridgedDictionary {
    public convenience init(count: GPUSize32, mask: GPUSampleMask, alphaToCoverageEnabled: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.count] = _toJSValue(count)
        object[Strings.mask] = _toJSValue(mask)
        object[Strings.alphaToCoverageEnabled] = _toJSValue(alphaToCoverageEnabled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _count = ReadWriteAttribute(jsObject: object, name: Strings.count)
        _mask = ReadWriteAttribute(jsObject: object, name: Strings.mask)
        _alphaToCoverageEnabled = ReadWriteAttribute(jsObject: object, name: Strings.alphaToCoverageEnabled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var count: GPUSize32

    @ReadWriteAttribute
    public var mask: GPUSampleMask

    @ReadWriteAttribute
    public var alphaToCoverageEnabled: Bool
}

public protocol GPUObjectBase: JSBridgedClass {}
public extension GPUObjectBase {
    @inlinable var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        nonmutating set { jsObject[Strings.label] = _toJSValue(newValue) }
    }
}

public class GPUObjectDescriptorBase: BridgedDictionary {
    public convenience init(label: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _label = ReadWriteAttribute(jsObject: object, name: Strings.label)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var label: String
}

public class GPUOrigin2DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate
}

public class GPUOrigin3DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, z: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)
        object[Strings.z] = _toJSValue(z)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        _z = ReadWriteAttribute(jsObject: object, name: Strings.z)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var z: GPUIntegerCoordinate
}

public class GPUOutOfMemoryError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUOutOfMemoryError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public protocol GPUPipelineBase: JSBridgedClass {}
public extension GPUPipelineBase {
    @inlinable func getBindGroupLayout(index: UInt32) -> GPUBindGroupLayout {
        let this = jsObject
        return this[Strings.getBindGroupLayout].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}

public class GPUPipelineDescriptorBase: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout
}

public class GPUPipelineError: DOMException {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUPipelineError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String? = nil, options: GPUPipelineErrorInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var reason: GPUPipelineErrorReason
}

public class GPUPipelineErrorInit: BridgedDictionary {
    public convenience init(reason: GPUPipelineErrorReason) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.reason] = _toJSValue(reason)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _reason = ReadWriteAttribute(jsObject: object, name: Strings.reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var reason: GPUPipelineErrorReason
}

public enum GPUPipelineErrorReason: JSString, JSValueCompatible {
    case validation = "validation"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPipelineLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUPipelineLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUPipelineLayoutDescriptor: BridgedDictionary {
    public convenience init(bindGroupLayouts: [GPUBindGroupLayout]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bindGroupLayouts] = _toJSValue(bindGroupLayouts)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bindGroupLayouts = ReadWriteAttribute(jsObject: object, name: Strings.bindGroupLayouts)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bindGroupLayouts: [GPUBindGroupLayout]
}

public enum GPUPowerPreference: JSString, JSValueCompatible {
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPrimitiveState: BridgedDictionary {
    public convenience init(topology: GPUPrimitiveTopology, stripIndexFormat: GPUIndexFormat, frontFace: GPUFrontFace, cullMode: GPUCullMode, unclippedDepth: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.topology] = _toJSValue(topology)
        object[Strings.stripIndexFormat] = _toJSValue(stripIndexFormat)
        object[Strings.frontFace] = _toJSValue(frontFace)
        object[Strings.cullMode] = _toJSValue(cullMode)
        object[Strings.unclippedDepth] = _toJSValue(unclippedDepth)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _topology = ReadWriteAttribute(jsObject: object, name: Strings.topology)
        _stripIndexFormat = ReadWriteAttribute(jsObject: object, name: Strings.stripIndexFormat)
        _frontFace = ReadWriteAttribute(jsObject: object, name: Strings.frontFace)
        _cullMode = ReadWriteAttribute(jsObject: object, name: Strings.cullMode)
        _unclippedDepth = ReadWriteAttribute(jsObject: object, name: Strings.unclippedDepth)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var topology: GPUPrimitiveTopology

    @ReadWriteAttribute
    public var stripIndexFormat: GPUIndexFormat

    @ReadWriteAttribute
    public var frontFace: GPUFrontFace

    @ReadWriteAttribute
    public var cullMode: GPUCullMode

    @ReadWriteAttribute
    public var unclippedDepth: Bool
}

public enum GPUPrimitiveTopology: JSString, JSValueCompatible {
    case pointList = "point-list"
    case lineList = "line-list"
    case lineStrip = "line-strip"
    case triangleList = "triangle-list"
    case triangleStrip = "triangle-strip"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUProgrammableStage: BridgedDictionary {
    public convenience init(module: GPUShaderModule, entryPoint: String, constants: [String: GPUPipelineConstantValue]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.module] = _toJSValue(module)
        object[Strings.entryPoint] = _toJSValue(entryPoint)
        object[Strings.constants] = _toJSValue(constants)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _module = ReadWriteAttribute(jsObject: object, name: Strings.module)
        _entryPoint = ReadWriteAttribute(jsObject: object, name: Strings.entryPoint)
        _constants = ReadWriteAttribute(jsObject: object, name: Strings.constants)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var module: GPUShaderModule

    @ReadWriteAttribute
    public var entryPoint: String

    @ReadWriteAttribute
    public var constants: [String: GPUPipelineConstantValue]
}

public class GPUQuerySet: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUQuerySet].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _count = ReadonlyAttribute(jsObject: jsObject, name: Strings.count)
        self.jsObject = jsObject
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var type: GPUQueryType

    @ReadonlyAttribute
    public var count: GPUSize32Out
}

public class GPUQuerySetDescriptor: BridgedDictionary {
    public convenience init(type: GPUQueryType, count: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.count] = _toJSValue(count)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _count = ReadWriteAttribute(jsObject: object, name: Strings.count)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUQueryType

    @ReadWriteAttribute
    public var count: GPUSize32
}

public enum GPUQueryType: JSString, JSValueCompatible {
    case occlusion = "occlusion"
    case timestamp = "timestamp"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUQueue: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUQueue].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func submit(commandBuffers: [GPUCommandBuffer]) {
        let this = jsObject
        _ = this[Strings.submit].function!(this: this, arguments: [_toJSValue(commandBuffers)])
    }

    @inlinable public func onSubmittedWorkDone() -> JSPromise {
        let this = jsObject
        return this[Strings.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func onSubmittedWorkDone() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func writeBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: AllowSharedBufferSource, dataOffset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.writeBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(bufferOffset), _toJSValue(data), _toJSValue(dataOffset), _toJSValue(size)])
    }

    @inlinable public func writeTexture(destination: GPUImageCopyTexture, data: AllowSharedBufferSource, dataLayout: GPUImageDataLayout, size: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.writeTexture].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(data), _toJSValue(dataLayout), _toJSValue(size)])
    }

    @inlinable public func copyExternalImageToTexture(source: GPUImageCopyExternalImage, destination: GPUImageCopyTextureTagged, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyExternalImageToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }
}

public class GPUQueueDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundle: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderBundle].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderBundleDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundleEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderBundleEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func finish(descriptor: GPURenderBundleDescriptor? = nil) -> GPURenderBundle {
        let this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPURenderBundleEncoderDescriptor: BridgedDictionary {
    public convenience init(depthReadOnly: Bool, stencilReadOnly: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.depthReadOnly] = _toJSValue(depthReadOnly)
        object[Strings.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.depthReadOnly)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public protocol GPURenderCommandsMixin: JSBridgedClass {}
public extension GPURenderCommandsMixin {
    @inlinable func setPipeline(pipeline: GPURenderPipeline) {
        let this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable func setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.setIndexBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(indexFormat), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func setVertexBuffer(slot: GPUIndex32, buffer: GPUBuffer?, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.setVertexBuffer].function!(this: this, arguments: [_toJSValue(slot), _toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func draw(vertexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstVertex: GPUSize32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.draw].function!(this: this, arguments: [_toJSValue(vertexCount), _toJSValue(instanceCount), _toJSValue(firstVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndexed(indexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstIndex: GPUSize32? = nil, baseVertex: GPUSignedOffset32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.drawIndexed].function!(this: this, arguments: [_toJSValue(indexCount), _toJSValue(instanceCount), _toJSValue(firstIndex), _toJSValue(baseVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.drawIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable func drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.drawIndexedIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }
}

public class GPURenderPassColorAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, resolveTarget: GPUTextureView, clearValue: GPUColor, loadOp: GPULoadOp, storeOp: GPUStoreOp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.resolveTarget] = _toJSValue(resolveTarget)
        object[Strings.clearValue] = _toJSValue(clearValue)
        object[Strings.loadOp] = _toJSValue(loadOp)
        object[Strings.storeOp] = _toJSValue(storeOp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: Strings.view)
        _resolveTarget = ReadWriteAttribute(jsObject: object, name: Strings.resolveTarget)
        _clearValue = ReadWriteAttribute(jsObject: object, name: Strings.clearValue)
        _loadOp = ReadWriteAttribute(jsObject: object, name: Strings.loadOp)
        _storeOp = ReadWriteAttribute(jsObject: object, name: Strings.storeOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var resolveTarget: GPUTextureView

    @ReadWriteAttribute
    public var clearValue: GPUColor

    @ReadWriteAttribute
    public var loadOp: GPULoadOp

    @ReadWriteAttribute
    public var storeOp: GPUStoreOp
}

public class GPURenderPassDepthStencilAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, depthClearValue: Float, depthLoadOp: GPULoadOp, depthStoreOp: GPUStoreOp, depthReadOnly: Bool, stencilClearValue: GPUStencilValue, stencilLoadOp: GPULoadOp, stencilStoreOp: GPUStoreOp, stencilReadOnly: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.depthClearValue] = _toJSValue(depthClearValue)
        object[Strings.depthLoadOp] = _toJSValue(depthLoadOp)
        object[Strings.depthStoreOp] = _toJSValue(depthStoreOp)
        object[Strings.depthReadOnly] = _toJSValue(depthReadOnly)
        object[Strings.stencilClearValue] = _toJSValue(stencilClearValue)
        object[Strings.stencilLoadOp] = _toJSValue(stencilLoadOp)
        object[Strings.stencilStoreOp] = _toJSValue(stencilStoreOp)
        object[Strings.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: Strings.view)
        _depthClearValue = ReadWriteAttribute(jsObject: object, name: Strings.depthClearValue)
        _depthLoadOp = ReadWriteAttribute(jsObject: object, name: Strings.depthLoadOp)
        _depthStoreOp = ReadWriteAttribute(jsObject: object, name: Strings.depthStoreOp)
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.depthReadOnly)
        _stencilClearValue = ReadWriteAttribute(jsObject: object, name: Strings.stencilClearValue)
        _stencilLoadOp = ReadWriteAttribute(jsObject: object, name: Strings.stencilLoadOp)
        _stencilStoreOp = ReadWriteAttribute(jsObject: object, name: Strings.stencilStoreOp)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var depthClearValue: Float

    @ReadWriteAttribute
    public var depthLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var depthStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilClearValue: GPUStencilValue

    @ReadWriteAttribute
    public var stencilLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var stencilStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public class GPURenderPassDescriptor: BridgedDictionary {
    public convenience init(colorAttachments: [GPURenderPassColorAttachment?], depthStencilAttachment: GPURenderPassDepthStencilAttachment, occlusionQuerySet: GPUQuerySet, timestampWrites: GPURenderPassTimestampWrites, maxDrawCount: GPUSize64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorAttachments] = _toJSValue(colorAttachments)
        object[Strings.depthStencilAttachment] = _toJSValue(depthStencilAttachment)
        object[Strings.occlusionQuerySet] = _toJSValue(occlusionQuerySet)
        object[Strings.timestampWrites] = _toJSValue(timestampWrites)
        object[Strings.maxDrawCount] = _toJSValue(maxDrawCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorAttachments = ReadWriteAttribute(jsObject: object, name: Strings.colorAttachments)
        _depthStencilAttachment = ReadWriteAttribute(jsObject: object, name: Strings.depthStencilAttachment)
        _occlusionQuerySet = ReadWriteAttribute(jsObject: object, name: Strings.occlusionQuerySet)
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: Strings.timestampWrites)
        _maxDrawCount = ReadWriteAttribute(jsObject: object, name: Strings.maxDrawCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorAttachments: [GPURenderPassColorAttachment?]

    @ReadWriteAttribute
    public var depthStencilAttachment: GPURenderPassDepthStencilAttachment

    @ReadWriteAttribute
    public var occlusionQuerySet: GPUQuerySet

    @ReadWriteAttribute
    public var timestampWrites: GPURenderPassTimestampWrites

    @ReadWriteAttribute
    public var maxDrawCount: GPUSize64
}

public class GPURenderPassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderPassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setViewport(x: Float, y: Float, width: Float, height: Float, minDepth: Float, maxDepth: Float) {
        let this = jsObject
        _ = this[Strings.setViewport].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height), _toJSValue(minDepth), _toJSValue(maxDepth)])
    }

    @inlinable public func setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate) {
        let this = jsObject
        _ = this[Strings.setScissorRect].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)])
    }

    @inlinable public func setBlendConstant(color: GPUColor) {
        let this = jsObject
        _ = this[Strings.setBlendConstant].function!(this: this, arguments: [_toJSValue(color)])
    }

    @inlinable public func setStencilReference(reference: GPUStencilValue) {
        let this = jsObject
        _ = this[Strings.setStencilReference].function!(this: this, arguments: [_toJSValue(reference)])
    }

    @inlinable public func beginOcclusionQuery(queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[Strings.beginOcclusionQuery].function!(this: this, arguments: [_toJSValue(queryIndex)])
    }

    @inlinable public func endOcclusionQuery() {
        let this = jsObject
        _ = this[Strings.endOcclusionQuery].function!(this: this, arguments: [])
    }

    @inlinable public func executeBundles(bundles: [GPURenderBundle]) {
        let this = jsObject
        _ = this[Strings.executeBundles].function!(this: this, arguments: [_toJSValue(bundles)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

public class GPURenderPassLayout: BridgedDictionary {
    public convenience init(colorFormats: [GPUTextureFormat?], depthStencilFormat: GPUTextureFormat, sampleCount: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorFormats] = _toJSValue(colorFormats)
        object[Strings.depthStencilFormat] = _toJSValue(depthStencilFormat)
        object[Strings.sampleCount] = _toJSValue(sampleCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorFormats = ReadWriteAttribute(jsObject: object, name: Strings.colorFormats)
        _depthStencilFormat = ReadWriteAttribute(jsObject: object, name: Strings.depthStencilFormat)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: Strings.sampleCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorFormats: [GPUTextureFormat?]

    @ReadWriteAttribute
    public var depthStencilFormat: GPUTextureFormat

    @ReadWriteAttribute
    public var sampleCount: GPUSize32
}

public class GPURenderPassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = _toJSValue(querySet)
        object[Strings.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[Strings.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: Strings.querySet)
        _beginningOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: Strings.beginningOfPassWriteIndex)
        _endOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: Strings.endOfPassWriteIndex)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var beginningOfPassWriteIndex: GPUSize32

    @ReadWriteAttribute
    public var endOfPassWriteIndex: GPUSize32
}

public class GPURenderPipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderPipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderPipelineDescriptor: BridgedDictionary {
    public convenience init(vertex: GPUVertexState, primitive: GPUPrimitiveState, depthStencil: GPUDepthStencilState, multisample: GPUMultisampleState, fragment: GPUFragmentState) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.vertex] = _toJSValue(vertex)
        object[Strings.primitive] = _toJSValue(primitive)
        object[Strings.depthStencil] = _toJSValue(depthStencil)
        object[Strings.multisample] = _toJSValue(multisample)
        object[Strings.fragment] = _toJSValue(fragment)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _vertex = ReadWriteAttribute(jsObject: object, name: Strings.vertex)
        _primitive = ReadWriteAttribute(jsObject: object, name: Strings.primitive)
        _depthStencil = ReadWriteAttribute(jsObject: object, name: Strings.depthStencil)
        _multisample = ReadWriteAttribute(jsObject: object, name: Strings.multisample)
        _fragment = ReadWriteAttribute(jsObject: object, name: Strings.fragment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var vertex: GPUVertexState

    @ReadWriteAttribute
    public var primitive: GPUPrimitiveState

    @ReadWriteAttribute
    public var depthStencil: GPUDepthStencilState

    @ReadWriteAttribute
    public var multisample: GPUMultisampleState

    @ReadWriteAttribute
    public var fragment: GPUFragmentState
}

public class GPURequestAdapterOptions: BridgedDictionary {
    public convenience init(powerPreference: GPUPowerPreference, forceFallbackAdapter: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.powerPreference] = _toJSValue(powerPreference)
        object[Strings.forceFallbackAdapter] = _toJSValue(forceFallbackAdapter)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _powerPreference = ReadWriteAttribute(jsObject: object, name: Strings.powerPreference)
        _forceFallbackAdapter = ReadWriteAttribute(jsObject: object, name: Strings.forceFallbackAdapter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var powerPreference: GPUPowerPreference

    @ReadWriteAttribute
    public var forceFallbackAdapter: Bool
}

public class GPUSampler: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSampler].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUSamplerBindingLayout: BridgedDictionary {
    public convenience init(type: GPUSamplerBindingType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUSamplerBindingType
}

public enum GPUSamplerBindingType: JSString, JSValueCompatible {
    case filtering = "filtering"
    case nonFiltering = "non-filtering"
    case comparison = "comparison"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSamplerDescriptor: BridgedDictionary {
    public convenience init(addressModeU: GPUAddressMode, addressModeV: GPUAddressMode, addressModeW: GPUAddressMode, magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUMipmapFilterMode, lodMinClamp: Float, lodMaxClamp: Float, compare: GPUCompareFunction, maxAnisotropy: UInt16) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.addressModeU] = _toJSValue(addressModeU)
        object[Strings.addressModeV] = _toJSValue(addressModeV)
        object[Strings.addressModeW] = _toJSValue(addressModeW)
        object[Strings.magFilter] = _toJSValue(magFilter)
        object[Strings.minFilter] = _toJSValue(minFilter)
        object[Strings.mipmapFilter] = _toJSValue(mipmapFilter)
        object[Strings.lodMinClamp] = _toJSValue(lodMinClamp)
        object[Strings.lodMaxClamp] = _toJSValue(lodMaxClamp)
        object[Strings.compare] = _toJSValue(compare)
        object[Strings.maxAnisotropy] = _toJSValue(maxAnisotropy)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _addressModeU = ReadWriteAttribute(jsObject: object, name: Strings.addressModeU)
        _addressModeV = ReadWriteAttribute(jsObject: object, name: Strings.addressModeV)
        _addressModeW = ReadWriteAttribute(jsObject: object, name: Strings.addressModeW)
        _magFilter = ReadWriteAttribute(jsObject: object, name: Strings.magFilter)
        _minFilter = ReadWriteAttribute(jsObject: object, name: Strings.minFilter)
        _mipmapFilter = ReadWriteAttribute(jsObject: object, name: Strings.mipmapFilter)
        _lodMinClamp = ReadWriteAttribute(jsObject: object, name: Strings.lodMinClamp)
        _lodMaxClamp = ReadWriteAttribute(jsObject: object, name: Strings.lodMaxClamp)
        _compare = ReadWriteAttribute(jsObject: object, name: Strings.compare)
        _maxAnisotropy = ReadWriteAttribute(jsObject: object, name: Strings.maxAnisotropy)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var addressModeU: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeV: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeW: GPUAddressMode

    @ReadWriteAttribute
    public var magFilter: GPUFilterMode

    @ReadWriteAttribute
    public var minFilter: GPUFilterMode

    @ReadWriteAttribute
    public var mipmapFilter: GPUMipmapFilterMode

    @ReadWriteAttribute
    public var lodMinClamp: Float

    @ReadWriteAttribute
    public var lodMaxClamp: Float

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var maxAnisotropy: UInt16
}

public class GPUShaderModule: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUShaderModule].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getCompilationInfo() -> JSPromise {
        let this = jsObject
        return this[Strings.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getCompilationInfo() async throws -> GPUCompilationInfo {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUShaderModuleCompilationHint: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout
}

public class GPUShaderModuleDescriptor: BridgedDictionary {
    public convenience init(code: String, sourceMap: JSObject, hints: [String: GPUShaderModuleCompilationHint]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.code] = _toJSValue(code)
        object[Strings.sourceMap] = _toJSValue(sourceMap)
        object[Strings.hints] = _toJSValue(hints)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _code = ReadWriteAttribute(jsObject: object, name: Strings.code)
        _sourceMap = ReadWriteAttribute(jsObject: object, name: Strings.sourceMap)
        _hints = ReadWriteAttribute(jsObject: object, name: Strings.hints)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var sourceMap: JSObject

    @ReadWriteAttribute
    public var hints: [String: GPUShaderModuleCompilationHint]
}

public enum GPUShaderStage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUShaderStage].object!
    }

    public static let VERTEX: GPUFlagsConstant = 0x1

    public static let FRAGMENT: GPUFlagsConstant = 0x2

    public static let COMPUTE: GPUFlagsConstant = 0x4
}

public class GPUStencilFaceState: BridgedDictionary {
    public convenience init(compare: GPUCompareFunction, failOp: GPUStencilOperation, depthFailOp: GPUStencilOperation, passOp: GPUStencilOperation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.compare] = _toJSValue(compare)
        object[Strings.failOp] = _toJSValue(failOp)
        object[Strings.depthFailOp] = _toJSValue(depthFailOp)
        object[Strings.passOp] = _toJSValue(passOp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compare = ReadWriteAttribute(jsObject: object, name: Strings.compare)
        _failOp = ReadWriteAttribute(jsObject: object, name: Strings.failOp)
        _depthFailOp = ReadWriteAttribute(jsObject: object, name: Strings.depthFailOp)
        _passOp = ReadWriteAttribute(jsObject: object, name: Strings.passOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var failOp: GPUStencilOperation

    @ReadWriteAttribute
    public var depthFailOp: GPUStencilOperation

    @ReadWriteAttribute
    public var passOp: GPUStencilOperation
}

public enum GPUStencilOperation: JSString, JSValueCompatible {
    case keep = "keep"
    case zero = "zero"
    case replace = "replace"
    case invert = "invert"
    case incrementClamp = "increment-clamp"
    case decrementClamp = "decrement-clamp"
    case incrementWrap = "increment-wrap"
    case decrementWrap = "decrement-wrap"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUStorageTextureAccess: JSString, JSValueCompatible {
    case writeOnly = "write-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUStorageTextureBindingLayout: BridgedDictionary {
    public convenience init(access: GPUStorageTextureAccess, format: GPUTextureFormat, viewDimension: GPUTextureViewDimension) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.access] = _toJSValue(access)
        object[Strings.format] = _toJSValue(format)
        object[Strings.viewDimension] = _toJSValue(viewDimension)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _access = ReadWriteAttribute(jsObject: object, name: Strings.access)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: Strings.viewDimension)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var access: GPUStorageTextureAccess

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension
}

public enum GPUStoreOp: JSString, JSValueCompatible {
    case store = "store"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSupportedFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSupportedFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}

public class GPUSupportedLimits: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSupportedLimits].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _maxTextureDimension1D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension1D)
        _maxTextureDimension2D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension2D)
        _maxTextureDimension3D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension3D)
        _maxTextureArrayLayers = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureArrayLayers)
        _maxBindGroups = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxBindGroups)
        _maxBindGroupsPlusVertexBuffers = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxBindGroupsPlusVertexBuffers)
        _maxBindingsPerBindGroup = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxBindingsPerBindGroup)
        _maxDynamicUniformBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxDynamicUniformBuffersPerPipelineLayout)
        _maxDynamicStorageBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxDynamicStorageBuffersPerPipelineLayout)
        _maxSampledTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxSampledTexturesPerShaderStage)
        _maxSamplersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxSamplersPerShaderStage)
        _maxStorageBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageBuffersPerShaderStage)
        _maxStorageTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageTexturesPerShaderStage)
        _maxUniformBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxUniformBuffersPerShaderStage)
        _maxUniformBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxUniformBufferBindingSize)
        _maxStorageBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageBufferBindingSize)
        _minUniformBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: Strings.minUniformBufferOffsetAlignment)
        _minStorageBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: Strings.minStorageBufferOffsetAlignment)
        _maxVertexBuffers = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexBuffers)
        _maxBufferSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxBufferSize)
        _maxVertexAttributes = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexAttributes)
        _maxVertexBufferArrayStride = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexBufferArrayStride)
        _maxInterStageShaderComponents = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxInterStageShaderComponents)
        _maxInterStageShaderVariables = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxInterStageShaderVariables)
        _maxColorAttachments = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxColorAttachments)
        _maxColorAttachmentBytesPerSample = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxColorAttachmentBytesPerSample)
        _maxComputeWorkgroupStorageSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupStorageSize)
        _maxComputeInvocationsPerWorkgroup = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeInvocationsPerWorkgroup)
        _maxComputeWorkgroupSizeX = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeX)
        _maxComputeWorkgroupSizeY = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeY)
        _maxComputeWorkgroupSizeZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeZ)
        _maxComputeWorkgroupsPerDimension = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupsPerDimension)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var maxTextureDimension1D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension2D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension3D: UInt32

    @ReadonlyAttribute
    public var maxTextureArrayLayers: UInt32

    @ReadonlyAttribute
    public var maxBindGroups: UInt32

    @ReadonlyAttribute
    public var maxBindGroupsPlusVertexBuffers: UInt32

    @ReadonlyAttribute
    public var maxBindingsPerBindGroup: UInt32

    @ReadonlyAttribute
    public var maxDynamicUniformBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxDynamicStorageBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxSampledTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxSamplersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var maxStorageBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var minUniformBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var minStorageBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var maxVertexBuffers: UInt32

    @ReadonlyAttribute
    public var maxBufferSize: UInt64

    @ReadonlyAttribute
    public var maxVertexAttributes: UInt32

    @ReadonlyAttribute
    public var maxVertexBufferArrayStride: UInt32

    @ReadonlyAttribute
    public var maxInterStageShaderComponents: UInt32

    @ReadonlyAttribute
    public var maxInterStageShaderVariables: UInt32

    @ReadonlyAttribute
    public var maxColorAttachments: UInt32

    @ReadonlyAttribute
    public var maxColorAttachmentBytesPerSample: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupStorageSize: UInt32

    @ReadonlyAttribute
    public var maxComputeInvocationsPerWorkgroup: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeX: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeY: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeZ: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupsPerDimension: UInt32
}

public class GPUTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: Strings.height)
        _depthOrArrayLayers = ReadonlyAttribute(jsObject: jsObject, name: Strings.depthOrArrayLayers)
        _mipLevelCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.mipLevelCount)
        _sampleCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleCount)
        _dimension = ReadonlyAttribute(jsObject: jsObject, name: Strings.dimension)
        _format = ReadonlyAttribute(jsObject: jsObject, name: Strings.format)
        _usage = ReadonlyAttribute(jsObject: jsObject, name: Strings.usage)
        self.jsObject = jsObject
    }

    @inlinable public func createView(descriptor: GPUTextureViewDescriptor? = nil) -> GPUTextureView {
        let this = jsObject
        return this[Strings.createView].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var width: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var height: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var depthOrArrayLayers: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var mipLevelCount: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var sampleCount: GPUSize32Out

    @ReadonlyAttribute
    public var dimension: GPUTextureDimension

    @ReadonlyAttribute
    public var format: GPUTextureFormat

    @ReadonlyAttribute
    public var usage: GPUFlagsConstant
}

public enum GPUTextureAspect: JSString, JSValueCompatible {
    case all = "all"
    case stencilOnly = "stencil-only"
    case depthOnly = "depth-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUTextureBindingLayout: BridgedDictionary {
    public convenience init(sampleType: GPUTextureSampleType, viewDimension: GPUTextureViewDimension, multisampled: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.sampleType] = _toJSValue(sampleType)
        object[Strings.viewDimension] = _toJSValue(viewDimension)
        object[Strings.multisampled] = _toJSValue(multisampled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _sampleType = ReadWriteAttribute(jsObject: object, name: Strings.sampleType)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: Strings.viewDimension)
        _multisampled = ReadWriteAttribute(jsObject: object, name: Strings.multisampled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var sampleType: GPUTextureSampleType

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var multisampled: Bool
}

public class GPUTextureDescriptor: BridgedDictionary {
    public convenience init(size: GPUExtent3D, mipLevelCount: GPUIntegerCoordinate, sampleCount: GPUSize32, dimension: GPUTextureDimension, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.size] = _toJSValue(size)
        object[Strings.mipLevelCount] = _toJSValue(mipLevelCount)
        object[Strings.sampleCount] = _toJSValue(sampleCount)
        object[Strings.dimension] = _toJSValue(dimension)
        object[Strings.format] = _toJSValue(format)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.viewFormats] = _toJSValue(viewFormats)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: Strings.mipLevelCount)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: Strings.sampleCount)
        _dimension = ReadWriteAttribute(jsObject: object, name: Strings.dimension)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: Strings.viewFormats)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUExtent3D

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var sampleCount: GPUSize32

    @ReadWriteAttribute
    public var dimension: GPUTextureDimension

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]
}

public enum GPUTextureDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureFormat: JSString, JSValueCompatible {
    case r8unorm = "r8unorm"
    case r8snorm = "r8snorm"
    case r8uint = "r8uint"
    case r8sint = "r8sint"
    case r16uint = "r16uint"
    case r16sint = "r16sint"
    case r16float = "r16float"
    case rg8unorm = "rg8unorm"
    case rg8snorm = "rg8snorm"
    case rg8uint = "rg8uint"
    case rg8sint = "rg8sint"
    case r32uint = "r32uint"
    case r32sint = "r32sint"
    case r32float = "r32float"
    case rg16uint = "rg16uint"
    case rg16sint = "rg16sint"
    case rg16float = "rg16float"
    case rgba8unorm = "rgba8unorm"
    case rgba8unormSrgb = "rgba8unorm-srgb"
    case rgba8snorm = "rgba8snorm"
    case rgba8uint = "rgba8uint"
    case rgba8sint = "rgba8sint"
    case bgra8unorm = "bgra8unorm"
    case bgra8unormSrgb = "bgra8unorm-srgb"
    case rgb9e5ufloat = "rgb9e5ufloat"
    case rgb10a2unorm = "rgb10a2unorm"
    case rg11b10ufloat = "rg11b10ufloat"
    case rg32uint = "rg32uint"
    case rg32sint = "rg32sint"
    case rg32float = "rg32float"
    case rgba16uint = "rgba16uint"
    case rgba16sint = "rgba16sint"
    case rgba16float = "rgba16float"
    case rgba32uint = "rgba32uint"
    case rgba32sint = "rgba32sint"
    case rgba32float = "rgba32float"
    case stencil8 = "stencil8"
    case depth16unorm = "depth16unorm"
    case depth24plus = "depth24plus"
    case depth24plusStencil8 = "depth24plus-stencil8"
    case depth32float = "depth32float"
    case depth32floatStencil8 = "depth32float-stencil8"
    case bc1RgbaUnorm = "bc1-rgba-unorm"
    case bc1RgbaUnormSrgb = "bc1-rgba-unorm-srgb"
    case bc2RgbaUnorm = "bc2-rgba-unorm"
    case bc2RgbaUnormSrgb = "bc2-rgba-unorm-srgb"
    case bc3RgbaUnorm = "bc3-rgba-unorm"
    case bc3RgbaUnormSrgb = "bc3-rgba-unorm-srgb"
    case bc4RUnorm = "bc4-r-unorm"
    case bc4RSnorm = "bc4-r-snorm"
    case bc5RgUnorm = "bc5-rg-unorm"
    case bc5RgSnorm = "bc5-rg-snorm"
    case bc6hRgbUfloat = "bc6h-rgb-ufloat"
    case bc6hRgbFloat = "bc6h-rgb-float"
    case bc7RgbaUnorm = "bc7-rgba-unorm"
    case bc7RgbaUnormSrgb = "bc7-rgba-unorm-srgb"
    case etc2Rgb8unorm = "etc2-rgb8unorm"
    case etc2Rgb8unormSrgb = "etc2-rgb8unorm-srgb"
    case etc2Rgb8a1unorm = "etc2-rgb8a1unorm"
    case etc2Rgb8a1unormSrgb = "etc2-rgb8a1unorm-srgb"
    case etc2Rgba8unorm = "etc2-rgba8unorm"
    case etc2Rgba8unormSrgb = "etc2-rgba8unorm-srgb"
    case eacR11unorm = "eac-r11unorm"
    case eacR11snorm = "eac-r11snorm"
    case eacRg11unorm = "eac-rg11unorm"
    case eacRg11snorm = "eac-rg11snorm"
    case astc4x4Unorm = "astc-4x4-unorm"
    case astc4x4UnormSrgb = "astc-4x4-unorm-srgb"
    case astc5x4Unorm = "astc-5x4-unorm"
    case astc5x4UnormSrgb = "astc-5x4-unorm-srgb"
    case astc5x5Unorm = "astc-5x5-unorm"
    case astc5x5UnormSrgb = "astc-5x5-unorm-srgb"
    case astc6x5Unorm = "astc-6x5-unorm"
    case astc6x5UnormSrgb = "astc-6x5-unorm-srgb"
    case astc6x6Unorm = "astc-6x6-unorm"
    case astc6x6UnormSrgb = "astc-6x6-unorm-srgb"
    case astc8x5Unorm = "astc-8x5-unorm"
    case astc8x5UnormSrgb = "astc-8x5-unorm-srgb"
    case astc8x6Unorm = "astc-8x6-unorm"
    case astc8x6UnormSrgb = "astc-8x6-unorm-srgb"
    case astc8x8Unorm = "astc-8x8-unorm"
    case astc8x8UnormSrgb = "astc-8x8-unorm-srgb"
    case astc10x5Unorm = "astc-10x5-unorm"
    case astc10x5UnormSrgb = "astc-10x5-unorm-srgb"
    case astc10x6Unorm = "astc-10x6-unorm"
    case astc10x6UnormSrgb = "astc-10x6-unorm-srgb"
    case astc10x8Unorm = "astc-10x8-unorm"
    case astc10x8UnormSrgb = "astc-10x8-unorm-srgb"
    case astc10x10Unorm = "astc-10x10-unorm"
    case astc10x10UnormSrgb = "astc-10x10-unorm-srgb"
    case astc12x10Unorm = "astc-12x10-unorm"
    case astc12x10UnormSrgb = "astc-12x10-unorm-srgb"
    case astc12x12Unorm = "astc-12x12-unorm"
    case astc12x12UnormSrgb = "astc-12x12-unorm-srgb"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureSampleType: JSString, JSValueCompatible {
    case float = "float"
    case unfilterableFloat = "unfilterable-float"
    case depth = "depth"
    case sint = "sint"
    case uint = "uint"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUTextureUsage].object!
    }

    public static let COPY_SRC: GPUFlagsConstant = 0x01

    public static let COPY_DST: GPUFlagsConstant = 0x02

    public static let TEXTURE_BINDING: GPUFlagsConstant = 0x04

    public static let STORAGE_BINDING: GPUFlagsConstant = 0x08

    public static let RENDER_ATTACHMENT: GPUFlagsConstant = 0x10
}

public class GPUTextureView: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUTextureView].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUTextureViewDescriptor: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, dimension: GPUTextureViewDimension, aspect: GPUTextureAspect, baseMipLevel: GPUIntegerCoordinate, mipLevelCount: GPUIntegerCoordinate, baseArrayLayer: GPUIntegerCoordinate, arrayLayerCount: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.dimension] = _toJSValue(dimension)
        object[Strings.aspect] = _toJSValue(aspect)
        object[Strings.baseMipLevel] = _toJSValue(baseMipLevel)
        object[Strings.mipLevelCount] = _toJSValue(mipLevelCount)
        object[Strings.baseArrayLayer] = _toJSValue(baseArrayLayer)
        object[Strings.arrayLayerCount] = _toJSValue(arrayLayerCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _dimension = ReadWriteAttribute(jsObject: object, name: Strings.dimension)
        _aspect = ReadWriteAttribute(jsObject: object, name: Strings.aspect)
        _baseMipLevel = ReadWriteAttribute(jsObject: object, name: Strings.baseMipLevel)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: Strings.mipLevelCount)
        _baseArrayLayer = ReadWriteAttribute(jsObject: object, name: Strings.baseArrayLayer)
        _arrayLayerCount = ReadWriteAttribute(jsObject: object, name: Strings.arrayLayerCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var dimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect

    @ReadWriteAttribute
    public var baseMipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var baseArrayLayer: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var arrayLayerCount: GPUIntegerCoordinate
}

public enum GPUTextureViewDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _2dArray = "2d-array"
    case cube = "cube"
    case cubeArray = "cube-array"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUUncapturedErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUUncapturedErrorEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(gpuUncapturedErrorEventInitDict)]))
    }

    @ReadonlyAttribute
    public var error: GPUError
}

public class GPUUncapturedErrorEventInit: BridgedDictionary {
    public convenience init(error: GPUError) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.error] = _toJSValue(error)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _error = ReadWriteAttribute(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var error: GPUError
}

public class GPUValidationError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GPUValidationError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public class GPUVertexAttribute: BridgedDictionary {
    public convenience init(format: GPUVertexFormat, offset: GPUSize64, shaderLocation: GPUIndex32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.shaderLocation] = _toJSValue(shaderLocation)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _shaderLocation = ReadWriteAttribute(jsObject: object, name: Strings.shaderLocation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUVertexFormat

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var shaderLocation: GPUIndex32
}

public class GPUVertexBufferLayout: BridgedDictionary {
    public convenience init(arrayStride: GPUSize64, stepMode: GPUVertexStepMode, attributes: [GPUVertexAttribute]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.arrayStride] = _toJSValue(arrayStride)
        object[Strings.stepMode] = _toJSValue(stepMode)
        object[Strings.attributes] = _toJSValue(attributes)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _arrayStride = ReadWriteAttribute(jsObject: object, name: Strings.arrayStride)
        _stepMode = ReadWriteAttribute(jsObject: object, name: Strings.stepMode)
        _attributes = ReadWriteAttribute(jsObject: object, name: Strings.attributes)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var arrayStride: GPUSize64

    @ReadWriteAttribute
    public var stepMode: GPUVertexStepMode

    @ReadWriteAttribute
    public var attributes: [GPUVertexAttribute]
}

public enum GPUVertexFormat: JSString, JSValueCompatible {
    case uint8x2 = "uint8x2"
    case uint8x4 = "uint8x4"
    case sint8x2 = "sint8x2"
    case sint8x4 = "sint8x4"
    case unorm8x2 = "unorm8x2"
    case unorm8x4 = "unorm8x4"
    case snorm8x2 = "snorm8x2"
    case snorm8x4 = "snorm8x4"
    case uint16x2 = "uint16x2"
    case uint16x4 = "uint16x4"
    case sint16x2 = "sint16x2"
    case sint16x4 = "sint16x4"
    case unorm16x2 = "unorm16x2"
    case unorm16x4 = "unorm16x4"
    case snorm16x2 = "snorm16x2"
    case snorm16x4 = "snorm16x4"
    case float16x2 = "float16x2"
    case float16x4 = "float16x4"
    case float32 = "float32"
    case float32x2 = "float32x2"
    case float32x3 = "float32x3"
    case float32x4 = "float32x4"
    case uint32 = "uint32"
    case uint32x2 = "uint32x2"
    case uint32x3 = "uint32x3"
    case uint32x4 = "uint32x4"
    case sint32 = "sint32"
    case sint32x2 = "sint32x2"
    case sint32x3 = "sint32x3"
    case sint32x4 = "sint32x4"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUVertexState: BridgedDictionary {
    public convenience init(buffers: [GPUVertexBufferLayout?]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffers] = _toJSValue(buffers)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffers = ReadWriteAttribute(jsObject: object, name: Strings.buffers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffers: [GPUVertexBufferLayout?]
}

public enum GPUVertexStepMode: JSString, JSValueCompatible {
    case vertex = "vertex"
    case instance = "instance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol NavigatorGPU: JSBridgedClass {}
public extension NavigatorGPU {
    @inlinable var gpu: GPU { jsObject[Strings.gpu].fromJSValue()! }
}

extension Navigator: NavigatorGPU {}

public typealias GPUBufferUsageFlags = UInt32
public typealias GPUMapModeFlags = UInt32
public typealias GPUTextureUsageFlags = UInt32
public typealias GPUShaderStageFlags = UInt32

public typealias GPUPipelineConstantValue = Double
public typealias GPUColorWriteFlags = UInt32

public typealias GPUBufferDynamicOffset = UInt32
public typealias GPUStencilValue = UInt32
public typealias GPUSampleMask = UInt32
public typealias GPUDepthBias = Int32
public typealias GPUSize64 = UInt64
public typealias GPUIntegerCoordinate = UInt32
public typealias GPUIndex32 = UInt32
public typealias GPUSize32 = UInt32
public typealias GPUSignedOffset32 = Int32
public typealias GPUSize64Out = UInt64
public typealias GPUIntegerCoordinateOut = UInt32
public typealias GPUSize32Out = UInt32
public typealias GPUFlagsConstant = UInt32

public class WGSLLanguageFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WGSLLanguageFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}

@usableFromInline enum Strings {
    @usableFromInline static let _self: JSString = "self"
    @usableFromInline static let GPU: JSString = "GPU"
    @usableFromInline static let GPUAdapter: JSString = "GPUAdapter"
    @usableFromInline static let GPUAdapterInfo: JSString = "GPUAdapterInfo"
    @usableFromInline static let GPUBindGroup: JSString = "GPUBindGroup"
    @usableFromInline static let GPUBindGroupLayout: JSString = "GPUBindGroupLayout"
    @usableFromInline static let GPUBuffer: JSString = "GPUBuffer"
    @usableFromInline static let GPUBufferUsage: JSString = "GPUBufferUsage"
    @usableFromInline static let GPUCanvasContext: JSString = "GPUCanvasContext"
    @usableFromInline static let GPUColorWrite: JSString = "GPUColorWrite"
    @usableFromInline static let GPUCommandBuffer: JSString = "GPUCommandBuffer"
    @usableFromInline static let GPUCommandEncoder: JSString = "GPUCommandEncoder"
    @usableFromInline static let GPUCompilationInfo: JSString = "GPUCompilationInfo"
    @usableFromInline static let GPUCompilationMessage: JSString = "GPUCompilationMessage"
    @usableFromInline static let GPUComputePassEncoder: JSString = "GPUComputePassEncoder"
    @usableFromInline static let GPUComputePipeline: JSString = "GPUComputePipeline"
    @usableFromInline static let GPUDevice: JSString = "GPUDevice"
    @usableFromInline static let GPUDeviceLostInfo: JSString = "GPUDeviceLostInfo"
    @usableFromInline static let GPUError: JSString = "GPUError"
    @usableFromInline static let GPUExternalTexture: JSString = "GPUExternalTexture"
    @usableFromInline static let GPUInternalError: JSString = "GPUInternalError"
    @usableFromInline static let GPUMapMode: JSString = "GPUMapMode"
    @usableFromInline static let GPUOutOfMemoryError: JSString = "GPUOutOfMemoryError"
    @usableFromInline static let GPUPipelineError: JSString = "GPUPipelineError"
    @usableFromInline static let GPUPipelineLayout: JSString = "GPUPipelineLayout"
    @usableFromInline static let GPUQuerySet: JSString = "GPUQuerySet"
    @usableFromInline static let GPUQueue: JSString = "GPUQueue"
    @usableFromInline static let GPURenderBundle: JSString = "GPURenderBundle"
    @usableFromInline static let GPURenderBundleEncoder: JSString = "GPURenderBundleEncoder"
    @usableFromInline static let GPURenderPassEncoder: JSString = "GPURenderPassEncoder"
    @usableFromInline static let GPURenderPipeline: JSString = "GPURenderPipeline"
    @usableFromInline static let GPUSampler: JSString = "GPUSampler"
    @usableFromInline static let GPUShaderModule: JSString = "GPUShaderModule"
    @usableFromInline static let GPUShaderStage: JSString = "GPUShaderStage"
    @usableFromInline static let GPUSupportedFeatures: JSString = "GPUSupportedFeatures"
    @usableFromInline static let GPUSupportedLimits: JSString = "GPUSupportedLimits"
    @usableFromInline static let GPUTexture: JSString = "GPUTexture"
    @usableFromInline static let GPUTextureUsage: JSString = "GPUTextureUsage"
    @usableFromInline static let GPUTextureView: JSString = "GPUTextureView"
    @usableFromInline static let GPUUncapturedErrorEvent: JSString = "GPUUncapturedErrorEvent"
    @usableFromInline static let GPUValidationError: JSString = "GPUValidationError"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let WGSLLanguageFeatures: JSString = "WGSLLanguageFeatures"
    @usableFromInline static let a: JSString = "a"
    @usableFromInline static let access: JSString = "access"
    @usableFromInline static let addressModeU: JSString = "addressModeU"
    @usableFromInline static let addressModeV: JSString = "addressModeV"
    @usableFromInline static let addressModeW: JSString = "addressModeW"
    @usableFromInline static let alpha: JSString = "alpha"
    @usableFromInline static let alphaMode: JSString = "alphaMode"
    @usableFromInline static let alphaToCoverageEnabled: JSString = "alphaToCoverageEnabled"
    @usableFromInline static let architecture: JSString = "architecture"
    @usableFromInline static let arrayLayerCount: JSString = "arrayLayerCount"
    @usableFromInline static let arrayStride: JSString = "arrayStride"
    @usableFromInline static let aspect: JSString = "aspect"
    @usableFromInline static let attributes: JSString = "attributes"
    @usableFromInline static let b: JSString = "b"
    @usableFromInline static let baseArrayLayer: JSString = "baseArrayLayer"
    @usableFromInline static let baseMipLevel: JSString = "baseMipLevel"
    @usableFromInline static let beginComputePass: JSString = "beginComputePass"
    @usableFromInline static let beginOcclusionQuery: JSString = "beginOcclusionQuery"
    @usableFromInline static let beginRenderPass: JSString = "beginRenderPass"
    @usableFromInline static let beginningOfPassWriteIndex: JSString = "beginningOfPassWriteIndex"
    @usableFromInline static let bindGroupLayouts: JSString = "bindGroupLayouts"
    @usableFromInline static let binding: JSString = "binding"
    @usableFromInline static let blend: JSString = "blend"
    @usableFromInline static let buffer: JSString = "buffer"
    @usableFromInline static let buffers: JSString = "buffers"
    @usableFromInline static let bytesPerRow: JSString = "bytesPerRow"
    @usableFromInline static let canvas: JSString = "canvas"
    @usableFromInline static let clearBuffer: JSString = "clearBuffer"
    @usableFromInline static let clearValue: JSString = "clearValue"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let color: JSString = "color"
    @usableFromInline static let colorAttachments: JSString = "colorAttachments"
    @usableFromInline static let colorFormats: JSString = "colorFormats"
    @usableFromInline static let colorSpace: JSString = "colorSpace"
    @usableFromInline static let compare: JSString = "compare"
    @usableFromInline static let compute: JSString = "compute"
    @usableFromInline static let configure: JSString = "configure"
    @usableFromInline static let constants: JSString = "constants"
    @usableFromInline static let copyBufferToBuffer: JSString = "copyBufferToBuffer"
    @usableFromInline static let copyBufferToTexture: JSString = "copyBufferToTexture"
    @usableFromInline static let copyExternalImageToTexture: JSString = "copyExternalImageToTexture"
    @usableFromInline static let copyTextureToBuffer: JSString = "copyTextureToBuffer"
    @usableFromInline static let copyTextureToTexture: JSString = "copyTextureToTexture"
    @usableFromInline static let count: JSString = "count"
    @usableFromInline static let createBindGroup: JSString = "createBindGroup"
    @usableFromInline static let createBindGroupLayout: JSString = "createBindGroupLayout"
    @usableFromInline static let createBuffer: JSString = "createBuffer"
    @usableFromInline static let createCommandEncoder: JSString = "createCommandEncoder"
    @usableFromInline static let createComputePipeline: JSString = "createComputePipeline"
    @usableFromInline static let createComputePipelineAsync: JSString = "createComputePipelineAsync"
    @usableFromInline static let createPipelineLayout: JSString = "createPipelineLayout"
    @usableFromInline static let createQuerySet: JSString = "createQuerySet"
    @usableFromInline static let createRenderBundleEncoder: JSString = "createRenderBundleEncoder"
    @usableFromInline static let createRenderPipeline: JSString = "createRenderPipeline"
    @usableFromInline static let createRenderPipelineAsync: JSString = "createRenderPipelineAsync"
    @usableFromInline static let createSampler: JSString = "createSampler"
    @usableFromInline static let createShaderModule: JSString = "createShaderModule"
    @usableFromInline static let createTexture: JSString = "createTexture"
    @usableFromInline static let createView: JSString = "createView"
    @usableFromInline static let cullMode: JSString = "cullMode"
    @usableFromInline static let defaultQueue: JSString = "defaultQueue"
    @usableFromInline static let depthBias: JSString = "depthBias"
    @usableFromInline static let depthBiasClamp: JSString = "depthBiasClamp"
    @usableFromInline static let depthBiasSlopeScale: JSString = "depthBiasSlopeScale"
    @usableFromInline static let depthClearValue: JSString = "depthClearValue"
    @usableFromInline static let depthCompare: JSString = "depthCompare"
    @usableFromInline static let depthFailOp: JSString = "depthFailOp"
    @usableFromInline static let depthLoadOp: JSString = "depthLoadOp"
    @usableFromInline static let depthOrArrayLayers: JSString = "depthOrArrayLayers"
    @usableFromInline static let depthReadOnly: JSString = "depthReadOnly"
    @usableFromInline static let depthStencil: JSString = "depthStencil"
    @usableFromInline static let depthStencilAttachment: JSString = "depthStencilAttachment"
    @usableFromInline static let depthStencilFormat: JSString = "depthStencilFormat"
    @usableFromInline static let depthStoreOp: JSString = "depthStoreOp"
    @usableFromInline static let depthWriteEnabled: JSString = "depthWriteEnabled"
    @usableFromInline static let description: JSString = "description"
    @usableFromInline static let destroy: JSString = "destroy"
    @usableFromInline static let device: JSString = "device"
    @usableFromInline static let dimension: JSString = "dimension"
    @usableFromInline static let dispatchWorkgroups: JSString = "dispatchWorkgroups"
    @usableFromInline static let dispatchWorkgroupsIndirect: JSString = "dispatchWorkgroupsIndirect"
    @usableFromInline static let draw: JSString = "draw"
    @usableFromInline static let drawIndexed: JSString = "drawIndexed"
    @usableFromInline static let drawIndexedIndirect: JSString = "drawIndexedIndirect"
    @usableFromInline static let drawIndirect: JSString = "drawIndirect"
    @usableFromInline static let dstFactor: JSString = "dstFactor"
    @usableFromInline static let end: JSString = "end"
    @usableFromInline static let endOcclusionQuery: JSString = "endOcclusionQuery"
    @usableFromInline static let endOfPassWriteIndex: JSString = "endOfPassWriteIndex"
    @usableFromInline static let entries: JSString = "entries"
    @usableFromInline static let entryPoint: JSString = "entryPoint"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let executeBundles: JSString = "executeBundles"
    @usableFromInline static let externalTexture: JSString = "externalTexture"
    @usableFromInline static let failOp: JSString = "failOp"
    @usableFromInline static let features: JSString = "features"
    @usableFromInline static let finish: JSString = "finish"
    @usableFromInline static let flipY: JSString = "flipY"
    @usableFromInline static let forceFallbackAdapter: JSString = "forceFallbackAdapter"
    @usableFromInline static let format: JSString = "format"
    @usableFromInline static let fragment: JSString = "fragment"
    @usableFromInline static let frontFace: JSString = "frontFace"
    @usableFromInline static let g: JSString = "g"
    @usableFromInline static let getBindGroupLayout: JSString = "getBindGroupLayout"
    @usableFromInline static let getCompilationInfo: JSString = "getCompilationInfo"
    @usableFromInline static let getCurrentTexture: JSString = "getCurrentTexture"
    @usableFromInline static let getMappedRange: JSString = "getMappedRange"
    @usableFromInline static let getPreferredCanvasFormat: JSString = "getPreferredCanvasFormat"
    @usableFromInline static let gpu: JSString = "gpu"
    @usableFromInline static let hasDynamicOffset: JSString = "hasDynamicOffset"
    @usableFromInline static let height: JSString = "height"
    @usableFromInline static let hints: JSString = "hints"
    @usableFromInline static let importExternalTexture: JSString = "importExternalTexture"
    @usableFromInline static let insertDebugMarker: JSString = "insertDebugMarker"
    @usableFromInline static let isFallbackAdapter: JSString = "isFallbackAdapter"
    @usableFromInline static let label: JSString = "label"
    @usableFromInline static let layout: JSString = "layout"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let limits: JSString = "limits"
    @usableFromInline static let lineNum: JSString = "lineNum"
    @usableFromInline static let linePos: JSString = "linePos"
    @usableFromInline static let loadOp: JSString = "loadOp"
    @usableFromInline static let lodMaxClamp: JSString = "lodMaxClamp"
    @usableFromInline static let lodMinClamp: JSString = "lodMinClamp"
    @usableFromInline static let lost: JSString = "lost"
    @usableFromInline static let magFilter: JSString = "magFilter"
    @usableFromInline static let mapAsync: JSString = "mapAsync"
    @usableFromInline static let mapState: JSString = "mapState"
    @usableFromInline static let mappedAtCreation: JSString = "mappedAtCreation"
    @usableFromInline static let mask: JSString = "mask"
    @usableFromInline static let maxAnisotropy: JSString = "maxAnisotropy"
    @usableFromInline static let maxBindGroups: JSString = "maxBindGroups"
    @usableFromInline static let maxBindGroupsPlusVertexBuffers: JSString = "maxBindGroupsPlusVertexBuffers"
    @usableFromInline static let maxBindingsPerBindGroup: JSString = "maxBindingsPerBindGroup"
    @usableFromInline static let maxBufferSize: JSString = "maxBufferSize"
    @usableFromInline static let maxColorAttachmentBytesPerSample: JSString = "maxColorAttachmentBytesPerSample"
    @usableFromInline static let maxColorAttachments: JSString = "maxColorAttachments"
    @usableFromInline static let maxComputeInvocationsPerWorkgroup: JSString = "maxComputeInvocationsPerWorkgroup"
    @usableFromInline static let maxComputeWorkgroupSizeX: JSString = "maxComputeWorkgroupSizeX"
    @usableFromInline static let maxComputeWorkgroupSizeY: JSString = "maxComputeWorkgroupSizeY"
    @usableFromInline static let maxComputeWorkgroupSizeZ: JSString = "maxComputeWorkgroupSizeZ"
    @usableFromInline static let maxComputeWorkgroupStorageSize: JSString = "maxComputeWorkgroupStorageSize"
    @usableFromInline static let maxComputeWorkgroupsPerDimension: JSString = "maxComputeWorkgroupsPerDimension"
    @usableFromInline static let maxDrawCount: JSString = "maxDrawCount"
    @usableFromInline static let maxDynamicStorageBuffersPerPipelineLayout: JSString = "maxDynamicStorageBuffersPerPipelineLayout"
    @usableFromInline static let maxDynamicUniformBuffersPerPipelineLayout: JSString = "maxDynamicUniformBuffersPerPipelineLayout"
    @usableFromInline static let maxInterStageShaderComponents: JSString = "maxInterStageShaderComponents"
    @usableFromInline static let maxInterStageShaderVariables: JSString = "maxInterStageShaderVariables"
    @usableFromInline static let maxSampledTexturesPerShaderStage: JSString = "maxSampledTexturesPerShaderStage"
    @usableFromInline static let maxSamplersPerShaderStage: JSString = "maxSamplersPerShaderStage"
    @usableFromInline static let maxStorageBufferBindingSize: JSString = "maxStorageBufferBindingSize"
    @usableFromInline static let maxStorageBuffersPerShaderStage: JSString = "maxStorageBuffersPerShaderStage"
    @usableFromInline static let maxStorageTexturesPerShaderStage: JSString = "maxStorageTexturesPerShaderStage"
    @usableFromInline static let maxTextureArrayLayers: JSString = "maxTextureArrayLayers"
    @usableFromInline static let maxTextureDimension1D: JSString = "maxTextureDimension1D"
    @usableFromInline static let maxTextureDimension2D: JSString = "maxTextureDimension2D"
    @usableFromInline static let maxTextureDimension3D: JSString = "maxTextureDimension3D"
    @usableFromInline static let maxUniformBufferBindingSize: JSString = "maxUniformBufferBindingSize"
    @usableFromInline static let maxUniformBuffersPerShaderStage: JSString = "maxUniformBuffersPerShaderStage"
    @usableFromInline static let maxVertexAttributes: JSString = "maxVertexAttributes"
    @usableFromInline static let maxVertexBufferArrayStride: JSString = "maxVertexBufferArrayStride"
    @usableFromInline static let maxVertexBuffers: JSString = "maxVertexBuffers"
    @usableFromInline static let message: JSString = "message"
    @usableFromInline static let messages: JSString = "messages"
    @usableFromInline static let minBindingSize: JSString = "minBindingSize"
    @usableFromInline static let minFilter: JSString = "minFilter"
    @usableFromInline static let minStorageBufferOffsetAlignment: JSString = "minStorageBufferOffsetAlignment"
    @usableFromInline static let minUniformBufferOffsetAlignment: JSString = "minUniformBufferOffsetAlignment"
    @usableFromInline static let mipLevel: JSString = "mipLevel"
    @usableFromInline static let mipLevelCount: JSString = "mipLevelCount"
    @usableFromInline static let mipmapFilter: JSString = "mipmapFilter"
    @usableFromInline static let module: JSString = "module"
    @usableFromInline static let multisample: JSString = "multisample"
    @usableFromInline static let multisampled: JSString = "multisampled"
    @usableFromInline static let occlusionQuerySet: JSString = "occlusionQuerySet"
    @usableFromInline static let offset: JSString = "offset"
    @usableFromInline static let onSubmittedWorkDone: JSString = "onSubmittedWorkDone"
    @usableFromInline static let onuncapturederror: JSString = "onuncapturederror"
    @usableFromInline static let operation: JSString = "operation"
    @usableFromInline static let origin: JSString = "origin"
    @usableFromInline static let passOp: JSString = "passOp"
    @usableFromInline static let popDebugGroup: JSString = "popDebugGroup"
    @usableFromInline static let popErrorScope: JSString = "popErrorScope"
    @usableFromInline static let powerPreference: JSString = "powerPreference"
    @usableFromInline static let premultipliedAlpha: JSString = "premultipliedAlpha"
    @usableFromInline static let primitive: JSString = "primitive"
    @usableFromInline static let pushDebugGroup: JSString = "pushDebugGroup"
    @usableFromInline static let pushErrorScope: JSString = "pushErrorScope"
    @usableFromInline static let querySet: JSString = "querySet"
    @usableFromInline static let queue: JSString = "queue"
    @usableFromInline static let r: JSString = "r"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let requestAdapter: JSString = "requestAdapter"
    @usableFromInline static let requestAdapterInfo: JSString = "requestAdapterInfo"
    @usableFromInline static let requestDevice: JSString = "requestDevice"
    @usableFromInline static let requiredFeatures: JSString = "requiredFeatures"
    @usableFromInline static let requiredLimits: JSString = "requiredLimits"
    @usableFromInline static let resolveQuerySet: JSString = "resolveQuerySet"
    @usableFromInline static let resolveTarget: JSString = "resolveTarget"
    @usableFromInline static let resource: JSString = "resource"
    @usableFromInline static let rowsPerImage: JSString = "rowsPerImage"
    @usableFromInline static let sampleCount: JSString = "sampleCount"
    @usableFromInline static let sampleType: JSString = "sampleType"
    @usableFromInline static let sampler: JSString = "sampler"
    @usableFromInline static let setBindGroup: JSString = "setBindGroup"
    @usableFromInline static let setBlendConstant: JSString = "setBlendConstant"
    @usableFromInline static let setIndexBuffer: JSString = "setIndexBuffer"
    @usableFromInline static let setPipeline: JSString = "setPipeline"
    @usableFromInline static let setScissorRect: JSString = "setScissorRect"
    @usableFromInline static let setStencilReference: JSString = "setStencilReference"
    @usableFromInline static let setVertexBuffer: JSString = "setVertexBuffer"
    @usableFromInline static let setViewport: JSString = "setViewport"
    @usableFromInline static let shaderLocation: JSString = "shaderLocation"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let source: JSString = "source"
    @usableFromInline static let sourceMap: JSString = "sourceMap"
    @usableFromInline static let srcFactor: JSString = "srcFactor"
    @usableFromInline static let stencilBack: JSString = "stencilBack"
    @usableFromInline static let stencilClearValue: JSString = "stencilClearValue"
    @usableFromInline static let stencilFront: JSString = "stencilFront"
    @usableFromInline static let stencilLoadOp: JSString = "stencilLoadOp"
    @usableFromInline static let stencilReadMask: JSString = "stencilReadMask"
    @usableFromInline static let stencilReadOnly: JSString = "stencilReadOnly"
    @usableFromInline static let stencilStoreOp: JSString = "stencilStoreOp"
    @usableFromInline static let stencilWriteMask: JSString = "stencilWriteMask"
    @usableFromInline static let stepMode: JSString = "stepMode"
    @usableFromInline static let storageTexture: JSString = "storageTexture"
    @usableFromInline static let storeOp: JSString = "storeOp"
    @usableFromInline static let stripIndexFormat: JSString = "stripIndexFormat"
    @usableFromInline static let submit: JSString = "submit"
    @usableFromInline static let targets: JSString = "targets"
    @usableFromInline static let texture: JSString = "texture"
    @usableFromInline static let timestampWrites: JSString = "timestampWrites"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let topology: JSString = "topology"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let unclippedDepth: JSString = "unclippedDepth"
    @usableFromInline static let unconfigure: JSString = "unconfigure"
    @usableFromInline static let unmap: JSString = "unmap"
    @usableFromInline static let usage: JSString = "usage"
    @usableFromInline static let vendor: JSString = "vendor"
    @usableFromInline static let vertex: JSString = "vertex"
    @usableFromInline static let view: JSString = "view"
    @usableFromInline static let viewDimension: JSString = "viewDimension"
    @usableFromInline static let viewFormats: JSString = "viewFormats"
    @usableFromInline static let visibility: JSString = "visibility"
    @usableFromInline static let wgslLanguageFeatures: JSString = "wgslLanguageFeatures"
    @usableFromInline static let width: JSString = "width"
    @usableFromInline static let writeBuffer: JSString = "writeBuffer"
    @usableFromInline static let writeMask: JSString = "writeMask"
    @usableFromInline static let writeTexture: JSString = "writeTexture"
    @usableFromInline static let writeTimestamp: JSString = "writeTimestamp"
    @usableFromInline static let x: JSString = "x"
    @usableFromInline static let y: JSString = "y"
    @usableFromInline static let z: JSString = "z"
}

public protocol Any_GPUAutoLayoutMode_or_GPUPipelineLayout: ConvertibleToJSValue {}
extension GPUAutoLayoutMode: Any_GPUAutoLayoutMode_or_GPUPipelineLayout {}
extension GPUPipelineLayout: Any_GPUAutoLayoutMode_or_GPUPipelineLayout {}

public enum GPUAutoLayoutMode_or_GPUPipelineLayout: JSValueCompatible, Any_GPUAutoLayoutMode_or_GPUPipelineLayout {
    case gpuAutoLayoutMode(GPUAutoLayoutMode)
    case gpuPipelineLayout(GPUPipelineLayout)

    init(_ gpuAutoLayoutMode: GPUAutoLayoutMode) {
        let val: GPUAutoLayoutMode_or_GPUPipelineLayout = .gpuAutoLayoutMode(gpuAutoLayoutMode)
        self = val
    }

    init(_ gpuPipelineLayout: GPUPipelineLayout) {
        let val: GPUAutoLayoutMode_or_GPUPipelineLayout = .gpuPipelineLayout(gpuPipelineLayout)
        self = val
    }

    public var gpuAutoLayoutMode: GPUAutoLayoutMode? {
        switch self {
        case let .gpuAutoLayoutMode(gpuAutoLayoutMode): return gpuAutoLayoutMode
        default: return nil
        }
    }

    public var gpuPipelineLayout: GPUPipelineLayout? {
        switch self {
        case let .gpuPipelineLayout(gpuPipelineLayout): return gpuPipelineLayout
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuAutoLayoutMode: GPUAutoLayoutMode = value.fromJSValue() {
            return .gpuAutoLayoutMode(gpuAutoLayoutMode)
        }
        if let gpuPipelineLayout: GPUPipelineLayout = value.fromJSValue() {
            return .gpuPipelineLayout(gpuPipelineLayout)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuAutoLayoutMode(gpuAutoLayoutMode):
            return gpuAutoLayoutMode.jsValue
        case let .gpuPipelineLayout(gpuPipelineLayout):
            return gpuPipelineLayout.jsValue
        }
    }
}

public protocol Any_GPUBindingResource: ConvertibleToJSValue {}
extension GPUBufferBinding: Any_GPUBindingResource {}
extension GPUExternalTexture: Any_GPUBindingResource {}
extension GPUSampler: Any_GPUBindingResource {}
extension GPUTextureView: Any_GPUBindingResource {}

public enum GPUBindingResource: JSValueCompatible, Any_GPUBindingResource {
    case gpuBufferBinding(GPUBufferBinding)
    case gpuExternalTexture(GPUExternalTexture)
    case gpuSampler(GPUSampler)
    case gpuTextureView(GPUTextureView)

    init(_ gpuBufferBinding: GPUBufferBinding) {
        let val: GPUBindingResource = .gpuBufferBinding(gpuBufferBinding)
        self = val
    }

    init(_ gpuExternalTexture: GPUExternalTexture) {
        let val: GPUBindingResource = .gpuExternalTexture(gpuExternalTexture)
        self = val
    }

    init(_ gpuSampler: GPUSampler) {
        let val: GPUBindingResource = .gpuSampler(gpuSampler)
        self = val
    }

    init(_ gpuTextureView: GPUTextureView) {
        let val: GPUBindingResource = .gpuTextureView(gpuTextureView)
        self = val
    }

    public var gpuBufferBinding: GPUBufferBinding? {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding): return gpuBufferBinding
        default: return nil
        }
    }

    public var gpuExternalTexture: GPUExternalTexture? {
        switch self {
        case let .gpuExternalTexture(gpuExternalTexture): return gpuExternalTexture
        default: return nil
        }
    }

    public var gpuSampler: GPUSampler? {
        switch self {
        case let .gpuSampler(gpuSampler): return gpuSampler
        default: return nil
        }
    }

    public var gpuTextureView: GPUTextureView? {
        switch self {
        case let .gpuTextureView(gpuTextureView): return gpuTextureView
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuBufferBinding: GPUBufferBinding = value.fromJSValue() {
            return .gpuBufferBinding(gpuBufferBinding)
        }
        if let gpuExternalTexture: GPUExternalTexture = value.fromJSValue() {
            return .gpuExternalTexture(gpuExternalTexture)
        }
        if let gpuSampler: GPUSampler = value.fromJSValue() {
            return .gpuSampler(gpuSampler)
        }
        if let gpuTextureView: GPUTextureView = value.fromJSValue() {
            return .gpuTextureView(gpuTextureView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding):
            return gpuBufferBinding.jsValue
        case let .gpuExternalTexture(gpuExternalTexture):
            return gpuExternalTexture.jsValue
        case let .gpuSampler(gpuSampler):
            return gpuSampler.jsValue
        case let .gpuTextureView(gpuTextureView):
            return gpuTextureView.jsValue
        }
    }
}

public protocol Any_GPUColor: ConvertibleToJSValue {}
extension GPUColorDict: Any_GPUColor {}
extension Array: Any_GPUColor where Element == Double {}

public enum GPUColor: JSValueCompatible, Any_GPUColor {
    case gpuColorDict(GPUColorDict)
    case seq_of_Double([Double])

    init(_ gpuColorDict: GPUColorDict) {
        let val: GPUColor = .gpuColorDict(gpuColorDict)
        self = val
    }

    init(_ seq_of_Double: [Double]) {
        let val: GPUColor = .seq_of_Double(seq_of_Double)
        self = val
    }

    public var gpuColorDict: GPUColorDict? {
        switch self {
        case let .gpuColorDict(gpuColorDict): return gpuColorDict
        default: return nil
        }
    }

    public var seq_of_Double: [Double]? {
        switch self {
        case let .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuColorDict: GPUColorDict = value.fromJSValue() {
            return .gpuColorDict(gpuColorDict)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuColorDict(gpuColorDict):
            return gpuColorDict.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public protocol Any_GPUExtent3D: ConvertibleToJSValue {}
extension GPUExtent3DDict: Any_GPUExtent3D {}
extension Array: Any_GPUExtent3D where Element == GPUIntegerCoordinate {}

public enum GPUExtent3D: JSValueCompatible, Any_GPUExtent3D {
    case gpuExtent3DDict(GPUExtent3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    init(_ gpuExtent3DDict: GPUExtent3DDict) {
        let val: GPUExtent3D = .gpuExtent3DDict(gpuExtent3DDict)
        self = val
    }

    init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        let val: GPUExtent3D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        self = val
    }

    public var gpuExtent3DDict: GPUExtent3DDict? {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict): return gpuExtent3DDict
        default: return nil
        }
    }

    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuExtent3DDict: GPUExtent3DDict = value.fromJSValue() {
            return .gpuExtent3DDict(gpuExtent3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict):
            return gpuExtent3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_GPUImageCopyExternalImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_GPUImageCopyExternalImageSource {}
extension HTMLVideoElement: Any_GPUImageCopyExternalImageSource {}
extension ImageBitmap: Any_GPUImageCopyExternalImageSource {}
extension OffscreenCanvas: Any_GPUImageCopyExternalImageSource {}
extension VideoFrame: Any_GPUImageCopyExternalImageSource {}

public enum GPUImageCopyExternalImageSource: JSValueCompatible, Any_GPUImageCopyExternalImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    init(_ htmlCanvasElement: HTMLCanvasElement) {
        let val: GPUImageCopyExternalImageSource = .htmlCanvasElement(htmlCanvasElement)
        self = val
    }

    init(_ htmlVideoElement: HTMLVideoElement) {
        let val: GPUImageCopyExternalImageSource = .htmlVideoElement(htmlVideoElement)
        self = val
    }

    init(_ imageBitmap: ImageBitmap) {
        let val: GPUImageCopyExternalImageSource = .imageBitmap(imageBitmap)
        self = val
    }

    init(_ offscreenCanvas: OffscreenCanvas) {
        let val: GPUImageCopyExternalImageSource = .offscreenCanvas(offscreenCanvas)
        self = val
    }

    init(_ videoFrame: VideoFrame) {
        let val: GPUImageCopyExternalImageSource = .videoFrame(videoFrame)
        self = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    public var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_GPUOrigin2D: ConvertibleToJSValue {}
extension GPUOrigin2DDict: Any_GPUOrigin2D {}
extension Array: Any_GPUOrigin2D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin2D: JSValueCompatible, Any_GPUOrigin2D {
    case gpuOrigin2DDict(GPUOrigin2DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    init(_ gpuOrigin2DDict: GPUOrigin2DDict) {
        let val: GPUOrigin2D = .gpuOrigin2DDict(gpuOrigin2DDict)
        self = val
    }

    init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        let val: GPUOrigin2D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        self = val
    }

    public var gpuOrigin2DDict: GPUOrigin2DDict? {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict): return gpuOrigin2DDict
        default: return nil
        }
    }

    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin2DDict: GPUOrigin2DDict = value.fromJSValue() {
            return .gpuOrigin2DDict(gpuOrigin2DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict):
            return gpuOrigin2DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_GPUOrigin3D: ConvertibleToJSValue {}
extension GPUOrigin3DDict: Any_GPUOrigin3D {}
extension Array: Any_GPUOrigin3D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin3D: JSValueCompatible, Any_GPUOrigin3D {
    case gpuOrigin3DDict(GPUOrigin3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    init(_ gpuOrigin3DDict: GPUOrigin3DDict) {
        let val: GPUOrigin3D = .gpuOrigin3DDict(gpuOrigin3DDict)
        self = val
    }

    init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        let val: GPUOrigin3D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        self = val
    }

    public var gpuOrigin3DDict: GPUOrigin3DDict? {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict): return gpuOrigin3DDict
        default: return nil
        }
    }

    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin3DDict: GPUOrigin3DDict = value.fromJSValue() {
            return .gpuOrigin3DDict(gpuOrigin3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict):
            return gpuOrigin3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    init(_ htmlCanvasElement: HTMLCanvasElement) {
        let val: HTMLCanvasElement_or_OffscreenCanvas = .htmlCanvasElement(htmlCanvasElement)
        self = val
    }

    init(_ offscreenCanvas: OffscreenCanvas) {
        let val: HTMLCanvasElement_or_OffscreenCanvas = .offscreenCanvas(offscreenCanvas)
        self = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLVideoElement_or_VideoFrame: ConvertibleToJSValue {}
extension HTMLVideoElement: Any_HTMLVideoElement_or_VideoFrame {}
extension VideoFrame: Any_HTMLVideoElement_or_VideoFrame {}

public enum HTMLVideoElement_or_VideoFrame: JSValueCompatible, Any_HTMLVideoElement_or_VideoFrame {
    case htmlVideoElement(HTMLVideoElement)
    case videoFrame(VideoFrame)

    init(_ htmlVideoElement: HTMLVideoElement) {
        let val: HTMLVideoElement_or_VideoFrame = .htmlVideoElement(htmlVideoElement)
        self = val
    }

    init(_ videoFrame: VideoFrame) {
        let val: HTMLVideoElement_or_VideoFrame = .videoFrame(videoFrame)
        self = val
    }

    public var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    public var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}
