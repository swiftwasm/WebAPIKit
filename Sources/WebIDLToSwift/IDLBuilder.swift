import Foundation
import WebIDL

enum IDLBuilder {
    static let preamble = """
    // This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

    import JavaScriptKit
    import JavaScriptEventLoop
    \n
    """

    static let outDir = "Sources/DOMKit/WebIDL/"
    static func writeFile(named name: String, content: String) throws {
        let path = outDir + name + ".swift"
        if FileManager.default.fileExists(atPath: path) {
            fatalError("file already exists for \(name)")
        } else {
            try (preamble + content).write(toFile: path, atomically: true, encoding: .utf8)
        }
    }

    static func cleanOutputFolder() throws {
        for file in try FileManager.default.contentsOfDirectory(atPath: outDir) {
            try FileManager.default.removeItem(atPath: outDir + file)
        }
    }

    static func generateIDLBindings(idl: [String: GenericCollection<IDLNode>]) throws {
        let declarations = [
            "dom", "hr-time", "html", "console", "FileAPI", "geometry", "webidl", "fetch", "xhr",
            "referrer-policy", "uievents", "wai-aria", "cssom", "css-conditional", "streams",
        ].flatMap { idl[$0]!.array }
        let merged = DeclarationMerger.merge(declarations: declarations)
        for (i, node) in merged.declarations.enumerated() {
            guard let nameNode = Mirror(reflecting: node).children.first(where: { $0.label == "name" }),
                  let name = nameNode.value as? String
            else {
                fatalError("Cannot find name for \(node)")
            }
            let content = Context.withState(.root(
                interfaces: merged.interfaces,
                ignored: [
                    // functions as parameters are unsupported
                    "EventTarget": ["addEventListener", "removeEventListener"],
                    "HTMLCanvasElement": ["toBlob"],
                    "AnimationFrameProvider": ["requestAnimationFrame"],
                    "DataTransferItem": ["getAsString"],
                    "WindowOrWorkerGlobalScope": ["queueMicrotask"],
                    "MutationObserver": ["<constructor>"],
                    // functions as return types are unsupported
                    "CustomElementRegistry": ["define", "whenDefined"],
                    // NodeFilter
                    "Document": ["createNodeIterator", "createTreeWalker"],
                    "TreeWalker": ["filter"],
                    "NodeIterator": ["filter"],
                    // invalid overload in Swift
                    "BeforeUnloadEvent": ["returnValue"],
                    // XPathNSResolver
                    "XPathEvaluatorBase": ["createExpression", "createNSResolver", "evaluate"],
                ],
                types: merged.types
            )) {
                toSwift(node).source
            }
            try writeFile(named: name, content: content)
        }
    }

    static func generateClosureTypes() throws {
        let argCounts = Context.requiredClosureArgCounts.sorted()
        let closureTypesContent: SwiftSource = """
        /* variadic generics please */
        public enum ClosureAttribute {
            // MARK: Required closures
            \(lines: argCounts.map { ClosureWrapper(nullable: false, argCount: $0).swiftRepresentation })

            // MARK: - Optional closures
            \(lines: argCounts.map { ClosureWrapper(nullable: true, argCount: $0).swiftRepresentation })
        }
        """

        try writeFile(named: "ClosureAttribute", content: closureTypesContent.source)
    }

    static func generateStrings() throws {
        let strings = Context.strings.sorted()
        let stringsContent: SwiftSource = """
            enum Strings {
                static let _self: JSString = "self"
                \(lines: strings.map { "static let \($0): JSString = \(quoted: $0)" })
            }
        """

        try writeFile(named: "Strings", content: stringsContent.source)
    }
}
