// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public protocol Body: JSBridgedClass {}
public extension Body {
    // XXX: attribute 'body' is ignored

    @inlinable var bodyUsed: Bool { ReadonlyAttribute[Strings.bodyUsed, in: jsObject] }

    @inlinable func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func blob() -> JSPromise {
        let this = jsObject
        return this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func blob() async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func formData() -> JSPromise {
        let this = jsObject
        return this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func formData() async throws -> FormData {
        let this = jsObject
        let _promise: JSPromise = this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func json() -> JSPromise {
        let this = jsObject
        return this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func json() async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func text() -> JSPromise {
        let this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class Headers: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Headers].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: HeadersInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [name.jsValue])
    }

    @inlinable public func get(name: String) -> String? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<Headers> {
        ValueIterableIterator(sequence: self)
    }
}

public class Request: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Request].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _method = ReadonlyAttribute(jsObject: jsObject, name: Strings.method)
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: Strings.headers)
        _destination = ReadonlyAttribute(jsObject: jsObject, name: Strings.destination)
        _referrer = ReadonlyAttribute(jsObject: jsObject, name: Strings.referrer)
        _referrerPolicy = ReadonlyAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _mode = ReadonlyAttribute(jsObject: jsObject, name: Strings.mode)
        _credentials = ReadonlyAttribute(jsObject: jsObject, name: Strings.credentials)
        _cache = ReadonlyAttribute(jsObject: jsObject, name: Strings.cache)
        _redirect = ReadonlyAttribute(jsObject: jsObject, name: Strings.redirect)
        _integrity = ReadonlyAttribute(jsObject: jsObject, name: Strings.integrity)
        _keepalive = ReadonlyAttribute(jsObject: jsObject, name: Strings.keepalive)
        _isReloadNavigation = ReadonlyAttribute(jsObject: jsObject, name: Strings.isReloadNavigation)
        _isHistoryNavigation = ReadonlyAttribute(jsObject: jsObject, name: Strings.isHistoryNavigation)
        _signal = ReadonlyAttribute(jsObject: jsObject, name: Strings.signal)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(input: RequestInfo, init: RequestInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [input.jsValue, `init`?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var method: String

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var headers: Headers

    @ReadonlyAttribute
    public var destination: RequestDestination

    @ReadonlyAttribute
    public var referrer: String

    @ReadonlyAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadonlyAttribute
    public var mode: RequestMode

    @ReadonlyAttribute
    public var credentials: RequestCredentials

    @ReadonlyAttribute
    public var cache: RequestCache

    @ReadonlyAttribute
    public var redirect: RequestRedirect

    @ReadonlyAttribute
    public var integrity: String

    @ReadonlyAttribute
    public var keepalive: Bool

    @ReadonlyAttribute
    public var isReloadNavigation: Bool

    @ReadonlyAttribute
    public var isHistoryNavigation: Bool

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum RequestCache: JSString, JSValueCompatible {
    case `default` = "default"
    case noStore = "no-store"
    case reload = "reload"
    case noCache = "no-cache"
    case forceCache = "force-cache"
    case onlyIfCached = "only-if-cached"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestCredentials: JSString, JSValueCompatible {
    case omit = "omit"
    case sameOrigin = "same-origin"
    case include = "include"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestDestination: JSString, JSValueCompatible {
    case _empty = ""
    case audio = "audio"
    case audioworklet = "audioworklet"
    case document = "document"
    case embed = "embed"
    case font = "font"
    case frame = "frame"
    case iframe = "iframe"
    case image = "image"
    case manifest = "manifest"
    case object = "object"
    case paintworklet = "paintworklet"
    case report = "report"
    case script = "script"
    case sharedworker = "sharedworker"
    case style = "style"
    case track = "track"
    case video = "video"
    case worker = "worker"
    case xslt = "xslt"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RequestInit: BridgedDictionary {
    public convenience init(method: String, headers: HeadersInit, body: BodyInit?, referrer: String, referrerPolicy: ReferrerPolicy, mode: RequestMode, credentials: RequestCredentials, cache: RequestCache, redirect: RequestRedirect, integrity: String, keepalive: Bool, signal: AbortSignal?, window: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.method] = method.jsValue
        object[Strings.headers] = headers.jsValue
        object[Strings.body] = body.jsValue
        object[Strings.referrer] = referrer.jsValue
        object[Strings.referrerPolicy] = referrerPolicy.jsValue
        object[Strings.mode] = mode.jsValue
        object[Strings.credentials] = credentials.jsValue
        object[Strings.cache] = cache.jsValue
        object[Strings.redirect] = redirect.jsValue
        object[Strings.integrity] = integrity.jsValue
        object[Strings.keepalive] = keepalive.jsValue
        object[Strings.signal] = signal.jsValue
        object[Strings.window] = window.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _method = ReadWriteAttribute(jsObject: object, name: Strings.method)
        _headers = ReadWriteAttribute(jsObject: object, name: Strings.headers)
        _body = ReadWriteAttribute(jsObject: object, name: Strings.body)
        _referrer = ReadWriteAttribute(jsObject: object, name: Strings.referrer)
        _referrerPolicy = ReadWriteAttribute(jsObject: object, name: Strings.referrerPolicy)
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        _credentials = ReadWriteAttribute(jsObject: object, name: Strings.credentials)
        _cache = ReadWriteAttribute(jsObject: object, name: Strings.cache)
        _redirect = ReadWriteAttribute(jsObject: object, name: Strings.redirect)
        _integrity = ReadWriteAttribute(jsObject: object, name: Strings.integrity)
        _keepalive = ReadWriteAttribute(jsObject: object, name: Strings.keepalive)
        _signal = ReadWriteAttribute(jsObject: object, name: Strings.signal)
        _window = ReadWriteAttribute(jsObject: object, name: Strings.window)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var headers: HeadersInit

    @ReadWriteAttribute
    public var body: BodyInit?

    @ReadWriteAttribute
    public var referrer: String

    @ReadWriteAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadWriteAttribute
    public var mode: RequestMode

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var cache: RequestCache

    @ReadWriteAttribute
    public var redirect: RequestRedirect

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var keepalive: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal?

    @ReadWriteAttribute
    public var window: JSValue
}

public enum RequestMode: JSString, JSValueCompatible {
    case navigate = "navigate"
    case sameOrigin = "same-origin"
    case noCors = "no-cors"
    case cors = "cors"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestRedirect: JSString, JSValueCompatible {
    case follow = "follow"
    case error = "error"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Response: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Response].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _redirected = ReadonlyAttribute(jsObject: jsObject, name: Strings.redirected)
        _status = ReadonlyAttribute(jsObject: jsObject, name: Strings.status)
        _ok = ReadonlyAttribute(jsObject: jsObject, name: Strings.ok)
        _statusText = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusText)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: Strings.headers)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(body: BodyInit? = nil, init: ResponseInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [body?.jsValue ?? .undefined, `init`?.jsValue ?? .undefined]))
    }

    @inlinable public static func error() -> Self {
        let this = constructor
        return this[Strings.error].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public static func redirect(url: String, status: UInt16? = nil) -> Self {
        let this = constructor
        return this[Strings.redirect].function!(this: this, arguments: [url.jsValue, status?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var type: ResponseType

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var redirected: Bool

    @ReadonlyAttribute
    public var status: UInt16

    @ReadonlyAttribute
    public var ok: Bool

    @ReadonlyAttribute
    public var statusText: String

    @ReadonlyAttribute
    public var headers: Headers

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ResponseInit: BridgedDictionary {
    public convenience init(status: UInt16, statusText: String, headers: HeadersInit) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.status] = status.jsValue
        object[Strings.statusText] = statusText.jsValue
        object[Strings.headers] = headers.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _status = ReadWriteAttribute(jsObject: object, name: Strings.status)
        _statusText = ReadWriteAttribute(jsObject: object, name: Strings.statusText)
        _headers = ReadWriteAttribute(jsObject: object, name: Strings.headers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var status: UInt16

    @ReadWriteAttribute
    public var statusText: String

    @ReadWriteAttribute
    public var headers: HeadersInit
}

public enum ResponseType: JSString, JSValueCompatible {
    case basic = "basic"
    case cors = "cors"
    case `default` = "default"
    case error = "error"
    case opaque = "opaque"
    case opaqueredirect = "opaqueredirect"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol WindowOrWorkerGlobalScope: JSBridgedClass {}
public extension WindowOrWorkerGlobalScope {
    @inlinable func fetch(input: RequestInfo, init: RequestInit? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.fetch].function!(this: this, arguments: [input.jsValue, `init`?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func fetch(input: RequestInfo, init: RequestInit? = nil) async throws -> Response {
        let this = jsObject
        let _promise: JSPromise = this[Strings.fetch].function!(this: this, arguments: [input.jsValue, `init`?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

/* variadic generics please */

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let Headers: JSString = "Headers"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let Request: JSString = "Request"
    @usableFromInline static let Response: JSString = "Response"
    @usableFromInline static let append: JSString = "append"
    @usableFromInline static let arrayBuffer: JSString = "arrayBuffer"
    @usableFromInline static let blob: JSString = "blob"
    @usableFromInline static let body: JSString = "body"
    @usableFromInline static let bodyUsed: JSString = "bodyUsed"
    @usableFromInline static let cache: JSString = "cache"
    @usableFromInline static let clone: JSString = "clone"
    @usableFromInline static let credentials: JSString = "credentials"
    @usableFromInline static let delete: JSString = "delete"
    @usableFromInline static let destination: JSString = "destination"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let fetch: JSString = "fetch"
    @usableFromInline static let formData: JSString = "formData"
    @usableFromInline static let get: JSString = "get"
    @usableFromInline static let has: JSString = "has"
    @usableFromInline static let headers: JSString = "headers"
    @usableFromInline static let integrity: JSString = "integrity"
    @usableFromInline static let isHistoryNavigation: JSString = "isHistoryNavigation"
    @usableFromInline static let isReloadNavigation: JSString = "isReloadNavigation"
    @usableFromInline static let json: JSString = "json"
    @usableFromInline static let keepalive: JSString = "keepalive"
    @usableFromInline static let method: JSString = "method"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let ok: JSString = "ok"
    @usableFromInline static let redirect: JSString = "redirect"
    @usableFromInline static let redirected: JSString = "redirected"
    @usableFromInline static let referrer: JSString = "referrer"
    @usableFromInline static let referrerPolicy: JSString = "referrerPolicy"
    @usableFromInline static let set: JSString = "set"
    @usableFromInline static let signal: JSString = "signal"
    @usableFromInline static let status: JSString = "status"
    @usableFromInline static let statusText: JSString = "statusText"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let url: JSString = "url"
    @usableFromInline static let window: JSString = "window"
}

public protocol Any_HeadersInit: ConvertibleToJSValue {}
extension Dictionary: Any_HeadersInit where Key == String, Value == String {}
extension Array: Any_HeadersInit where Element == [String] {}

public enum HeadersInit: JSValueCompatible, Any_HeadersInit {
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_RequestInfo: ConvertibleToJSValue {}
extension Request: Any_RequestInfo {}
extension String: Any_RequestInfo {}

public enum RequestInfo: JSValueCompatible, Any_RequestInfo {
    case request(Request)
    case string(String)

    var request: Request? {
        switch self {
        case let .request(request): return request
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let request: Request = value.fromJSValue() {
            return .request(request)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .request(request):
            return request.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Blob: Any_XMLHttpRequestBodyInit {}
extension BufferSource: Any_XMLHttpRequestBodyInit {}
extension FormData: Any_XMLHttpRequestBodyInit {}
extension String: Any_XMLHttpRequestBodyInit {}
extension URLSearchParams: Any_XMLHttpRequestBodyInit {}

public enum XMLHttpRequestBodyInit: JSValueCompatible, Any_XMLHttpRequestBodyInit {
    case blob(Blob)
    case bufferSource(BufferSource)
    case formData(FormData)
    case string(String)
    case urlSearchParams(URLSearchParams)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var urlSearchParams: URLSearchParams? {
        switch self {
        case let .urlSearchParams(urlSearchParams): return urlSearchParams
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let urlSearchParams: URLSearchParams = value.fromJSValue() {
            return .urlSearchParams(urlSearchParams)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        case let .urlSearchParams(urlSearchParams):
            return urlSearchParams.jsValue
        }
    }
}
