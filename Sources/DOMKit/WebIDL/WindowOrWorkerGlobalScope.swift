// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public protocol WindowOrWorkerGlobalScope: JSBridgedClass {}
public extension WindowOrWorkerGlobalScope {
    func fetch(input: RequestInfo, init: RequestInit? = nil) -> JSPromise {
        jsObject[Strings.fetch]!(input.jsValue(), `init`?.jsValue() ?? .undefined).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    func fetch(input: RequestInfo, init: RequestInit? = nil) async throws -> Response {
        let _promise: JSPromise = jsObject[Strings.fetch]!(input.jsValue(), `init`?.jsValue() ?? .undefined).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    var indexedDB: IDBFactory { ReadonlyAttribute[Strings.indexedDB, in: jsObject] }

    var trustedTypes: TrustedTypePolicyFactory { ReadonlyAttribute[Strings.trustedTypes, in: jsObject] }

    var performance: Performance { ReadonlyAttribute[Strings.performance, in: jsObject] }

    var crypto: Crypto { ReadonlyAttribute[Strings.crypto, in: jsObject] }

    var scheduler: Scheduler { ReadonlyAttribute[Strings.scheduler, in: jsObject] }

    var origin: String { ReadonlyAttribute[Strings.origin, in: jsObject] }

    var isSecureContext: Bool { ReadonlyAttribute[Strings.isSecureContext, in: jsObject] }

    var crossOriginIsolated: Bool { ReadonlyAttribute[Strings.crossOriginIsolated, in: jsObject] }

    func reportError(e: JSValue) {
        _ = jsObject[Strings.reportError]!(e.jsValue())
    }

    func btoa(data: String) -> String {
        jsObject[Strings.btoa]!(data.jsValue()).fromJSValue()!
    }

    func atob(data: String) -> String {
        jsObject[Strings.atob]!(data.jsValue()).fromJSValue()!
    }

    func setTimeout(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        jsObject[Strings.setTimeout]!(handler.jsValue(), timeout?.jsValue() ?? .undefined, arguments.jsValue()).fromJSValue()!
    }

    func clearTimeout(id: Int32? = nil) {
        _ = jsObject[Strings.clearTimeout]!(id?.jsValue() ?? .undefined)
    }

    func setInterval(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        jsObject[Strings.setInterval]!(handler.jsValue(), timeout?.jsValue() ?? .undefined, arguments.jsValue()).fromJSValue()!
    }

    func clearInterval(id: Int32? = nil) {
        _ = jsObject[Strings.clearInterval]!(id?.jsValue() ?? .undefined)
    }

    // XXX: method 'queueMicrotask' is ignored

    func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) -> JSPromise {
        jsObject[Strings.createImageBitmap]!(image.jsValue(), options?.jsValue() ?? .undefined).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let _promise: JSPromise = jsObject[Strings.createImageBitmap]!(image.jsValue(), options?.jsValue() ?? .undefined).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) -> JSPromise {
        let _arg0 = image.jsValue()
        let _arg1 = sx.jsValue()
        let _arg2 = sy.jsValue()
        let _arg3 = sw.jsValue()
        let _arg4 = sh.jsValue()
        let _arg5 = options?.jsValue() ?? .undefined
        return jsObject[Strings.createImageBitmap]!(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let _arg0 = image.jsValue()
        let _arg1 = sx.jsValue()
        let _arg2 = sy.jsValue()
        let _arg3 = sw.jsValue()
        let _arg4 = sh.jsValue()
        let _arg5 = options?.jsValue() ?? .undefined
        let _promise: JSPromise = jsObject[Strings.createImageBitmap]!(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    func structuredClone(value: JSValue, options: StructuredSerializeOptions? = nil) -> JSValue {
        jsObject[Strings.structuredClone]!(value.jsValue(), options?.jsValue() ?? .undefined).fromJSValue()!
    }

    var originPolicyIds: [String] { ReadonlyAttribute[Strings.originPolicyIds, in: jsObject] }

    var caches: CacheStorage { ReadonlyAttribute[Strings.caches, in: jsObject] }
}
