// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public class SubtleCrypto: JSBridgedClass {
    public class var constructor: JSFunction { JSObject.global[Strings.SubtleCrypto].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    public func encrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) -> JSPromise {
        let this = jsObject
        return this[Strings.encrypt].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func encrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.encrypt].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func decrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) -> JSPromise {
        let this = jsObject
        return this[Strings.decrypt].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func decrypt(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.decrypt].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) -> JSPromise {
        let this = jsObject
        return this[Strings.sign].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: BufferSource) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.sign].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), data.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func verify(algorithm: AlgorithmIdentifier, key: CryptoKey, signature: BufferSource, data: BufferSource) -> JSPromise {
        let this = jsObject
        return this[Strings.verify].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), signature.jsValue(), data.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func verify(algorithm: AlgorithmIdentifier, key: CryptoKey, signature: BufferSource, data: BufferSource) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.verify].function!(this: this, arguments: [algorithm.jsValue(), key.jsValue(), signature.jsValue(), data.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func digest(algorithm: AlgorithmIdentifier, data: BufferSource) -> JSPromise {
        let this = jsObject
        return this[Strings.digest].function!(this: this, arguments: [algorithm.jsValue(), data.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func digest(algorithm: AlgorithmIdentifier, data: BufferSource) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.digest].function!(this: this, arguments: [algorithm.jsValue(), data.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func generateKey(algorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) -> JSPromise {
        let this = jsObject
        return this[Strings.generateKey].function!(this: this, arguments: [algorithm.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func generateKey(algorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.generateKey].function!(this: this, arguments: [algorithm.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func deriveKey(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) -> JSPromise {
        let this = jsObject
        return this[Strings.deriveKey].function!(this: this, arguments: [algorithm.jsValue(), baseKey.jsValue(), derivedKeyType.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deriveKey(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.deriveKey].function!(this: this, arguments: [algorithm.jsValue(), baseKey.jsValue(), derivedKeyType.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func deriveBits(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, length: UInt32) -> JSPromise {
        let this = jsObject
        return this[Strings.deriveBits].function!(this: this, arguments: [algorithm.jsValue(), baseKey.jsValue(), length.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func deriveBits(algorithm: AlgorithmIdentifier, baseKey: CryptoKey, length: UInt32) async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.deriveBits].function!(this: this, arguments: [algorithm.jsValue(), baseKey.jsValue(), length.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func importKey(format: KeyFormat, keyData: __UNSUPPORTED_UNION__, algorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) -> JSPromise {
        let this = jsObject
        return this[Strings.importKey].function!(this: this, arguments: [format.jsValue(), keyData.jsValue(), algorithm.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func importKey(format: KeyFormat, keyData: __UNSUPPORTED_UNION__, algorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) async throws -> CryptoKey {
        let this = jsObject
        let _promise: JSPromise = this[Strings.importKey].function!(this: this, arguments: [format.jsValue(), keyData.jsValue(), algorithm.jsValue(), extractable.jsValue(), keyUsages.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func exportKey(format: KeyFormat, key: CryptoKey) -> JSPromise {
        let this = jsObject
        return this[Strings.exportKey].function!(this: this, arguments: [format.jsValue(), key.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func exportKey(format: KeyFormat, key: CryptoKey) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.exportKey].function!(this: this, arguments: [format.jsValue(), key.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier) -> JSPromise {
        let this = jsObject
        return this[Strings.wrapKey].function!(this: this, arguments: [format.jsValue(), key.jsValue(), wrappingKey.jsValue(), wrapAlgorithm.jsValue()]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier) async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.wrapKey].function!(this: this, arguments: [format.jsValue(), key.jsValue(), wrappingKey.jsValue(), wrapAlgorithm.jsValue()]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) -> JSPromise {
        let _arg0 = format.jsValue()
        let _arg1 = wrappedKey.jsValue()
        let _arg2 = unwrappingKey.jsValue()
        let _arg3 = unwrapAlgorithm.jsValue()
        let _arg4 = unwrappedKeyAlgorithm.jsValue()
        let _arg5 = extractable.jsValue()
        let _arg6 = keyUsages.jsValue()
        let this = jsObject
        return this[Strings.unwrapKey].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: Bool, keyUsages: [KeyUsage]) async throws -> CryptoKey {
        let _arg0 = format.jsValue()
        let _arg1 = wrappedKey.jsValue()
        let _arg2 = unwrappingKey.jsValue()
        let _arg3 = unwrapAlgorithm.jsValue()
        let _arg4 = unwrappedKeyAlgorithm.jsValue()
        let _arg5 = extractable.jsValue()
        let _arg6 = keyUsages.jsValue()
        let this = jsObject
        let _promise: JSPromise = this[Strings.unwrapKey].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6]).fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }
}
