// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public class HTMLMediaElement: HTMLElement {
    override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMediaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _sinkId = ReadonlyAttribute(jsObject: jsObject, name: Strings.sinkId)
        _mediaKeys = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaKeys)
        _onencrypted = ClosureAttribute.Optional1(jsObject: jsObject, name: Strings.onencrypted)
        _onwaitingforkey = ClosureAttribute.Optional1(jsObject: jsObject, name: Strings.onwaitingforkey)
        _remote = ReadonlyAttribute(jsObject: jsObject, name: Strings.remote)
        _disableRemotePlayback = ReadWriteAttribute(jsObject: jsObject, name: Strings.disableRemotePlayback)
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _srcObject = ReadWriteAttribute(jsObject: jsObject, name: Strings.srcObject)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentSrc)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Strings.crossOrigin)
        _networkState = ReadonlyAttribute(jsObject: jsObject, name: Strings.networkState)
        _preload = ReadWriteAttribute(jsObject: jsObject, name: Strings.preload)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: Strings.buffered)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _seeking = ReadonlyAttribute(jsObject: jsObject, name: Strings.seeking)
        _currentTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.currentTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _paused = ReadonlyAttribute(jsObject: jsObject, name: Strings.paused)
        _defaultPlaybackRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultPlaybackRate)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.playbackRate)
        _preservesPitch = ReadWriteAttribute(jsObject: jsObject, name: Strings.preservesPitch)
        _played = ReadonlyAttribute(jsObject: jsObject, name: Strings.played)
        _seekable = ReadonlyAttribute(jsObject: jsObject, name: Strings.seekable)
        _ended = ReadonlyAttribute(jsObject: jsObject, name: Strings.ended)
        _autoplay = ReadWriteAttribute(jsObject: jsObject, name: Strings.autoplay)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Strings.loop)
        _controls = ReadWriteAttribute(jsObject: jsObject, name: Strings.controls)
        _volume = ReadWriteAttribute(jsObject: jsObject, name: Strings.volume)
        _muted = ReadWriteAttribute(jsObject: jsObject, name: Strings.muted)
        _defaultMuted = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultMuted)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.textTracks)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var sinkId: String

    public func setSinkId(sinkId: String) -> JSPromise {
        jsObject[Strings.setSinkId]!(sinkId.jsValue()).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func setSinkId(sinkId: String) async throws {
        let _promise: JSPromise = jsObject[Strings.setSinkId]!(sinkId.jsValue()).fromJSValue()!
        _ = try await _promise.get()
    }

    @ReadonlyAttribute
    public var mediaKeys: MediaKeys?

    @ClosureAttribute.Optional1
    public var onencrypted: EventHandler

    @ClosureAttribute.Optional1
    public var onwaitingforkey: EventHandler

    public func setMediaKeys(mediaKeys: MediaKeys?) -> JSPromise {
        jsObject[Strings.setMediaKeys]!(mediaKeys.jsValue()).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func setMediaKeys(mediaKeys: MediaKeys?) async throws {
        let _promise: JSPromise = jsObject[Strings.setMediaKeys]!(mediaKeys.jsValue()).fromJSValue()!
        _ = try await _promise.get()
    }

    public func captureStream() -> MediaStream {
        jsObject[Strings.captureStream]!().fromJSValue()!
    }

    @ReadonlyAttribute
    public var remote: RemotePlayback

    @ReadWriteAttribute
    public var disableRemotePlayback: Bool

    @ReadonlyAttribute
    public var error: MediaError?

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcObject: MediaProvider?

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    public static let NETWORK_EMPTY: UInt16 = 0

    public static let NETWORK_IDLE: UInt16 = 1

    public static let NETWORK_LOADING: UInt16 = 2

    public static let NETWORK_NO_SOURCE: UInt16 = 3

    @ReadonlyAttribute
    public var networkState: UInt16

    @ReadWriteAttribute
    public var preload: String

    @ReadonlyAttribute
    public var buffered: TimeRanges

    public func load() {
        _ = jsObject[Strings.load]!()
    }

    public func canPlayType(type: String) -> CanPlayTypeResult {
        jsObject[Strings.canPlayType]!(type.jsValue()).fromJSValue()!
    }

    public static let HAVE_NOTHING: UInt16 = 0

    public static let HAVE_METADATA: UInt16 = 1

    public static let HAVE_CURRENT_DATA: UInt16 = 2

    public static let HAVE_FUTURE_DATA: UInt16 = 3

    public static let HAVE_ENOUGH_DATA: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var seeking: Bool

    @ReadWriteAttribute
    public var currentTime: Double

    public func fastSeek(time: Double) {
        _ = jsObject[Strings.fastSeek]!(time.jsValue())
    }

    @ReadonlyAttribute
    public var duration: Double

    public func getStartDate() -> JSObject {
        jsObject[Strings.getStartDate]!().fromJSValue()!
    }

    @ReadonlyAttribute
    public var paused: Bool

    @ReadWriteAttribute
    public var defaultPlaybackRate: Double

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadWriteAttribute
    public var preservesPitch: Bool

    @ReadonlyAttribute
    public var played: TimeRanges

    @ReadonlyAttribute
    public var seekable: TimeRanges

    @ReadonlyAttribute
    public var ended: Bool

    @ReadWriteAttribute
    public var autoplay: Bool

    @ReadWriteAttribute
    public var loop: Bool

    public func play() -> JSPromise {
        jsObject[Strings.play]!().fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func play() async throws {
        let _promise: JSPromise = jsObject[Strings.play]!().fromJSValue()!
        _ = try await _promise.get()
    }

    public func pause() {
        _ = jsObject[Strings.pause]!()
    }

    @ReadWriteAttribute
    public var controls: Bool

    @ReadWriteAttribute
    public var volume: Double

    @ReadWriteAttribute
    public var muted: Bool

    @ReadWriteAttribute
    public var defaultMuted: Bool

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    public func addTextTrack(kind: TextTrackKind, label: String? = nil, language: String? = nil) -> TextTrack {
        jsObject[Strings.addTextTrack]!(kind.jsValue(), label?.jsValue() ?? .undefined, language?.jsValue() ?? .undefined).fromJSValue()!
    }
}
