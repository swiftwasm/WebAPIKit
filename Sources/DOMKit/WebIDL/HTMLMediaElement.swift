// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public class HTMLMediaElement: HTMLElement {
    override public class var constructor: JSFunction { JSObject.global.HTMLMediaElement.function! }

    private enum Keys {
        static let HAVE_CURRENT_DATA: JSString = "HAVE_CURRENT_DATA"
        static let HAVE_ENOUGH_DATA: JSString = "HAVE_ENOUGH_DATA"
        static let HAVE_FUTURE_DATA: JSString = "HAVE_FUTURE_DATA"
        static let HAVE_METADATA: JSString = "HAVE_METADATA"
        static let HAVE_NOTHING: JSString = "HAVE_NOTHING"
        static let NETWORK_EMPTY: JSString = "NETWORK_EMPTY"
        static let NETWORK_IDLE: JSString = "NETWORK_IDLE"
        static let NETWORK_LOADING: JSString = "NETWORK_LOADING"
        static let NETWORK_NO_SOURCE: JSString = "NETWORK_NO_SOURCE"
        static let addTextTrack: JSString = "addTextTrack"
        static let audioTracks: JSString = "audioTracks"
        static let autoplay: JSString = "autoplay"
        static let buffered: JSString = "buffered"
        static let canPlayType: JSString = "canPlayType"
        static let controls: JSString = "controls"
        static let crossOrigin: JSString = "crossOrigin"
        static let currentSrc: JSString = "currentSrc"
        static let currentTime: JSString = "currentTime"
        static let defaultMuted: JSString = "defaultMuted"
        static let defaultPlaybackRate: JSString = "defaultPlaybackRate"
        static let duration: JSString = "duration"
        static let ended: JSString = "ended"
        static let error: JSString = "error"
        static let fastSeek: JSString = "fastSeek"
        static let getStartDate: JSString = "getStartDate"
        static let load: JSString = "load"
        static let loop: JSString = "loop"
        static let muted: JSString = "muted"
        static let networkState: JSString = "networkState"
        static let pause: JSString = "pause"
        static let paused: JSString = "paused"
        static let play: JSString = "play"
        static let playbackRate: JSString = "playbackRate"
        static let played: JSString = "played"
        static let preload: JSString = "preload"
        static let preservesPitch: JSString = "preservesPitch"
        static let readyState: JSString = "readyState"
        static let seekable: JSString = "seekable"
        static let seeking: JSString = "seeking"
        static let src: JSString = "src"
        static let srcObject: JSString = "srcObject"
        static let textTracks: JSString = "textTracks"
        static let videoTracks: JSString = "videoTracks"
        static let volume: JSString = "volume"
    }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: Keys.error)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Keys.src)
        _srcObject = ReadWriteAttribute(jsObject: jsObject, name: Keys.srcObject)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: Keys.currentSrc)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Keys.crossOrigin)
        _networkState = ReadonlyAttribute(jsObject: jsObject, name: Keys.networkState)
        _preload = ReadWriteAttribute(jsObject: jsObject, name: Keys.preload)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: Keys.buffered)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Keys.readyState)
        _seeking = ReadonlyAttribute(jsObject: jsObject, name: Keys.seeking)
        _currentTime = ReadWriteAttribute(jsObject: jsObject, name: Keys.currentTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Keys.duration)
        _paused = ReadonlyAttribute(jsObject: jsObject, name: Keys.paused)
        _defaultPlaybackRate = ReadWriteAttribute(jsObject: jsObject, name: Keys.defaultPlaybackRate)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: Keys.playbackRate)
        _preservesPitch = ReadWriteAttribute(jsObject: jsObject, name: Keys.preservesPitch)
        _played = ReadonlyAttribute(jsObject: jsObject, name: Keys.played)
        _seekable = ReadonlyAttribute(jsObject: jsObject, name: Keys.seekable)
        _ended = ReadonlyAttribute(jsObject: jsObject, name: Keys.ended)
        _autoplay = ReadWriteAttribute(jsObject: jsObject, name: Keys.autoplay)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Keys.loop)
        _controls = ReadWriteAttribute(jsObject: jsObject, name: Keys.controls)
        _volume = ReadWriteAttribute(jsObject: jsObject, name: Keys.volume)
        _muted = ReadWriteAttribute(jsObject: jsObject, name: Keys.muted)
        _defaultMuted = ReadWriteAttribute(jsObject: jsObject, name: Keys.defaultMuted)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: Keys.audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: Keys.videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: Keys.textTracks)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var error: MediaError?

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcObject: MediaProvider?

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    public static let NETWORK_EMPTY: UInt16 = 0

    public static let NETWORK_IDLE: UInt16 = 1

    public static let NETWORK_LOADING: UInt16 = 2

    public static let NETWORK_NO_SOURCE: UInt16 = 3

    @ReadonlyAttribute
    public var networkState: UInt16

    @ReadWriteAttribute
    public var preload: String

    @ReadonlyAttribute
    public var buffered: TimeRanges

    public func load() {
        jsObject[Keys.load]!().fromJSValue()!
    }

    public func canPlayType(type: String) -> CanPlayTypeResult {
        jsObject[Keys.canPlayType]!(type.jsValue()).fromJSValue()!
    }

    public static let HAVE_NOTHING: UInt16 = 0

    public static let HAVE_METADATA: UInt16 = 1

    public static let HAVE_CURRENT_DATA: UInt16 = 2

    public static let HAVE_FUTURE_DATA: UInt16 = 3

    public static let HAVE_ENOUGH_DATA: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var seeking: Bool

    @ReadWriteAttribute
    public var currentTime: Double

    public func fastSeek(time: Double) {
        jsObject[Keys.fastSeek]!(time.jsValue()).fromJSValue()!
    }

    @ReadonlyAttribute
    public var duration: Double

    public func getStartDate() -> JSObject {
        jsObject[Keys.getStartDate]!().fromJSValue()!
    }

    @ReadonlyAttribute
    public var paused: Bool

    @ReadWriteAttribute
    public var defaultPlaybackRate: Double

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadWriteAttribute
    public var preservesPitch: Bool

    @ReadonlyAttribute
    public var played: TimeRanges

    @ReadonlyAttribute
    public var seekable: TimeRanges

    @ReadonlyAttribute
    public var ended: Bool

    @ReadWriteAttribute
    public var autoplay: Bool

    @ReadWriteAttribute
    public var loop: Bool

    public func play() -> JSPromise {
        jsObject[Keys.play]!().fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func play() async throws {
        let _promise: JSPromise = jsObject[Keys.play]!().fromJSValue()!
        return try await _promise.get().fromJSValue()!
    }

    public func pause() {
        jsObject[Keys.pause]!().fromJSValue()!
    }

    @ReadWriteAttribute
    public var controls: Bool

    @ReadWriteAttribute
    public var volume: Double

    @ReadWriteAttribute
    public var muted: Bool

    @ReadWriteAttribute
    public var defaultMuted: Bool

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    public func addTextTrack(kind: TextTrackKind, label: String? = nil, language: String? = nil) -> TextTrack {
        jsObject[Keys.addTextTrack]!(kind.jsValue(), label?.jsValue() ?? .undefined, language?.jsValue() ?? .undefined).fromJSValue()!
    }
}
