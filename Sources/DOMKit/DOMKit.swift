// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit

public class Blob: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Blob].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(blobParts: [BlobPart]? = nil, options: BlobPropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [blobParts?.jsValue ?? .undefined, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var size: UInt64

    @ReadonlyAttribute
    public var type: String

    @inlinable public func slice(start: Int64? = nil, end: Int64? = nil, contentType: String? = nil) -> Self {
        let this = jsObject
        return this[Strings.slice].function!(this: this, arguments: [start?.jsValue ?? .undefined, end?.jsValue ?? .undefined, contentType?.jsValue ?? .undefined]).fromJSValue()!
    }

    // XXX: member 'stream' is ignored

    @inlinable public func text() -> JSPromise {
        let this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BlobPropertyBag: BridgedDictionary {
    public convenience init(type: String, endings: EndingType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.endings] = endings.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _endings = ReadWriteAttribute(jsObject: object, name: Strings.endings)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var endings: EndingType
}

public class DOMException: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMException].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(message: String? = nil, name: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [message?.jsValue ?? .undefined, name?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var code: UInt16

    public static let INDEX_SIZE_ERR: UInt16 = 1

    public static let DOMSTRING_SIZE_ERR: UInt16 = 2

    public static let HIERARCHY_REQUEST_ERR: UInt16 = 3

    public static let WRONG_DOCUMENT_ERR: UInt16 = 4

    public static let INVALID_CHARACTER_ERR: UInt16 = 5

    public static let NO_DATA_ALLOWED_ERR: UInt16 = 6

    public static let NO_MODIFICATION_ALLOWED_ERR: UInt16 = 7

    public static let NOT_FOUND_ERR: UInt16 = 8

    public static let NOT_SUPPORTED_ERR: UInt16 = 9

    public static let INUSE_ATTRIBUTE_ERR: UInt16 = 10

    public static let INVALID_STATE_ERR: UInt16 = 11

    public static let SYNTAX_ERR: UInt16 = 12

    public static let INVALID_MODIFICATION_ERR: UInt16 = 13

    public static let NAMESPACE_ERR: UInt16 = 14

    public static let INVALID_ACCESS_ERR: UInt16 = 15

    public static let VALIDATION_ERR: UInt16 = 16

    public static let TYPE_MISMATCH_ERR: UInt16 = 17

    public static let SECURITY_ERR: UInt16 = 18

    public static let NETWORK_ERR: UInt16 = 19

    public static let ABORT_ERR: UInt16 = 20

    public static let URL_MISMATCH_ERR: UInt16 = 21

    public static let QUOTA_EXCEEDED_ERR: UInt16 = 22

    public static let TIMEOUT_ERR: UInt16 = 23

    public static let INVALID_NODE_TYPE_ERR: UInt16 = 24

    public static let DATA_CLONE_ERR: UInt16 = 25
}

public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class File: Blob {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.File].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastModified)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(fileBits: [BlobPart], fileName: String, options: FilePropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [fileBits.jsValue, fileName.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var lastModified: Int64
}

public class FileList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.FileList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> File? {
        jsObject[key].fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32
}

public class FilePropertyBag: BridgedDictionary {
    public convenience init(lastModified: Int64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.lastModified] = lastModified.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lastModified = ReadWriteAttribute(jsObject: object, name: Strings.lastModified)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lastModified: Int64
}

public class FileReader: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.FileReader].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _result = ReadonlyAttribute(jsObject: jsObject, name: Strings.result)
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        _onloadstart = ReadWriteAttribute(jsObject: jsObject, name: Strings.onloadstart)
        _onprogress = ReadWriteAttribute(jsObject: jsObject, name: Strings.onprogress)
        _onload = ReadWriteAttribute(jsObject: jsObject, name: Strings.onload)
        _onabort = ReadWriteAttribute(jsObject: jsObject, name: Strings.onabort)
        _onerror = ReadWriteAttribute(jsObject: jsObject, name: Strings.onerror)
        _onloadend = ReadWriteAttribute(jsObject: jsObject, name: Strings.onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func readAsArrayBuffer(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsArrayBuffer].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsBinaryString(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsBinaryString].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsText(blob: Blob, encoding: String? = nil) {
        let this = jsObject
        _ = this[Strings.readAsText].function!(this: this, arguments: [blob.jsValue, encoding?.jsValue ?? .undefined])
    }

    @inlinable public func readAsDataURL(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsDataURL].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    public static let EMPTY: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let DONE: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var result: JSValue?

    @ReadonlyAttribute
    public var error: DOMException?

    @ReadWriteAttribute
    public var onloadstart: EventHandler

    @ReadWriteAttribute
    public var onprogress: EventHandler

    @ReadWriteAttribute
    public var onload: EventHandler

    @ReadWriteAttribute
    public var onabort: EventHandler

    @ReadWriteAttribute
    public var onerror: EventHandler

    @ReadWriteAttribute
    public var onloadend: EventHandler
}

public typealias DOMTimeStamp = UInt64

public typealias VoidFunction = () -> Void
public class URL: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.URL].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: Strings.href)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: Strings.origin)
        _protocol = ReadWriteAttribute(jsObject: jsObject, name: Strings.protocol)
        _username = ReadWriteAttribute(jsObject: jsObject, name: Strings.username)
        _password = ReadWriteAttribute(jsObject: jsObject, name: Strings.password)
        _host = ReadWriteAttribute(jsObject: jsObject, name: Strings.host)
        _hostname = ReadWriteAttribute(jsObject: jsObject, name: Strings.hostname)
        _port = ReadWriteAttribute(jsObject: jsObject, name: Strings.port)
        _pathname = ReadWriteAttribute(jsObject: jsObject, name: Strings.pathname)
        _search = ReadWriteAttribute(jsObject: jsObject, name: Strings.search)
        _searchParams = ReadonlyAttribute(jsObject: jsObject, name: Strings.searchParams)
        _hash = ReadWriteAttribute(jsObject: jsObject, name: Strings.hash)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(url: String, base: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [url.jsValue, base?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadonlyAttribute
    public var origin: String

    @ReadWriteAttribute
    public var `protocol`: String

    @ReadWriteAttribute
    public var username: String

    @ReadWriteAttribute
    public var password: String

    @ReadWriteAttribute
    public var host: String

    @ReadWriteAttribute
    public var hostname: String

    @ReadWriteAttribute
    public var port: String

    @ReadWriteAttribute
    public var pathname: String

    @ReadWriteAttribute
    public var search: String

    @ReadonlyAttribute
    public var searchParams: URLSearchParams

    @ReadWriteAttribute
    public var hash: String

    @inlinable public func toJSON() -> String {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public static func createObjectURL(obj: JSValue) -> String {
        let this = constructor
        return this[Strings.createObjectURL].function!(this: this, arguments: [obj.jsValue]).fromJSValue()!
    }

    @inlinable public static func revokeObjectURL(url: String) {
        let this = constructor
        _ = this[Strings.revokeObjectURL].function!(this: this, arguments: [url.jsValue])
    }
}

public class URLSearchParams: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.URLSearchParams].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: JSValue? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [name.jsValue])
    }

    @inlinable public func get(name: String) -> String? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func getAll(name: String) -> [String] {
        let this = jsObject
        return this[Strings.getAll].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func sort() {
        let this = jsObject
        _ = this[Strings.sort].function!(this: this, arguments: [])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<URLSearchParams> {
        ValueIterableIterator(sequence: self)
    }

    @inlinable public var description: String {
        jsObject[Strings.toString]!().fromJSValue()!
    }
}

public enum console {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.console].object!
    }

    @inlinable public static func assert(condition: Bool? = nil, data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.assert].function!(this: this, arguments: [condition?.jsValue ?? .undefined] + data.map(\.jsValue))
    }

    @inlinable public static func clear() {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }

    @inlinable public static func debug(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.debug].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func error(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.error].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func info(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.info].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func log(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.log].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func table(tabularData: JSValue? = nil, properties: [String]? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.table].function!(this: this, arguments: [tabularData?.jsValue ?? .undefined, properties?.jsValue ?? .undefined])
    }

    @inlinable public static func trace(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.trace].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func warn(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.warn].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func dir(item: JSValue? = nil, options: JSObject? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.dir].function!(this: this, arguments: [item?.jsValue ?? .undefined, options?.jsValue ?? .undefined])
    }

    @inlinable public static func dirxml(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.dirxml].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func count(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.count].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func countReset(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.countReset].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func group(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.group].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func groupCollapsed(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.groupCollapsed].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func groupEnd() {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.groupEnd].function!(this: this, arguments: [])
    }

    @inlinable public static func time(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.time].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func timeLog(label: String? = nil, data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.timeLog].function!(this: this, arguments: [label?.jsValue ?? .undefined] + data.map(\.jsValue))
    }

    @inlinable public static func timeEnd(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.timeEnd].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }
}

/* variadic generics please */
@propertyWrapper public final class ClosureAttribute0OptionalVoid {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (() -> Void)? {
        get { ClosureAttribute0OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute0OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (() -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function() }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure { _ in
                    newValue()
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute0Void {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: () -> Void {
        get { ClosureAttribute0Void[name, in: jsObject] }
        set { ClosureAttribute0Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> () -> Void {
        get {
            let function = jsObject[name].function!
            return { function() }
        }
        set {
            jsObject[name] = JSClosure { _ in
                newValue()
                return .undefined
            }.jsValue
        }
    }
}

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let Blob: JSString = "Blob"
    @usableFromInline static let DOMException: JSString = "DOMException"
    @usableFromInline static let File: JSString = "File"
    @usableFromInline static let FileList: JSString = "FileList"
    @usableFromInline static let FileReader: JSString = "FileReader"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let URL: JSString = "URL"
    @usableFromInline static let URLSearchParams: JSString = "URLSearchParams"
    @usableFromInline static let abort: JSString = "abort"
    @usableFromInline static let append: JSString = "append"
    @usableFromInline static let arrayBuffer: JSString = "arrayBuffer"
    @usableFromInline static let assert: JSString = "assert"
    @usableFromInline static let clear: JSString = "clear"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let console: JSString = "console"
    @usableFromInline static let count: JSString = "count"
    @usableFromInline static let countReset: JSString = "countReset"
    @usableFromInline static let createObjectURL: JSString = "createObjectURL"
    @usableFromInline static let debug: JSString = "debug"
    @usableFromInline static let delete: JSString = "delete"
    @usableFromInline static let dir: JSString = "dir"
    @usableFromInline static let dirxml: JSString = "dirxml"
    @usableFromInline static let endings: JSString = "endings"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let get: JSString = "get"
    @usableFromInline static let getAll: JSString = "getAll"
    @usableFromInline static let group: JSString = "group"
    @usableFromInline static let groupCollapsed: JSString = "groupCollapsed"
    @usableFromInline static let groupEnd: JSString = "groupEnd"
    @usableFromInline static let has: JSString = "has"
    @usableFromInline static let hash: JSString = "hash"
    @usableFromInline static let host: JSString = "host"
    @usableFromInline static let hostname: JSString = "hostname"
    @usableFromInline static let href: JSString = "href"
    @usableFromInline static let info: JSString = "info"
    @usableFromInline static let lastModified: JSString = "lastModified"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let log: JSString = "log"
    @usableFromInline static let message: JSString = "message"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onload: JSString = "onload"
    @usableFromInline static let onloadend: JSString = "onloadend"
    @usableFromInline static let onloadstart: JSString = "onloadstart"
    @usableFromInline static let onprogress: JSString = "onprogress"
    @usableFromInline static let origin: JSString = "origin"
    @usableFromInline static let password: JSString = "password"
    @usableFromInline static let pathname: JSString = "pathname"
    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let `protocol`: JSString = "protocol"
    @usableFromInline static let readAsArrayBuffer: JSString = "readAsArrayBuffer"
    @usableFromInline static let readAsBinaryString: JSString = "readAsBinaryString"
    @usableFromInline static let readAsDataURL: JSString = "readAsDataURL"
    @usableFromInline static let readAsText: JSString = "readAsText"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let result: JSString = "result"
    @usableFromInline static let revokeObjectURL: JSString = "revokeObjectURL"
    @usableFromInline static let search: JSString = "search"
    @usableFromInline static let searchParams: JSString = "searchParams"
    @usableFromInline static let set: JSString = "set"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let slice: JSString = "slice"
    @usableFromInline static let sort: JSString = "sort"
    @usableFromInline static let table: JSString = "table"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let time: JSString = "time"
    @usableFromInline static let timeEnd: JSString = "timeEnd"
    @usableFromInline static let timeLog: JSString = "timeLog"
    @usableFromInline static let toJSON: JSString = "toJSON"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let trace: JSString = "trace"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let username: JSString = "username"
    @usableFromInline static let warn: JSString = "warn"
}
