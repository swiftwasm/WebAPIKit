// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import JavaScriptEventLoop
import JavaScriptKit

public protocol ARIAMixin: JSBridgedClass {}
public extension ARIAMixin {
    @inlinable var role: String? {
        get { ReadWriteAttribute[Strings.role, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.role, in: jsObject] = newValue }
    }

    @inlinable var ariaAtomic: String? {
        get { ReadWriteAttribute[Strings.ariaAtomic, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaAtomic, in: jsObject] = newValue }
    }

    @inlinable var ariaAutoComplete: String? {
        get { ReadWriteAttribute[Strings.ariaAutoComplete, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaAutoComplete, in: jsObject] = newValue }
    }

    @inlinable var ariaBusy: String? {
        get { ReadWriteAttribute[Strings.ariaBusy, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaBusy, in: jsObject] = newValue }
    }

    @inlinable var ariaChecked: String? {
        get { ReadWriteAttribute[Strings.ariaChecked, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaChecked, in: jsObject] = newValue }
    }

    @inlinable var ariaColCount: String? {
        get { ReadWriteAttribute[Strings.ariaColCount, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaColCount, in: jsObject] = newValue }
    }

    @inlinable var ariaColIndex: String? {
        get { ReadWriteAttribute[Strings.ariaColIndex, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaColIndex, in: jsObject] = newValue }
    }

    @inlinable var ariaColIndexText: String? {
        get { ReadWriteAttribute[Strings.ariaColIndexText, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaColIndexText, in: jsObject] = newValue }
    }

    @inlinable var ariaColSpan: String? {
        get { ReadWriteAttribute[Strings.ariaColSpan, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaColSpan, in: jsObject] = newValue }
    }

    @inlinable var ariaCurrent: String? {
        get { ReadWriteAttribute[Strings.ariaCurrent, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaCurrent, in: jsObject] = newValue }
    }

    @inlinable var ariaDescription: String? {
        get { ReadWriteAttribute[Strings.ariaDescription, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaDescription, in: jsObject] = newValue }
    }

    @inlinable var ariaDisabled: String? {
        get { ReadWriteAttribute[Strings.ariaDisabled, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaDisabled, in: jsObject] = newValue }
    }

    @inlinable var ariaExpanded: String? {
        get { ReadWriteAttribute[Strings.ariaExpanded, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaExpanded, in: jsObject] = newValue }
    }

    @inlinable var ariaHasPopup: String? {
        get { ReadWriteAttribute[Strings.ariaHasPopup, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaHasPopup, in: jsObject] = newValue }
    }

    @inlinable var ariaHidden: String? {
        get { ReadWriteAttribute[Strings.ariaHidden, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaHidden, in: jsObject] = newValue }
    }

    @inlinable var ariaInvalid: String? {
        get { ReadWriteAttribute[Strings.ariaInvalid, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaInvalid, in: jsObject] = newValue }
    }

    @inlinable var ariaKeyShortcuts: String? {
        get { ReadWriteAttribute[Strings.ariaKeyShortcuts, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaKeyShortcuts, in: jsObject] = newValue }
    }

    @inlinable var ariaLabel: String? {
        get { ReadWriteAttribute[Strings.ariaLabel, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaLabel, in: jsObject] = newValue }
    }

    @inlinable var ariaLevel: String? {
        get { ReadWriteAttribute[Strings.ariaLevel, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaLevel, in: jsObject] = newValue }
    }

    @inlinable var ariaLive: String? {
        get { ReadWriteAttribute[Strings.ariaLive, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaLive, in: jsObject] = newValue }
    }

    @inlinable var ariaModal: String? {
        get { ReadWriteAttribute[Strings.ariaModal, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaModal, in: jsObject] = newValue }
    }

    @inlinable var ariaMultiLine: String? {
        get { ReadWriteAttribute[Strings.ariaMultiLine, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaMultiLine, in: jsObject] = newValue }
    }

    @inlinable var ariaMultiSelectable: String? {
        get { ReadWriteAttribute[Strings.ariaMultiSelectable, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaMultiSelectable, in: jsObject] = newValue }
    }

    @inlinable var ariaOrientation: String? {
        get { ReadWriteAttribute[Strings.ariaOrientation, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaOrientation, in: jsObject] = newValue }
    }

    @inlinable var ariaPlaceholder: String? {
        get { ReadWriteAttribute[Strings.ariaPlaceholder, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaPlaceholder, in: jsObject] = newValue }
    }

    @inlinable var ariaPosInSet: String? {
        get { ReadWriteAttribute[Strings.ariaPosInSet, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaPosInSet, in: jsObject] = newValue }
    }

    @inlinable var ariaPressed: String? {
        get { ReadWriteAttribute[Strings.ariaPressed, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaPressed, in: jsObject] = newValue }
    }

    @inlinable var ariaReadOnly: String? {
        get { ReadWriteAttribute[Strings.ariaReadOnly, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaReadOnly, in: jsObject] = newValue }
    }

    @inlinable var ariaRequired: String? {
        get { ReadWriteAttribute[Strings.ariaRequired, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRequired, in: jsObject] = newValue }
    }

    @inlinable var ariaRoleDescription: String? {
        get { ReadWriteAttribute[Strings.ariaRoleDescription, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRoleDescription, in: jsObject] = newValue }
    }

    @inlinable var ariaRowCount: String? {
        get { ReadWriteAttribute[Strings.ariaRowCount, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRowCount, in: jsObject] = newValue }
    }

    @inlinable var ariaRowIndex: String? {
        get { ReadWriteAttribute[Strings.ariaRowIndex, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRowIndex, in: jsObject] = newValue }
    }

    @inlinable var ariaRowIndexText: String? {
        get { ReadWriteAttribute[Strings.ariaRowIndexText, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRowIndexText, in: jsObject] = newValue }
    }

    @inlinable var ariaRowSpan: String? {
        get { ReadWriteAttribute[Strings.ariaRowSpan, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaRowSpan, in: jsObject] = newValue }
    }

    @inlinable var ariaSelected: String? {
        get { ReadWriteAttribute[Strings.ariaSelected, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaSelected, in: jsObject] = newValue }
    }

    @inlinable var ariaSetSize: String? {
        get { ReadWriteAttribute[Strings.ariaSetSize, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaSetSize, in: jsObject] = newValue }
    }

    @inlinable var ariaSort: String? {
        get { ReadWriteAttribute[Strings.ariaSort, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaSort, in: jsObject] = newValue }
    }

    @inlinable var ariaValueMax: String? {
        get { ReadWriteAttribute[Strings.ariaValueMax, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaValueMax, in: jsObject] = newValue }
    }

    @inlinable var ariaValueMin: String? {
        get { ReadWriteAttribute[Strings.ariaValueMin, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaValueMin, in: jsObject] = newValue }
    }

    @inlinable var ariaValueNow: String? {
        get { ReadWriteAttribute[Strings.ariaValueNow, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaValueNow, in: jsObject] = newValue }
    }

    @inlinable var ariaValueText: String? {
        get { ReadWriteAttribute[Strings.ariaValueText, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.ariaValueText, in: jsObject] = newValue }
    }
}

public class AbortController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AbortController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _signal = ReadonlyAttribute(jsObject: jsObject, name: Strings.signal)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func abort(reason: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined])
    }
}

public class AbortSignal: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AbortSignal].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _aborted = ReadonlyAttribute(jsObject: jsObject, name: Strings.aborted)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onabort)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public static func abort(reason: JSValue? = nil) -> Self {
        let this = constructor
        return this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public static func timeout(milliseconds: UInt64) -> Self {
        let this = constructor
        return this[Strings.timeout].function!(this: this, arguments: [milliseconds.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var aborted: Bool

    @ReadonlyAttribute
    public var reason: JSValue

    @inlinable public func throwIfAborted() {
        let this = jsObject
        _ = this[Strings.throwIfAborted].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onabort: EventHandler
}

public class AbstractRange: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AbstractRange].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _startContainer = ReadonlyAttribute(jsObject: jsObject, name: Strings.startContainer)
        _startOffset = ReadonlyAttribute(jsObject: jsObject, name: Strings.startOffset)
        _endContainer = ReadonlyAttribute(jsObject: jsObject, name: Strings.endContainer)
        _endOffset = ReadonlyAttribute(jsObject: jsObject, name: Strings.endOffset)
        _collapsed = ReadonlyAttribute(jsObject: jsObject, name: Strings.collapsed)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var startContainer: Node

    @ReadonlyAttribute
    public var startOffset: UInt32

    @ReadonlyAttribute
    public var endContainer: Node

    @ReadonlyAttribute
    public var endOffset: UInt32

    @ReadonlyAttribute
    public var collapsed: Bool
}

public protocol AbstractWorker: JSBridgedClass {}
public extension AbstractWorker {
    @inlinable var onerror: EventHandler {
        get { ClosureAttribute1Optional[Strings.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onerror, in: jsObject] = newValue }
    }
}

public class AddEventListenerOptions: BridgedDictionary {
    public convenience init(passive: Bool, once: Bool, signal: AbortSignal) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.passive] = passive.jsValue
        object[Strings.once] = once.jsValue
        object[Strings.signal] = signal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _passive = ReadWriteAttribute(jsObject: object, name: Strings.passive)
        _once = ReadWriteAttribute(jsObject: object, name: Strings.once)
        _signal = ReadWriteAttribute(jsObject: object, name: Strings.signal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var passive: Bool

    @ReadWriteAttribute
    public var once: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal
}

public enum AlphaOption: JSString, JSValueCompatible {
    case keep = "keep"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AnalyserNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AnalyserNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _fftSize = ReadWriteAttribute(jsObject: jsObject, name: Strings.fftSize)
        _frequencyBinCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequencyBinCount)
        _minDecibels = ReadWriteAttribute(jsObject: jsObject, name: Strings.minDecibels)
        _maxDecibels = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxDecibels)
        _smoothingTimeConstant = ReadWriteAttribute(jsObject: jsObject, name: Strings.smoothingTimeConstant)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: AnalyserOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @inlinable public func getFloatFrequencyData(array: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFloatFrequencyData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getByteFrequencyData(array: Uint8Array) {
        let this = jsObject
        _ = this[Strings.getByteFrequencyData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getFloatTimeDomainData(array: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFloatTimeDomainData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getByteTimeDomainData(array: Uint8Array) {
        let this = jsObject
        _ = this[Strings.getByteTimeDomainData].function!(this: this, arguments: [array.jsValue])
    }

    @ReadWriteAttribute
    public var fftSize: UInt32

    @ReadonlyAttribute
    public var frequencyBinCount: UInt32

    @ReadWriteAttribute
    public var minDecibels: Double

    @ReadWriteAttribute
    public var maxDecibels: Double

    @ReadWriteAttribute
    public var smoothingTimeConstant: Double
}

public class AnalyserOptions: BridgedDictionary {
    public convenience init(fftSize: UInt32, maxDecibels: Double, minDecibels: Double, smoothingTimeConstant: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.fftSize] = fftSize.jsValue
        object[Strings.maxDecibels] = maxDecibels.jsValue
        object[Strings.minDecibels] = minDecibels.jsValue
        object[Strings.smoothingTimeConstant] = smoothingTimeConstant.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _fftSize = ReadWriteAttribute(jsObject: object, name: Strings.fftSize)
        _maxDecibels = ReadWriteAttribute(jsObject: object, name: Strings.maxDecibels)
        _minDecibels = ReadWriteAttribute(jsObject: object, name: Strings.minDecibels)
        _smoothingTimeConstant = ReadWriteAttribute(jsObject: object, name: Strings.smoothingTimeConstant)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var fftSize: UInt32

    @ReadWriteAttribute
    public var maxDecibels: Double

    @ReadWriteAttribute
    public var minDecibels: Double

    @ReadWriteAttribute
    public var smoothingTimeConstant: Double
}

public protocol Animatable: JSBridgedClass {}
public extension Animatable {
    @inlinable func animate(keyframes: JSObject?, options: Double_or_KeyframeAnimationOptions? = nil) -> Animation {
        let this = jsObject
        return this[Strings.animate].function!(this: this, arguments: [keyframes.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func getAnimations(options: GetAnimationsOptions? = nil) -> [Animation] {
        let this = jsObject
        return this[Strings.getAnimations].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class Animation: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Animation].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadWriteAttribute(jsObject: jsObject, name: Strings.id)
        _effect = ReadWriteAttribute(jsObject: jsObject, name: Strings.effect)
        _timeline = ReadWriteAttribute(jsObject: jsObject, name: Strings.timeline)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.playbackRate)
        _playState = ReadonlyAttribute(jsObject: jsObject, name: Strings.playState)
        _replaceState = ReadonlyAttribute(jsObject: jsObject, name: Strings.replaceState)
        _pending = ReadonlyAttribute(jsObject: jsObject, name: Strings.pending)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: Strings.ready)
        _finished = ReadonlyAttribute(jsObject: jsObject, name: Strings.finished)
        _onfinish = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onfinish)
        _oncancel = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncancel)
        _onremove = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onremove)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(effect: AnimationEffect? = nil, timeline: AnimationTimeline? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [effect?.jsValue ?? .undefined, timeline?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var effect: AnimationEffect?

    @ReadWriteAttribute
    public var timeline: AnimationTimeline?

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadonlyAttribute
    public var playState: AnimationPlayState

    @ReadonlyAttribute
    public var replaceState: AnimationReplaceState

    @ReadonlyAttribute
    public var pending: Bool

    @ReadonlyAttribute
    public var ready: JSPromise

    @ReadonlyAttribute
    public var finished: JSPromise

    @ClosureAttribute1Optional
    public var onfinish: EventHandler

    @ClosureAttribute1Optional
    public var oncancel: EventHandler

    @ClosureAttribute1Optional
    public var onremove: EventHandler

    @inlinable public func cancel() {
        let this = jsObject
        _ = this[Strings.cancel].function!(this: this, arguments: [])
    }

    @inlinable public func finish() {
        let this = jsObject
        _ = this[Strings.finish].function!(this: this, arguments: [])
    }

    @inlinable public func play() {
        let this = jsObject
        _ = this[Strings.play].function!(this: this, arguments: [])
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[Strings.pause].function!(this: this, arguments: [])
    }

    @inlinable public func updatePlaybackRate(playbackRate: Double) {
        let this = jsObject
        _ = this[Strings.updatePlaybackRate].function!(this: this, arguments: [playbackRate.jsValue])
    }

    @inlinable public func reverse() {
        let this = jsObject
        _ = this[Strings.reverse].function!(this: this, arguments: [])
    }

    @inlinable public func persist() {
        let this = jsObject
        _ = this[Strings.persist].function!(this: this, arguments: [])
    }

    @inlinable public func commitStyles() {
        let this = jsObject
        _ = this[Strings.commitStyles].function!(this: this, arguments: [])
    }
}

public class AnimationEffect: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AnimationEffect].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getTiming() -> EffectTiming {
        let this = jsObject
        return this[Strings.getTiming].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getComputedTiming() -> ComputedEffectTiming {
        let this = jsObject
        return this[Strings.getComputedTiming].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func updateTiming(timing: OptionalEffectTiming? = nil) {
        let this = jsObject
        _ = this[Strings.updateTiming].function!(this: this, arguments: [timing?.jsValue ?? .undefined])
    }
}

public protocol AnimationFrameProvider: JSBridgedClass {}
public extension AnimationFrameProvider {
    // XXX: method 'requestAnimationFrame' is ignored

    @inlinable func cancelAnimationFrame(handle: UInt32) {
        let this = jsObject
        _ = this[Strings.cancelAnimationFrame].function!(this: this, arguments: [handle.jsValue])
    }
}

public enum AnimationPlayState: JSString, JSValueCompatible {
    case idle = "idle"
    case running = "running"
    case paused = "paused"
    case finished = "finished"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum AnimationReplaceState: JSString, JSValueCompatible {
    case active = "active"
    case removed = "removed"
    case persisted = "persisted"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AnimationTimeline: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AnimationTimeline].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _currentTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentTime)
        _phase = ReadonlyAttribute(jsObject: jsObject, name: Strings.phase)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var currentTime: Double?

    @ReadonlyAttribute
    public var phase: TimelinePhase
}

public class AssignedNodesOptions: BridgedDictionary {
    public convenience init(flatten: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.flatten] = flatten.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _flatten = ReadWriteAttribute(jsObject: object, name: Strings.flatten)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var flatten: Bool
}

public class Attr: Node {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Attr].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: Strings.namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: Strings.prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: Strings.localName)
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _ownerElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.ownerElement)
        _specified = ReadonlyAttribute(jsObject: jsObject, name: Strings.specified)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var ownerElement: Element?

    @ReadonlyAttribute
    public var specified: Bool
}

public class AudioBuffer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioBuffer].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleRate)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _numberOfChannels = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfChannels)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(options: AudioBufferOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [options.jsValue]))
    }

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var duration: Double

    @ReadonlyAttribute
    public var numberOfChannels: UInt32

    @inlinable public func getChannelData(channel: UInt32) -> Float32Array {
        let this = jsObject
        return this[Strings.getChannelData].function!(this: this, arguments: [channel.jsValue]).fromJSValue()!
    }

    @inlinable public func copyFromChannel(destination: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.copyFromChannel].function!(this: this, arguments: [destination.jsValue, channelNumber.jsValue, bufferOffset?.jsValue ?? .undefined])
    }

    @inlinable public func copyToChannel(source: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.copyToChannel].function!(this: this, arguments: [source.jsValue, channelNumber.jsValue, bufferOffset?.jsValue ?? .undefined])
    }
}

public class AudioBufferOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.length] = length.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _length = ReadWriteAttribute(jsObject: object, name: Strings.length)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var sampleRate: Float
}

public class AudioBufferSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioBufferSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: jsObject, name: Strings.buffer)
        _playbackRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.playbackRate)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Strings.loop)
        _loopStart = ReadWriteAttribute(jsObject: jsObject, name: Strings.loopStart)
        _loopEnd = ReadWriteAttribute(jsObject: jsObject, name: Strings.loopEnd)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: AudioBufferSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadonlyAttribute
    public var playbackRate: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @ReadWriteAttribute
    public var loop: Bool

    @ReadWriteAttribute
    public var loopStart: Double

    @ReadWriteAttribute
    public var loopEnd: Double

    // XXX: member 'start' is ignored
}

public class AudioBufferSourceOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, detune: Float, loop: Bool, loopEnd: Double, loopStart: Double, playbackRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.loop] = loop.jsValue
        object[Strings.loopEnd] = loopEnd.jsValue
        object[Strings.loopStart] = loopStart.jsValue
        object[Strings.playbackRate] = playbackRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _loop = ReadWriteAttribute(jsObject: object, name: Strings.loop)
        _loopEnd = ReadWriteAttribute(jsObject: object, name: Strings.loopEnd)
        _loopStart = ReadWriteAttribute(jsObject: object, name: Strings.loopStart)
        _playbackRate = ReadWriteAttribute(jsObject: object, name: Strings.playbackRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var loop: Bool

    @ReadWriteAttribute
    public var loopEnd: Double

    @ReadWriteAttribute
    public var loopStart: Double

    @ReadWriteAttribute
    public var playbackRate: Float
}

public class AudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioContext].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _baseLatency = ReadonlyAttribute(jsObject: jsObject, name: Strings.baseLatency)
        _outputLatency = ReadonlyAttribute(jsObject: jsObject, name: Strings.outputLatency)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(contextOptions: AudioContextOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [contextOptions?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var baseLatency: Double

    @ReadonlyAttribute
    public var outputLatency: Double

    @inlinable public func getOutputTimestamp() -> AudioTimestamp {
        let this = jsObject
        return this[Strings.getOutputTimestamp].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func suspend() -> JSPromise {
        let this = jsObject
        return this[Strings.suspend].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.suspend].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func createMediaElementSource(mediaElement: HTMLMediaElement) -> MediaElementAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaElementSource].function!(this: this, arguments: [mediaElement.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamSource(mediaStream: MediaStream) -> MediaStreamAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaStreamSource].function!(this: this, arguments: [mediaStream.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack) -> MediaStreamTrackAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaStreamTrackSource].function!(this: this, arguments: [mediaStreamTrack.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamDestination() -> MediaStreamAudioDestinationNode {
        let this = jsObject
        return this[Strings.createMediaStreamDestination].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum AudioContextLatencyCategory: JSString, JSValueCompatible {
    case balanced = "balanced"
    case interactive = "interactive"
    case playback = "playback"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioContextOptions: BridgedDictionary {
    public convenience init(latencyHint: AudioContextLatencyCategory_or_Double, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.latencyHint] = latencyHint.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _latencyHint = ReadWriteAttribute(jsObject: object, name: Strings.latencyHint)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var latencyHint: AudioContextLatencyCategory_or_Double

    @ReadWriteAttribute
    public var sampleRate: Float
}

public enum AudioContextState: JSString, JSValueCompatible {
    case suspended = "suspended"
    case running = "running"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioData].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _format = ReadonlyAttribute(jsObject: jsObject, name: Strings.format)
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleRate)
        _numberOfFrames = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfFrames)
        _numberOfChannels = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfChannels)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: Strings.timestamp)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: AudioDataInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var format: AudioSampleFormat?

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var numberOfFrames: UInt32

    @ReadonlyAttribute
    public var numberOfChannels: UInt32

    @ReadonlyAttribute
    public var duration: UInt64

    @ReadonlyAttribute
    public var timestamp: Int64

    @inlinable public func allocationSize(options: AudioDataCopyToOptions) -> UInt32 {
        let this = jsObject
        return this[Strings.allocationSize].function!(this: this, arguments: [options.jsValue]).fromJSValue()!
    }

    @inlinable public func copyTo(destination: BufferSource, options: AudioDataCopyToOptions) {
        let this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [destination.jsValue, options.jsValue])
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

public class AudioDataCopyToOptions: BridgedDictionary {
    public convenience init(planeIndex: UInt32, frameOffset: UInt32, frameCount: UInt32, format: AudioSampleFormat) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.planeIndex] = planeIndex.jsValue
        object[Strings.frameOffset] = frameOffset.jsValue
        object[Strings.frameCount] = frameCount.jsValue
        object[Strings.format] = format.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _planeIndex = ReadWriteAttribute(jsObject: object, name: Strings.planeIndex)
        _frameOffset = ReadWriteAttribute(jsObject: object, name: Strings.frameOffset)
        _frameCount = ReadWriteAttribute(jsObject: object, name: Strings.frameCount)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var planeIndex: UInt32

    @ReadWriteAttribute
    public var frameOffset: UInt32

    @ReadWriteAttribute
    public var frameCount: UInt32

    @ReadWriteAttribute
    public var format: AudioSampleFormat
}

public class AudioDataInit: BridgedDictionary {
    public convenience init(format: AudioSampleFormat, sampleRate: Float, numberOfFrames: UInt32, numberOfChannels: UInt32, timestamp: Int64, data: BufferSource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.numberOfFrames] = numberOfFrames.jsValue
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.timestamp] = timestamp.jsValue
        object[Strings.data] = data.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _numberOfFrames = ReadWriteAttribute(jsObject: object, name: Strings.numberOfFrames)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _timestamp = ReadWriteAttribute(jsObject: object, name: Strings.timestamp)
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: AudioSampleFormat

    @ReadWriteAttribute
    public var sampleRate: Float

    @ReadWriteAttribute
    public var numberOfFrames: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var data: BufferSource
}

public class AudioDecoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioDecoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _decodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.decodeQueueSize)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: AudioDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var decodeQueueSize: UInt32

    @inlinable public func configure(config: AudioDecoderConfig) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [config.jsValue])
    }

    @inlinable public func decode(chunk: EncodedAudioChunk) {
        let this = jsObject
        _ = this[Strings.decode].function!(this: this, arguments: [chunk.jsValue])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public static func isConfigSupported(config: AudioDecoderConfig) -> JSPromise {
        let this = constructor
        return this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public static func isConfigSupported(config: AudioDecoderConfig) async throws -> AudioDecoderSupport {
        let this = constructor
        let _promise: JSPromise = this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class AudioDecoderConfig: BridgedDictionary {
    public convenience init(codec: String, sampleRate: UInt32, numberOfChannels: UInt32, description: BufferSource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = codec.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.description] = description.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: Strings.codec)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _description = ReadWriteAttribute(jsObject: object, name: Strings.description)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var sampleRate: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var description: BufferSource
}

public class AudioDecoderInit: BridgedDictionary {
    public convenience init(output: @escaping AudioDataOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute1Void[Strings.output, in: object] = output
        ClosureAttribute1Void[Strings.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute1Void(jsObject: object, name: Strings.output)
        _error = ClosureAttribute1Void(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1Void
    public var output: AudioDataOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class AudioDecoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: AudioDecoderConfig) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = supported.jsValue
        object[Strings.config] = config.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: Strings.supported)
        _config = ReadWriteAttribute(jsObject: object, name: Strings.config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: AudioDecoderConfig
}

public class AudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioDestinationNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _maxChannelCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxChannelCount)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var maxChannelCount: UInt32
}

public class AudioEncoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _encodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.encodeQueueSize)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: AudioEncoderInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var encodeQueueSize: UInt32

    @inlinable public func configure(config: AudioEncoderConfig) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [config.jsValue])
    }

    @inlinable public func encode(data: AudioData) {
        let this = jsObject
        _ = this[Strings.encode].function!(this: this, arguments: [data.jsValue])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public static func isConfigSupported(config: AudioEncoderConfig) -> JSPromise {
        let this = constructor
        return this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public static func isConfigSupported(config: AudioEncoderConfig) async throws -> AudioEncoderSupport {
        let this = constructor
        let _promise: JSPromise = this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class AudioEncoderConfig: BridgedDictionary {
    public convenience init(codec: String, sampleRate: UInt32, numberOfChannels: UInt32, bitrate: UInt64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = codec.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.bitrate] = bitrate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: Strings.codec)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _bitrate = ReadWriteAttribute(jsObject: object, name: Strings.bitrate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var sampleRate: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var bitrate: UInt64
}

public class AudioEncoderInit: BridgedDictionary {
    public convenience init(output: @escaping EncodedAudioChunkOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute2Void[Strings.output, in: object] = output
        ClosureAttribute1Void[Strings.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute2Void(jsObject: object, name: Strings.output)
        _error = ClosureAttribute1Void(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute2Void
    public var output: EncodedAudioChunkOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class AudioEncoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: AudioEncoderConfig) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = supported.jsValue
        object[Strings.config] = config.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: Strings.supported)
        _config = ReadWriteAttribute(jsObject: object, name: Strings.config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: AudioEncoderConfig
}

public class AudioListener: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioListener].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _positionX = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionX)
        _positionY = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionY)
        _positionZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionZ)
        _forwardX = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardX)
        _forwardY = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardY)
        _forwardZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardZ)
        _upX = ReadonlyAttribute(jsObject: jsObject, name: Strings.upX)
        _upY = ReadonlyAttribute(jsObject: jsObject, name: Strings.upY)
        _upZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.upZ)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var positionX: AudioParam

    @ReadonlyAttribute
    public var positionY: AudioParam

    @ReadonlyAttribute
    public var positionZ: AudioParam

    @ReadonlyAttribute
    public var forwardX: AudioParam

    @ReadonlyAttribute
    public var forwardY: AudioParam

    @ReadonlyAttribute
    public var forwardZ: AudioParam

    @ReadonlyAttribute
    public var upX: AudioParam

    @ReadonlyAttribute
    public var upY: AudioParam

    @ReadonlyAttribute
    public var upZ: AudioParam

    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setPosition].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable public func setOrientation(x: Float, y: Float, z: Float, xUp: Float, yUp: Float, zUp: Float) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = z.jsValue
        let _arg3 = xUp.jsValue
        let _arg4 = yUp.jsValue
        let _arg5 = zUp.jsValue
        let this = jsObject
        _ = this[Strings.setOrientation].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }
}

public class AudioNode: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _context = ReadonlyAttribute(jsObject: jsObject, name: Strings.context)
        _numberOfInputs = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfInputs)
        _numberOfOutputs = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfOutputs)
        _channelCount = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelCount)
        _channelCountMode = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelCountMode)
        _channelInterpretation = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelInterpretation)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func connect(destinationNode: AudioNode, output: UInt32? = nil, input: UInt32? = nil) -> Self {
        let this = jsObject
        return this[Strings.connect].function!(this: this, arguments: [destinationNode.jsValue, output?.jsValue ?? .undefined, input?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func connect(destinationParam: AudioParam, output: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.connect].function!(this: this, arguments: [destinationParam.jsValue, output?.jsValue ?? .undefined])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func disconnect(output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [output.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue, output.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32, input: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue, output.jsValue, input.jsValue])
    }

    @inlinable public func disconnect(destinationParam: AudioParam) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationParam.jsValue])
    }

    @inlinable public func disconnect(destinationParam: AudioParam, output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationParam.jsValue, output.jsValue])
    }

    @ReadonlyAttribute
    public var context: BaseAudioContext

    @ReadonlyAttribute
    public var numberOfInputs: UInt32

    @ReadonlyAttribute
    public var numberOfOutputs: UInt32

    @ReadWriteAttribute
    public var channelCount: UInt32

    @ReadWriteAttribute
    public var channelCountMode: ChannelCountMode

    @ReadWriteAttribute
    public var channelInterpretation: ChannelInterpretation
}

public class AudioNodeOptions: BridgedDictionary {
    public convenience init(channelCount: UInt32, channelCountMode: ChannelCountMode, channelInterpretation: ChannelInterpretation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.channelCountMode] = channelCountMode.jsValue
        object[Strings.channelInterpretation] = channelInterpretation.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _channelCountMode = ReadWriteAttribute(jsObject: object, name: Strings.channelCountMode)
        _channelInterpretation = ReadWriteAttribute(jsObject: object, name: Strings.channelInterpretation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var channelCount: UInt32

    @ReadWriteAttribute
    public var channelCountMode: ChannelCountMode

    @ReadWriteAttribute
    public var channelInterpretation: ChannelInterpretation
}

public class AudioParam: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioParam].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _automationRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.automationRate)
        _defaultValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.defaultValue)
        _minValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.minValue)
        _maxValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxValue)
        self.jsObject = jsObject
    }

    @ReadWriteAttribute
    public var value: Float

    @ReadWriteAttribute
    public var automationRate: AutomationRate

    @ReadonlyAttribute
    public var defaultValue: Float

    @ReadonlyAttribute
    public var minValue: Float

    @ReadonlyAttribute
    public var maxValue: Float

    @inlinable public func setValueAtTime(value: Float, startTime: Double) -> Self {
        let this = jsObject
        return this[Strings.setValueAtTime].function!(this: this, arguments: [value.jsValue, startTime.jsValue]).fromJSValue()!
    }

    @inlinable public func linearRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[Strings.linearRampToValueAtTime].function!(this: this, arguments: [value.jsValue, endTime.jsValue]).fromJSValue()!
    }

    @inlinable public func exponentialRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[Strings.exponentialRampToValueAtTime].function!(this: this, arguments: [value.jsValue, endTime.jsValue]).fromJSValue()!
    }

    @inlinable public func setTargetAtTime(target: Float, startTime: Double, timeConstant: Float) -> Self {
        let this = jsObject
        return this[Strings.setTargetAtTime].function!(this: this, arguments: [target.jsValue, startTime.jsValue, timeConstant.jsValue]).fromJSValue()!
    }

    @inlinable public func setValueCurveAtTime(values: [Float], startTime: Double, duration: Double) -> Self {
        let this = jsObject
        return this[Strings.setValueCurveAtTime].function!(this: this, arguments: [values.jsValue, startTime.jsValue, duration.jsValue]).fromJSValue()!
    }

    @inlinable public func cancelScheduledValues(cancelTime: Double) -> Self {
        let this = jsObject
        return this[Strings.cancelScheduledValues].function!(this: this, arguments: [cancelTime.jsValue]).fromJSValue()!
    }

    @inlinable public func cancelAndHoldAtTime(cancelTime: Double) -> Self {
        let this = jsObject
        return this[Strings.cancelAndHoldAtTime].function!(this: this, arguments: [cancelTime.jsValue]).fromJSValue()!
    }
}

public class AudioParamDescriptor: BridgedDictionary {
    public convenience init(name: String, defaultValue: Float, minValue: Float, maxValue: Float, automationRate: AutomationRate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.name] = name.jsValue
        object[Strings.defaultValue] = defaultValue.jsValue
        object[Strings.minValue] = minValue.jsValue
        object[Strings.maxValue] = maxValue.jsValue
        object[Strings.automationRate] = automationRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _name = ReadWriteAttribute(jsObject: object, name: Strings.name)
        _defaultValue = ReadWriteAttribute(jsObject: object, name: Strings.defaultValue)
        _minValue = ReadWriteAttribute(jsObject: object, name: Strings.minValue)
        _maxValue = ReadWriteAttribute(jsObject: object, name: Strings.maxValue)
        _automationRate = ReadWriteAttribute(jsObject: object, name: Strings.automationRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var defaultValue: Float

    @ReadWriteAttribute
    public var minValue: Float

    @ReadWriteAttribute
    public var maxValue: Float

    @ReadWriteAttribute
    public var automationRate: AutomationRate
}

public class AudioParamMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioParamMap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Map-like!
}

public class AudioProcessingEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioProcessingEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _playbackTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.playbackTime)
        _inputBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.inputBuffer)
        _outputBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.outputBuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: AudioProcessingEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var playbackTime: Double

    @ReadonlyAttribute
    public var inputBuffer: AudioBuffer

    @ReadonlyAttribute
    public var outputBuffer: AudioBuffer
}

public class AudioProcessingEventInit: BridgedDictionary {
    public convenience init(playbackTime: Double, inputBuffer: AudioBuffer, outputBuffer: AudioBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.playbackTime] = playbackTime.jsValue
        object[Strings.inputBuffer] = inputBuffer.jsValue
        object[Strings.outputBuffer] = outputBuffer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _playbackTime = ReadWriteAttribute(jsObject: object, name: Strings.playbackTime)
        _inputBuffer = ReadWriteAttribute(jsObject: object, name: Strings.inputBuffer)
        _outputBuffer = ReadWriteAttribute(jsObject: object, name: Strings.outputBuffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var playbackTime: Double

    @ReadWriteAttribute
    public var inputBuffer: AudioBuffer

    @ReadWriteAttribute
    public var outputBuffer: AudioBuffer
}

public enum AudioSampleFormat: JSString, JSValueCompatible {
    case u8 = "u8"
    case s16 = "s16"
    case s32 = "s32"
    case f32 = "f32"
    case u8Planar = "u8-planar"
    case s16Planar = "s16-planar"
    case s32Planar = "s32-planar"
    case f32Planar = "f32-planar"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioScheduledSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioScheduledSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onended = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onended)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onended: EventHandler

    @inlinable public func start(when: Double? = nil) {
        let this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [when?.jsValue ?? .undefined])
    }

    @inlinable public func stop(when: Double? = nil) {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [when?.jsValue ?? .undefined])
    }
}

public class AudioTimestamp: BridgedDictionary {
    public convenience init(contextTime: Double, performanceTime: DOMHighResTimeStamp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.contextTime] = contextTime.jsValue
        object[Strings.performanceTime] = performanceTime.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _contextTime = ReadWriteAttribute(jsObject: object, name: Strings.contextTime)
        _performanceTime = ReadWriteAttribute(jsObject: object, name: Strings.performanceTime)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var contextTime: Double

    @ReadWriteAttribute
    public var performanceTime: DOMHighResTimeStamp
}

public class AudioTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.AudioTrack].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: Strings.id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: Strings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: Strings.language)
        _enabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.enabled)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var enabled: Bool
}

public class AudioTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> AudioTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> AudioTrack? {
        let this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class AudioWorklet: Worklet {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioWorklet].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class AudioWorkletNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.AudioWorkletNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _parameters = ReadonlyAttribute(jsObject: jsObject, name: Strings.parameters)
        _port = ReadonlyAttribute(jsObject: jsObject, name: Strings.port)
        _onprocessorerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onprocessorerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, name: String, options: AudioWorkletNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, name.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var parameters: AudioParamMap

    @ReadonlyAttribute
    public var port: MessagePort

    @ClosureAttribute1Optional
    public var onprocessorerror: EventHandler
}

public class AudioWorkletNodeOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32, numberOfOutputs: UInt32, outputChannelCount: [UInt32], parameterData: [String: Double], processorOptions: JSObject) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfInputs] = numberOfInputs.jsValue
        object[Strings.numberOfOutputs] = numberOfOutputs.jsValue
        object[Strings.outputChannelCount] = outputChannelCount.jsValue
        object[Strings.parameterData] = parameterData.jsValue
        object[Strings.processorOptions] = processorOptions.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfInputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfInputs)
        _numberOfOutputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfOutputs)
        _outputChannelCount = ReadWriteAttribute(jsObject: object, name: Strings.outputChannelCount)
        _parameterData = ReadWriteAttribute(jsObject: object, name: Strings.parameterData)
        _processorOptions = ReadWriteAttribute(jsObject: object, name: Strings.processorOptions)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfInputs: UInt32

    @ReadWriteAttribute
    public var numberOfOutputs: UInt32

    @ReadWriteAttribute
    public var outputChannelCount: [UInt32]

    @ReadWriteAttribute
    public var parameterData: [String: Double]

    @ReadWriteAttribute
    public var processorOptions: JSObject
}

public enum AutomationRate: JSString, JSValueCompatible {
    case aRate = "a-rate"
    case kRate = "k-rate"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class BarProp: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.BarProp].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _visible = ReadonlyAttribute(jsObject: jsObject, name: Strings.visible)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var visible: Bool
}

public class BaseAudioContext: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.BaseAudioContext].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _destination = ReadonlyAttribute(jsObject: jsObject, name: Strings.destination)
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleRate)
        _currentTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentTime)
        _listener = ReadonlyAttribute(jsObject: jsObject, name: Strings.listener)
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _audioWorklet = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioWorklet)
        _onstatechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var destination: AudioDestinationNode

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var currentTime: Double

    @ReadonlyAttribute
    public var listener: AudioListener

    @ReadonlyAttribute
    public var state: AudioContextState

    @ReadonlyAttribute
    public var audioWorklet: AudioWorklet

    @ClosureAttribute1Optional
    public var onstatechange: EventHandler

    @inlinable public func createAnalyser() -> AnalyserNode {
        let this = jsObject
        return this[Strings.createAnalyser].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createBiquadFilter() -> BiquadFilterNode {
        let this = jsObject
        return this[Strings.createBiquadFilter].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createBuffer(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) -> AudioBuffer {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: [numberOfChannels.jsValue, length.jsValue, sampleRate.jsValue]).fromJSValue()!
    }

    @inlinable public func createBufferSource() -> AudioBufferSourceNode {
        let this = jsObject
        return this[Strings.createBufferSource].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createChannelMerger(numberOfInputs: UInt32? = nil) -> ChannelMergerNode {
        let this = jsObject
        return this[Strings.createChannelMerger].function!(this: this, arguments: [numberOfInputs?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createChannelSplitter(numberOfOutputs: UInt32? = nil) -> ChannelSplitterNode {
        let this = jsObject
        return this[Strings.createChannelSplitter].function!(this: this, arguments: [numberOfOutputs?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createConstantSource() -> ConstantSourceNode {
        let this = jsObject
        return this[Strings.createConstantSource].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createConvolver() -> ConvolverNode {
        let this = jsObject
        return this[Strings.createConvolver].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createDelay(maxDelayTime: Double? = nil) -> DelayNode {
        let this = jsObject
        return this[Strings.createDelay].function!(this: this, arguments: [maxDelayTime?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createDynamicsCompressor() -> DynamicsCompressorNode {
        let this = jsObject
        return this[Strings.createDynamicsCompressor].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createGain() -> GainNode {
        let this = jsObject
        return this[Strings.createGain].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createIIRFilter(feedforward: [Double], feedback: [Double]) -> IIRFilterNode {
        let this = jsObject
        return this[Strings.createIIRFilter].function!(this: this, arguments: [feedforward.jsValue, feedback.jsValue]).fromJSValue()!
    }

    @inlinable public func createOscillator() -> OscillatorNode {
        let this = jsObject
        return this[Strings.createOscillator].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createPanner() -> PannerNode {
        let this = jsObject
        return this[Strings.createPanner].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createPeriodicWave(real: [Float], imag: [Float], constraints: PeriodicWaveConstraints? = nil) -> PeriodicWave {
        let this = jsObject
        return this[Strings.createPeriodicWave].function!(this: this, arguments: [real.jsValue, imag.jsValue, constraints?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createScriptProcessor(bufferSize: UInt32? = nil, numberOfInputChannels: UInt32? = nil, numberOfOutputChannels: UInt32? = nil) -> ScriptProcessorNode {
        let this = jsObject
        return this[Strings.createScriptProcessor].function!(this: this, arguments: [bufferSize?.jsValue ?? .undefined, numberOfInputChannels?.jsValue ?? .undefined, numberOfOutputChannels?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createStereoPanner() -> StereoPannerNode {
        let this = jsObject
        return this[Strings.createStereoPanner].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createWaveShaper() -> WaveShaperNode {
        let this = jsObject
        return this[Strings.createWaveShaper].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'decodeAudioData' is ignored

    // XXX: member 'decodeAudioData' is ignored
}

public class BaseComputedKeyframe: BridgedDictionary {
    public convenience init(offset: Double?, computedOffset: Double, easing: String, composite: CompositeOperationOrAuto) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        object[Strings.computedOffset] = computedOffset.jsValue
        object[Strings.easing] = easing.jsValue
        object[Strings.composite] = composite.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _computedOffset = ReadWriteAttribute(jsObject: object, name: Strings.computedOffset)
        _easing = ReadWriteAttribute(jsObject: object, name: Strings.easing)
        _composite = ReadWriteAttribute(jsObject: object, name: Strings.composite)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Double?

    @ReadWriteAttribute
    public var computedOffset: Double

    @ReadWriteAttribute
    public var easing: String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto
}

public class BaseKeyframe: BridgedDictionary {
    public convenience init(offset: Double?, easing: String, composite: CompositeOperationOrAuto) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        object[Strings.easing] = easing.jsValue
        object[Strings.composite] = composite.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _easing = ReadWriteAttribute(jsObject: object, name: Strings.easing)
        _composite = ReadWriteAttribute(jsObject: object, name: Strings.composite)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Double?

    @ReadWriteAttribute
    public var easing: String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto
}

public class BasePropertyIndexedKeyframe: BridgedDictionary {
    public convenience init(offset: nullable_Double_or_seq_of_nullable_Double, easing: String_or_seq_of_String, composite: CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        object[Strings.easing] = easing.jsValue
        object[Strings.composite] = composite.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _easing = ReadWriteAttribute(jsObject: object, name: Strings.easing)
        _composite = ReadWriteAttribute(jsObject: object, name: Strings.composite)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: nullable_Double_or_seq_of_nullable_Double

    @ReadWriteAttribute
    public var easing: String_or_seq_of_String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto
}

public class BeforeUnloadEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.BeforeUnloadEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    // XXX: member 'returnValue' is ignored
}

public enum BinaryType: JSString, JSValueCompatible {
    case blob = "blob"
    case arraybuffer = "arraybuffer"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class BiquadFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.BiquadFilterNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _frequency = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequency)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        _Q = ReadonlyAttribute(jsObject: jsObject, name: Strings.Q)
        _gain = ReadonlyAttribute(jsObject: jsObject, name: Strings.gain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: BiquadFilterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var type: BiquadFilterType

    @ReadonlyAttribute
    public var frequency: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @ReadonlyAttribute
    public var Q: AudioParam

    @ReadonlyAttribute
    public var gain: AudioParam

    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFrequencyResponse].function!(this: this, arguments: [frequencyHz.jsValue, magResponse.jsValue, phaseResponse.jsValue])
    }
}

public class BiquadFilterOptions: BridgedDictionary {
    public convenience init(type: BiquadFilterType, Q: Float, detune: Float, frequency: Float, gain: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.Q] = Q.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.frequency] = frequency.jsValue
        object[Strings.gain] = gain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _Q = ReadWriteAttribute(jsObject: object, name: Strings.Q)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _frequency = ReadWriteAttribute(jsObject: object, name: Strings.frequency)
        _gain = ReadWriteAttribute(jsObject: object, name: Strings.gain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: BiquadFilterType

    @ReadWriteAttribute
    public var Q: Float

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var frequency: Float

    @ReadWriteAttribute
    public var gain: Float
}

public enum BiquadFilterType: JSString, JSValueCompatible {
    case lowpass = "lowpass"
    case highpass = "highpass"
    case bandpass = "bandpass"
    case lowshelf = "lowshelf"
    case highshelf = "highshelf"
    case peaking = "peaking"
    case notch = "notch"
    case allpass = "allpass"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum BitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Blob: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Blob].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(blobParts: [BlobPart]? = nil, options: BlobPropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [blobParts?.jsValue ?? .undefined, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var size: UInt64

    @ReadonlyAttribute
    public var type: String

    @inlinable public func slice(start: Int64? = nil, end: Int64? = nil, contentType: String? = nil) -> Self {
        let this = jsObject
        return this[Strings.slice].function!(this: this, arguments: [start?.jsValue ?? .undefined, end?.jsValue ?? .undefined, contentType?.jsValue ?? .undefined]).fromJSValue()!
    }

    // XXX: member 'stream' is ignored

    @inlinable public func text() -> JSPromise {
        let this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BlobEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.BlobEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: Strings.data)
        _timecode = ReadonlyAttribute(jsObject: jsObject, name: Strings.timecode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: BlobEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var data: Blob

    @ReadonlyAttribute
    public var timecode: DOMHighResTimeStamp
}

public class BlobEventInit: BridgedDictionary {
    public convenience init(data: Blob, timecode: DOMHighResTimeStamp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.data] = data.jsValue
        object[Strings.timecode] = timecode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        _timecode = ReadWriteAttribute(jsObject: object, name: Strings.timecode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: Blob

    @ReadWriteAttribute
    public var timecode: DOMHighResTimeStamp
}

public class BlobPropertyBag: BridgedDictionary {
    public convenience init(type: String, endings: EndingType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.endings] = endings.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _endings = ReadWriteAttribute(jsObject: object, name: Strings.endings)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var endings: EndingType
}

public protocol Body: JSBridgedClass {}
public extension Body {
    // XXX: attribute 'body' is ignored

    @inlinable var bodyUsed: Bool { ReadonlyAttribute[Strings.bodyUsed, in: jsObject] }

    @inlinable func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func blob() -> JSPromise {
        let this = jsObject
        return this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func blob() async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func formData() -> JSPromise {
        let this = jsObject
        return this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func formData() async throws -> FormData {
        let this = jsObject
        let _promise: JSPromise = this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func json() -> JSPromise {
        let this = jsObject
        return this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func json() async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func text() -> JSPromise {
        let this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BoxQuadOptions: BridgedDictionary {
    public convenience init(box: CSSBoxType, relativeTo: GeometryNode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.box] = box.jsValue
        object[Strings.relativeTo] = relativeTo.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _box = ReadWriteAttribute(jsObject: object, name: Strings.box)
        _relativeTo = ReadWriteAttribute(jsObject: object, name: Strings.relativeTo)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var box: CSSBoxType

    @ReadWriteAttribute
    public var relativeTo: GeometryNode
}

public class BroadcastChannel: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.BroadcastChannel].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(name: String) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [name.jsValue]))
    }

    @ReadonlyAttribute
    public var name: String

    @inlinable public func postMessage(message: JSValue) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class ByteLengthQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ByteLengthQueuingStrategy].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _highWaterMark = ReadonlyAttribute(jsObject: jsObject, name: Strings.highWaterMark)
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var highWaterMark: Double

    @ReadonlyAttribute
    public var size: JSFunction
}

public class CDATASection: Text {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CDATASection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public enum CSSBoxType: JSString, JSValueCompatible {
    case margin = "margin"
    case border = "border"
    case padding = "padding"
    case content = "content"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSPseudoElement: EventTarget, GeometryUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CSSPseudoElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _element = ReadonlyAttribute(jsObject: jsObject, name: Strings.element)
        _parent = ReadonlyAttribute(jsObject: jsObject, name: Strings.parent)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var element: Element

    @ReadonlyAttribute
    public var parent: CSSPseudoElement_or_Element

    @inlinable public func pseudo(type: String) -> CSSPseudoElement? {
        let this = jsObject
        return this[Strings.pseudo].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }
}

public class Cache: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Cache].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.matchAll].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Response] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.matchAll].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func add(request: RequestInfo) -> JSPromise {
        let this = jsObject
        return this[Strings.add].function!(this: this, arguments: [request.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func add(request: RequestInfo) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.add].function!(this: this, arguments: [request.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func addAll(requests: [RequestInfo]) -> JSPromise {
        let this = jsObject
        return this[Strings.addAll].function!(this: this, arguments: [requests.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addAll(requests: [RequestInfo]) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.addAll].function!(this: this, arguments: [requests.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func put(request: RequestInfo, response: Response) -> JSPromise {
        let this = jsObject
        return this[Strings.put].function!(this: this, arguments: [request.jsValue, response.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func put(request: RequestInfo, response: Response) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.put].function!(this: this, arguments: [request.jsValue, response.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.delete].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[Strings.delete].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.keys].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Request] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.keys].function!(this: this, arguments: [request?.jsValue ?? .undefined, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class CacheQueryOptions: BridgedDictionary {
    public convenience init(ignoreSearch: Bool, ignoreMethod: Bool, ignoreVary: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ignoreSearch] = ignoreSearch.jsValue
        object[Strings.ignoreMethod] = ignoreMethod.jsValue
        object[Strings.ignoreVary] = ignoreVary.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _ignoreSearch = ReadWriteAttribute(jsObject: object, name: Strings.ignoreSearch)
        _ignoreMethod = ReadWriteAttribute(jsObject: object, name: Strings.ignoreMethod)
        _ignoreVary = ReadWriteAttribute(jsObject: object, name: Strings.ignoreVary)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var ignoreSearch: Bool

    @ReadWriteAttribute
    public var ignoreMethod: Bool

    @ReadWriteAttribute
    public var ignoreVary: Bool
}

public class CacheStorage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CacheStorage].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.match].function!(this: this, arguments: [request.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func has(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func has(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[Strings.has].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func open(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[Strings.open].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func open(cacheName: String) async throws -> Cache {
        let this = jsObject
        let _promise: JSPromise = this[Strings.open].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func delete(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[Strings.delete].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[Strings.delete].function!(this: this, arguments: [cacheName.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys() -> JSPromise {
        let this = jsObject
        return this[Strings.keys].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys() async throws -> [String] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.keys].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class CameraDevicePermissionDescriptor: BridgedDictionary {
    public convenience init(panTiltZoom: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.panTiltZoom] = panTiltZoom.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _panTiltZoom = ReadWriteAttribute(jsObject: object, name: Strings.panTiltZoom)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var panTiltZoom: Bool
}

public enum CanPlayTypeResult: JSString, JSValueCompatible {
    case _empty = ""
    case maybe = "maybe"
    case probably = "probably"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasCompositing: JSBridgedClass {}
public extension CanvasCompositing {
    @inlinable var globalAlpha: Double {
        get { ReadWriteAttribute[Strings.globalAlpha, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.globalAlpha, in: jsObject] = newValue }
    }

    @inlinable var globalCompositeOperation: String {
        get { ReadWriteAttribute[Strings.globalCompositeOperation, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.globalCompositeOperation, in: jsObject] = newValue }
    }
}

public enum CanvasDirection: JSString, JSValueCompatible {
    case ltr = "ltr"
    case rtl = "rtl"
    case inherit = "inherit"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasDrawImage: JSBridgedClass {}
public extension CanvasDrawImage {
    @inlinable func drawImage(image: CanvasImageSource, dx: Double, dy: Double) {
        let this = jsObject
        _ = this[Strings.drawImage].function!(this: this, arguments: [image.jsValue, dx.jsValue, dy.jsValue])
    }

    @inlinable func drawImage(image: CanvasImageSource, dx: Double, dy: Double, dw: Double, dh: Double) {
        let this = jsObject
        _ = this[Strings.drawImage].function!(this: this, arguments: [image.jsValue, dx.jsValue, dy.jsValue, dw.jsValue, dh.jsValue])
    }

    @inlinable func drawImage(image: CanvasImageSource, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double) {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = dx.jsValue
        let _arg6 = dy.jsValue
        let _arg7 = dw.jsValue
        let _arg8 = dh.jsValue
        let this = jsObject
        _ = this[Strings.drawImage].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }
}

public protocol CanvasDrawPath: JSBridgedClass {}
public extension CanvasDrawPath {
    @inlinable func beginPath() {
        let this = jsObject
        _ = this[Strings.beginPath].function!(this: this, arguments: [])
    }

    @inlinable func fill(fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[Strings.fill].function!(this: this, arguments: [fillRule?.jsValue ?? .undefined])
    }

    @inlinable func fill(path: Path2D, fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[Strings.fill].function!(this: this, arguments: [path.jsValue, fillRule?.jsValue ?? .undefined])
    }

    @inlinable func stroke() {
        let this = jsObject
        _ = this[Strings.stroke].function!(this: this, arguments: [])
    }

    @inlinable func stroke(path: Path2D) {
        let this = jsObject
        _ = this[Strings.stroke].function!(this: this, arguments: [path.jsValue])
    }

    @inlinable func clip(fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[Strings.clip].function!(this: this, arguments: [fillRule?.jsValue ?? .undefined])
    }

    @inlinable func clip(path: Path2D, fillRule: CanvasFillRule? = nil) {
        let this = jsObject
        _ = this[Strings.clip].function!(this: this, arguments: [path.jsValue, fillRule?.jsValue ?? .undefined])
    }

    @inlinable func isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule? = nil) -> Bool {
        let this = jsObject
        return this[Strings.isPointInPath].function!(this: this, arguments: [x.jsValue, y.jsValue, fillRule?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule? = nil) -> Bool {
        let this = jsObject
        return this[Strings.isPointInPath].function!(this: this, arguments: [path.jsValue, x.jsValue, y.jsValue, fillRule?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func isPointInStroke(x: Double, y: Double) -> Bool {
        let this = jsObject
        return this[Strings.isPointInStroke].function!(this: this, arguments: [x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable func isPointInStroke(path: Path2D, x: Double, y: Double) -> Bool {
        let this = jsObject
        return this[Strings.isPointInStroke].function!(this: this, arguments: [path.jsValue, x.jsValue, y.jsValue]).fromJSValue()!
    }
}

public enum CanvasFillRule: JSString, JSValueCompatible {
    case nonzero = "nonzero"
    case evenodd = "evenodd"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasFillStrokeStyles: JSBridgedClass {}
public extension CanvasFillStrokeStyles {
    @inlinable var strokeStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { ReadWriteAttribute[Strings.strokeStyle, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.strokeStyle, in: jsObject] = newValue }
    }

    @inlinable var fillStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { ReadWriteAttribute[Strings.fillStyle, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.fillStyle, in: jsObject] = newValue }
    }

    @inlinable func createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double) -> CanvasGradient {
        let this = jsObject
        return this[Strings.createLinearGradient].function!(this: this, arguments: [x0.jsValue, y0.jsValue, x1.jsValue, y1.jsValue]).fromJSValue()!
    }

    @inlinable func createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double) -> CanvasGradient {
        let _arg0 = x0.jsValue
        let _arg1 = y0.jsValue
        let _arg2 = r0.jsValue
        let _arg3 = x1.jsValue
        let _arg4 = y1.jsValue
        let _arg5 = r1.jsValue
        let this = jsObject
        return this[Strings.createRadialGradient].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @inlinable func createConicGradient(startAngle: Double, x: Double, y: Double) -> CanvasGradient {
        let this = jsObject
        return this[Strings.createConicGradient].function!(this: this, arguments: [startAngle.jsValue, x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable func createPattern(image: CanvasImageSource, repetition: String) -> CanvasPattern? {
        let this = jsObject
        return this[Strings.createPattern].function!(this: this, arguments: [image.jsValue, repetition.jsValue]).fromJSValue()!
    }
}

public class CanvasFilter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CanvasFilter].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(filters: CanvasFilterInput_or_seq_of_CanvasFilterInput? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [filters?.jsValue ?? .undefined]))
    }
}

public protocol CanvasFilters: JSBridgedClass {}
public extension CanvasFilters {
    @inlinable var filter: CanvasFilter_or_String {
        get { ReadWriteAttribute[Strings.filter, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.filter, in: jsObject] = newValue }
    }
}

public enum CanvasFontKerning: JSString, JSValueCompatible {
    case auto = "auto"
    case normal = "normal"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasFontStretch: JSString, JSValueCompatible {
    case ultraCondensed = "ultra-condensed"
    case extraCondensed = "extra-condensed"
    case condensed = "condensed"
    case semiCondensed = "semi-condensed"
    case normal = "normal"
    case semiExpanded = "semi-expanded"
    case expanded = "expanded"
    case extraExpanded = "extra-expanded"
    case ultraExpanded = "ultra-expanded"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasFontVariantCaps: JSString, JSValueCompatible {
    case normal = "normal"
    case smallCaps = "small-caps"
    case allSmallCaps = "all-small-caps"
    case petiteCaps = "petite-caps"
    case allPetiteCaps = "all-petite-caps"
    case unicase = "unicase"
    case titlingCaps = "titling-caps"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CanvasGradient: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CanvasGradient].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func addColorStop(offset: Double, color: String) {
        let this = jsObject
        _ = this[Strings.addColorStop].function!(this: this, arguments: [offset.jsValue, color.jsValue])
    }
}

public protocol CanvasImageData: JSBridgedClass {}
public extension CanvasImageData {
    @inlinable func createImageData(sw: Int32, sh: Int32, settings: ImageDataSettings? = nil) -> ImageData {
        let this = jsObject
        return this[Strings.createImageData].function!(this: this, arguments: [sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func createImageData(imagedata: ImageData) -> ImageData {
        let this = jsObject
        return this[Strings.createImageData].function!(this: this, arguments: [imagedata.jsValue]).fromJSValue()!
    }

    @inlinable func getImageData(sx: Int32, sy: Int32, sw: Int32, sh: Int32, settings: ImageDataSettings? = nil) -> ImageData {
        let this = jsObject
        return this[Strings.getImageData].function!(this: this, arguments: [sx.jsValue, sy.jsValue, sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func putImageData(imagedata: ImageData, dx: Int32, dy: Int32) {
        let this = jsObject
        _ = this[Strings.putImageData].function!(this: this, arguments: [imagedata.jsValue, dx.jsValue, dy.jsValue])
    }

    @inlinable func putImageData(imagedata: ImageData, dx: Int32, dy: Int32, dirtyX: Int32, dirtyY: Int32, dirtyWidth: Int32, dirtyHeight: Int32) {
        let _arg0 = imagedata.jsValue
        let _arg1 = dx.jsValue
        let _arg2 = dy.jsValue
        let _arg3 = dirtyX.jsValue
        let _arg4 = dirtyY.jsValue
        let _arg5 = dirtyWidth.jsValue
        let _arg6 = dirtyHeight.jsValue
        let this = jsObject
        _ = this[Strings.putImageData].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }
}

public protocol CanvasImageSmoothing: JSBridgedClass {}
public extension CanvasImageSmoothing {
    @inlinable var imageSmoothingEnabled: Bool {
        get { ReadWriteAttribute[Strings.imageSmoothingEnabled, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.imageSmoothingEnabled, in: jsObject] = newValue }
    }

    @inlinable var imageSmoothingQuality: ImageSmoothingQuality {
        get { ReadWriteAttribute[Strings.imageSmoothingQuality, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.imageSmoothingQuality, in: jsObject] = newValue }
    }
}

public enum CanvasLineCap: JSString, JSValueCompatible {
    case butt = "butt"
    case round = "round"
    case square = "square"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasLineJoin: JSString, JSValueCompatible {
    case round = "round"
    case bevel = "bevel"
    case miter = "miter"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasPath: JSBridgedClass {}
public extension CanvasPath {
    @inlinable func closePath() {
        let this = jsObject
        _ = this[Strings.closePath].function!(this: this, arguments: [])
    }

    @inlinable func moveTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.moveTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func lineTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.lineTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.quadraticCurveTo].function!(this: this, arguments: [cpx.jsValue, cpy.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double) {
        let _arg0 = cp1x.jsValue
        let _arg1 = cp1y.jsValue
        let _arg2 = cp2x.jsValue
        let _arg3 = cp2y.jsValue
        let _arg4 = x.jsValue
        let _arg5 = y.jsValue
        let this = jsObject
        _ = this[Strings.bezierCurveTo].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double) {
        let this = jsObject
        _ = this[Strings.arcTo].function!(this: this, arguments: [x1.jsValue, y1.jsValue, x2.jsValue, y2.jsValue, radius.jsValue])
    }

    @inlinable func rect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[Strings.rect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func roundRect(x: Double, y: Double, w: Double, h: Double, radii: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double? = nil) {
        let this = jsObject
        _ = this[Strings.roundRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue, radii?.jsValue ?? .undefined])
    }

    @inlinable func arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, counterclockwise: Bool? = nil) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = radius.jsValue
        let _arg3 = startAngle.jsValue
        let _arg4 = endAngle.jsValue
        let _arg5 = counterclockwise?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.arc].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, counterclockwise: Bool? = nil) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = radiusX.jsValue
        let _arg3 = radiusY.jsValue
        let _arg4 = rotation.jsValue
        let _arg5 = startAngle.jsValue
        let _arg6 = endAngle.jsValue
        let _arg7 = counterclockwise?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.ellipse].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public protocol CanvasPathDrawingStyles: JSBridgedClass {}
public extension CanvasPathDrawingStyles {
    @inlinable var lineWidth: Double {
        get { ReadWriteAttribute[Strings.lineWidth, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.lineWidth, in: jsObject] = newValue }
    }

    @inlinable var lineCap: CanvasLineCap {
        get { ReadWriteAttribute[Strings.lineCap, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.lineCap, in: jsObject] = newValue }
    }

    @inlinable var lineJoin: CanvasLineJoin {
        get { ReadWriteAttribute[Strings.lineJoin, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.lineJoin, in: jsObject] = newValue }
    }

    @inlinable var miterLimit: Double {
        get { ReadWriteAttribute[Strings.miterLimit, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.miterLimit, in: jsObject] = newValue }
    }

    @inlinable func setLineDash(segments: [Double]) {
        let this = jsObject
        _ = this[Strings.setLineDash].function!(this: this, arguments: [segments.jsValue])
    }

    @inlinable func getLineDash() -> [Double] {
        let this = jsObject
        return this[Strings.getLineDash].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var lineDashOffset: Double {
        get { ReadWriteAttribute[Strings.lineDashOffset, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.lineDashOffset, in: jsObject] = newValue }
    }
}

public class CanvasPattern: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CanvasPattern].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setTransform(transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[Strings.setTransform].function!(this: this, arguments: [transform?.jsValue ?? .undefined])
    }
}

public protocol CanvasRect: JSBridgedClass {}
public extension CanvasRect {
    @inlinable func clearRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[Strings.clearRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func fillRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[Strings.fillRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }

    @inlinable func strokeRect(x: Double, y: Double, w: Double, h: Double) {
        let this = jsObject
        _ = this[Strings.strokeRect].function!(this: this, arguments: [x.jsValue, y.jsValue, w.jsValue, h.jsValue])
    }
}

public class CanvasRenderingContext2D: JSBridgedClass, CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CanvasRenderingContext2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: Strings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement

    @inlinable public func getContextAttributes() -> CanvasRenderingContext2DSettings {
        let this = jsObject
        return this[Strings.getContextAttributes].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class CanvasRenderingContext2DSettings: BridgedDictionary {
    public convenience init(alpha: Bool, desynchronized: Bool, colorSpace: PredefinedColorSpace, willReadFrequently: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = alpha.jsValue
        object[Strings.desynchronized] = desynchronized.jsValue
        object[Strings.colorSpace] = colorSpace.jsValue
        object[Strings.willReadFrequently] = willReadFrequently.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        _desynchronized = ReadWriteAttribute(jsObject: object, name: Strings.desynchronized)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _willReadFrequently = ReadWriteAttribute(jsObject: object, name: Strings.willReadFrequently)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool

    @ReadWriteAttribute
    public var desynchronized: Bool

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var willReadFrequently: Bool
}

public protocol CanvasShadowStyles: JSBridgedClass {}
public extension CanvasShadowStyles {
    @inlinable var shadowOffsetX: Double {
        get { ReadWriteAttribute[Strings.shadowOffsetX, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.shadowOffsetX, in: jsObject] = newValue }
    }

    @inlinable var shadowOffsetY: Double {
        get { ReadWriteAttribute[Strings.shadowOffsetY, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.shadowOffsetY, in: jsObject] = newValue }
    }

    @inlinable var shadowBlur: Double {
        get { ReadWriteAttribute[Strings.shadowBlur, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.shadowBlur, in: jsObject] = newValue }
    }

    @inlinable var shadowColor: String {
        get { ReadWriteAttribute[Strings.shadowColor, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.shadowColor, in: jsObject] = newValue }
    }
}

public protocol CanvasState: JSBridgedClass {}
public extension CanvasState {
    @inlinable func save() {
        let this = jsObject
        _ = this[Strings.save].function!(this: this, arguments: [])
    }

    @inlinable func restore() {
        let this = jsObject
        _ = this[Strings.restore].function!(this: this, arguments: [])
    }

    @inlinable func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable func isContextLost() -> Bool {
        let this = jsObject
        return this[Strings.isContextLost].function!(this: this, arguments: []).fromJSValue()!
    }
}

public protocol CanvasText: JSBridgedClass {}
public extension CanvasText {
    @inlinable func fillText(text: String, x: Double, y: Double, maxWidth: Double? = nil) {
        let this = jsObject
        _ = this[Strings.fillText].function!(this: this, arguments: [text.jsValue, x.jsValue, y.jsValue, maxWidth?.jsValue ?? .undefined])
    }

    @inlinable func strokeText(text: String, x: Double, y: Double, maxWidth: Double? = nil) {
        let this = jsObject
        _ = this[Strings.strokeText].function!(this: this, arguments: [text.jsValue, x.jsValue, y.jsValue, maxWidth?.jsValue ?? .undefined])
    }

    @inlinable func measureText(text: String) -> TextMetrics {
        let this = jsObject
        return this[Strings.measureText].function!(this: this, arguments: [text.jsValue]).fromJSValue()!
    }
}

public enum CanvasTextAlign: JSString, JSValueCompatible {
    case start = "start"
    case end = "end"
    case left = "left"
    case right = "right"
    case center = "center"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CanvasTextBaseline: JSString, JSValueCompatible {
    case top = "top"
    case hanging = "hanging"
    case middle = "middle"
    case alphabetic = "alphabetic"
    case ideographic = "ideographic"
    case bottom = "bottom"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasTextDrawingStyles: JSBridgedClass {}
public extension CanvasTextDrawingStyles {
    @inlinable var font: String {
        get { ReadWriteAttribute[Strings.font, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.font, in: jsObject] = newValue }
    }

    @inlinable var textAlign: CanvasTextAlign {
        get { ReadWriteAttribute[Strings.textAlign, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.textAlign, in: jsObject] = newValue }
    }

    @inlinable var textBaseline: CanvasTextBaseline {
        get { ReadWriteAttribute[Strings.textBaseline, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.textBaseline, in: jsObject] = newValue }
    }

    @inlinable var direction: CanvasDirection {
        get { ReadWriteAttribute[Strings.direction, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.direction, in: jsObject] = newValue }
    }

    @inlinable var letterSpacing: String {
        get { ReadWriteAttribute[Strings.letterSpacing, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.letterSpacing, in: jsObject] = newValue }
    }

    @inlinable var fontKerning: CanvasFontKerning {
        get { ReadWriteAttribute[Strings.fontKerning, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.fontKerning, in: jsObject] = newValue }
    }

    @inlinable var fontStretch: CanvasFontStretch {
        get { ReadWriteAttribute[Strings.fontStretch, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.fontStretch, in: jsObject] = newValue }
    }

    @inlinable var fontVariantCaps: CanvasFontVariantCaps {
        get { ReadWriteAttribute[Strings.fontVariantCaps, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.fontVariantCaps, in: jsObject] = newValue }
    }

    @inlinable var textRendering: CanvasTextRendering {
        get { ReadWriteAttribute[Strings.textRendering, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.textRendering, in: jsObject] = newValue }
    }

    @inlinable var wordSpacing: String {
        get { ReadWriteAttribute[Strings.wordSpacing, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.wordSpacing, in: jsObject] = newValue }
    }
}

public enum CanvasTextRendering: JSString, JSValueCompatible {
    case auto = "auto"
    case optimizeSpeed = "optimizeSpeed"
    case optimizeLegibility = "optimizeLegibility"
    case geometricPrecision = "geometricPrecision"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol CanvasTransform: JSBridgedClass {}
public extension CanvasTransform {
    @inlinable func scale(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scale].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func rotate(angle: Double) {
        let this = jsObject
        _ = this[Strings.rotate].function!(this: this, arguments: [angle.jsValue])
    }

    @inlinable func translate(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.translate].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable func transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        let _arg0 = a.jsValue
        let _arg1 = b.jsValue
        let _arg2 = c.jsValue
        let _arg3 = d.jsValue
        let _arg4 = e.jsValue
        let _arg5 = f.jsValue
        let this = jsObject
        _ = this[Strings.transform].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func getTransform() -> DOMMatrix {
        let this = jsObject
        return this[Strings.getTransform].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        let _arg0 = a.jsValue
        let _arg1 = b.jsValue
        let _arg2 = c.jsValue
        let _arg3 = d.jsValue
        let _arg4 = e.jsValue
        let _arg5 = f.jsValue
        let this = jsObject
        _ = this[Strings.setTransform].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func setTransform(transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[Strings.setTransform].function!(this: this, arguments: [transform?.jsValue ?? .undefined])
    }

    @inlinable func resetTransform() {
        let this = jsObject
        _ = this[Strings.resetTransform].function!(this: this, arguments: [])
    }
}

public protocol CanvasUserInterface: JSBridgedClass {}
public extension CanvasUserInterface {
    @inlinable func drawFocusIfNeeded(element: Element) {
        let this = jsObject
        _ = this[Strings.drawFocusIfNeeded].function!(this: this, arguments: [element.jsValue])
    }

    @inlinable func drawFocusIfNeeded(path: Path2D, element: Element) {
        let this = jsObject
        _ = this[Strings.drawFocusIfNeeded].function!(this: this, arguments: [path.jsValue, element.jsValue])
    }

    @inlinable func scrollPathIntoView() {
        let this = jsObject
        _ = this[Strings.scrollPathIntoView].function!(this: this, arguments: [])
    }

    @inlinable func scrollPathIntoView(path: Path2D) {
        let this = jsObject
        _ = this[Strings.scrollPathIntoView].function!(this: this, arguments: [path.jsValue])
    }
}

public class CaretPosition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CaretPosition].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _offsetNode = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetNode)
        _offset = ReadonlyAttribute(jsObject: jsObject, name: Strings.offset)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var offsetNode: Node

    @ReadonlyAttribute
    public var offset: UInt32

    @inlinable public func getClientRect() -> DOMRect? {
        let this = jsObject
        return this[Strings.getClientRect].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum ChannelCountMode: JSString, JSValueCompatible {
    case max = "max"
    case clampedMax = "clamped-max"
    case explicit = "explicit"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ChannelInterpretation: JSString, JSValueCompatible {
    case speakers = "speakers"
    case discrete = "discrete"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ChannelMergerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ChannelMergerNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ChannelMergerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class ChannelMergerOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfInputs] = numberOfInputs.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfInputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfInputs)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfInputs: UInt32
}

public class ChannelSplitterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ChannelSplitterNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ChannelSplitterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class ChannelSplitterOptions: BridgedDictionary {
    public convenience init(numberOfOutputs: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfOutputs] = numberOfOutputs.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfOutputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfOutputs)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfOutputs: UInt32
}

public class CharacterData: Node, NonDocumentTypeChildNode, ChildNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CharacterData].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: Strings.data)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var data: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func substringData(offset: UInt32, count: UInt32) -> String {
        let this = jsObject
        return this[Strings.substringData].function!(this: this, arguments: [offset.jsValue, count.jsValue]).fromJSValue()!
    }

    @inlinable public func appendData(data: String) {
        let this = jsObject
        _ = this[Strings.appendData].function!(this: this, arguments: [data.jsValue])
    }

    @inlinable public func insertData(offset: UInt32, data: String) {
        let this = jsObject
        _ = this[Strings.insertData].function!(this: this, arguments: [offset.jsValue, data.jsValue])
    }

    @inlinable public func deleteData(offset: UInt32, count: UInt32) {
        let this = jsObject
        _ = this[Strings.deleteData].function!(this: this, arguments: [offset.jsValue, count.jsValue])
    }

    @inlinable public func replaceData(offset: UInt32, count: UInt32, data: String) {
        let this = jsObject
        _ = this[Strings.replaceData].function!(this: this, arguments: [offset.jsValue, count.jsValue, data.jsValue])
    }
}

public protocol ChildNode: JSBridgedClass {}
public extension ChildNode {
    @inlinable func before(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.before].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func after(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.after].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func replaceWith(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.replaceWith].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func remove() {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [])
    }
}

public class ClientQueryOptions: BridgedDictionary {
    public convenience init(includeUncontrolled: Bool, type: ClientType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.includeUncontrolled] = includeUncontrolled.jsValue
        object[Strings.type] = type.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _includeUncontrolled = ReadWriteAttribute(jsObject: object, name: Strings.includeUncontrolled)
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var includeUncontrolled: Bool

    @ReadWriteAttribute
    public var type: ClientType
}

public enum ClientType: JSString, JSValueCompatible {
    case window = "window"
    case worker = "worker"
    case sharedworker = "sharedworker"
    case all = "all"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CloseEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CloseEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wasClean = ReadonlyAttribute(jsObject: jsObject, name: Strings.wasClean)
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CloseEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var wasClean: Bool

    @ReadonlyAttribute
    public var code: UInt16

    @ReadonlyAttribute
    public var reason: String
}

public class CloseEventInit: BridgedDictionary {
    public convenience init(wasClean: Bool, code: UInt16, reason: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.wasClean] = wasClean.jsValue
        object[Strings.code] = code.jsValue
        object[Strings.reason] = reason.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _wasClean = ReadWriteAttribute(jsObject: object, name: Strings.wasClean)
        _code = ReadWriteAttribute(jsObject: object, name: Strings.code)
        _reason = ReadWriteAttribute(jsObject: object, name: Strings.reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var wasClean: Bool

    @ReadWriteAttribute
    public var code: UInt16

    @ReadWriteAttribute
    public var reason: String
}

public enum CodecState: JSString, JSValueCompatible {
    case unconfigured = "unconfigured"
    case configured = "configured"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ColorSpaceConversion: JSString, JSValueCompatible {
    case none = "none"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Comment: CharacterData {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Comment].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data?.jsValue ?? .undefined]))
    }
}

public enum CompositeOperation: JSString, JSValueCompatible {
    case replace = "replace"
    case add = "add"
    case accumulate = "accumulate"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CompositeOperationOrAuto: JSString, JSValueCompatible {
    case replace = "replace"
    case add = "add"
    case accumulate = "accumulate"
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CompositionEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CompositionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: Strings.data)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CompositionEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var data: String

    @inlinable public func initCompositionEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: WindowProxy? = nil, dataArg: String? = nil) {
        let this = jsObject
        _ = this[Strings.initCompositionEvent].function!(this: this, arguments: [typeArg.jsValue, bubblesArg?.jsValue ?? .undefined, cancelableArg?.jsValue ?? .undefined, viewArg?.jsValue ?? .undefined, dataArg?.jsValue ?? .undefined])
    }
}

public class CompositionEventInit: BridgedDictionary {
    public convenience init(data: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.data] = data.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: String
}

public class ComputedEffectTiming: BridgedDictionary {
    public convenience init(progress: Double?, currentIteration: Double?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.progress] = progress.jsValue
        object[Strings.currentIteration] = currentIteration.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _progress = ReadWriteAttribute(jsObject: object, name: Strings.progress)
        _currentIteration = ReadWriteAttribute(jsObject: object, name: Strings.currentIteration)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var progress: Double?

    @ReadWriteAttribute
    public var currentIteration: Double?
}

public class ConstantSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ConstantSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _offset = ReadonlyAttribute(jsObject: jsObject, name: Strings.offset)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ConstantSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var offset: AudioParam
}

public class ConstantSourceOptions: BridgedDictionary {
    public convenience init(offset: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Float
}

public class ConstrainBooleanParameters: BridgedDictionary {
    public convenience init(exact: Bool, ideal: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = exact.jsValue
        object[Strings.ideal] = ideal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: Strings.exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: Strings.ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: Bool

    @ReadWriteAttribute
    public var ideal: Bool
}

public class ConstrainDOMStringParameters: BridgedDictionary {
    public convenience init(exact: String_or_seq_of_String, ideal: String_or_seq_of_String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = exact.jsValue
        object[Strings.ideal] = ideal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: Strings.exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: Strings.ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: String_or_seq_of_String

    @ReadWriteAttribute
    public var ideal: String_or_seq_of_String
}

public class ConstrainDoubleRange: BridgedDictionary {
    public convenience init(exact: Double, ideal: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = exact.jsValue
        object[Strings.ideal] = ideal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: Strings.exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: Strings.ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: Double

    @ReadWriteAttribute
    public var ideal: Double
}

public class ConstrainULongRange: BridgedDictionary {
    public convenience init(exact: UInt32, ideal: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = exact.jsValue
        object[Strings.ideal] = ideal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: Strings.exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: Strings.ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: UInt32

    @ReadWriteAttribute
    public var ideal: UInt32
}

public class ConvertCoordinateOptions: BridgedDictionary {
    public convenience init(fromBox: CSSBoxType, toBox: CSSBoxType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.fromBox] = fromBox.jsValue
        object[Strings.toBox] = toBox.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _fromBox = ReadWriteAttribute(jsObject: object, name: Strings.fromBox)
        _toBox = ReadWriteAttribute(jsObject: object, name: Strings.toBox)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var fromBox: CSSBoxType

    @ReadWriteAttribute
    public var toBox: CSSBoxType
}

public class ConvolverNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ConvolverNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: jsObject, name: Strings.buffer)
        _normalize = ReadWriteAttribute(jsObject: jsObject, name: Strings.normalize)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ConvolverOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var normalize: Bool
}

public class ConvolverOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, disableNormalization: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        object[Strings.disableNormalization] = disableNormalization.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _disableNormalization = ReadWriteAttribute(jsObject: object, name: Strings.disableNormalization)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var disableNormalization: Bool
}

public class CountQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CountQueuingStrategy].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _highWaterMark = ReadonlyAttribute(jsObject: jsObject, name: Strings.highWaterMark)
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var highWaterMark: Double

    @ReadonlyAttribute
    public var size: JSFunction
}

public class CustomElementRegistry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.CustomElementRegistry].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func define(name: String, constructor: CustomElementConstructor, options: ElementDefinitionOptions? = nil) {
        let this = jsObject
        _ = this[Strings.define].function!(this: this, arguments: [name.jsValue, constructor.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func get(name: String) -> CustomElementConstructor? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func whenDefined(name: String) -> JSPromise {
        let this = jsObject
        return this[Strings.whenDefined].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func whenDefined(name: String) async throws -> CustomElementConstructor {
        let this = jsObject
        let _promise: JSPromise = this[Strings.whenDefined].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func upgrade(root: Node) {
        let this = jsObject
        _ = this[Strings.upgrade].function!(this: this, arguments: [root.jsValue])
    }
}

public class CustomEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.CustomEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _detail = ReadonlyAttribute(jsObject: jsObject, name: Strings.detail)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CustomEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var detail: JSValue

    @inlinable public func initCustomEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, detail: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.initCustomEvent].function!(this: this, arguments: [type.jsValue, bubbles?.jsValue ?? .undefined, cancelable?.jsValue ?? .undefined, detail?.jsValue ?? .undefined])
    }
}

public class CustomEventInit: BridgedDictionary {
    public convenience init(detail: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.detail] = detail.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _detail = ReadWriteAttribute(jsObject: object, name: Strings.detail)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var detail: JSValue
}

public class DOMException: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMException].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(message: String? = nil, name: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [message?.jsValue ?? .undefined, name?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var code: UInt16

    public static let INDEX_SIZE_ERR: UInt16 = 1

    public static let DOMSTRING_SIZE_ERR: UInt16 = 2

    public static let HIERARCHY_REQUEST_ERR: UInt16 = 3

    public static let WRONG_DOCUMENT_ERR: UInt16 = 4

    public static let INVALID_CHARACTER_ERR: UInt16 = 5

    public static let NO_DATA_ALLOWED_ERR: UInt16 = 6

    public static let NO_MODIFICATION_ALLOWED_ERR: UInt16 = 7

    public static let NOT_FOUND_ERR: UInt16 = 8

    public static let NOT_SUPPORTED_ERR: UInt16 = 9

    public static let INUSE_ATTRIBUTE_ERR: UInt16 = 10

    public static let INVALID_STATE_ERR: UInt16 = 11

    public static let SYNTAX_ERR: UInt16 = 12

    public static let INVALID_MODIFICATION_ERR: UInt16 = 13

    public static let NAMESPACE_ERR: UInt16 = 14

    public static let INVALID_ACCESS_ERR: UInt16 = 15

    public static let VALIDATION_ERR: UInt16 = 16

    public static let TYPE_MISMATCH_ERR: UInt16 = 17

    public static let SECURITY_ERR: UInt16 = 18

    public static let NETWORK_ERR: UInt16 = 19

    public static let ABORT_ERR: UInt16 = 20

    public static let URL_MISMATCH_ERR: UInt16 = 21

    public static let QUOTA_EXCEEDED_ERR: UInt16 = 22

    public static let TIMEOUT_ERR: UInt16 = 23

    public static let INVALID_NODE_TYPE_ERR: UInt16 = 24

    public static let DATA_CLONE_ERR: UInt16 = 25
}

public class DOMImplementation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMImplementation].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func createDocumentType(qualifiedName: String, publicId: String, systemId: String) -> DocumentType {
        let this = jsObject
        return this[Strings.createDocumentType].function!(this: this, arguments: [qualifiedName.jsValue, publicId.jsValue, systemId.jsValue]).fromJSValue()!
    }

    @inlinable public func createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = nil) -> XMLDocument {
        let this = jsObject
        return this[Strings.createDocument].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, doctype?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createHTMLDocument(title: String? = nil) -> Document {
        let this = jsObject
        return this[Strings.createHTMLDocument].function!(this: this, arguments: [title?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func hasFeature() -> Bool {
        let this = jsObject
        return this[Strings.hasFeature].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMMatrix: DOMMatrixReadOnly {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DOMMatrix].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _a = ReadWriteAttribute(jsObject: jsObject, name: Strings.a)
        _b = ReadWriteAttribute(jsObject: jsObject, name: Strings.b)
        _c = ReadWriteAttribute(jsObject: jsObject, name: Strings.c)
        _d = ReadWriteAttribute(jsObject: jsObject, name: Strings.d)
        _e = ReadWriteAttribute(jsObject: jsObject, name: Strings.e)
        _f = ReadWriteAttribute(jsObject: jsObject, name: Strings.f)
        _m11 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m11)
        _m12 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m12)
        _m13 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m13)
        _m14 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m14)
        _m21 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m21)
        _m22 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m22)
        _m23 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m23)
        _m24 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m24)
        _m31 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m31)
        _m32 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m32)
        _m33 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m33)
        _m34 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m34)
        _m41 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m41)
        _m42 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m42)
        _m43 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m43)
        _m44 = ReadWriteAttribute(jsObject: jsObject, name: Strings.m44)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: String_or_seq_of_Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    // XXX: illegal static override
    // override public static func fromMatrix(other: DOMMatrixInit? = nil) -> Self

    // XXX: illegal static override
    // override public static func fromFloat32Array(array32: Float32Array) -> Self

    // XXX: illegal static override
    // override public static func fromFloat64Array(array64: Float64Array) -> Self

    @usableFromInline let _a: ReadWriteAttribute<Double>
    @inlinable override public var a: Double {
        get { _a.wrappedValue }
        set { _a.wrappedValue = newValue }
    }

    @usableFromInline let _b: ReadWriteAttribute<Double>
    @inlinable override public var b: Double {
        get { _b.wrappedValue }
        set { _b.wrappedValue = newValue }
    }

    @usableFromInline let _c: ReadWriteAttribute<Double>
    @inlinable override public var c: Double {
        get { _c.wrappedValue }
        set { _c.wrappedValue = newValue }
    }

    @usableFromInline let _d: ReadWriteAttribute<Double>
    @inlinable override public var d: Double {
        get { _d.wrappedValue }
        set { _d.wrappedValue = newValue }
    }

    @usableFromInline let _e: ReadWriteAttribute<Double>
    @inlinable override public var e: Double {
        get { _e.wrappedValue }
        set { _e.wrappedValue = newValue }
    }

    @usableFromInline let _f: ReadWriteAttribute<Double>
    @inlinable override public var f: Double {
        get { _f.wrappedValue }
        set { _f.wrappedValue = newValue }
    }

    @usableFromInline let _m11: ReadWriteAttribute<Double>
    @inlinable override public var m11: Double {
        get { _m11.wrappedValue }
        set { _m11.wrappedValue = newValue }
    }

    @usableFromInline let _m12: ReadWriteAttribute<Double>
    @inlinable override public var m12: Double {
        get { _m12.wrappedValue }
        set { _m12.wrappedValue = newValue }
    }

    @usableFromInline let _m13: ReadWriteAttribute<Double>
    @inlinable override public var m13: Double {
        get { _m13.wrappedValue }
        set { _m13.wrappedValue = newValue }
    }

    @usableFromInline let _m14: ReadWriteAttribute<Double>
    @inlinable override public var m14: Double {
        get { _m14.wrappedValue }
        set { _m14.wrappedValue = newValue }
    }

    @usableFromInline let _m21: ReadWriteAttribute<Double>
    @inlinable override public var m21: Double {
        get { _m21.wrappedValue }
        set { _m21.wrappedValue = newValue }
    }

    @usableFromInline let _m22: ReadWriteAttribute<Double>
    @inlinable override public var m22: Double {
        get { _m22.wrappedValue }
        set { _m22.wrappedValue = newValue }
    }

    @usableFromInline let _m23: ReadWriteAttribute<Double>
    @inlinable override public var m23: Double {
        get { _m23.wrappedValue }
        set { _m23.wrappedValue = newValue }
    }

    @usableFromInline let _m24: ReadWriteAttribute<Double>
    @inlinable override public var m24: Double {
        get { _m24.wrappedValue }
        set { _m24.wrappedValue = newValue }
    }

    @usableFromInline let _m31: ReadWriteAttribute<Double>
    @inlinable override public var m31: Double {
        get { _m31.wrappedValue }
        set { _m31.wrappedValue = newValue }
    }

    @usableFromInline let _m32: ReadWriteAttribute<Double>
    @inlinable override public var m32: Double {
        get { _m32.wrappedValue }
        set { _m32.wrappedValue = newValue }
    }

    @usableFromInline let _m33: ReadWriteAttribute<Double>
    @inlinable override public var m33: Double {
        get { _m33.wrappedValue }
        set { _m33.wrappedValue = newValue }
    }

    @usableFromInline let _m34: ReadWriteAttribute<Double>
    @inlinable override public var m34: Double {
        get { _m34.wrappedValue }
        set { _m34.wrappedValue = newValue }
    }

    @usableFromInline let _m41: ReadWriteAttribute<Double>
    @inlinable override public var m41: Double {
        get { _m41.wrappedValue }
        set { _m41.wrappedValue = newValue }
    }

    @usableFromInline let _m42: ReadWriteAttribute<Double>
    @inlinable override public var m42: Double {
        get { _m42.wrappedValue }
        set { _m42.wrappedValue = newValue }
    }

    @usableFromInline let _m43: ReadWriteAttribute<Double>
    @inlinable override public var m43: Double {
        get { _m43.wrappedValue }
        set { _m43.wrappedValue = newValue }
    }

    @usableFromInline let _m44: ReadWriteAttribute<Double>
    @inlinable override public var m44: Double {
        get { _m44.wrappedValue }
        set { _m44.wrappedValue = newValue }
    }

    @inlinable public func multiplySelf(other: DOMMatrixInit? = nil) -> Self {
        let this = jsObject
        return this[Strings.multiplySelf].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func preMultiplySelf(other: DOMMatrixInit? = nil) -> Self {
        let this = jsObject
        return this[Strings.preMultiplySelf].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func translateSelf(tx: Double? = nil, ty: Double? = nil, tz: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.translateSelf].function!(this: this, arguments: [tx?.jsValue ?? .undefined, ty?.jsValue ?? .undefined, tz?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func scaleSelf(scaleX: Double? = nil, scaleY: Double? = nil, scaleZ: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> Self {
        let _arg0 = scaleX?.jsValue ?? .undefined
        let _arg1 = scaleY?.jsValue ?? .undefined
        let _arg2 = scaleZ?.jsValue ?? .undefined
        let _arg3 = originX?.jsValue ?? .undefined
        let _arg4 = originY?.jsValue ?? .undefined
        let _arg5 = originZ?.jsValue ?? .undefined
        let this = jsObject
        return this[Strings.scaleSelf].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @inlinable public func scale3dSelf(scale: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.scale3dSelf].function!(this: this, arguments: [scale?.jsValue ?? .undefined, originX?.jsValue ?? .undefined, originY?.jsValue ?? .undefined, originZ?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotateSelf(rotX: Double? = nil, rotY: Double? = nil, rotZ: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.rotateSelf].function!(this: this, arguments: [rotX?.jsValue ?? .undefined, rotY?.jsValue ?? .undefined, rotZ?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotateFromVectorSelf(x: Double? = nil, y: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.rotateFromVectorSelf].function!(this: this, arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotateAxisAngleSelf(x: Double? = nil, y: Double? = nil, z: Double? = nil, angle: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.rotateAxisAngleSelf].function!(this: this, arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, z?.jsValue ?? .undefined, angle?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func skewXSelf(sx: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.skewXSelf].function!(this: this, arguments: [sx?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func skewYSelf(sy: Double? = nil) -> Self {
        let this = jsObject
        return this[Strings.skewYSelf].function!(this: this, arguments: [sy?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func invertSelf() -> Self {
        let this = jsObject
        return this[Strings.invertSelf].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setMatrixValue(transformList: String) -> Self {
        let this = jsObject
        return this[Strings.setMatrixValue].function!(this: this, arguments: [transformList.jsValue]).fromJSValue()!
    }
}

public class DOMMatrix2DInit: BridgedDictionary {
    public convenience init(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double, m11: Double, m12: Double, m21: Double, m22: Double, m41: Double, m42: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.a] = a.jsValue
        object[Strings.b] = b.jsValue
        object[Strings.c] = c.jsValue
        object[Strings.d] = d.jsValue
        object[Strings.e] = e.jsValue
        object[Strings.f] = f.jsValue
        object[Strings.m11] = m11.jsValue
        object[Strings.m12] = m12.jsValue
        object[Strings.m21] = m21.jsValue
        object[Strings.m22] = m22.jsValue
        object[Strings.m41] = m41.jsValue
        object[Strings.m42] = m42.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _a = ReadWriteAttribute(jsObject: object, name: Strings.a)
        _b = ReadWriteAttribute(jsObject: object, name: Strings.b)
        _c = ReadWriteAttribute(jsObject: object, name: Strings.c)
        _d = ReadWriteAttribute(jsObject: object, name: Strings.d)
        _e = ReadWriteAttribute(jsObject: object, name: Strings.e)
        _f = ReadWriteAttribute(jsObject: object, name: Strings.f)
        _m11 = ReadWriteAttribute(jsObject: object, name: Strings.m11)
        _m12 = ReadWriteAttribute(jsObject: object, name: Strings.m12)
        _m21 = ReadWriteAttribute(jsObject: object, name: Strings.m21)
        _m22 = ReadWriteAttribute(jsObject: object, name: Strings.m22)
        _m41 = ReadWriteAttribute(jsObject: object, name: Strings.m41)
        _m42 = ReadWriteAttribute(jsObject: object, name: Strings.m42)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var a: Double

    @ReadWriteAttribute
    public var b: Double

    @ReadWriteAttribute
    public var c: Double

    @ReadWriteAttribute
    public var d: Double

    @ReadWriteAttribute
    public var e: Double

    @ReadWriteAttribute
    public var f: Double

    @ReadWriteAttribute
    public var m11: Double

    @ReadWriteAttribute
    public var m12: Double

    @ReadWriteAttribute
    public var m21: Double

    @ReadWriteAttribute
    public var m22: Double

    @ReadWriteAttribute
    public var m41: Double

    @ReadWriteAttribute
    public var m42: Double
}

public class DOMMatrixInit: BridgedDictionary {
    public convenience init(m13: Double, m14: Double, m23: Double, m24: Double, m31: Double, m32: Double, m33: Double, m34: Double, m43: Double, m44: Double, is2D: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.m13] = m13.jsValue
        object[Strings.m14] = m14.jsValue
        object[Strings.m23] = m23.jsValue
        object[Strings.m24] = m24.jsValue
        object[Strings.m31] = m31.jsValue
        object[Strings.m32] = m32.jsValue
        object[Strings.m33] = m33.jsValue
        object[Strings.m34] = m34.jsValue
        object[Strings.m43] = m43.jsValue
        object[Strings.m44] = m44.jsValue
        object[Strings.is2D] = is2D.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _m13 = ReadWriteAttribute(jsObject: object, name: Strings.m13)
        _m14 = ReadWriteAttribute(jsObject: object, name: Strings.m14)
        _m23 = ReadWriteAttribute(jsObject: object, name: Strings.m23)
        _m24 = ReadWriteAttribute(jsObject: object, name: Strings.m24)
        _m31 = ReadWriteAttribute(jsObject: object, name: Strings.m31)
        _m32 = ReadWriteAttribute(jsObject: object, name: Strings.m32)
        _m33 = ReadWriteAttribute(jsObject: object, name: Strings.m33)
        _m34 = ReadWriteAttribute(jsObject: object, name: Strings.m34)
        _m43 = ReadWriteAttribute(jsObject: object, name: Strings.m43)
        _m44 = ReadWriteAttribute(jsObject: object, name: Strings.m44)
        _is2D = ReadWriteAttribute(jsObject: object, name: Strings.is2D)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var m13: Double

    @ReadWriteAttribute
    public var m14: Double

    @ReadWriteAttribute
    public var m23: Double

    @ReadWriteAttribute
    public var m24: Double

    @ReadWriteAttribute
    public var m31: Double

    @ReadWriteAttribute
    public var m32: Double

    @ReadWriteAttribute
    public var m33: Double

    @ReadWriteAttribute
    public var m34: Double

    @ReadWriteAttribute
    public var m43: Double

    @ReadWriteAttribute
    public var m44: Double

    @ReadWriteAttribute
    public var is2D: Bool
}

public class DOMMatrixReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMMatrixReadOnly].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _a = ReadonlyAttribute(jsObject: jsObject, name: Strings.a)
        _b = ReadonlyAttribute(jsObject: jsObject, name: Strings.b)
        _c = ReadonlyAttribute(jsObject: jsObject, name: Strings.c)
        _d = ReadonlyAttribute(jsObject: jsObject, name: Strings.d)
        _e = ReadonlyAttribute(jsObject: jsObject, name: Strings.e)
        _f = ReadonlyAttribute(jsObject: jsObject, name: Strings.f)
        _m11 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m11)
        _m12 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m12)
        _m13 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m13)
        _m14 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m14)
        _m21 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m21)
        _m22 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m22)
        _m23 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m23)
        _m24 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m24)
        _m31 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m31)
        _m32 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m32)
        _m33 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m33)
        _m34 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m34)
        _m41 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m41)
        _m42 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m42)
        _m43 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m43)
        _m44 = ReadonlyAttribute(jsObject: jsObject, name: Strings.m44)
        _is2D = ReadonlyAttribute(jsObject: jsObject, name: Strings.is2D)
        _isIdentity = ReadonlyAttribute(jsObject: jsObject, name: Strings.isIdentity)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: String_or_seq_of_Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @inlinable public static func fromMatrix(other: DOMMatrixInit? = nil) -> Self {
        let this = constructor
        return this[Strings.fromMatrix].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public static func fromFloat32Array(array32: Float32Array) -> Self {
        let this = constructor
        return this[Strings.fromFloat32Array].function!(this: this, arguments: [array32.jsValue]).fromJSValue()!
    }

    @inlinable public static func fromFloat64Array(array64: Float64Array) -> Self {
        let this = constructor
        return this[Strings.fromFloat64Array].function!(this: this, arguments: [array64.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var a: Double

    @ReadonlyAttribute
    public var b: Double

    @ReadonlyAttribute
    public var c: Double

    @ReadonlyAttribute
    public var d: Double

    @ReadonlyAttribute
    public var e: Double

    @ReadonlyAttribute
    public var f: Double

    @ReadonlyAttribute
    public var m11: Double

    @ReadonlyAttribute
    public var m12: Double

    @ReadonlyAttribute
    public var m13: Double

    @ReadonlyAttribute
    public var m14: Double

    @ReadonlyAttribute
    public var m21: Double

    @ReadonlyAttribute
    public var m22: Double

    @ReadonlyAttribute
    public var m23: Double

    @ReadonlyAttribute
    public var m24: Double

    @ReadonlyAttribute
    public var m31: Double

    @ReadonlyAttribute
    public var m32: Double

    @ReadonlyAttribute
    public var m33: Double

    @ReadonlyAttribute
    public var m34: Double

    @ReadonlyAttribute
    public var m41: Double

    @ReadonlyAttribute
    public var m42: Double

    @ReadonlyAttribute
    public var m43: Double

    @ReadonlyAttribute
    public var m44: Double

    @ReadonlyAttribute
    public var is2D: Bool

    @ReadonlyAttribute
    public var isIdentity: Bool

    @inlinable public func translate(tx: Double? = nil, ty: Double? = nil, tz: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.translate].function!(this: this, arguments: [tx?.jsValue ?? .undefined, ty?.jsValue ?? .undefined, tz?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func scale(scaleX: Double? = nil, scaleY: Double? = nil, scaleZ: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> DOMMatrix {
        let _arg0 = scaleX?.jsValue ?? .undefined
        let _arg1 = scaleY?.jsValue ?? .undefined
        let _arg2 = scaleZ?.jsValue ?? .undefined
        let _arg3 = originX?.jsValue ?? .undefined
        let _arg4 = originY?.jsValue ?? .undefined
        let _arg5 = originZ?.jsValue ?? .undefined
        let this = jsObject
        return this[Strings.scale].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @inlinable public func scaleNonUniform(scaleX: Double? = nil, scaleY: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.scaleNonUniform].function!(this: this, arguments: [scaleX?.jsValue ?? .undefined, scaleY?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func scale3d(scale: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.scale3d].function!(this: this, arguments: [scale?.jsValue ?? .undefined, originX?.jsValue ?? .undefined, originY?.jsValue ?? .undefined, originZ?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotate(rotX: Double? = nil, rotY: Double? = nil, rotZ: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.rotate].function!(this: this, arguments: [rotX?.jsValue ?? .undefined, rotY?.jsValue ?? .undefined, rotZ?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotateFromVector(x: Double? = nil, y: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.rotateFromVector].function!(this: this, arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func rotateAxisAngle(x: Double? = nil, y: Double? = nil, z: Double? = nil, angle: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.rotateAxisAngle].function!(this: this, arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, z?.jsValue ?? .undefined, angle?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func skewX(sx: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.skewX].function!(this: this, arguments: [sx?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func skewY(sy: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.skewY].function!(this: this, arguments: [sy?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func multiply(other: DOMMatrixInit? = nil) -> DOMMatrix {
        let this = jsObject
        return this[Strings.multiply].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func flipX() -> DOMMatrix {
        let this = jsObject
        return this[Strings.flipX].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func flipY() -> DOMMatrix {
        let this = jsObject
        return this[Strings.flipY].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func inverse() -> DOMMatrix {
        let this = jsObject
        return this[Strings.inverse].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func transformPoint(point: DOMPointInit? = nil) -> DOMPoint {
        let this = jsObject
        return this[Strings.transformPoint].function!(this: this, arguments: [point?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func toFloat32Array() -> Float32Array {
        let this = jsObject
        return this[Strings.toFloat32Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func toFloat64Array() -> Float64Array {
        let this = jsObject
        return this[Strings.toFloat64Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var description: String {
        jsObject[Strings.toString]!().fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMParser: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMParser].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func parseFromString(string: String, type: DOMParserSupportedType) -> Document {
        let this = jsObject
        return this[Strings.parseFromString].function!(this: this, arguments: [string.jsValue, type.jsValue]).fromJSValue()!
    }
}

public enum DOMParserSupportedType: JSString, JSValueCompatible {
    case textHtml = "text/html"
    case textXml = "text/xml"
    case applicationXml = "application/xml"
    case applicationXhtmlXml = "application/xhtml+xml"
    case imageSvgXml = "image/svg+xml"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DOMPoint: DOMPointReadOnly {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DOMPoint].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadWriteAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: jsObject, name: Strings.y)
        _z = ReadWriteAttribute(jsObject: jsObject, name: Strings.z)
        _w = ReadWriteAttribute(jsObject: jsObject, name: Strings.w)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, z: Double? = nil, w: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, z?.jsValue ?? .undefined, w?.jsValue ?? .undefined]))
    }

    // XXX: illegal static override
    // override public static func fromPoint(other: DOMPointInit? = nil) -> Self

    @usableFromInline let _x: ReadWriteAttribute<Double>
    @inlinable override public var x: Double {
        get { _x.wrappedValue }
        set { _x.wrappedValue = newValue }
    }

    @usableFromInline let _y: ReadWriteAttribute<Double>
    @inlinable override public var y: Double {
        get { _y.wrappedValue }
        set { _y.wrappedValue = newValue }
    }

    @usableFromInline let _z: ReadWriteAttribute<Double>
    @inlinable override public var z: Double {
        get { _z.wrappedValue }
        set { _z.wrappedValue = newValue }
    }

    @usableFromInline let _w: ReadWriteAttribute<Double>
    @inlinable override public var w: Double {
        get { _w.wrappedValue }
        set { _w.wrappedValue = newValue }
    }
}

public class DOMPointInit: BridgedDictionary {
    public convenience init(x: Double, y: Double, z: Double, w: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = x.jsValue
        object[Strings.y] = y.jsValue
        object[Strings.z] = z.jsValue
        object[Strings.w] = w.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        _z = ReadWriteAttribute(jsObject: object, name: Strings.z)
        _w = ReadWriteAttribute(jsObject: object, name: Strings.w)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: Double

    @ReadWriteAttribute
    public var y: Double

    @ReadWriteAttribute
    public var z: Double

    @ReadWriteAttribute
    public var w: Double
}

public class DOMPointReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMPointReadOnly].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadonlyAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: Strings.y)
        _z = ReadonlyAttribute(jsObject: jsObject, name: Strings.z)
        _w = ReadonlyAttribute(jsObject: jsObject, name: Strings.w)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, z: Double? = nil, w: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, z?.jsValue ?? .undefined, w?.jsValue ?? .undefined]))
    }

    @inlinable public static func fromPoint(other: DOMPointInit? = nil) -> Self {
        let this = constructor
        return this[Strings.fromPoint].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var z: Double

    @ReadonlyAttribute
    public var w: Double

    @inlinable public func matrixTransform(matrix: DOMMatrixInit? = nil) -> DOMPoint {
        let this = jsObject
        return this[Strings.matrixTransform].function!(this: this, arguments: [matrix?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMQuad: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMQuad].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _p1 = ReadonlyAttribute(jsObject: jsObject, name: Strings.p1)
        _p2 = ReadonlyAttribute(jsObject: jsObject, name: Strings.p2)
        _p3 = ReadonlyAttribute(jsObject: jsObject, name: Strings.p3)
        _p4 = ReadonlyAttribute(jsObject: jsObject, name: Strings.p4)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(p1: DOMPointInit? = nil, p2: DOMPointInit? = nil, p3: DOMPointInit? = nil, p4: DOMPointInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [p1?.jsValue ?? .undefined, p2?.jsValue ?? .undefined, p3?.jsValue ?? .undefined, p4?.jsValue ?? .undefined]))
    }

    @inlinable public static func fromRect(other: DOMRectInit? = nil) -> Self {
        let this = constructor
        return this[Strings.fromRect].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public static func fromQuad(other: DOMQuadInit? = nil) -> Self {
        let this = constructor
        return this[Strings.fromQuad].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var p1: DOMPoint

    @ReadonlyAttribute
    public var p2: DOMPoint

    @ReadonlyAttribute
    public var p3: DOMPoint

    @ReadonlyAttribute
    public var p4: DOMPoint

    @inlinable public func getBounds() -> DOMRect {
        let this = jsObject
        return this[Strings.getBounds].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMQuadInit: BridgedDictionary {
    public convenience init(p1: DOMPointInit, p2: DOMPointInit, p3: DOMPointInit, p4: DOMPointInit) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.p1] = p1.jsValue
        object[Strings.p2] = p2.jsValue
        object[Strings.p3] = p3.jsValue
        object[Strings.p4] = p4.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _p1 = ReadWriteAttribute(jsObject: object, name: Strings.p1)
        _p2 = ReadWriteAttribute(jsObject: object, name: Strings.p2)
        _p3 = ReadWriteAttribute(jsObject: object, name: Strings.p3)
        _p4 = ReadWriteAttribute(jsObject: object, name: Strings.p4)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var p1: DOMPointInit

    @ReadWriteAttribute
    public var p2: DOMPointInit

    @ReadWriteAttribute
    public var p3: DOMPointInit

    @ReadWriteAttribute
    public var p4: DOMPointInit
}

public class DOMRect: DOMRectReadOnly {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DOMRect].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadWriteAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: jsObject, name: Strings.y)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, width?.jsValue ?? .undefined, height?.jsValue ?? .undefined]))
    }

    // XXX: illegal static override
    // override public static func fromRect(other: DOMRectInit? = nil) -> Self

    @usableFromInline let _x: ReadWriteAttribute<Double>
    @inlinable override public var x: Double {
        get { _x.wrappedValue }
        set { _x.wrappedValue = newValue }
    }

    @usableFromInline let _y: ReadWriteAttribute<Double>
    @inlinable override public var y: Double {
        get { _y.wrappedValue }
        set { _y.wrappedValue = newValue }
    }

    @usableFromInline let _width: ReadWriteAttribute<Double>
    @inlinable override public var width: Double {
        get { _width.wrappedValue }
        set { _width.wrappedValue = newValue }
    }

    @usableFromInline let _height: ReadWriteAttribute<Double>
    @inlinable override public var height: Double {
        get { _height.wrappedValue }
        set { _height.wrappedValue = newValue }
    }
}

public class DOMRectInit: BridgedDictionary {
    public convenience init(x: Double, y: Double, width: Double, height: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = x.jsValue
        object[Strings.y] = y.jsValue
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: Double

    @ReadWriteAttribute
    public var y: Double

    @ReadWriteAttribute
    public var width: Double

    @ReadWriteAttribute
    public var height: Double
}

public class DOMRectList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMRectList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> DOMRect? {
        jsObject[key].fromJSValue()
    }
}

public class DOMRectReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMRectReadOnly].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadonlyAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: Strings.y)
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: Strings.height)
        _top = ReadonlyAttribute(jsObject: jsObject, name: Strings.top)
        _right = ReadonlyAttribute(jsObject: jsObject, name: Strings.right)
        _bottom = ReadonlyAttribute(jsObject: jsObject, name: Strings.bottom)
        _left = ReadonlyAttribute(jsObject: jsObject, name: Strings.left)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [x?.jsValue ?? .undefined, y?.jsValue ?? .undefined, width?.jsValue ?? .undefined, height?.jsValue ?? .undefined]))
    }

    @inlinable public static func fromRect(other: DOMRectInit? = nil) -> Self {
        let this = constructor
        return this[Strings.fromRect].function!(this: this, arguments: [other?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var height: Double

    @ReadonlyAttribute
    public var top: Double

    @ReadonlyAttribute
    public var right: Double

    @ReadonlyAttribute
    public var bottom: Double

    @ReadonlyAttribute
    public var left: Double

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMStringList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMStringList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func contains(string: String) -> Bool {
        let this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [string.jsValue]).fromJSValue()!
    }
}

public class DOMStringMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMStringMap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: String) -> String {
        jsObject[key].fromJSValue()!
    }

    // XXX: unsupported setter for keys of type String

    // XXX: unsupported deleter for keys of type String
}

public class DOMTokenList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DOMTokenList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func contains(token: String) -> Bool {
        let this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [token.jsValue]).fromJSValue()!
    }

    @inlinable public func add(tokens: String...) {
        let this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: tokens.map(\.jsValue))
    }

    @inlinable public func remove(tokens: String...) {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: tokens.map(\.jsValue))
    }

    @inlinable public func toggle(token: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[Strings.toggle].function!(this: this, arguments: [token.jsValue, force?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func replace(token: String, newToken: String) -> Bool {
        let this = jsObject
        return this[Strings.replace].function!(this: this, arguments: [token.jsValue, newToken.jsValue]).fromJSValue()!
    }

    @inlinable public func supports(token: String) -> Bool {
        let this = jsObject
        return this[Strings.supports].function!(this: this, arguments: [token.jsValue]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var value: String

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<DOMTokenList> {
        ValueIterableIterator(sequence: self)
    }
}

public class DataTransfer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DataTransfer].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dropEffect = ReadWriteAttribute(jsObject: jsObject, name: Strings.dropEffect)
        _effectAllowed = ReadWriteAttribute(jsObject: jsObject, name: Strings.effectAllowed)
        _items = ReadonlyAttribute(jsObject: jsObject, name: Strings.items)
        _types = ReadonlyAttribute(jsObject: jsObject, name: Strings.types)
        _files = ReadonlyAttribute(jsObject: jsObject, name: Strings.files)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dropEffect: String

    @ReadWriteAttribute
    public var effectAllowed: String

    @ReadonlyAttribute
    public var items: DataTransferItemList

    @inlinable public func setDragImage(image: Element, x: Int32, y: Int32) {
        let this = jsObject
        _ = this[Strings.setDragImage].function!(this: this, arguments: [image.jsValue, x.jsValue, y.jsValue])
    }

    @ReadonlyAttribute
    public var types: [String]

    @inlinable public func getData(format: String) -> String {
        let this = jsObject
        return this[Strings.getData].function!(this: this, arguments: [format.jsValue]).fromJSValue()!
    }

    @inlinable public func setData(format: String, data: String) {
        let this = jsObject
        _ = this[Strings.setData].function!(this: this, arguments: [format.jsValue, data.jsValue])
    }

    @inlinable public func clearData(format: String? = nil) {
        let this = jsObject
        _ = this[Strings.clearData].function!(this: this, arguments: [format?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var files: FileList
}

public class DataTransferItem: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DataTransferItem].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var type: String

    // XXX: member 'getAsString' is ignored

    @inlinable public func getAsFile() -> File? {
        let this = jsObject
        return this[Strings.getAsFile].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DataTransferItemList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.DataTransferItemList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> DataTransferItem {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func add(data: String, type: String) -> DataTransferItem? {
        let this = jsObject
        return this[Strings.add].function!(this: this, arguments: [data.jsValue, type.jsValue]).fromJSValue()!
    }

    @inlinable public func add(data: File) -> DataTransferItem? {
        let this = jsObject
        return this[Strings.add].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func remove(index: UInt32) {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable public func clear() {
        let this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }
}

public class DelayNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DelayNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _delayTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.delayTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: DelayOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var delayTime: AudioParam
}

public class DelayOptions: BridgedDictionary {
    public convenience init(maxDelayTime: Double, delayTime: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.maxDelayTime] = maxDelayTime.jsValue
        object[Strings.delayTime] = delayTime.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _maxDelayTime = ReadWriteAttribute(jsObject: object, name: Strings.maxDelayTime)
        _delayTime = ReadWriteAttribute(jsObject: object, name: Strings.delayTime)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var maxDelayTime: Double

    @ReadWriteAttribute
    public var delayTime: Double
}

public class DevicePermissionDescriptor: BridgedDictionary {
    public convenience init(deviceId: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.deviceId] = deviceId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _deviceId = ReadWriteAttribute(jsObject: object, name: Strings.deviceId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var deviceId: String
}

public enum DistanceModelType: JSString, JSValueCompatible {
    case linear = "linear"
    case inverse = "inverse"
    case exponential = "exponential"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Document: Node, NonElementParentNode, DocumentOrShadowRoot, ParentNode, XPathEvaluatorBase, GlobalEventHandlers, DocumentAndElementEventHandlers, GeometryUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Document].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _implementation = ReadonlyAttribute(jsObject: jsObject, name: Strings.implementation)
        _URL = ReadonlyAttribute(jsObject: jsObject, name: Strings.URL)
        _documentURI = ReadonlyAttribute(jsObject: jsObject, name: Strings.documentURI)
        _compatMode = ReadonlyAttribute(jsObject: jsObject, name: Strings.compatMode)
        _characterSet = ReadonlyAttribute(jsObject: jsObject, name: Strings.characterSet)
        _charset = ReadonlyAttribute(jsObject: jsObject, name: Strings.charset)
        _inputEncoding = ReadonlyAttribute(jsObject: jsObject, name: Strings.inputEncoding)
        _contentType = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentType)
        _doctype = ReadonlyAttribute(jsObject: jsObject, name: Strings.doctype)
        _documentElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.documentElement)
        _location = ReadonlyAttribute(jsObject: jsObject, name: Strings.location)
        _domain = ReadWriteAttribute(jsObject: jsObject, name: Strings.domain)
        _referrer = ReadonlyAttribute(jsObject: jsObject, name: Strings.referrer)
        _cookie = ReadWriteAttribute(jsObject: jsObject, name: Strings.cookie)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastModified)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _title = ReadWriteAttribute(jsObject: jsObject, name: Strings.title)
        _dir = ReadWriteAttribute(jsObject: jsObject, name: Strings.dir)
        _body = ReadWriteAttribute(jsObject: jsObject, name: Strings.body)
        _head = ReadonlyAttribute(jsObject: jsObject, name: Strings.head)
        _images = ReadonlyAttribute(jsObject: jsObject, name: Strings.images)
        _embeds = ReadonlyAttribute(jsObject: jsObject, name: Strings.embeds)
        _plugins = ReadonlyAttribute(jsObject: jsObject, name: Strings.plugins)
        _links = ReadonlyAttribute(jsObject: jsObject, name: Strings.links)
        _forms = ReadonlyAttribute(jsObject: jsObject, name: Strings.forms)
        _scripts = ReadonlyAttribute(jsObject: jsObject, name: Strings.scripts)
        _currentScript = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentScript)
        _defaultView = ReadonlyAttribute(jsObject: jsObject, name: Strings.defaultView)
        _designMode = ReadWriteAttribute(jsObject: jsObject, name: Strings.designMode)
        _hidden = ReadonlyAttribute(jsObject: jsObject, name: Strings.hidden)
        _visibilityState = ReadonlyAttribute(jsObject: jsObject, name: Strings.visibilityState)
        _onreadystatechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onreadystatechange)
        _onvisibilitychange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onvisibilitychange)
        _fgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.fgColor)
        _linkColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.linkColor)
        _vlinkColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.vlinkColor)
        _alinkColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.alinkColor)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        _anchors = ReadonlyAttribute(jsObject: jsObject, name: Strings.anchors)
        _applets = ReadonlyAttribute(jsObject: jsObject, name: Strings.applets)
        _all = ReadonlyAttribute(jsObject: jsObject, name: Strings.all)
        _timeline = ReadonlyAttribute(jsObject: jsObject, name: Strings.timeline)
        _scrollingElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollingElement)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var implementation: DOMImplementation

    @ReadonlyAttribute
    public var URL: String

    @ReadonlyAttribute
    public var documentURI: String

    @ReadonlyAttribute
    public var compatMode: String

    @ReadonlyAttribute
    public var characterSet: String

    @ReadonlyAttribute
    public var charset: String

    @ReadonlyAttribute
    public var inputEncoding: String

    @ReadonlyAttribute
    public var contentType: String

    @ReadonlyAttribute
    public var doctype: DocumentType?

    @ReadonlyAttribute
    public var documentElement: Element?

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByTagName].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByTagNameNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByClassName].function!(this: this, arguments: [classNames.jsValue]).fromJSValue()!
    }

    @inlinable public func createElement(localName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[Strings.createElement].function!(this: this, arguments: [localName.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[Strings.createElementNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createDocumentFragment() -> DocumentFragment {
        let this = jsObject
        return this[Strings.createDocumentFragment].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createTextNode(data: String) -> Text {
        let this = jsObject
        return this[Strings.createTextNode].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createCDATASection(data: String) -> CDATASection {
        let this = jsObject
        return this[Strings.createCDATASection].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createComment(data: String) -> Comment {
        let this = jsObject
        return this[Strings.createComment].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable public func createProcessingInstruction(target: String, data: String) -> ProcessingInstruction {
        let this = jsObject
        return this[Strings.createProcessingInstruction].function!(this: this, arguments: [target.jsValue, data.jsValue]).fromJSValue()!
    }

    @inlinable public func importNode(node: Node, deep: Bool? = nil) -> Node {
        let this = jsObject
        return this[Strings.importNode].function!(this: this, arguments: [node.jsValue, deep?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func adoptNode(node: Node) -> Node {
        let this = jsObject
        return this[Strings.adoptNode].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public func createAttribute(localName: String) -> Attr {
        let this = jsObject
        return this[Strings.createAttribute].function!(this: this, arguments: [localName.jsValue]).fromJSValue()!
    }

    @inlinable public func createAttributeNS(namespace: String?, qualifiedName: String) -> Attr {
        let this = jsObject
        return this[Strings.createAttributeNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func createEvent(interface: String) -> Event {
        let this = jsObject
        return this[Strings.createEvent].function!(this: this, arguments: [interface.jsValue]).fromJSValue()!
    }

    @inlinable public func createRange() -> Range {
        let this = jsObject
        return this[Strings.createRange].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'createNodeIterator' is ignored

    // XXX: member 'createTreeWalker' is ignored

    @ReadonlyAttribute
    public var location: Location?

    @ReadWriteAttribute
    public var domain: String

    @ReadonlyAttribute
    public var referrer: String

    @ReadWriteAttribute
    public var cookie: String

    @ReadonlyAttribute
    public var lastModified: String

    @ReadonlyAttribute
    public var readyState: DocumentReadyState

    @inlinable public subscript(key: String) -> JSObject {
        jsObject[key].fromJSValue()!
    }

    @ReadWriteAttribute
    public var title: String

    @ReadWriteAttribute
    public var dir: String

    @ReadWriteAttribute
    public var body: HTMLElement?

    @ReadonlyAttribute
    public var head: HTMLHeadElement?

    @ReadonlyAttribute
    public var images: HTMLCollection

    @ReadonlyAttribute
    public var embeds: HTMLCollection

    @ReadonlyAttribute
    public var plugins: HTMLCollection

    @ReadonlyAttribute
    public var links: HTMLCollection

    @ReadonlyAttribute
    public var forms: HTMLCollection

    @ReadonlyAttribute
    public var scripts: HTMLCollection

    @inlinable public func getElementsByName(elementName: String) -> NodeList {
        let this = jsObject
        return this[Strings.getElementsByName].function!(this: this, arguments: [elementName.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var currentScript: HTMLOrSVGScriptElement?

    @inlinable public func open(unused1: String? = nil, unused2: String? = nil) -> Self {
        let this = jsObject
        return this[Strings.open].function!(this: this, arguments: [unused1?.jsValue ?? .undefined, unused2?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func open(url: String, name: String, features: String) -> WindowProxy? {
        let this = jsObject
        return this[Strings.open].function!(this: this, arguments: [url.jsValue, name.jsValue, features.jsValue]).fromJSValue()!
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public func write(text: String...) {
        let this = jsObject
        _ = this[Strings.write].function!(this: this, arguments: text.map(\.jsValue))
    }

    @inlinable public func writeln(text: String...) {
        let this = jsObject
        _ = this[Strings.writeln].function!(this: this, arguments: text.map(\.jsValue))
    }

    @ReadonlyAttribute
    public var defaultView: WindowProxy?

    @inlinable public func hasFocus() -> Bool {
        let this = jsObject
        return this[Strings.hasFocus].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var designMode: String

    @inlinable public func execCommand(commandId: String, showUI: Bool? = nil, value: String? = nil) -> Bool {
        let this = jsObject
        return this[Strings.execCommand].function!(this: this, arguments: [commandId.jsValue, showUI?.jsValue ?? .undefined, value?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func queryCommandEnabled(commandId: String) -> Bool {
        let this = jsObject
        return this[Strings.queryCommandEnabled].function!(this: this, arguments: [commandId.jsValue]).fromJSValue()!
    }

    @inlinable public func queryCommandIndeterm(commandId: String) -> Bool {
        let this = jsObject
        return this[Strings.queryCommandIndeterm].function!(this: this, arguments: [commandId.jsValue]).fromJSValue()!
    }

    @inlinable public func queryCommandState(commandId: String) -> Bool {
        let this = jsObject
        return this[Strings.queryCommandState].function!(this: this, arguments: [commandId.jsValue]).fromJSValue()!
    }

    @inlinable public func queryCommandSupported(commandId: String) -> Bool {
        let this = jsObject
        return this[Strings.queryCommandSupported].function!(this: this, arguments: [commandId.jsValue]).fromJSValue()!
    }

    @inlinable public func queryCommandValue(commandId: String) -> String {
        let this = jsObject
        return this[Strings.queryCommandValue].function!(this: this, arguments: [commandId.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var hidden: Bool

    @ReadonlyAttribute
    public var visibilityState: DocumentVisibilityState

    @ClosureAttribute1Optional
    public var onreadystatechange: EventHandler

    @ClosureAttribute1Optional
    public var onvisibilitychange: EventHandler

    @ReadWriteAttribute
    public var fgColor: String

    @ReadWriteAttribute
    public var linkColor: String

    @ReadWriteAttribute
    public var vlinkColor: String

    @ReadWriteAttribute
    public var alinkColor: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadonlyAttribute
    public var anchors: HTMLCollection

    @ReadonlyAttribute
    public var applets: HTMLCollection

    @inlinable public func clear() {
        let this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }

    @inlinable public func captureEvents() {
        let this = jsObject
        _ = this[Strings.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable public func releaseEvents() {
        let this = jsObject
        _ = this[Strings.releaseEvents].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var all: HTMLAllCollection

    @ReadonlyAttribute
    public var timeline: DocumentTimeline

    @inlinable public func elementFromPoint(x: Double, y: Double) -> Element? {
        let this = jsObject
        return this[Strings.elementFromPoint].function!(this: this, arguments: [x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable public func elementsFromPoint(x: Double, y: Double) -> [Element] {
        let this = jsObject
        return this[Strings.elementsFromPoint].function!(this: this, arguments: [x.jsValue, y.jsValue]).fromJSValue()!
    }

    @inlinable public func caretPositionFromPoint(x: Double, y: Double) -> CaretPosition? {
        let this = jsObject
        return this[Strings.caretPositionFromPoint].function!(this: this, arguments: [x.jsValue, y.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var scrollingElement: Element?
}

public protocol DocumentAndElementEventHandlers: JSBridgedClass {}
public extension DocumentAndElementEventHandlers {
    @inlinable var oncopy: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncopy, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncopy, in: jsObject] = newValue }
    }

    @inlinable var oncut: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncut, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncut, in: jsObject] = newValue }
    }

    @inlinable var onpaste: EventHandler {
        get { ClosureAttribute1Optional[Strings.onpaste, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onpaste, in: jsObject] = newValue }
    }
}

public class DocumentFragment: Node, NonElementParentNode, ParentNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DocumentFragment].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public protocol DocumentOrShadowRoot: JSBridgedClass {}
public extension DocumentOrShadowRoot {
    @inlinable var activeElement: Element? { ReadonlyAttribute[Strings.activeElement, in: jsObject] }

    @inlinable func getAnimations() -> [Animation] {
        let this = jsObject
        return this[Strings.getAnimations].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum DocumentReadyState: JSString, JSValueCompatible {
    case loading = "loading"
    case interactive = "interactive"
    case complete = "complete"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DocumentTimeline: AnimationTimeline {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DocumentTimeline].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(options: DocumentTimelineOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [options?.jsValue ?? .undefined]))
    }
}

public class DocumentTimelineOptions: BridgedDictionary {
    public convenience init(originTime: DOMHighResTimeStamp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.originTime] = originTime.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _originTime = ReadWriteAttribute(jsObject: object, name: Strings.originTime)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var originTime: DOMHighResTimeStamp
}

public class DocumentType: Node, ChildNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DocumentType].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _publicId = ReadonlyAttribute(jsObject: jsObject, name: Strings.publicId)
        _systemId = ReadonlyAttribute(jsObject: jsObject, name: Strings.systemId)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var publicId: String

    @ReadonlyAttribute
    public var systemId: String
}

public enum DocumentVisibilityState: JSString, JSValueCompatible {
    case visible = "visible"
    case hidden = "hidden"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DoubleRange: BridgedDictionary {
    public convenience init(max: Double, min: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = max.jsValue
        object[Strings.min] = min.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _max = ReadWriteAttribute(jsObject: object, name: Strings.max)
        _min = ReadWriteAttribute(jsObject: object, name: Strings.min)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var max: Double

    @ReadWriteAttribute
    public var min: Double
}

public class DragEvent: MouseEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DragEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dataTransfer = ReadonlyAttribute(jsObject: jsObject, name: Strings.dataTransfer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: DragEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var dataTransfer: DataTransfer?
}

public class DragEventInit: BridgedDictionary {
    public convenience init(dataTransfer: DataTransfer?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.dataTransfer] = dataTransfer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _dataTransfer = ReadWriteAttribute(jsObject: object, name: Strings.dataTransfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var dataTransfer: DataTransfer?
}

public class DynamicsCompressorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.DynamicsCompressorNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _threshold = ReadonlyAttribute(jsObject: jsObject, name: Strings.threshold)
        _knee = ReadonlyAttribute(jsObject: jsObject, name: Strings.knee)
        _ratio = ReadonlyAttribute(jsObject: jsObject, name: Strings.ratio)
        _reduction = ReadonlyAttribute(jsObject: jsObject, name: Strings.reduction)
        _attack = ReadonlyAttribute(jsObject: jsObject, name: Strings.attack)
        _release = ReadonlyAttribute(jsObject: jsObject, name: Strings.release)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: DynamicsCompressorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var threshold: AudioParam

    @ReadonlyAttribute
    public var knee: AudioParam

    @ReadonlyAttribute
    public var ratio: AudioParam

    @ReadonlyAttribute
    public var reduction: Float

    @ReadonlyAttribute
    public var attack: AudioParam

    @ReadonlyAttribute
    public var release: AudioParam
}

public class DynamicsCompressorOptions: BridgedDictionary {
    public convenience init(attack: Float, knee: Float, ratio: Float, release: Float, threshold: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.attack] = attack.jsValue
        object[Strings.knee] = knee.jsValue
        object[Strings.ratio] = ratio.jsValue
        object[Strings.release] = release.jsValue
        object[Strings.threshold] = threshold.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _attack = ReadWriteAttribute(jsObject: object, name: Strings.attack)
        _knee = ReadWriteAttribute(jsObject: object, name: Strings.knee)
        _ratio = ReadWriteAttribute(jsObject: object, name: Strings.ratio)
        _release = ReadWriteAttribute(jsObject: object, name: Strings.release)
        _threshold = ReadWriteAttribute(jsObject: object, name: Strings.threshold)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var attack: Float

    @ReadWriteAttribute
    public var knee: Float

    @ReadWriteAttribute
    public var ratio: Float

    @ReadWriteAttribute
    public var release: Float

    @ReadWriteAttribute
    public var threshold: Float
}

public class EffectTiming: BridgedDictionary {
    public convenience init(delay: Double, endDelay: Double, fill: FillMode, iterationStart: Double, iterations: Double, direction: PlaybackDirection, easing: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.delay] = delay.jsValue
        object[Strings.endDelay] = endDelay.jsValue
        object[Strings.fill] = fill.jsValue
        object[Strings.iterationStart] = iterationStart.jsValue
        object[Strings.iterations] = iterations.jsValue
        object[Strings.direction] = direction.jsValue
        object[Strings.easing] = easing.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _delay = ReadWriteAttribute(jsObject: object, name: Strings.delay)
        _endDelay = ReadWriteAttribute(jsObject: object, name: Strings.endDelay)
        _fill = ReadWriteAttribute(jsObject: object, name: Strings.fill)
        _iterationStart = ReadWriteAttribute(jsObject: object, name: Strings.iterationStart)
        _iterations = ReadWriteAttribute(jsObject: object, name: Strings.iterations)
        _direction = ReadWriteAttribute(jsObject: object, name: Strings.direction)
        _easing = ReadWriteAttribute(jsObject: object, name: Strings.easing)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var delay: Double

    @ReadWriteAttribute
    public var endDelay: Double

    @ReadWriteAttribute
    public var fill: FillMode

    @ReadWriteAttribute
    public var iterationStart: Double

    @ReadWriteAttribute
    public var iterations: Double

    @ReadWriteAttribute
    public var direction: PlaybackDirection

    @ReadWriteAttribute
    public var easing: String
}

public class Element: Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slottable, ARIAMixin, Animatable, GeometryUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Element].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: Strings.namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: Strings.prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: Strings.localName)
        _tagName = ReadonlyAttribute(jsObject: jsObject, name: Strings.tagName)
        _id = ReadWriteAttribute(jsObject: jsObject, name: Strings.id)
        _className = ReadWriteAttribute(jsObject: jsObject, name: Strings.className)
        _classList = ReadonlyAttribute(jsObject: jsObject, name: Strings.classList)
        _slot = ReadWriteAttribute(jsObject: jsObject, name: Strings.slot)
        _attributes = ReadonlyAttribute(jsObject: jsObject, name: Strings.attributes)
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: Strings.shadowRoot)
        _scrollTop = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrollTop)
        _scrollLeft = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrollLeft)
        _scrollWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollWidth)
        _scrollHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollHeight)
        _clientTop = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientTop)
        _clientLeft = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientLeft)
        _clientWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientWidth)
        _clientHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientHeight)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var tagName: String

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var className: String

    @ReadonlyAttribute
    public var classList: DOMTokenList

    @ReadWriteAttribute
    public var slot: String

    @inlinable public func hasAttributes() -> Bool {
        let this = jsObject
        return this[Strings.hasAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var attributes: NamedNodeMap

    @inlinable public func getAttributeNames() -> [String] {
        let this = jsObject
        return this[Strings.getAttributeNames].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getAttribute(qualifiedName: String) -> String? {
        let this = jsObject
        return this[Strings.getAttribute].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNS(namespace: String?, localName: String) -> String? {
        let this = jsObject
        return this[Strings.getAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttribute(qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[Strings.setAttribute].function!(this: this, arguments: [qualifiedName.jsValue, value.jsValue])
    }

    @inlinable public func setAttributeNS(namespace: String?, qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[Strings.setAttributeNS].function!(this: this, arguments: [namespace.jsValue, qualifiedName.jsValue, value.jsValue])
    }

    @inlinable public func removeAttribute(qualifiedName: String) {
        let this = jsObject
        _ = this[Strings.removeAttribute].function!(this: this, arguments: [qualifiedName.jsValue])
    }

    @inlinable public func removeAttributeNS(namespace: String?, localName: String) {
        let this = jsObject
        _ = this[Strings.removeAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue])
    }

    @inlinable public func toggleAttribute(qualifiedName: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[Strings.toggleAttribute].function!(this: this, arguments: [qualifiedName.jsValue, force?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func hasAttribute(qualifiedName: String) -> Bool {
        let this = jsObject
        return this[Strings.hasAttribute].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func hasAttributeNS(namespace: String?, localName: String) -> Bool {
        let this = jsObject
        return this[Strings.hasAttributeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNode(qualifiedName: String) -> Attr? {
        let this = jsObject
        return this[Strings.getAttributeNode].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getAttributeNodeNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[Strings.getAttributeNodeNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttributeNode(attr: Attr) -> Attr? {
        let this = jsObject
        return this[Strings.setAttributeNode].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func setAttributeNodeNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[Strings.setAttributeNodeNS].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func removeAttributeNode(attr: Attr) -> Attr {
        let this = jsObject
        return this[Strings.removeAttributeNode].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func attachShadow(init: ShadowRootInit) -> ShadowRoot {
        let this = jsObject
        return this[Strings.attachShadow].function!(this: this, arguments: [`init`.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func closest(selectors: String) -> Element? {
        let this = jsObject
        return this[Strings.closest].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func matches(selectors: String) -> Bool {
        let this = jsObject
        return this[Strings.matches].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func webkitMatchesSelector(selectors: String) -> Bool {
        let this = jsObject
        return this[Strings.webkitMatchesSelector].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByTagName].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByTagNameNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[Strings.getElementsByClassName].function!(this: this, arguments: [classNames.jsValue]).fromJSValue()!
    }

    @inlinable public func insertAdjacentElement(where: String, element: Element) -> Element? {
        let this = jsObject
        return this[Strings.insertAdjacentElement].function!(this: this, arguments: [`where`.jsValue, element.jsValue]).fromJSValue()!
    }

    @inlinable public func insertAdjacentText(where: String, data: String) {
        let this = jsObject
        _ = this[Strings.insertAdjacentText].function!(this: this, arguments: [`where`.jsValue, data.jsValue])
    }

    @inlinable public func pseudo(type: String) -> CSSPseudoElement? {
        let this = jsObject
        return this[Strings.pseudo].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @inlinable public func getClientRects() -> DOMRectList {
        let this = jsObject
        return this[Strings.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getBoundingClientRect() -> DOMRect {
        let this = jsObject
        return this[Strings.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func isVisible(options: IsVisibleOptions? = nil) -> Bool {
        let this = jsObject
        return this[Strings.isVisible].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func scrollIntoView(arg: Bool_or_ScrollIntoViewOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scrollIntoView].function!(this: this, arguments: [arg?.jsValue ?? .undefined])
    }

    @inlinable public func scroll(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scroll(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func scrollTo(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scrollTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func scrollBy(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scrollBy(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @ReadWriteAttribute
    public var scrollTop: Double

    @ReadWriteAttribute
    public var scrollLeft: Double

    @ReadonlyAttribute
    public var scrollWidth: Int32

    @ReadonlyAttribute
    public var scrollHeight: Int32

    @ReadonlyAttribute
    public var clientTop: Int32

    @ReadonlyAttribute
    public var clientLeft: Int32

    @ReadonlyAttribute
    public var clientWidth: Int32

    @ReadonlyAttribute
    public var clientHeight: Int32
}

public protocol ElementContentEditable: JSBridgedClass {}
public extension ElementContentEditable {
    @inlinable var contentEditable: String {
        get { ReadWriteAttribute[Strings.contentEditable, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.contentEditable, in: jsObject] = newValue }
    }

    @inlinable var enterKeyHint: String {
        get { ReadWriteAttribute[Strings.enterKeyHint, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.enterKeyHint, in: jsObject] = newValue }
    }

    @inlinable var isContentEditable: Bool { ReadonlyAttribute[Strings.isContentEditable, in: jsObject] }

    @inlinable var inputMode: String {
        get { ReadWriteAttribute[Strings.inputMode, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.inputMode, in: jsObject] = newValue }
    }
}

public class ElementCreationOptions: BridgedDictionary {
    public convenience init(is: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.is] = `is`.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _is = ReadWriteAttribute(jsObject: object, name: Strings.is)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var `is`: String
}

public class ElementDefinitionOptions: BridgedDictionary {
    public convenience init(extends: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.extends] = extends.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _extends = ReadWriteAttribute(jsObject: object, name: Strings.extends)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var extends: String
}

public class ElementInternals: JSBridgedClass, ARIAMixin {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ElementInternals].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: Strings.shadowRoot)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func setFormValue(value: File_or_FormData_or_String?, state: File_or_FormData_or_String? = nil) {
        let this = jsObject
        _ = this[Strings.setFormValue].function!(this: this, arguments: [value.jsValue, state?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @inlinable public func setValidity(flags: ValidityStateFlags? = nil, message: String? = nil, anchor: HTMLElement? = nil) {
        let this = jsObject
        _ = this[Strings.setValidity].function!(this: this, arguments: [flags?.jsValue ?? .undefined, message?.jsValue ?? .undefined, anchor?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class EncodedAudioChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.EncodedAudioChunk].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: Strings.timestamp)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _byteLength = ReadonlyAttribute(jsObject: jsObject, name: Strings.byteLength)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: EncodedAudioChunkInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var type: EncodedAudioChunkType

    @ReadonlyAttribute
    public var timestamp: Int64

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var byteLength: UInt32

    @inlinable public func copyTo(destination: BufferSource) {
        let this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [destination.jsValue])
    }
}

public class EncodedAudioChunkInit: BridgedDictionary {
    public convenience init(type: EncodedAudioChunkType, timestamp: Int64, duration: UInt64, data: BufferSource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.timestamp] = timestamp.jsValue
        object[Strings.duration] = duration.jsValue
        object[Strings.data] = data.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _timestamp = ReadWriteAttribute(jsObject: object, name: Strings.timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: Strings.duration)
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: EncodedAudioChunkType

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var data: BufferSource
}

public class EncodedAudioChunkMetadata: BridgedDictionary {
    public convenience init(decoderConfig: AudioDecoderConfig) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.decoderConfig] = decoderConfig.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _decoderConfig = ReadWriteAttribute(jsObject: object, name: Strings.decoderConfig)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var decoderConfig: AudioDecoderConfig
}

public enum EncodedAudioChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class EncodedVideoChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.EncodedVideoChunk].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: Strings.timestamp)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _byteLength = ReadonlyAttribute(jsObject: jsObject, name: Strings.byteLength)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: EncodedVideoChunkInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var type: EncodedVideoChunkType

    @ReadonlyAttribute
    public var timestamp: Int64

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var byteLength: UInt32

    @inlinable public func copyTo(destination: BufferSource) {
        let this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [destination.jsValue])
    }
}

public class EncodedVideoChunkInit: BridgedDictionary {
    public convenience init(type: EncodedVideoChunkType, timestamp: Int64, duration: UInt64, data: BufferSource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.timestamp] = timestamp.jsValue
        object[Strings.duration] = duration.jsValue
        object[Strings.data] = data.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _timestamp = ReadWriteAttribute(jsObject: object, name: Strings.timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: Strings.duration)
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: EncodedVideoChunkType

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var data: BufferSource
}

public class EncodedVideoChunkMetadata: BridgedDictionary {
    public convenience init(decoderConfig: VideoDecoderConfig, svc: SvcOutputMetadata, alphaSideData: BufferSource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.decoderConfig] = decoderConfig.jsValue
        object[Strings.svc] = svc.jsValue
        object[Strings.alphaSideData] = alphaSideData.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _decoderConfig = ReadWriteAttribute(jsObject: object, name: Strings.decoderConfig)
        _svc = ReadWriteAttribute(jsObject: object, name: Strings.svc)
        _alphaSideData = ReadWriteAttribute(jsObject: object, name: Strings.alphaSideData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var decoderConfig: VideoDecoderConfig

    @ReadWriteAttribute
    public var svc: SvcOutputMetadata

    @ReadWriteAttribute
    public var alphaSideData: BufferSource
}

public enum EncodedVideoChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ErrorEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: Strings.filename)
        _lineno = ReadonlyAttribute(jsObject: jsObject, name: Strings.lineno)
        _colno = ReadonlyAttribute(jsObject: jsObject, name: Strings.colno)
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ErrorEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var lineno: UInt32

    @ReadonlyAttribute
    public var colno: UInt32

    @ReadonlyAttribute
    public var error: JSValue
}

public class ErrorEventInit: BridgedDictionary {
    public convenience init(message: String, filename: String, lineno: UInt32, colno: UInt32, error: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.message] = message.jsValue
        object[Strings.filename] = filename.jsValue
        object[Strings.lineno] = lineno.jsValue
        object[Strings.colno] = colno.jsValue
        object[Strings.error] = error.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _message = ReadWriteAttribute(jsObject: object, name: Strings.message)
        _filename = ReadWriteAttribute(jsObject: object, name: Strings.filename)
        _lineno = ReadWriteAttribute(jsObject: object, name: Strings.lineno)
        _colno = ReadWriteAttribute(jsObject: object, name: Strings.colno)
        _error = ReadWriteAttribute(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var message: String

    @ReadWriteAttribute
    public var filename: String

    @ReadWriteAttribute
    public var lineno: UInt32

    @ReadWriteAttribute
    public var colno: UInt32

    @ReadWriteAttribute
    public var error: JSValue
}

public class Event: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Event].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: Strings.target)
        _srcElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.srcElement)
        _currentTarget = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentTarget)
        _eventPhase = ReadonlyAttribute(jsObject: jsObject, name: Strings.eventPhase)
        _cancelBubble = ReadWriteAttribute(jsObject: jsObject, name: Strings.cancelBubble)
        _bubbles = ReadonlyAttribute(jsObject: jsObject, name: Strings.bubbles)
        _cancelable = ReadonlyAttribute(jsObject: jsObject, name: Strings.cancelable)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.returnValue)
        _defaultPrevented = ReadonlyAttribute(jsObject: jsObject, name: Strings.defaultPrevented)
        _composed = ReadonlyAttribute(jsObject: jsObject, name: Strings.composed)
        _isTrusted = ReadonlyAttribute(jsObject: jsObject, name: Strings.isTrusted)
        _timeStamp = ReadonlyAttribute(jsObject: jsObject, name: Strings.timeStamp)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(type: String, eventInitDict: EventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: EventTarget?

    @ReadonlyAttribute
    public var srcElement: EventTarget?

    @ReadonlyAttribute
    public var currentTarget: EventTarget?

    @inlinable public func composedPath() -> [EventTarget] {
        let this = jsObject
        return this[Strings.composedPath].function!(this: this, arguments: []).fromJSValue()!
    }

    public static let NONE: UInt16 = 0

    public static let CAPTURING_PHASE: UInt16 = 1

    public static let AT_TARGET: UInt16 = 2

    public static let BUBBLING_PHASE: UInt16 = 3

    @ReadonlyAttribute
    public var eventPhase: UInt16

    @inlinable public func stopPropagation() {
        let this = jsObject
        _ = this[Strings.stopPropagation].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var cancelBubble: Bool

    @inlinable public func stopImmediatePropagation() {
        let this = jsObject
        _ = this[Strings.stopImmediatePropagation].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var bubbles: Bool

    @ReadonlyAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var returnValue: Bool

    @inlinable public func preventDefault() {
        let this = jsObject
        _ = this[Strings.preventDefault].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var defaultPrevented: Bool

    @ReadonlyAttribute
    public var composed: Bool

    @ReadonlyAttribute
    public var isTrusted: Bool

    @ReadonlyAttribute
    public var timeStamp: DOMHighResTimeStamp

    @inlinable public func initEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil) {
        let this = jsObject
        _ = this[Strings.initEvent].function!(this: this, arguments: [type.jsValue, bubbles?.jsValue ?? .undefined, cancelable?.jsValue ?? .undefined])
    }
}

public class EventInit: BridgedDictionary {
    public convenience init(bubbles: Bool, cancelable: Bool, composed: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = bubbles.jsValue
        object[Strings.cancelable] = cancelable.jsValue
        object[Strings.composed] = composed.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bubbles = ReadWriteAttribute(jsObject: object, name: Strings.bubbles)
        _cancelable = ReadWriteAttribute(jsObject: object, name: Strings.cancelable)
        _composed = ReadWriteAttribute(jsObject: object, name: Strings.composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bubbles: Bool

    @ReadWriteAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var composed: Bool
}

public class EventListenerOptions: BridgedDictionary {
    public convenience init(capture: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.capture] = capture.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _capture = ReadWriteAttribute(jsObject: object, name: Strings.capture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var capture: Bool
}

public class EventModifierInit: BridgedDictionary {
    public convenience init(ctrlKey: Bool, shiftKey: Bool, altKey: Bool, metaKey: Bool, modifierAltGraph: Bool, modifierCapsLock: Bool, modifierFn: Bool, modifierFnLock: Bool, modifierHyper: Bool, modifierNumLock: Bool, modifierScrollLock: Bool, modifierSuper: Bool, modifierSymbol: Bool, modifierSymbolLock: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ctrlKey] = ctrlKey.jsValue
        object[Strings.shiftKey] = shiftKey.jsValue
        object[Strings.altKey] = altKey.jsValue
        object[Strings.metaKey] = metaKey.jsValue
        object[Strings.modifierAltGraph] = modifierAltGraph.jsValue
        object[Strings.modifierCapsLock] = modifierCapsLock.jsValue
        object[Strings.modifierFn] = modifierFn.jsValue
        object[Strings.modifierFnLock] = modifierFnLock.jsValue
        object[Strings.modifierHyper] = modifierHyper.jsValue
        object[Strings.modifierNumLock] = modifierNumLock.jsValue
        object[Strings.modifierScrollLock] = modifierScrollLock.jsValue
        object[Strings.modifierSuper] = modifierSuper.jsValue
        object[Strings.modifierSymbol] = modifierSymbol.jsValue
        object[Strings.modifierSymbolLock] = modifierSymbolLock.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _ctrlKey = ReadWriteAttribute(jsObject: object, name: Strings.ctrlKey)
        _shiftKey = ReadWriteAttribute(jsObject: object, name: Strings.shiftKey)
        _altKey = ReadWriteAttribute(jsObject: object, name: Strings.altKey)
        _metaKey = ReadWriteAttribute(jsObject: object, name: Strings.metaKey)
        _modifierAltGraph = ReadWriteAttribute(jsObject: object, name: Strings.modifierAltGraph)
        _modifierCapsLock = ReadWriteAttribute(jsObject: object, name: Strings.modifierCapsLock)
        _modifierFn = ReadWriteAttribute(jsObject: object, name: Strings.modifierFn)
        _modifierFnLock = ReadWriteAttribute(jsObject: object, name: Strings.modifierFnLock)
        _modifierHyper = ReadWriteAttribute(jsObject: object, name: Strings.modifierHyper)
        _modifierNumLock = ReadWriteAttribute(jsObject: object, name: Strings.modifierNumLock)
        _modifierScrollLock = ReadWriteAttribute(jsObject: object, name: Strings.modifierScrollLock)
        _modifierSuper = ReadWriteAttribute(jsObject: object, name: Strings.modifierSuper)
        _modifierSymbol = ReadWriteAttribute(jsObject: object, name: Strings.modifierSymbol)
        _modifierSymbolLock = ReadWriteAttribute(jsObject: object, name: Strings.modifierSymbolLock)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var ctrlKey: Bool

    @ReadWriteAttribute
    public var shiftKey: Bool

    @ReadWriteAttribute
    public var altKey: Bool

    @ReadWriteAttribute
    public var metaKey: Bool

    @ReadWriteAttribute
    public var modifierAltGraph: Bool

    @ReadWriteAttribute
    public var modifierCapsLock: Bool

    @ReadWriteAttribute
    public var modifierFn: Bool

    @ReadWriteAttribute
    public var modifierFnLock: Bool

    @ReadWriteAttribute
    public var modifierHyper: Bool

    @ReadWriteAttribute
    public var modifierNumLock: Bool

    @ReadWriteAttribute
    public var modifierScrollLock: Bool

    @ReadWriteAttribute
    public var modifierSuper: Bool

    @ReadWriteAttribute
    public var modifierSymbol: Bool

    @ReadWriteAttribute
    public var modifierSymbolLock: Bool
}

public class EventSource: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.EventSource].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _withCredentials = ReadonlyAttribute(jsObject: jsObject, name: Strings.withCredentials)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _onopen = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onopen)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(url: String, eventSourceInitDict: EventSourceInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [url.jsValue, eventSourceInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var withCredentials: Bool

    public static let CONNECTING: UInt16 = 0

    public static let OPEN: UInt16 = 1

    public static let CLOSED: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ClosureAttribute1Optional
    public var onopen: EventHandler

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

public class EventSourceInit: BridgedDictionary {
    public convenience init(withCredentials: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.withCredentials] = withCredentials.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _withCredentials = ReadWriteAttribute(jsObject: object, name: Strings.withCredentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var withCredentials: Bool
}

public class EventTarget: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.EventTarget].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    // XXX: member 'addEventListener' is ignored

    // XXX: member 'removeEventListener' is ignored

    @inlinable public func dispatchEvent(event: Event) -> Bool {
        let this = jsObject
        return this[Strings.dispatchEvent].function!(this: this, arguments: [event.jsValue]).fromJSValue()!
    }
}

public class ExtendableEventInit: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class External: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.External].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func AddSearchProvider() {
        let this = jsObject
        _ = this[Strings.AddSearchProvider].function!(this: this, arguments: [])
    }

    @inlinable public func IsSearchProviderInstalled() {
        let this = jsObject
        _ = this[Strings.IsSearchProviderInstalled].function!(this: this, arguments: [])
    }
}

public class FetchEventInit: BridgedDictionary {
    public convenience init(request: Request, preloadResponse: JSPromise, clientId: String, resultingClientId: String, replacesClientId: String, handled: JSPromise) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.request] = request.jsValue
        object[Strings.preloadResponse] = preloadResponse.jsValue
        object[Strings.clientId] = clientId.jsValue
        object[Strings.resultingClientId] = resultingClientId.jsValue
        object[Strings.replacesClientId] = replacesClientId.jsValue
        object[Strings.handled] = handled.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _request = ReadWriteAttribute(jsObject: object, name: Strings.request)
        _preloadResponse = ReadWriteAttribute(jsObject: object, name: Strings.preloadResponse)
        _clientId = ReadWriteAttribute(jsObject: object, name: Strings.clientId)
        _resultingClientId = ReadWriteAttribute(jsObject: object, name: Strings.resultingClientId)
        _replacesClientId = ReadWriteAttribute(jsObject: object, name: Strings.replacesClientId)
        _handled = ReadWriteAttribute(jsObject: object, name: Strings.handled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var request: Request

    @ReadWriteAttribute
    public var preloadResponse: JSPromise

    @ReadWriteAttribute
    public var clientId: String

    @ReadWriteAttribute
    public var resultingClientId: String

    @ReadWriteAttribute
    public var replacesClientId: String

    @ReadWriteAttribute
    public var handled: JSPromise
}

public class File: Blob {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.File].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastModified)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(fileBits: [BlobPart], fileName: String, options: FilePropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [fileBits.jsValue, fileName.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var lastModified: Int64
}

public class FileList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.FileList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> File? {
        jsObject[key].fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32
}

public class FilePropertyBag: BridgedDictionary {
    public convenience init(lastModified: Int64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.lastModified] = lastModified.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lastModified = ReadWriteAttribute(jsObject: object, name: Strings.lastModified)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lastModified: Int64
}

public class FileReader: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.FileReader].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _result = ReadonlyAttribute(jsObject: jsObject, name: Strings.result)
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        _onloadstart = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onloadstart)
        _onprogress = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onprogress)
        _onload = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onload)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onabort)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        _onloadend = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func readAsArrayBuffer(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsArrayBuffer].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsBinaryString(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsBinaryString].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func readAsText(blob: Blob, encoding: String? = nil) {
        let this = jsObject
        _ = this[Strings.readAsText].function!(this: this, arguments: [blob.jsValue, encoding?.jsValue ?? .undefined])
    }

    @inlinable public func readAsDataURL(blob: Blob) {
        let this = jsObject
        _ = this[Strings.readAsDataURL].function!(this: this, arguments: [blob.jsValue])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    public static let EMPTY: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let DONE: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var result: ArrayBuffer_or_String?

    @ReadonlyAttribute
    public var error: DOMException?

    @ClosureAttribute1Optional
    public var onloadstart: EventHandler

    @ClosureAttribute1Optional
    public var onprogress: EventHandler

    @ClosureAttribute1Optional
    public var onload: EventHandler

    @ClosureAttribute1Optional
    public var onabort: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onloadend: EventHandler
}

public enum FillMode: JSString, JSValueCompatible {
    case none = "none"
    case forwards = "forwards"
    case backwards = "backwards"
    case both = "both"
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class FocusEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.FocusEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _relatedTarget = ReadonlyAttribute(jsObject: jsObject, name: Strings.relatedTarget)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: FocusEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var relatedTarget: EventTarget?
}

public class FocusEventInit: BridgedDictionary {
    public convenience init(relatedTarget: EventTarget?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.relatedTarget] = relatedTarget.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _relatedTarget = ReadWriteAttribute(jsObject: object, name: Strings.relatedTarget)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var relatedTarget: EventTarget?
}

public class FocusOptions: BridgedDictionary {
    public convenience init(preventScroll: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventScroll] = preventScroll.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventScroll = ReadWriteAttribute(jsObject: object, name: Strings.preventScroll)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventScroll: Bool
}

public class FormData: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.FormData].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(form: HTMLFormElement? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [form?.jsValue ?? .undefined]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func append(name: String, blobValue: Blob, filename: String? = nil) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, blobValue.jsValue, filename?.jsValue ?? .undefined])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [name.jsValue])
    }

    @inlinable public func get(name: String) -> FormDataEntryValue? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func getAll(name: String) -> [FormDataEntryValue] {
        let this = jsObject
        return this[Strings.getAll].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func set(name: String, blobValue: Blob, filename: String? = nil) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, blobValue.jsValue, filename?.jsValue ?? .undefined])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<FormData> {
        ValueIterableIterator(sequence: self)
    }
}

public class FormDataEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.FormDataEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _formData = ReadonlyAttribute(jsObject: jsObject, name: Strings.formData)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: FormDataEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var formData: FormData
}

public class FormDataEventInit: BridgedDictionary {
    public convenience init(formData: FormData) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.formData] = formData.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _formData = ReadWriteAttribute(jsObject: object, name: Strings.formData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var formData: FormData
}

public enum FrameType: JSString, JSValueCompatible {
    case auxiliary = "auxiliary"
    case topLevel = "top-level"
    case nested = "nested"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPU: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPU].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestAdapter].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) async throws -> GPUAdapter? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestAdapter].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUAdapter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUAdapter].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _features = ReadonlyAttribute(jsObject: jsObject, name: Strings.features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: Strings.limits)
        _isFallbackAdapter = ReadonlyAttribute(jsObject: jsObject, name: Strings.isFallbackAdapter)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var isFallbackAdapter: Bool

    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.requestDevice].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) async throws -> GPUDevice {
        let this = jsObject
        let _promise: JSPromise = this[Strings.requestDevice].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum GPUAddressMode: JSString, JSValueCompatible {
    case clampToEdge = "clamp-to-edge"
    case `repeat` = "repeat"
    case mirrorRepeat = "mirror-repeat"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBindGroup: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUBindGroup].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupDescriptor: BridgedDictionary {
    public convenience init(layout: GPUBindGroupLayout, entries: [GPUBindGroupEntry]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = layout.jsValue
        object[Strings.entries] = entries.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        _entries = ReadWriteAttribute(jsObject: object, name: Strings.entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUBindGroupLayout

    @ReadWriteAttribute
    public var entries: [GPUBindGroupEntry]
}

public class GPUBindGroupEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, resource: GPUBindingResource) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = binding.jsValue
        object[Strings.resource] = resource.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: Strings.binding)
        _resource = ReadWriteAttribute(jsObject: object, name: Strings.resource)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var resource: GPUBindingResource
}

public class GPUBindGroupLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUBindGroupLayout].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupLayoutDescriptor: BridgedDictionary {
    public convenience init(entries: [GPUBindGroupLayoutEntry]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.entries] = entries.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _entries = ReadWriteAttribute(jsObject: object, name: Strings.entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var entries: [GPUBindGroupLayoutEntry]
}

public class GPUBindGroupLayoutEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, visibility: GPUShaderStageFlags, buffer: GPUBufferBindingLayout, sampler: GPUSamplerBindingLayout, texture: GPUTextureBindingLayout, storageTexture: GPUStorageTextureBindingLayout, externalTexture: GPUExternalTextureBindingLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = binding.jsValue
        object[Strings.visibility] = visibility.jsValue
        object[Strings.buffer] = buffer.jsValue
        object[Strings.sampler] = sampler.jsValue
        object[Strings.texture] = texture.jsValue
        object[Strings.storageTexture] = storageTexture.jsValue
        object[Strings.externalTexture] = externalTexture.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: Strings.binding)
        _visibility = ReadWriteAttribute(jsObject: object, name: Strings.visibility)
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _sampler = ReadWriteAttribute(jsObject: object, name: Strings.sampler)
        _texture = ReadWriteAttribute(jsObject: object, name: Strings.texture)
        _storageTexture = ReadWriteAttribute(jsObject: object, name: Strings.storageTexture)
        _externalTexture = ReadWriteAttribute(jsObject: object, name: Strings.externalTexture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var visibility: GPUShaderStageFlags

    @ReadWriteAttribute
    public var buffer: GPUBufferBindingLayout

    @ReadWriteAttribute
    public var sampler: GPUSamplerBindingLayout

    @ReadWriteAttribute
    public var texture: GPUTextureBindingLayout

    @ReadWriteAttribute
    public var storageTexture: GPUStorageTextureBindingLayout

    @ReadWriteAttribute
    public var externalTexture: GPUExternalTextureBindingLayout
}

public class GPUBlendComponent: BridgedDictionary {
    public convenience init(operation: GPUBlendOperation, srcFactor: GPUBlendFactor, dstFactor: GPUBlendFactor) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.operation] = operation.jsValue
        object[Strings.srcFactor] = srcFactor.jsValue
        object[Strings.dstFactor] = dstFactor.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _operation = ReadWriteAttribute(jsObject: object, name: Strings.operation)
        _srcFactor = ReadWriteAttribute(jsObject: object, name: Strings.srcFactor)
        _dstFactor = ReadWriteAttribute(jsObject: object, name: Strings.dstFactor)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var operation: GPUBlendOperation

    @ReadWriteAttribute
    public var srcFactor: GPUBlendFactor

    @ReadWriteAttribute
    public var dstFactor: GPUBlendFactor
}

public enum GPUBlendFactor: JSString, JSValueCompatible {
    case zero = "zero"
    case one = "one"
    case src = "src"
    case oneMinusSrc = "one-minus-src"
    case srcAlpha = "src-alpha"
    case oneMinusSrcAlpha = "one-minus-src-alpha"
    case dst = "dst"
    case oneMinusDst = "one-minus-dst"
    case dstAlpha = "dst-alpha"
    case oneMinusDstAlpha = "one-minus-dst-alpha"
    case srcAlphaSaturated = "src-alpha-saturated"
    case constant = "constant"
    case oneMinusConstant = "one-minus-constant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBlendOperation: JSString, JSValueCompatible {
    case add = "add"
    case subtract = "subtract"
    case reverseSubtract = "reverse-subtract"
    case min = "min"
    case max = "max"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBlendState: BridgedDictionary {
    public convenience init(color: GPUBlendComponent, alpha: GPUBlendComponent) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.color] = color.jsValue
        object[Strings.alpha] = alpha.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _color = ReadWriteAttribute(jsObject: object, name: Strings.color)
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var color: GPUBlendComponent

    @ReadWriteAttribute
    public var alpha: GPUBlendComponent
}

public class GPUBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUBuffer].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.mapAsync].function!(this: this, arguments: [mode.jsValue, offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.mapAsync].function!(this: this, arguments: [mode.jsValue, offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getMappedRange(offset: GPUSize64? = nil, size: GPUSize64? = nil) -> ArrayBuffer {
        let this = jsObject
        return this[Strings.getMappedRange].function!(this: this, arguments: [offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func unmap() {
        let this = jsObject
        _ = this[Strings.unmap].function!(this: this, arguments: [])
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }
}

public class GPUBufferBinding: BridgedDictionary {
    public convenience init(buffer: GPUBuffer, offset: GPUSize64, size: GPUSize64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        object[Strings.offset] = offset.jsValue
        object[Strings.size] = size.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var size: GPUSize64
}

public class GPUBufferBindingLayout: BridgedDictionary {
    public convenience init(type: GPUBufferBindingType, hasDynamicOffset: Bool, minBindingSize: GPUSize64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.hasDynamicOffset] = hasDynamicOffset.jsValue
        object[Strings.minBindingSize] = minBindingSize.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _hasDynamicOffset = ReadWriteAttribute(jsObject: object, name: Strings.hasDynamicOffset)
        _minBindingSize = ReadWriteAttribute(jsObject: object, name: Strings.minBindingSize)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUBufferBindingType

    @ReadWriteAttribute
    public var hasDynamicOffset: Bool

    @ReadWriteAttribute
    public var minBindingSize: GPUSize64
}

public enum GPUBufferBindingType: JSString, JSValueCompatible {
    case uniform = "uniform"
    case storage = "storage"
    case readOnlyStorage = "read-only-storage"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBufferDescriptor: BridgedDictionary {
    public convenience init(size: GPUSize64, usage: GPUBufferUsageFlags, mappedAtCreation: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.size] = size.jsValue
        object[Strings.usage] = usage.jsValue
        object[Strings.mappedAtCreation] = mappedAtCreation.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _mappedAtCreation = ReadWriteAttribute(jsObject: object, name: Strings.mappedAtCreation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUSize64

    @ReadWriteAttribute
    public var usage: GPUBufferUsageFlags

    @ReadWriteAttribute
    public var mappedAtCreation: Bool
}

public enum GPUBufferUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUBufferUsage].object!
    }

    public static let MAP_READ: GPUFlagsConstant = 0x0001

    public static let MAP_WRITE: GPUFlagsConstant = 0x0002

    public static let COPY_SRC: GPUFlagsConstant = 0x0004

    public static let COPY_DST: GPUFlagsConstant = 0x0008

    public static let INDEX: GPUFlagsConstant = 0x0010

    public static let VERTEX: GPUFlagsConstant = 0x0020

    public static let UNIFORM: GPUFlagsConstant = 0x0040

    public static let STORAGE: GPUFlagsConstant = 0x0080

    public static let INDIRECT: GPUFlagsConstant = 0x0100

    public static let QUERY_RESOLVE: GPUFlagsConstant = 0x0200
}

public enum GPUCanvasCompositingAlphaMode: JSString, JSValueCompatible {
    case opaque = "opaque"
    case premultiplied = "premultiplied"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCanvasConfiguration: BridgedDictionary {
    public convenience init(device: GPUDevice, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat], colorSpace: GPUPredefinedColorSpace, compositingAlphaMode: GPUCanvasCompositingAlphaMode, size: GPUExtent3D) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.device] = device.jsValue
        object[Strings.format] = format.jsValue
        object[Strings.usage] = usage.jsValue
        object[Strings.viewFormats] = viewFormats.jsValue
        object[Strings.colorSpace] = colorSpace.jsValue
        object[Strings.compositingAlphaMode] = compositingAlphaMode.jsValue
        object[Strings.size] = size.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _device = ReadWriteAttribute(jsObject: object, name: Strings.device)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: Strings.viewFormats)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _compositingAlphaMode = ReadWriteAttribute(jsObject: object, name: Strings.compositingAlphaMode)
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var device: GPUDevice

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]

    @ReadWriteAttribute
    public var colorSpace: GPUPredefinedColorSpace

    @ReadWriteAttribute
    public var compositingAlphaMode: GPUCanvasCompositingAlphaMode

    @ReadWriteAttribute
    public var size: GPUExtent3D
}

public class GPUCanvasContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUCanvasContext].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: Strings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement_or_OffscreenCanvas

    @inlinable public func configure(configuration: GPUCanvasConfiguration) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [configuration.jsValue])
    }

    @inlinable public func unconfigure() {
        let this = jsObject
        _ = this[Strings.unconfigure].function!(this: this, arguments: [])
    }

    @inlinable public func getPreferredFormat(adapter: GPUAdapter) -> GPUTextureFormat {
        let this = jsObject
        return this[Strings.getPreferredFormat].function!(this: this, arguments: [adapter.jsValue]).fromJSValue()!
    }

    @inlinable public func getCurrentTexture() -> GPUTexture {
        let this = jsObject
        return this[Strings.getCurrentTexture].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class GPUColorDict: BridgedDictionary {
    public convenience init(r: Double, g: Double, b: Double, a: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.r] = r.jsValue
        object[Strings.g] = g.jsValue
        object[Strings.b] = b.jsValue
        object[Strings.a] = a.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _r = ReadWriteAttribute(jsObject: object, name: Strings.r)
        _g = ReadWriteAttribute(jsObject: object, name: Strings.g)
        _b = ReadWriteAttribute(jsObject: object, name: Strings.b)
        _a = ReadWriteAttribute(jsObject: object, name: Strings.a)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var r: Double

    @ReadWriteAttribute
    public var g: Double

    @ReadWriteAttribute
    public var b: Double

    @ReadWriteAttribute
    public var a: Double
}

public class GPUColorTargetState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, blend: GPUBlendState, writeMask: GPUColorWriteFlags) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.blend] = blend.jsValue
        object[Strings.writeMask] = writeMask.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _blend = ReadWriteAttribute(jsObject: object, name: Strings.blend)
        _writeMask = ReadWriteAttribute(jsObject: object, name: Strings.writeMask)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var blend: GPUBlendState

    @ReadWriteAttribute
    public var writeMask: GPUColorWriteFlags
}

public enum GPUColorWrite {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUColorWrite].object!
    }

    public static let RED: GPUFlagsConstant = 0x1

    public static let GREEN: GPUFlagsConstant = 0x2

    public static let BLUE: GPUFlagsConstant = 0x4

    public static let ALPHA: GPUFlagsConstant = 0x8

    public static let ALL: GPUFlagsConstant = 0xF
}

public class GPUCommandBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUCommandBuffer].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUCommandBufferDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUCommandEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUCommandEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func beginRenderPass(descriptor: GPURenderPassDescriptor) -> GPURenderPassEncoder {
        let this = jsObject
        return this[Strings.beginRenderPass].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func beginComputePass(descriptor: GPUComputePassDescriptor? = nil) -> GPUComputePassEncoder {
        let this = jsObject
        return this[Strings.beginComputePass].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func copyBufferToBuffer(source: GPUBuffer, sourceOffset: GPUSize64, destination: GPUBuffer, destinationOffset: GPUSize64, size: GPUSize64) {
        let this = jsObject
        _ = this[Strings.copyBufferToBuffer].function!(this: this, arguments: [source.jsValue, sourceOffset.jsValue, destination.jsValue, destinationOffset.jsValue, size.jsValue])
    }

    @inlinable public func copyBufferToTexture(source: GPUImageCopyBuffer, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyBufferToTexture].function!(this: this, arguments: [source.jsValue, destination.jsValue, copySize.jsValue])
    }

    @inlinable public func copyTextureToBuffer(source: GPUImageCopyTexture, destination: GPUImageCopyBuffer, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyTextureToBuffer].function!(this: this, arguments: [source.jsValue, destination.jsValue, copySize.jsValue])
    }

    @inlinable public func copyTextureToTexture(source: GPUImageCopyTexture, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyTextureToTexture].function!(this: this, arguments: [source.jsValue, destination.jsValue, copySize.jsValue])
    }

    @inlinable public func clearBuffer(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.clearBuffer].function!(this: this, arguments: [buffer.jsValue, offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined])
    }

    @inlinable public func writeTimestamp(querySet: GPUQuerySet, queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[Strings.writeTimestamp].function!(this: this, arguments: [querySet.jsValue, queryIndex.jsValue])
    }

    @inlinable public func resolveQuerySet(querySet: GPUQuerySet, firstQuery: GPUSize32, queryCount: GPUSize32, destination: GPUBuffer, destinationOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.resolveQuerySet].function!(this: this, arguments: [querySet.jsValue, firstQuery.jsValue, queryCount.jsValue, destination.jsValue, destinationOffset.jsValue])
    }

    @inlinable public func finish(descriptor: GPUCommandBufferDescriptor? = nil) -> GPUCommandBuffer {
        let this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class GPUCommandEncoderDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public protocol GPUCommandsMixin: JSBridgedClass {}
public extension GPUCommandsMixin {}

public enum GPUCompareFunction: JSString, JSValueCompatible {
    case never = "never"
    case less = "less"
    case equal = "equal"
    case lessEqual = "less-equal"
    case greater = "greater"
    case notEqual = "not-equal"
    case greaterEqual = "greater-equal"
    case always = "always"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCompilationInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUCompilationInfo].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _messages = ReadonlyAttribute(jsObject: jsObject, name: Strings.messages)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var messages: [GPUCompilationMessage]
}

public class GPUCompilationMessage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUCompilationMessage].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _lineNum = ReadonlyAttribute(jsObject: jsObject, name: Strings.lineNum)
        _linePos = ReadonlyAttribute(jsObject: jsObject, name: Strings.linePos)
        _offset = ReadonlyAttribute(jsObject: jsObject, name: Strings.offset)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var type: GPUCompilationMessageType

    @ReadonlyAttribute
    public var lineNum: UInt64

    @ReadonlyAttribute
    public var linePos: UInt64

    @ReadonlyAttribute
    public var offset: UInt64

    @ReadonlyAttribute
    public var length: UInt64
}

public enum GPUCompilationMessageType: JSString, JSValueCompatible {
    case error = "error"
    case warning = "warning"
    case info = "info"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUComputePassDescriptor: BridgedDictionary {
    public convenience init(timestampWrites: GPUComputePassTimestampWrites) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.timestampWrites] = timestampWrites.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: Strings.timestampWrites)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var timestampWrites: GPUComputePassTimestampWrites
}

public class GPUComputePassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUProgrammablePassEncoder {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUComputePassEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setPipeline(pipeline: GPUComputePipeline) {
        let this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [pipeline.jsValue])
    }

    @inlinable public func dispatch(workgroupCountX: GPUSize32, workgroupCountY: GPUSize32? = nil, workgroupCountZ: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.dispatch].function!(this: this, arguments: [workgroupCountX.jsValue, workgroupCountY?.jsValue ?? .undefined, workgroupCountZ?.jsValue ?? .undefined])
    }

    @inlinable public func dispatchIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.dispatchIndirect].function!(this: this, arguments: [indirectBuffer.jsValue, indirectOffset.jsValue])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

public enum GPUComputePassTimestampLocation: JSString, JSValueCompatible {
    case beginning = "beginning"
    case end = "end"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUComputePassTimestampWrite: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, queryIndex: GPUSize32, location: GPUComputePassTimestampLocation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = querySet.jsValue
        object[Strings.queryIndex] = queryIndex.jsValue
        object[Strings.location] = location.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: Strings.querySet)
        _queryIndex = ReadWriteAttribute(jsObject: object, name: Strings.queryIndex)
        _location = ReadWriteAttribute(jsObject: object, name: Strings.location)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var queryIndex: GPUSize32

    @ReadWriteAttribute
    public var location: GPUComputePassTimestampLocation
}

public class GPUComputePipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUComputePipeline].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUComputePipelineDescriptor: BridgedDictionary {
    public convenience init(compute: GPUProgrammableStage) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.compute] = compute.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compute = ReadWriteAttribute(jsObject: object, name: Strings.compute)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compute: GPUProgrammableStage
}

public enum GPUCullMode: JSString, JSValueCompatible {
    case none = "none"
    case front = "front"
    case back = "back"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GPUDebugCommandsMixin: JSBridgedClass {}
public extension GPUDebugCommandsMixin {
    @inlinable func pushDebugGroup(groupLabel: String) {
        let this = jsObject
        _ = this[Strings.pushDebugGroup].function!(this: this, arguments: [groupLabel.jsValue])
    }

    @inlinable func popDebugGroup() {
        let this = jsObject
        _ = this[Strings.popDebugGroup].function!(this: this, arguments: [])
    }

    @inlinable func insertDebugMarker(markerLabel: String) {
        let this = jsObject
        _ = this[Strings.insertDebugMarker].function!(this: this, arguments: [markerLabel.jsValue])
    }
}

public class GPUDepthStencilState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, depthWriteEnabled: Bool, depthCompare: GPUCompareFunction, stencilFront: GPUStencilFaceState, stencilBack: GPUStencilFaceState, stencilReadMask: GPUStencilValue, stencilWriteMask: GPUStencilValue, depthBias: GPUDepthBias, depthBiasSlopeScale: Float, depthBiasClamp: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.depthWriteEnabled] = depthWriteEnabled.jsValue
        object[Strings.depthCompare] = depthCompare.jsValue
        object[Strings.stencilFront] = stencilFront.jsValue
        object[Strings.stencilBack] = stencilBack.jsValue
        object[Strings.stencilReadMask] = stencilReadMask.jsValue
        object[Strings.stencilWriteMask] = stencilWriteMask.jsValue
        object[Strings.depthBias] = depthBias.jsValue
        object[Strings.depthBiasSlopeScale] = depthBiasSlopeScale.jsValue
        object[Strings.depthBiasClamp] = depthBiasClamp.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _depthWriteEnabled = ReadWriteAttribute(jsObject: object, name: Strings.depthWriteEnabled)
        _depthCompare = ReadWriteAttribute(jsObject: object, name: Strings.depthCompare)
        _stencilFront = ReadWriteAttribute(jsObject: object, name: Strings.stencilFront)
        _stencilBack = ReadWriteAttribute(jsObject: object, name: Strings.stencilBack)
        _stencilReadMask = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadMask)
        _stencilWriteMask = ReadWriteAttribute(jsObject: object, name: Strings.stencilWriteMask)
        _depthBias = ReadWriteAttribute(jsObject: object, name: Strings.depthBias)
        _depthBiasSlopeScale = ReadWriteAttribute(jsObject: object, name: Strings.depthBiasSlopeScale)
        _depthBiasClamp = ReadWriteAttribute(jsObject: object, name: Strings.depthBiasClamp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var depthWriteEnabled: Bool

    @ReadWriteAttribute
    public var depthCompare: GPUCompareFunction

    @ReadWriteAttribute
    public var stencilFront: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilBack: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilReadMask: GPUStencilValue

    @ReadWriteAttribute
    public var stencilWriteMask: GPUStencilValue

    @ReadWriteAttribute
    public var depthBias: GPUDepthBias

    @ReadWriteAttribute
    public var depthBiasSlopeScale: Float

    @ReadWriteAttribute
    public var depthBiasClamp: Float
}

public class GPUDevice: EventTarget, GPUObjectBase {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.GPUDevice].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _features = ReadonlyAttribute(jsObject: jsObject, name: Strings.features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: Strings.limits)
        _queue = ReadonlyAttribute(jsObject: jsObject, name: Strings.queue)
        _lost = ReadonlyAttribute(jsObject: jsObject, name: Strings.lost)
        _onuncapturederror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onuncapturederror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var queue: GPUQueue

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable public func createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createTexture(descriptor: GPUTextureDescriptor) -> GPUTexture {
        let this = jsObject
        return this[Strings.createTexture].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createSampler(descriptor: GPUSamplerDescriptor? = nil) -> GPUSampler {
        let this = jsObject
        return this[Strings.createSampler].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func importExternalTexture(descriptor: GPUExternalTextureDescriptor) -> GPUExternalTexture {
        let this = jsObject
        return this[Strings.importExternalTexture].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor) -> GPUBindGroupLayout {
        let this = jsObject
        return this[Strings.createBindGroupLayout].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor) -> GPUPipelineLayout {
        let this = jsObject
        return this[Strings.createPipelineLayout].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createBindGroup(descriptor: GPUBindGroupDescriptor) -> GPUBindGroup {
        let this = jsObject
        return this[Strings.createBindGroup].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createShaderModule(descriptor: GPUShaderModuleDescriptor) -> GPUShaderModule {
        let this = jsObject
        return this[Strings.createShaderModule].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createComputePipeline(descriptor: GPUComputePipelineDescriptor) -> GPUComputePipeline {
        let this = jsObject
        return this[Strings.createComputePipeline].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createRenderPipeline(descriptor: GPURenderPipelineDescriptor) -> GPURenderPipeline {
        let this = jsObject
        return this[Strings.createRenderPipeline].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[Strings.createComputePipelineAsync].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) async throws -> GPUComputePipeline {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createComputePipelineAsync].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[Strings.createRenderPipelineAsync].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) async throws -> GPURenderPipeline {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createRenderPipelineAsync].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createCommandEncoder(descriptor: GPUCommandEncoderDescriptor? = nil) -> GPUCommandEncoder {
        let this = jsObject
        return this[Strings.createCommandEncoder].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor) -> GPURenderBundleEncoder {
        let this = jsObject
        return this[Strings.createRenderBundleEncoder].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @inlinable public func createQuerySet(descriptor: GPUQuerySetDescriptor) -> GPUQuerySet {
        let this = jsObject
        return this[Strings.createQuerySet].function!(this: this, arguments: [descriptor.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var lost: JSPromise

    @inlinable public func pushErrorScope(filter: GPUErrorFilter) {
        let this = jsObject
        _ = this[Strings.pushErrorScope].function!(this: this, arguments: [filter.jsValue])
    }

    @inlinable public func popErrorScope() -> JSPromise {
        let this = jsObject
        return this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func popErrorScope() async throws -> GPUError? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onuncapturederror: EventHandler
}

public class GPUDeviceDescriptor: BridgedDictionary {
    public convenience init(requiredFeatures: [GPUFeatureName], requiredLimits: [String: GPUSize64], defaultQueue: GPUQueueDescriptor) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.requiredFeatures] = requiredFeatures.jsValue
        object[Strings.requiredLimits] = requiredLimits.jsValue
        object[Strings.defaultQueue] = defaultQueue.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _requiredFeatures = ReadWriteAttribute(jsObject: object, name: Strings.requiredFeatures)
        _requiredLimits = ReadWriteAttribute(jsObject: object, name: Strings.requiredLimits)
        _defaultQueue = ReadWriteAttribute(jsObject: object, name: Strings.defaultQueue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var requiredFeatures: [GPUFeatureName]

    @ReadWriteAttribute
    public var requiredLimits: [String: GPUSize64]

    @ReadWriteAttribute
    public var defaultQueue: GPUQueueDescriptor
}

public class GPUDeviceLostInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUDeviceLostInfo].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var reason: GPUDeviceLostReason?

    @ReadonlyAttribute
    public var message: String
}

public enum GPUDeviceLostReason: JSString, JSValueCompatible {
    case destroyed = "destroyed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUErrorFilter: JSString, JSValueCompatible {
    case outOfMemory = "out-of-memory"
    case validation = "validation"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUExtent3DDict: BridgedDictionary {
    public convenience init(width: GPUIntegerCoordinate, height: GPUIntegerCoordinate, depthOrArrayLayers: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.depthOrArrayLayers] = depthOrArrayLayers.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _depthOrArrayLayers = ReadWriteAttribute(jsObject: object, name: Strings.depthOrArrayLayers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var height: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var depthOrArrayLayers: GPUIntegerCoordinate
}

public class GPUExternalTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUExternalTexture].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _expired = ReadonlyAttribute(jsObject: jsObject, name: Strings.expired)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var expired: Bool
}

public class GPUExternalTextureBindingLayout: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUExternalTextureDescriptor: BridgedDictionary {
    public convenience init(source: HTMLVideoElement, colorSpace: GPUPredefinedColorSpace) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = source.jsValue
        object[Strings.colorSpace] = colorSpace.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: Strings.source)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: HTMLVideoElement

    @ReadWriteAttribute
    public var colorSpace: GPUPredefinedColorSpace
}

public enum GPUFeatureName: JSString, JSValueCompatible {
    case depthClipControl = "depth-clip-control"
    case depth24unormStencil8 = "depth24unorm-stencil8"
    case depth32floatStencil8 = "depth32float-stencil8"
    case textureCompressionBc = "texture-compression-bc"
    case textureCompressionEtc2 = "texture-compression-etc2"
    case textureCompressionAstc = "texture-compression-astc"
    case timestampQuery = "timestamp-query"
    case indirectFirstInstance = "indirect-first-instance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUFragmentState: BridgedDictionary {
    public convenience init(targets: [GPUColorTargetState?]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.targets] = targets.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _targets = ReadWriteAttribute(jsObject: object, name: Strings.targets)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var targets: [GPUColorTargetState?]
}

public enum GPUFrontFace: JSString, JSValueCompatible {
    case ccw = "ccw"
    case cw = "cw"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUImageCopyBuffer: BridgedDictionary {
    public convenience init(buffer: GPUBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer
}

public class GPUImageCopyExternalImage: BridgedDictionary {
    public convenience init(source: HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas, origin: GPUOrigin2D, flipY: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = source.jsValue
        object[Strings.origin] = origin.jsValue
        object[Strings.flipY] = flipY.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: Strings.source)
        _origin = ReadWriteAttribute(jsObject: object, name: Strings.origin)
        _flipY = ReadWriteAttribute(jsObject: object, name: Strings.flipY)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas

    @ReadWriteAttribute
    public var origin: GPUOrigin2D

    @ReadWriteAttribute
    public var flipY: Bool
}

public class GPUImageCopyTexture: BridgedDictionary {
    public convenience init(texture: GPUTexture, mipLevel: GPUIntegerCoordinate, origin: GPUOrigin3D, aspect: GPUTextureAspect) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.texture] = texture.jsValue
        object[Strings.mipLevel] = mipLevel.jsValue
        object[Strings.origin] = origin.jsValue
        object[Strings.aspect] = aspect.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _texture = ReadWriteAttribute(jsObject: object, name: Strings.texture)
        _mipLevel = ReadWriteAttribute(jsObject: object, name: Strings.mipLevel)
        _origin = ReadWriteAttribute(jsObject: object, name: Strings.origin)
        _aspect = ReadWriteAttribute(jsObject: object, name: Strings.aspect)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var texture: GPUTexture

    @ReadWriteAttribute
    public var mipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var origin: GPUOrigin3D

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect
}

public class GPUImageCopyTextureTagged: BridgedDictionary {
    public convenience init(colorSpace: GPUPredefinedColorSpace, premultipliedAlpha: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorSpace] = colorSpace.jsValue
        object[Strings.premultipliedAlpha] = premultipliedAlpha.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _premultipliedAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultipliedAlpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: GPUPredefinedColorSpace

    @ReadWriteAttribute
    public var premultipliedAlpha: Bool
}

public class GPUImageDataLayout: BridgedDictionary {
    public convenience init(offset: GPUSize64, bytesPerRow: GPUSize32, rowsPerImage: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        object[Strings.bytesPerRow] = bytesPerRow.jsValue
        object[Strings.rowsPerImage] = rowsPerImage.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _bytesPerRow = ReadWriteAttribute(jsObject: object, name: Strings.bytesPerRow)
        _rowsPerImage = ReadWriteAttribute(jsObject: object, name: Strings.rowsPerImage)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var bytesPerRow: GPUSize32

    @ReadWriteAttribute
    public var rowsPerImage: GPUSize32
}

public enum GPUIndexFormat: JSString, JSValueCompatible {
    case uint16 = "uint16"
    case uint32 = "uint32"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPULoadOp: JSString, JSValueCompatible {
    case load = "load"
    case clear = "clear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUMapMode {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUMapMode].object!
    }

    public static let READ: GPUFlagsConstant = 0x0001

    public static let WRITE: GPUFlagsConstant = 0x0002
}

public enum GPUMipmapFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUMultisampleState: BridgedDictionary {
    public convenience init(count: GPUSize32, mask: GPUSampleMask, alphaToCoverageEnabled: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.count] = count.jsValue
        object[Strings.mask] = mask.jsValue
        object[Strings.alphaToCoverageEnabled] = alphaToCoverageEnabled.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _count = ReadWriteAttribute(jsObject: object, name: Strings.count)
        _mask = ReadWriteAttribute(jsObject: object, name: Strings.mask)
        _alphaToCoverageEnabled = ReadWriteAttribute(jsObject: object, name: Strings.alphaToCoverageEnabled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var count: GPUSize32

    @ReadWriteAttribute
    public var mask: GPUSampleMask

    @ReadWriteAttribute
    public var alphaToCoverageEnabled: Bool
}

public protocol GPUObjectBase: JSBridgedClass {}
public extension GPUObjectBase {
    @inlinable var label: String? {
        get { ReadWriteAttribute[Strings.label, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.label, in: jsObject] = newValue }
    }
}

public class GPUObjectDescriptorBase: BridgedDictionary {
    public convenience init(label: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = label.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _label = ReadWriteAttribute(jsObject: object, name: Strings.label)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var label: String
}

public class GPUOrigin2DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = x.jsValue
        object[Strings.y] = y.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate
}

public class GPUOrigin3DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, z: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = x.jsValue
        object[Strings.y] = y.jsValue
        object[Strings.z] = z.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: Strings.x)
        _y = ReadWriteAttribute(jsObject: object, name: Strings.y)
        _z = ReadWriteAttribute(jsObject: object, name: Strings.z)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var z: GPUIntegerCoordinate
}

public class GPUOutOfMemoryError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUOutOfMemoryError].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public protocol GPUPipelineBase: JSBridgedClass {}
public extension GPUPipelineBase {
    @inlinable func getBindGroupLayout(index: UInt32) -> GPUBindGroupLayout {
        let this = jsObject
        return this[Strings.getBindGroupLayout].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }
}

public class GPUPipelineDescriptorBase: BridgedDictionary {
    public convenience init(layout: GPUPipelineLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = layout.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUPipelineLayout
}

public class GPUPipelineLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUPipelineLayout].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUPipelineLayoutDescriptor: BridgedDictionary {
    public convenience init(bindGroupLayouts: [GPUBindGroupLayout]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bindGroupLayouts] = bindGroupLayouts.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bindGroupLayouts = ReadWriteAttribute(jsObject: object, name: Strings.bindGroupLayouts)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bindGroupLayouts: [GPUBindGroupLayout]
}

public enum GPUPowerPreference: JSString, JSValueCompatible {
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUPredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPrimitiveState: BridgedDictionary {
    public convenience init(topology: GPUPrimitiveTopology, stripIndexFormat: GPUIndexFormat, frontFace: GPUFrontFace, cullMode: GPUCullMode, unclippedDepth: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.topology] = topology.jsValue
        object[Strings.stripIndexFormat] = stripIndexFormat.jsValue
        object[Strings.frontFace] = frontFace.jsValue
        object[Strings.cullMode] = cullMode.jsValue
        object[Strings.unclippedDepth] = unclippedDepth.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _topology = ReadWriteAttribute(jsObject: object, name: Strings.topology)
        _stripIndexFormat = ReadWriteAttribute(jsObject: object, name: Strings.stripIndexFormat)
        _frontFace = ReadWriteAttribute(jsObject: object, name: Strings.frontFace)
        _cullMode = ReadWriteAttribute(jsObject: object, name: Strings.cullMode)
        _unclippedDepth = ReadWriteAttribute(jsObject: object, name: Strings.unclippedDepth)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var topology: GPUPrimitiveTopology

    @ReadWriteAttribute
    public var stripIndexFormat: GPUIndexFormat

    @ReadWriteAttribute
    public var frontFace: GPUFrontFace

    @ReadWriteAttribute
    public var cullMode: GPUCullMode

    @ReadWriteAttribute
    public var unclippedDepth: Bool
}

public enum GPUPrimitiveTopology: JSString, JSValueCompatible {
    case pointList = "point-list"
    case lineList = "line-list"
    case lineStrip = "line-strip"
    case triangleList = "triangle-list"
    case triangleStrip = "triangle-strip"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GPUProgrammablePassEncoder: JSBridgedClass {}
public extension GPUProgrammablePassEncoder {
    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup, dynamicOffsets: [GPUBufferDynamicOffset]? = nil) {
        let this = jsObject
        _ = this[Strings.setBindGroup].function!(this: this, arguments: [index.jsValue, bindGroup.jsValue, dynamicOffsets?.jsValue ?? .undefined])
    }

    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32) {
        let this = jsObject
        _ = this[Strings.setBindGroup].function!(this: this, arguments: [index.jsValue, bindGroup.jsValue, dynamicOffsetsData.jsValue, dynamicOffsetsDataStart.jsValue, dynamicOffsetsDataLength.jsValue])
    }
}

public class GPUProgrammableStage: BridgedDictionary {
    public convenience init(module: GPUShaderModule, entryPoint: String, constants: [String: GPUPipelineConstantValue]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.module] = module.jsValue
        object[Strings.entryPoint] = entryPoint.jsValue
        object[Strings.constants] = constants.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _module = ReadWriteAttribute(jsObject: object, name: Strings.module)
        _entryPoint = ReadWriteAttribute(jsObject: object, name: Strings.entryPoint)
        _constants = ReadWriteAttribute(jsObject: object, name: Strings.constants)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var module: GPUShaderModule

    @ReadWriteAttribute
    public var entryPoint: String

    @ReadWriteAttribute
    public var constants: [String: GPUPipelineConstantValue]
}

public class GPUQuerySet: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUQuerySet].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }
}

public class GPUQuerySetDescriptor: BridgedDictionary {
    public convenience init(type: GPUQueryType, count: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.count] = count.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _count = ReadWriteAttribute(jsObject: object, name: Strings.count)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUQueryType

    @ReadWriteAttribute
    public var count: GPUSize32
}

public enum GPUQueryType: JSString, JSValueCompatible {
    case occlusion = "occlusion"
    case timestamp = "timestamp"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUQueue: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUQueue].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func submit(commandBuffers: [GPUCommandBuffer]) {
        let this = jsObject
        _ = this[Strings.submit].function!(this: this, arguments: [commandBuffers.jsValue])
    }

    @inlinable public func onSubmittedWorkDone() -> JSPromise {
        let this = jsObject
        return this[Strings.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func onSubmittedWorkDone() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func writeBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: BufferSource, dataOffset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.writeBuffer].function!(this: this, arguments: [buffer.jsValue, bufferOffset.jsValue, data.jsValue, dataOffset?.jsValue ?? .undefined, size?.jsValue ?? .undefined])
    }

    @inlinable public func writeTexture(destination: GPUImageCopyTexture, data: BufferSource, dataLayout: GPUImageDataLayout, size: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.writeTexture].function!(this: this, arguments: [destination.jsValue, data.jsValue, dataLayout.jsValue, size.jsValue])
    }

    @inlinable public func copyExternalImageToTexture(source: GPUImageCopyExternalImage, destination: GPUImageCopyTextureTagged, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[Strings.copyExternalImageToTexture].function!(this: this, arguments: [source.jsValue, destination.jsValue, copySize.jsValue])
    }
}

public class GPUQueueDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundle: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPURenderBundle].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderBundleDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundleEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUProgrammablePassEncoder, GPURenderEncoderBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPURenderBundleEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func finish(descriptor: GPURenderBundleDescriptor? = nil) -> GPURenderBundle {
        let this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class GPURenderBundleEncoderDescriptor: BridgedDictionary {
    public convenience init(depthReadOnly: Bool, stencilReadOnly: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.depthReadOnly] = depthReadOnly.jsValue
        object[Strings.stencilReadOnly] = stencilReadOnly.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.depthReadOnly)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public protocol GPURenderEncoderBase: JSBridgedClass {}
public extension GPURenderEncoderBase {
    @inlinable func setPipeline(pipeline: GPURenderPipeline) {
        let this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [pipeline.jsValue])
    }

    @inlinable func setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.setIndexBuffer].function!(this: this, arguments: [buffer.jsValue, indexFormat.jsValue, offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined])
    }

    @inlinable func setVertexBuffer(slot: GPUIndex32, buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[Strings.setVertexBuffer].function!(this: this, arguments: [slot.jsValue, buffer.jsValue, offset?.jsValue ?? .undefined, size?.jsValue ?? .undefined])
    }

    @inlinable func draw(vertexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstVertex: GPUSize32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.draw].function!(this: this, arguments: [vertexCount.jsValue, instanceCount?.jsValue ?? .undefined, firstVertex?.jsValue ?? .undefined, firstInstance?.jsValue ?? .undefined])
    }

    @inlinable func drawIndexed(indexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstIndex: GPUSize32? = nil, baseVertex: GPUSignedOffset32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[Strings.drawIndexed].function!(this: this, arguments: [indexCount.jsValue, instanceCount?.jsValue ?? .undefined, firstIndex?.jsValue ?? .undefined, baseVertex?.jsValue ?? .undefined, firstInstance?.jsValue ?? .undefined])
    }

    @inlinable func drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.drawIndirect].function!(this: this, arguments: [indirectBuffer.jsValue, indirectOffset.jsValue])
    }

    @inlinable func drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[Strings.drawIndexedIndirect].function!(this: this, arguments: [indirectBuffer.jsValue, indirectOffset.jsValue])
    }
}

public class GPURenderPassColorAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, resolveTarget: GPUTextureView, clearValue: GPUColor, loadOp: GPULoadOp, storeOp: GPUStoreOp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = view.jsValue
        object[Strings.resolveTarget] = resolveTarget.jsValue
        object[Strings.clearValue] = clearValue.jsValue
        object[Strings.loadOp] = loadOp.jsValue
        object[Strings.storeOp] = storeOp.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: Strings.view)
        _resolveTarget = ReadWriteAttribute(jsObject: object, name: Strings.resolveTarget)
        _clearValue = ReadWriteAttribute(jsObject: object, name: Strings.clearValue)
        _loadOp = ReadWriteAttribute(jsObject: object, name: Strings.loadOp)
        _storeOp = ReadWriteAttribute(jsObject: object, name: Strings.storeOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var resolveTarget: GPUTextureView

    @ReadWriteAttribute
    public var clearValue: GPUColor

    @ReadWriteAttribute
    public var loadOp: GPULoadOp

    @ReadWriteAttribute
    public var storeOp: GPUStoreOp
}

public class GPURenderPassDepthStencilAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, depthClearValue: Float, depthLoadOp: GPULoadOp, depthStoreOp: GPUStoreOp, depthReadOnly: Bool, stencilClearValue: GPUStencilValue, stencilLoadOp: GPULoadOp, stencilStoreOp: GPUStoreOp, stencilReadOnly: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = view.jsValue
        object[Strings.depthClearValue] = depthClearValue.jsValue
        object[Strings.depthLoadOp] = depthLoadOp.jsValue
        object[Strings.depthStoreOp] = depthStoreOp.jsValue
        object[Strings.depthReadOnly] = depthReadOnly.jsValue
        object[Strings.stencilClearValue] = stencilClearValue.jsValue
        object[Strings.stencilLoadOp] = stencilLoadOp.jsValue
        object[Strings.stencilStoreOp] = stencilStoreOp.jsValue
        object[Strings.stencilReadOnly] = stencilReadOnly.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: Strings.view)
        _depthClearValue = ReadWriteAttribute(jsObject: object, name: Strings.depthClearValue)
        _depthLoadOp = ReadWriteAttribute(jsObject: object, name: Strings.depthLoadOp)
        _depthStoreOp = ReadWriteAttribute(jsObject: object, name: Strings.depthStoreOp)
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.depthReadOnly)
        _stencilClearValue = ReadWriteAttribute(jsObject: object, name: Strings.stencilClearValue)
        _stencilLoadOp = ReadWriteAttribute(jsObject: object, name: Strings.stencilLoadOp)
        _stencilStoreOp = ReadWriteAttribute(jsObject: object, name: Strings.stencilStoreOp)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: Strings.stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var depthClearValue: Float

    @ReadWriteAttribute
    public var depthLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var depthStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilClearValue: GPUStencilValue

    @ReadWriteAttribute
    public var stencilLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var stencilStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public class GPURenderPassDescriptor: BridgedDictionary {
    public convenience init(colorAttachments: [GPURenderPassColorAttachment?], depthStencilAttachment: GPURenderPassDepthStencilAttachment, occlusionQuerySet: GPUQuerySet, timestampWrites: GPURenderPassTimestampWrites) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorAttachments] = colorAttachments.jsValue
        object[Strings.depthStencilAttachment] = depthStencilAttachment.jsValue
        object[Strings.occlusionQuerySet] = occlusionQuerySet.jsValue
        object[Strings.timestampWrites] = timestampWrites.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorAttachments = ReadWriteAttribute(jsObject: object, name: Strings.colorAttachments)
        _depthStencilAttachment = ReadWriteAttribute(jsObject: object, name: Strings.depthStencilAttachment)
        _occlusionQuerySet = ReadWriteAttribute(jsObject: object, name: Strings.occlusionQuerySet)
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: Strings.timestampWrites)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorAttachments: [GPURenderPassColorAttachment?]

    @ReadWriteAttribute
    public var depthStencilAttachment: GPURenderPassDepthStencilAttachment

    @ReadWriteAttribute
    public var occlusionQuerySet: GPUQuerySet

    @ReadWriteAttribute
    public var timestampWrites: GPURenderPassTimestampWrites
}

public class GPURenderPassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUProgrammablePassEncoder, GPURenderEncoderBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPURenderPassEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setViewport(x: Float, y: Float, width: Float, height: Float, minDepth: Float, maxDepth: Float) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = minDepth.jsValue
        let _arg5 = maxDepth.jsValue
        let this = jsObject
        _ = this[Strings.setViewport].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable public func setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate) {
        let this = jsObject
        _ = this[Strings.setScissorRect].function!(this: this, arguments: [x.jsValue, y.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable public func setBlendConstant(color: GPUColor) {
        let this = jsObject
        _ = this[Strings.setBlendConstant].function!(this: this, arguments: [color.jsValue])
    }

    @inlinable public func setStencilReference(reference: GPUStencilValue) {
        let this = jsObject
        _ = this[Strings.setStencilReference].function!(this: this, arguments: [reference.jsValue])
    }

    @inlinable public func beginOcclusionQuery(queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[Strings.beginOcclusionQuery].function!(this: this, arguments: [queryIndex.jsValue])
    }

    @inlinable public func endOcclusionQuery() {
        let this = jsObject
        _ = this[Strings.endOcclusionQuery].function!(this: this, arguments: [])
    }

    @inlinable public func executeBundles(bundles: [GPURenderBundle]) {
        let this = jsObject
        _ = this[Strings.executeBundles].function!(this: this, arguments: [bundles.jsValue])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

public class GPURenderPassLayout: BridgedDictionary {
    public convenience init(colorFormats: [GPUTextureFormat?], depthStencilFormat: GPUTextureFormat, sampleCount: GPUSize32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorFormats] = colorFormats.jsValue
        object[Strings.depthStencilFormat] = depthStencilFormat.jsValue
        object[Strings.sampleCount] = sampleCount.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorFormats = ReadWriteAttribute(jsObject: object, name: Strings.colorFormats)
        _depthStencilFormat = ReadWriteAttribute(jsObject: object, name: Strings.depthStencilFormat)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: Strings.sampleCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorFormats: [GPUTextureFormat?]

    @ReadWriteAttribute
    public var depthStencilFormat: GPUTextureFormat

    @ReadWriteAttribute
    public var sampleCount: GPUSize32
}

public enum GPURenderPassTimestampLocation: JSString, JSValueCompatible {
    case beginning = "beginning"
    case end = "end"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPURenderPassTimestampWrite: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, queryIndex: GPUSize32, location: GPURenderPassTimestampLocation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = querySet.jsValue
        object[Strings.queryIndex] = queryIndex.jsValue
        object[Strings.location] = location.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: Strings.querySet)
        _queryIndex = ReadWriteAttribute(jsObject: object, name: Strings.queryIndex)
        _location = ReadWriteAttribute(jsObject: object, name: Strings.location)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var queryIndex: GPUSize32

    @ReadWriteAttribute
    public var location: GPURenderPassTimestampLocation
}

public class GPURenderPipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPURenderPipeline].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderPipelineDescriptor: BridgedDictionary {
    public convenience init(vertex: GPUVertexState, primitive: GPUPrimitiveState, depthStencil: GPUDepthStencilState, multisample: GPUMultisampleState, fragment: GPUFragmentState) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.vertex] = vertex.jsValue
        object[Strings.primitive] = primitive.jsValue
        object[Strings.depthStencil] = depthStencil.jsValue
        object[Strings.multisample] = multisample.jsValue
        object[Strings.fragment] = fragment.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _vertex = ReadWriteAttribute(jsObject: object, name: Strings.vertex)
        _primitive = ReadWriteAttribute(jsObject: object, name: Strings.primitive)
        _depthStencil = ReadWriteAttribute(jsObject: object, name: Strings.depthStencil)
        _multisample = ReadWriteAttribute(jsObject: object, name: Strings.multisample)
        _fragment = ReadWriteAttribute(jsObject: object, name: Strings.fragment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var vertex: GPUVertexState

    @ReadWriteAttribute
    public var primitive: GPUPrimitiveState

    @ReadWriteAttribute
    public var depthStencil: GPUDepthStencilState

    @ReadWriteAttribute
    public var multisample: GPUMultisampleState

    @ReadWriteAttribute
    public var fragment: GPUFragmentState
}

public class GPURequestAdapterOptions: BridgedDictionary {
    public convenience init(powerPreference: GPUPowerPreference, forceFallbackAdapter: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.powerPreference] = powerPreference.jsValue
        object[Strings.forceFallbackAdapter] = forceFallbackAdapter.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _powerPreference = ReadWriteAttribute(jsObject: object, name: Strings.powerPreference)
        _forceFallbackAdapter = ReadWriteAttribute(jsObject: object, name: Strings.forceFallbackAdapter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var powerPreference: GPUPowerPreference

    @ReadWriteAttribute
    public var forceFallbackAdapter: Bool
}

public class GPUSampler: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUSampler].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUSamplerBindingLayout: BridgedDictionary {
    public convenience init(type: GPUSamplerBindingType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUSamplerBindingType
}

public enum GPUSamplerBindingType: JSString, JSValueCompatible {
    case filtering = "filtering"
    case nonFiltering = "non-filtering"
    case comparison = "comparison"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSamplerDescriptor: BridgedDictionary {
    public convenience init(addressModeU: GPUAddressMode, addressModeV: GPUAddressMode, addressModeW: GPUAddressMode, magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUMipmapFilterMode, lodMinClamp: Float, lodMaxClamp: Float, compare: GPUCompareFunction, maxAnisotropy: UInt16) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.addressModeU] = addressModeU.jsValue
        object[Strings.addressModeV] = addressModeV.jsValue
        object[Strings.addressModeW] = addressModeW.jsValue
        object[Strings.magFilter] = magFilter.jsValue
        object[Strings.minFilter] = minFilter.jsValue
        object[Strings.mipmapFilter] = mipmapFilter.jsValue
        object[Strings.lodMinClamp] = lodMinClamp.jsValue
        object[Strings.lodMaxClamp] = lodMaxClamp.jsValue
        object[Strings.compare] = compare.jsValue
        object[Strings.maxAnisotropy] = maxAnisotropy.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _addressModeU = ReadWriteAttribute(jsObject: object, name: Strings.addressModeU)
        _addressModeV = ReadWriteAttribute(jsObject: object, name: Strings.addressModeV)
        _addressModeW = ReadWriteAttribute(jsObject: object, name: Strings.addressModeW)
        _magFilter = ReadWriteAttribute(jsObject: object, name: Strings.magFilter)
        _minFilter = ReadWriteAttribute(jsObject: object, name: Strings.minFilter)
        _mipmapFilter = ReadWriteAttribute(jsObject: object, name: Strings.mipmapFilter)
        _lodMinClamp = ReadWriteAttribute(jsObject: object, name: Strings.lodMinClamp)
        _lodMaxClamp = ReadWriteAttribute(jsObject: object, name: Strings.lodMaxClamp)
        _compare = ReadWriteAttribute(jsObject: object, name: Strings.compare)
        _maxAnisotropy = ReadWriteAttribute(jsObject: object, name: Strings.maxAnisotropy)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var addressModeU: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeV: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeW: GPUAddressMode

    @ReadWriteAttribute
    public var magFilter: GPUFilterMode

    @ReadWriteAttribute
    public var minFilter: GPUFilterMode

    @ReadWriteAttribute
    public var mipmapFilter: GPUMipmapFilterMode

    @ReadWriteAttribute
    public var lodMinClamp: Float

    @ReadWriteAttribute
    public var lodMaxClamp: Float

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var maxAnisotropy: UInt16
}

public class GPUShaderModule: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUShaderModule].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func compilationInfo() -> JSPromise {
        let this = jsObject
        return this[Strings.compilationInfo].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func compilationInfo() async throws -> GPUCompilationInfo {
        let this = jsObject
        let _promise: JSPromise = this[Strings.compilationInfo].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUShaderModuleCompilationHint: BridgedDictionary {
    public convenience init(layout: GPUPipelineLayout) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = layout.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUPipelineLayout
}

public class GPUShaderModuleDescriptor: BridgedDictionary {
    public convenience init(code: String, sourceMap: JSObject, hints: [String: GPUShaderModuleCompilationHint]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.code] = code.jsValue
        object[Strings.sourceMap] = sourceMap.jsValue
        object[Strings.hints] = hints.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _code = ReadWriteAttribute(jsObject: object, name: Strings.code)
        _sourceMap = ReadWriteAttribute(jsObject: object, name: Strings.sourceMap)
        _hints = ReadWriteAttribute(jsObject: object, name: Strings.hints)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var sourceMap: JSObject

    @ReadWriteAttribute
    public var hints: [String: GPUShaderModuleCompilationHint]
}

public enum GPUShaderStage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUShaderStage].object!
    }

    public static let VERTEX: GPUFlagsConstant = 0x1

    public static let FRAGMENT: GPUFlagsConstant = 0x2

    public static let COMPUTE: GPUFlagsConstant = 0x4
}

public class GPUStencilFaceState: BridgedDictionary {
    public convenience init(compare: GPUCompareFunction, failOp: GPUStencilOperation, depthFailOp: GPUStencilOperation, passOp: GPUStencilOperation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.compare] = compare.jsValue
        object[Strings.failOp] = failOp.jsValue
        object[Strings.depthFailOp] = depthFailOp.jsValue
        object[Strings.passOp] = passOp.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compare = ReadWriteAttribute(jsObject: object, name: Strings.compare)
        _failOp = ReadWriteAttribute(jsObject: object, name: Strings.failOp)
        _depthFailOp = ReadWriteAttribute(jsObject: object, name: Strings.depthFailOp)
        _passOp = ReadWriteAttribute(jsObject: object, name: Strings.passOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var failOp: GPUStencilOperation

    @ReadWriteAttribute
    public var depthFailOp: GPUStencilOperation

    @ReadWriteAttribute
    public var passOp: GPUStencilOperation
}

public enum GPUStencilOperation: JSString, JSValueCompatible {
    case keep = "keep"
    case zero = "zero"
    case replace = "replace"
    case invert = "invert"
    case incrementClamp = "increment-clamp"
    case decrementClamp = "decrement-clamp"
    case incrementWrap = "increment-wrap"
    case decrementWrap = "decrement-wrap"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUStorageTextureAccess: JSString, JSValueCompatible {
    case writeOnly = "write-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUStorageTextureBindingLayout: BridgedDictionary {
    public convenience init(access: GPUStorageTextureAccess, format: GPUTextureFormat, viewDimension: GPUTextureViewDimension) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.access] = access.jsValue
        object[Strings.format] = format.jsValue
        object[Strings.viewDimension] = viewDimension.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _access = ReadWriteAttribute(jsObject: object, name: Strings.access)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: Strings.viewDimension)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var access: GPUStorageTextureAccess

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension
}

public enum GPUStoreOp: JSString, JSValueCompatible {
    case store = "store"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSupportedFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUSupportedFeatures].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}

public class GPUSupportedLimits: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUSupportedLimits].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _maxTextureDimension1D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension1D)
        _maxTextureDimension2D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension2D)
        _maxTextureDimension3D = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureDimension3D)
        _maxTextureArrayLayers = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxTextureArrayLayers)
        _maxBindGroups = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxBindGroups)
        _maxDynamicUniformBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxDynamicUniformBuffersPerPipelineLayout)
        _maxDynamicStorageBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxDynamicStorageBuffersPerPipelineLayout)
        _maxSampledTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxSampledTexturesPerShaderStage)
        _maxSamplersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxSamplersPerShaderStage)
        _maxStorageBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageBuffersPerShaderStage)
        _maxStorageTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageTexturesPerShaderStage)
        _maxUniformBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxUniformBuffersPerShaderStage)
        _maxUniformBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxUniformBufferBindingSize)
        _maxStorageBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxStorageBufferBindingSize)
        _minUniformBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: Strings.minUniformBufferOffsetAlignment)
        _minStorageBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: Strings.minStorageBufferOffsetAlignment)
        _maxVertexBuffers = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexBuffers)
        _maxVertexAttributes = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexAttributes)
        _maxVertexBufferArrayStride = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxVertexBufferArrayStride)
        _maxInterStageShaderComponents = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxInterStageShaderComponents)
        _maxComputeWorkgroupStorageSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupStorageSize)
        _maxComputeInvocationsPerWorkgroup = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeInvocationsPerWorkgroup)
        _maxComputeWorkgroupSizeX = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeX)
        _maxComputeWorkgroupSizeY = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeY)
        _maxComputeWorkgroupSizeZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupSizeZ)
        _maxComputeWorkgroupsPerDimension = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxComputeWorkgroupsPerDimension)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var maxTextureDimension1D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension2D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension3D: UInt32

    @ReadonlyAttribute
    public var maxTextureArrayLayers: UInt32

    @ReadonlyAttribute
    public var maxBindGroups: UInt32

    @ReadonlyAttribute
    public var maxDynamicUniformBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxDynamicStorageBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxSampledTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxSamplersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var maxStorageBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var minUniformBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var minStorageBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var maxVertexBuffers: UInt32

    @ReadonlyAttribute
    public var maxVertexAttributes: UInt32

    @ReadonlyAttribute
    public var maxVertexBufferArrayStride: UInt32

    @ReadonlyAttribute
    public var maxInterStageShaderComponents: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupStorageSize: UInt32

    @ReadonlyAttribute
    public var maxComputeInvocationsPerWorkgroup: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeX: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeY: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeZ: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupsPerDimension: UInt32
}

public class GPUTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUTexture].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func createView(descriptor: GPUTextureViewDescriptor? = nil) -> GPUTextureView {
        let this = jsObject
        return this[Strings.createView].function!(this: this, arguments: [descriptor?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }
}

public enum GPUTextureAspect: JSString, JSValueCompatible {
    case all = "all"
    case stencilOnly = "stencil-only"
    case depthOnly = "depth-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUTextureBindingLayout: BridgedDictionary {
    public convenience init(sampleType: GPUTextureSampleType, viewDimension: GPUTextureViewDimension, multisampled: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.sampleType] = sampleType.jsValue
        object[Strings.viewDimension] = viewDimension.jsValue
        object[Strings.multisampled] = multisampled.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _sampleType = ReadWriteAttribute(jsObject: object, name: Strings.sampleType)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: Strings.viewDimension)
        _multisampled = ReadWriteAttribute(jsObject: object, name: Strings.multisampled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var sampleType: GPUTextureSampleType

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var multisampled: Bool
}

public class GPUTextureDescriptor: BridgedDictionary {
    public convenience init(size: GPUExtent3D, mipLevelCount: GPUIntegerCoordinate, sampleCount: GPUSize32, dimension: GPUTextureDimension, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.size] = size.jsValue
        object[Strings.mipLevelCount] = mipLevelCount.jsValue
        object[Strings.sampleCount] = sampleCount.jsValue
        object[Strings.dimension] = dimension.jsValue
        object[Strings.format] = format.jsValue
        object[Strings.usage] = usage.jsValue
        object[Strings.viewFormats] = viewFormats.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: Strings.size)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: Strings.mipLevelCount)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: Strings.sampleCount)
        _dimension = ReadWriteAttribute(jsObject: object, name: Strings.dimension)
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _usage = ReadWriteAttribute(jsObject: object, name: Strings.usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: Strings.viewFormats)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUExtent3D

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var sampleCount: GPUSize32

    @ReadWriteAttribute
    public var dimension: GPUTextureDimension

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]
}

public enum GPUTextureDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureFormat: JSString, JSValueCompatible {
    case r8unorm = "r8unorm"
    case r8snorm = "r8snorm"
    case r8uint = "r8uint"
    case r8sint = "r8sint"
    case r16uint = "r16uint"
    case r16sint = "r16sint"
    case r16float = "r16float"
    case rg8unorm = "rg8unorm"
    case rg8snorm = "rg8snorm"
    case rg8uint = "rg8uint"
    case rg8sint = "rg8sint"
    case r32uint = "r32uint"
    case r32sint = "r32sint"
    case r32float = "r32float"
    case rg16uint = "rg16uint"
    case rg16sint = "rg16sint"
    case rg16float = "rg16float"
    case rgba8unorm = "rgba8unorm"
    case rgba8unormSrgb = "rgba8unorm-srgb"
    case rgba8snorm = "rgba8snorm"
    case rgba8uint = "rgba8uint"
    case rgba8sint = "rgba8sint"
    case bgra8unorm = "bgra8unorm"
    case bgra8unormSrgb = "bgra8unorm-srgb"
    case rgb9e5ufloat = "rgb9e5ufloat"
    case rgb10a2unorm = "rgb10a2unorm"
    case rg11b10ufloat = "rg11b10ufloat"
    case rg32uint = "rg32uint"
    case rg32sint = "rg32sint"
    case rg32float = "rg32float"
    case rgba16uint = "rgba16uint"
    case rgba16sint = "rgba16sint"
    case rgba16float = "rgba16float"
    case rgba32uint = "rgba32uint"
    case rgba32sint = "rgba32sint"
    case rgba32float = "rgba32float"
    case stencil8 = "stencil8"
    case depth16unorm = "depth16unorm"
    case depth24plus = "depth24plus"
    case depth24plusStencil8 = "depth24plus-stencil8"
    case depth32float = "depth32float"
    case depth24unormStencil8 = "depth24unorm-stencil8"
    case depth32floatStencil8 = "depth32float-stencil8"
    case bc1RgbaUnorm = "bc1-rgba-unorm"
    case bc1RgbaUnormSrgb = "bc1-rgba-unorm-srgb"
    case bc2RgbaUnorm = "bc2-rgba-unorm"
    case bc2RgbaUnormSrgb = "bc2-rgba-unorm-srgb"
    case bc3RgbaUnorm = "bc3-rgba-unorm"
    case bc3RgbaUnormSrgb = "bc3-rgba-unorm-srgb"
    case bc4RUnorm = "bc4-r-unorm"
    case bc4RSnorm = "bc4-r-snorm"
    case bc5RgUnorm = "bc5-rg-unorm"
    case bc5RgSnorm = "bc5-rg-snorm"
    case bc6hRgbUfloat = "bc6h-rgb-ufloat"
    case bc6hRgbFloat = "bc6h-rgb-float"
    case bc7RgbaUnorm = "bc7-rgba-unorm"
    case bc7RgbaUnormSrgb = "bc7-rgba-unorm-srgb"
    case etc2Rgb8unorm = "etc2-rgb8unorm"
    case etc2Rgb8unormSrgb = "etc2-rgb8unorm-srgb"
    case etc2Rgb8a1unorm = "etc2-rgb8a1unorm"
    case etc2Rgb8a1unormSrgb = "etc2-rgb8a1unorm-srgb"
    case etc2Rgba8unorm = "etc2-rgba8unorm"
    case etc2Rgba8unormSrgb = "etc2-rgba8unorm-srgb"
    case eacR11unorm = "eac-r11unorm"
    case eacR11snorm = "eac-r11snorm"
    case eacRg11unorm = "eac-rg11unorm"
    case eacRg11snorm = "eac-rg11snorm"
    case astc4x4Unorm = "astc-4x4-unorm"
    case astc4x4UnormSrgb = "astc-4x4-unorm-srgb"
    case astc5x4Unorm = "astc-5x4-unorm"
    case astc5x4UnormSrgb = "astc-5x4-unorm-srgb"
    case astc5x5Unorm = "astc-5x5-unorm"
    case astc5x5UnormSrgb = "astc-5x5-unorm-srgb"
    case astc6x5Unorm = "astc-6x5-unorm"
    case astc6x5UnormSrgb = "astc-6x5-unorm-srgb"
    case astc6x6Unorm = "astc-6x6-unorm"
    case astc6x6UnormSrgb = "astc-6x6-unorm-srgb"
    case astc8x5Unorm = "astc-8x5-unorm"
    case astc8x5UnormSrgb = "astc-8x5-unorm-srgb"
    case astc8x6Unorm = "astc-8x6-unorm"
    case astc8x6UnormSrgb = "astc-8x6-unorm-srgb"
    case astc8x8Unorm = "astc-8x8-unorm"
    case astc8x8UnormSrgb = "astc-8x8-unorm-srgb"
    case astc10x5Unorm = "astc-10x5-unorm"
    case astc10x5UnormSrgb = "astc-10x5-unorm-srgb"
    case astc10x6Unorm = "astc-10x6-unorm"
    case astc10x6UnormSrgb = "astc-10x6-unorm-srgb"
    case astc10x8Unorm = "astc-10x8-unorm"
    case astc10x8UnormSrgb = "astc-10x8-unorm-srgb"
    case astc10x10Unorm = "astc-10x10-unorm"
    case astc10x10UnormSrgb = "astc-10x10-unorm-srgb"
    case astc12x10Unorm = "astc-12x10-unorm"
    case astc12x10UnormSrgb = "astc-12x10-unorm-srgb"
    case astc12x12Unorm = "astc-12x12-unorm"
    case astc12x12UnormSrgb = "astc-12x12-unorm-srgb"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureSampleType: JSString, JSValueCompatible {
    case float = "float"
    case unfilterableFloat = "unfilterable-float"
    case depth = "depth"
    case sint = "sint"
    case uint = "uint"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.GPUTextureUsage].object!
    }

    public static let COPY_SRC: GPUFlagsConstant = 0x01

    public static let COPY_DST: GPUFlagsConstant = 0x02

    public static let TEXTURE_BINDING: GPUFlagsConstant = 0x04

    public static let STORAGE_BINDING: GPUFlagsConstant = 0x08

    public static let RENDER_ATTACHMENT: GPUFlagsConstant = 0x10
}

public class GPUTextureView: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUTextureView].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUTextureViewDescriptor: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, dimension: GPUTextureViewDimension, aspect: GPUTextureAspect, baseMipLevel: GPUIntegerCoordinate, mipLevelCount: GPUIntegerCoordinate, baseArrayLayer: GPUIntegerCoordinate, arrayLayerCount: GPUIntegerCoordinate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.dimension] = dimension.jsValue
        object[Strings.aspect] = aspect.jsValue
        object[Strings.baseMipLevel] = baseMipLevel.jsValue
        object[Strings.mipLevelCount] = mipLevelCount.jsValue
        object[Strings.baseArrayLayer] = baseArrayLayer.jsValue
        object[Strings.arrayLayerCount] = arrayLayerCount.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _dimension = ReadWriteAttribute(jsObject: object, name: Strings.dimension)
        _aspect = ReadWriteAttribute(jsObject: object, name: Strings.aspect)
        _baseMipLevel = ReadWriteAttribute(jsObject: object, name: Strings.baseMipLevel)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: Strings.mipLevelCount)
        _baseArrayLayer = ReadWriteAttribute(jsObject: object, name: Strings.baseArrayLayer)
        _arrayLayerCount = ReadWriteAttribute(jsObject: object, name: Strings.arrayLayerCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var dimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect

    @ReadWriteAttribute
    public var baseMipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var baseArrayLayer: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var arrayLayerCount: GPUIntegerCoordinate
}

public enum GPUTextureViewDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _2dArray = "2d-array"
    case cube = "cube"
    case cubeArray = "cube-array"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUUncapturedErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.GPUUncapturedErrorEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, gpuUncapturedErrorEventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var error: GPUError
}

public class GPUUncapturedErrorEventInit: BridgedDictionary {
    public convenience init(error: GPUError) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.error] = error.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _error = ReadWriteAttribute(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var error: GPUError
}

public class GPUValidationError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.GPUValidationError].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [message.jsValue]))
    }

    @ReadonlyAttribute
    public var message: String
}

public class GPUVertexAttribute: BridgedDictionary {
    public convenience init(format: GPUVertexFormat, offset: GPUSize64, shaderLocation: GPUIndex32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.offset] = offset.jsValue
        object[Strings.shaderLocation] = shaderLocation.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _shaderLocation = ReadWriteAttribute(jsObject: object, name: Strings.shaderLocation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUVertexFormat

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var shaderLocation: GPUIndex32
}

public class GPUVertexBufferLayout: BridgedDictionary {
    public convenience init(arrayStride: GPUSize64, stepMode: GPUVertexStepMode, attributes: [GPUVertexAttribute]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.arrayStride] = arrayStride.jsValue
        object[Strings.stepMode] = stepMode.jsValue
        object[Strings.attributes] = attributes.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _arrayStride = ReadWriteAttribute(jsObject: object, name: Strings.arrayStride)
        _stepMode = ReadWriteAttribute(jsObject: object, name: Strings.stepMode)
        _attributes = ReadWriteAttribute(jsObject: object, name: Strings.attributes)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var arrayStride: GPUSize64

    @ReadWriteAttribute
    public var stepMode: GPUVertexStepMode

    @ReadWriteAttribute
    public var attributes: [GPUVertexAttribute]
}

public enum GPUVertexFormat: JSString, JSValueCompatible {
    case uint8x2 = "uint8x2"
    case uint8x4 = "uint8x4"
    case sint8x2 = "sint8x2"
    case sint8x4 = "sint8x4"
    case unorm8x2 = "unorm8x2"
    case unorm8x4 = "unorm8x4"
    case snorm8x2 = "snorm8x2"
    case snorm8x4 = "snorm8x4"
    case uint16x2 = "uint16x2"
    case uint16x4 = "uint16x4"
    case sint16x2 = "sint16x2"
    case sint16x4 = "sint16x4"
    case unorm16x2 = "unorm16x2"
    case unorm16x4 = "unorm16x4"
    case snorm16x2 = "snorm16x2"
    case snorm16x4 = "snorm16x4"
    case float16x2 = "float16x2"
    case float16x4 = "float16x4"
    case float32 = "float32"
    case float32x2 = "float32x2"
    case float32x3 = "float32x3"
    case float32x4 = "float32x4"
    case uint32 = "uint32"
    case uint32x2 = "uint32x2"
    case uint32x3 = "uint32x3"
    case uint32x4 = "uint32x4"
    case sint32 = "sint32"
    case sint32x2 = "sint32x2"
    case sint32x3 = "sint32x3"
    case sint32x4 = "sint32x4"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUVertexState: BridgedDictionary {
    public convenience init(buffers: [GPUVertexBufferLayout?]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffers] = buffers.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffers = ReadWriteAttribute(jsObject: object, name: Strings.buffers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffers: [GPUVertexBufferLayout?]
}

public enum GPUVertexStepMode: JSString, JSValueCompatible {
    case vertex = "vertex"
    case instance = "instance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GainNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.GainNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _gain = ReadonlyAttribute(jsObject: jsObject, name: Strings.gain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: GainOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var gain: AudioParam
}

public class GainOptions: BridgedDictionary {
    public convenience init(gain: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.gain] = gain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _gain = ReadWriteAttribute(jsObject: object, name: Strings.gain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var gain: Float
}

public protocol GenericTransformStream: JSBridgedClass {}
public extension GenericTransformStream {
    @inlinable var readable: ReadableStream { ReadonlyAttribute[Strings.readable, in: jsObject] }

    @inlinable var writable: WritableStream { ReadonlyAttribute[Strings.writable, in: jsObject] }
}

public protocol GeometryUtils: JSBridgedClass {}
public extension GeometryUtils {
    @inlinable func getBoxQuads(options: BoxQuadOptions? = nil) -> [DOMQuad] {
        let this = jsObject
        return this[Strings.getBoxQuads].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func convertQuadFromNode(quad: DOMQuadInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[Strings.convertQuadFromNode].function!(this: this, arguments: [quad.jsValue, from.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func convertRectFromNode(rect: DOMRectReadOnly, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[Strings.convertRectFromNode].function!(this: this, arguments: [rect.jsValue, from.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable func convertPointFromNode(point: DOMPointInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMPoint {
        let this = jsObject
        return this[Strings.convertPointFromNode].function!(this: this, arguments: [point.jsValue, from.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class GetAnimationsOptions: BridgedDictionary {
    public convenience init(subtree: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.subtree] = subtree.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _subtree = ReadWriteAttribute(jsObject: object, name: Strings.subtree)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var subtree: Bool
}

public class GetRootNodeOptions: BridgedDictionary {
    public convenience init(composed: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.composed] = composed.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _composed = ReadWriteAttribute(jsObject: object, name: Strings.composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var composed: Bool
}

public protocol GlobalEventHandlers: JSBridgedClass {}
public extension GlobalEventHandlers {
    @inlinable var onabort: EventHandler {
        get { ClosureAttribute1Optional[Strings.onabort, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onabort, in: jsObject] = newValue }
    }

    @inlinable var onauxclick: EventHandler {
        get { ClosureAttribute1Optional[Strings.onauxclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onauxclick, in: jsObject] = newValue }
    }

    @inlinable var onblur: EventHandler {
        get { ClosureAttribute1Optional[Strings.onblur, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onblur, in: jsObject] = newValue }
    }

    @inlinable var oncancel: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncancel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncancel, in: jsObject] = newValue }
    }

    @inlinable var oncanplay: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncanplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncanplay, in: jsObject] = newValue }
    }

    @inlinable var oncanplaythrough: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncanplaythrough, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncanplaythrough, in: jsObject] = newValue }
    }

    @inlinable var onchange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onchange, in: jsObject] = newValue }
    }

    @inlinable var onclick: EventHandler {
        get { ClosureAttribute1Optional[Strings.onclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onclick, in: jsObject] = newValue }
    }

    @inlinable var onclose: EventHandler {
        get { ClosureAttribute1Optional[Strings.onclose, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onclose, in: jsObject] = newValue }
    }

    @inlinable var oncontextlost: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncontextlost, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncontextlost, in: jsObject] = newValue }
    }

    @inlinable var oncontextmenu: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncontextmenu, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncontextmenu, in: jsObject] = newValue }
    }

    @inlinable var oncontextrestored: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncontextrestored, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncontextrestored, in: jsObject] = newValue }
    }

    @inlinable var oncuechange: EventHandler {
        get { ClosureAttribute1Optional[Strings.oncuechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oncuechange, in: jsObject] = newValue }
    }

    @inlinable var ondblclick: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondblclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondblclick, in: jsObject] = newValue }
    }

    @inlinable var ondrag: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondrag, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondrag, in: jsObject] = newValue }
    }

    @inlinable var ondragend: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondragend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondragend, in: jsObject] = newValue }
    }

    @inlinable var ondragenter: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondragenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondragenter, in: jsObject] = newValue }
    }

    @inlinable var ondragleave: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondragleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondragleave, in: jsObject] = newValue }
    }

    @inlinable var ondragover: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondragover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondragover, in: jsObject] = newValue }
    }

    @inlinable var ondragstart: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondragstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondragstart, in: jsObject] = newValue }
    }

    @inlinable var ondrop: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondrop, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondrop, in: jsObject] = newValue }
    }

    @inlinable var ondurationchange: EventHandler {
        get { ClosureAttribute1Optional[Strings.ondurationchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ondurationchange, in: jsObject] = newValue }
    }

    @inlinable var onemptied: EventHandler {
        get { ClosureAttribute1Optional[Strings.onemptied, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onemptied, in: jsObject] = newValue }
    }

    @inlinable var onended: EventHandler {
        get { ClosureAttribute1Optional[Strings.onended, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onended, in: jsObject] = newValue }
    }

    @inlinable var onerror: OnErrorEventHandler {
        get { ClosureAttribute5Optional[Strings.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute5Optional[Strings.onerror, in: jsObject] = newValue }
    }

    @inlinable var onfocus: EventHandler {
        get { ClosureAttribute1Optional[Strings.onfocus, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onfocus, in: jsObject] = newValue }
    }

    @inlinable var onformdata: EventHandler {
        get { ClosureAttribute1Optional[Strings.onformdata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onformdata, in: jsObject] = newValue }
    }

    @inlinable var oninput: EventHandler {
        get { ClosureAttribute1Optional[Strings.oninput, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oninput, in: jsObject] = newValue }
    }

    @inlinable var oninvalid: EventHandler {
        get { ClosureAttribute1Optional[Strings.oninvalid, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.oninvalid, in: jsObject] = newValue }
    }

    @inlinable var onkeydown: EventHandler {
        get { ClosureAttribute1Optional[Strings.onkeydown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onkeydown, in: jsObject] = newValue }
    }

    @inlinable var onkeypress: EventHandler {
        get { ClosureAttribute1Optional[Strings.onkeypress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onkeypress, in: jsObject] = newValue }
    }

    @inlinable var onkeyup: EventHandler {
        get { ClosureAttribute1Optional[Strings.onkeyup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onkeyup, in: jsObject] = newValue }
    }

    @inlinable var onload: EventHandler {
        get { ClosureAttribute1Optional[Strings.onload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onload, in: jsObject] = newValue }
    }

    @inlinable var onloadeddata: EventHandler {
        get { ClosureAttribute1Optional[Strings.onloadeddata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onloadeddata, in: jsObject] = newValue }
    }

    @inlinable var onloadedmetadata: EventHandler {
        get { ClosureAttribute1Optional[Strings.onloadedmetadata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onloadedmetadata, in: jsObject] = newValue }
    }

    @inlinable var onloadstart: EventHandler {
        get { ClosureAttribute1Optional[Strings.onloadstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onloadstart, in: jsObject] = newValue }
    }

    @inlinable var onmousedown: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmousedown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmousedown, in: jsObject] = newValue }
    }

    @inlinable var onmouseenter: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmouseenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmouseenter, in: jsObject] = newValue }
    }

    @inlinable var onmouseleave: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmouseleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmouseleave, in: jsObject] = newValue }
    }

    @inlinable var onmousemove: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmousemove, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmousemove, in: jsObject] = newValue }
    }

    @inlinable var onmouseout: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmouseout, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmouseout, in: jsObject] = newValue }
    }

    @inlinable var onmouseover: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmouseover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmouseover, in: jsObject] = newValue }
    }

    @inlinable var onmouseup: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmouseup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmouseup, in: jsObject] = newValue }
    }

    @inlinable var onpause: EventHandler {
        get { ClosureAttribute1Optional[Strings.onpause, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onpause, in: jsObject] = newValue }
    }

    @inlinable var onplay: EventHandler {
        get { ClosureAttribute1Optional[Strings.onplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onplay, in: jsObject] = newValue }
    }

    @inlinable var onplaying: EventHandler {
        get { ClosureAttribute1Optional[Strings.onplaying, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onplaying, in: jsObject] = newValue }
    }

    @inlinable var onprogress: EventHandler {
        get { ClosureAttribute1Optional[Strings.onprogress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onprogress, in: jsObject] = newValue }
    }

    @inlinable var onratechange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onratechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onratechange, in: jsObject] = newValue }
    }

    @inlinable var onreset: EventHandler {
        get { ClosureAttribute1Optional[Strings.onreset, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onreset, in: jsObject] = newValue }
    }

    @inlinable var onresize: EventHandler {
        get { ClosureAttribute1Optional[Strings.onresize, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onresize, in: jsObject] = newValue }
    }

    @inlinable var onscroll: EventHandler {
        get { ClosureAttribute1Optional[Strings.onscroll, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onscroll, in: jsObject] = newValue }
    }

    @inlinable var onsecuritypolicyviolation: EventHandler {
        get { ClosureAttribute1Optional[Strings.onsecuritypolicyviolation, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onsecuritypolicyviolation, in: jsObject] = newValue }
    }

    @inlinable var onseeked: EventHandler {
        get { ClosureAttribute1Optional[Strings.onseeked, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onseeked, in: jsObject] = newValue }
    }

    @inlinable var onseeking: EventHandler {
        get { ClosureAttribute1Optional[Strings.onseeking, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onseeking, in: jsObject] = newValue }
    }

    @inlinable var onselect: EventHandler {
        get { ClosureAttribute1Optional[Strings.onselect, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onselect, in: jsObject] = newValue }
    }

    @inlinable var onslotchange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onslotchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onslotchange, in: jsObject] = newValue }
    }

    @inlinable var onstalled: EventHandler {
        get { ClosureAttribute1Optional[Strings.onstalled, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onstalled, in: jsObject] = newValue }
    }

    @inlinable var onsubmit: EventHandler {
        get { ClosureAttribute1Optional[Strings.onsubmit, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onsubmit, in: jsObject] = newValue }
    }

    @inlinable var onsuspend: EventHandler {
        get { ClosureAttribute1Optional[Strings.onsuspend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onsuspend, in: jsObject] = newValue }
    }

    @inlinable var ontimeupdate: EventHandler {
        get { ClosureAttribute1Optional[Strings.ontimeupdate, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ontimeupdate, in: jsObject] = newValue }
    }

    @inlinable var ontoggle: EventHandler {
        get { ClosureAttribute1Optional[Strings.ontoggle, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ontoggle, in: jsObject] = newValue }
    }

    @inlinable var onvolumechange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onvolumechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onvolumechange, in: jsObject] = newValue }
    }

    @inlinable var onwaiting: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwaiting, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwaiting, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationend: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwebkitanimationend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwebkitanimationend, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationiteration: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwebkitanimationiteration, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwebkitanimationiteration, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationstart: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwebkitanimationstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwebkitanimationstart, in: jsObject] = newValue }
    }

    @inlinable var onwebkittransitionend: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwebkittransitionend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwebkittransitionend, in: jsObject] = newValue }
    }

    @inlinable var onwheel: EventHandler {
        get { ClosureAttribute1Optional[Strings.onwheel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onwheel, in: jsObject] = newValue }
    }
}

public class HTMLAllCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.HTMLAllCollection].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_HTMLCollection? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(nameOrIndex: String? = nil) -> Element_or_HTMLCollection? {
        let this = jsObject
        return this[Strings.item].function!(this: this, arguments: [nameOrIndex?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class HTMLAnchorElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLAnchorElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: Strings.download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: Strings.ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: Strings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: Strings.relList)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: Strings.hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _text = ReadWriteAttribute(jsObject: jsObject, name: Strings.text)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: Strings.coords)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: Strings.charset)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: Strings.rev)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: Strings.shape)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var shape: String
}

public class HTMLAreaElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLAreaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: Strings.alt)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: Strings.coords)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: Strings.shape)
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: Strings.download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: Strings.ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: Strings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: Strings.relList)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _noHref = ReadWriteAttribute(jsObject: jsObject, name: Strings.noHref)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var shape: String

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var noHref: Bool
}

public class HTMLAudioElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLAudioElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLBRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLBRElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _clear = ReadWriteAttribute(jsObject: jsObject, name: Strings.clear)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var clear: String
}

public class HTMLBaseElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLBaseElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: Strings.href)
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLBodyElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLBodyElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: Strings.text)
        _link = ReadWriteAttribute(jsObject: jsObject, name: Strings.link)
        _vLink = ReadWriteAttribute(jsObject: jsObject, name: Strings.vLink)
        _aLink = ReadWriteAttribute(jsObject: jsObject, name: Strings.aLink)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        _background = ReadWriteAttribute(jsObject: jsObject, name: Strings.background)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var link: String

    @ReadWriteAttribute
    public var vLink: String

    @ReadWriteAttribute
    public var aLink: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var background: String
}

public class HTMLButtonElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLButtonElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: Strings.formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: Strings.formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: Strings.formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: Strings.formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: Strings.formTarget)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLCanvasElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLCanvasElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @inlinable public func getContext(contextId: String, options: JSValue? = nil) -> RenderingContext? {
        let this = jsObject
        return this[Strings.getContext].function!(this: this, arguments: [contextId.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func toDataURL(type: String? = nil, quality: JSValue? = nil) -> String {
        let this = jsObject
        return this[Strings.toDataURL].function!(this: this, arguments: [type?.jsValue ?? .undefined, quality?.jsValue ?? .undefined]).fromJSValue()!
    }

    // XXX: member 'toBlob' is ignored

    @inlinable public func transferControlToOffscreen() -> OffscreenCanvas {
        let this = jsObject
        return this[Strings.transferControlToOffscreen].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.HTMLCollection].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Element? {
        jsObject[key].fromJSValue()
    }
}

public class HTMLDListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: Strings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDataElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDataElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: String
}

public class HTMLDataListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDataListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _options = ReadonlyAttribute(jsObject: jsObject, name: Strings.options)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var options: HTMLCollection
}

public class HTMLDetailsElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDetailsElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: Strings.open)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool
}

public class HTMLDialogElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDialogElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: Strings.open)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.returnValue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool

    @ReadWriteAttribute
    public var returnValue: String

    @inlinable public func show() {
        let this = jsObject
        _ = this[Strings.show].function!(this: this, arguments: [])
    }

    @inlinable public func showModal() {
        let this = jsObject
        _ = this[Strings.showModal].function!(this: this, arguments: [])
    }

    @inlinable public func close(returnValue: String? = nil) {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [returnValue?.jsValue ?? .undefined])
    }
}

public class HTMLDirectoryElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDirectoryElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: Strings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDivElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLDivElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLElement: Element, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable, HTMLOrSVGElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _title = ReadWriteAttribute(jsObject: jsObject, name: Strings.title)
        _lang = ReadWriteAttribute(jsObject: jsObject, name: Strings.lang)
        _translate = ReadWriteAttribute(jsObject: jsObject, name: Strings.translate)
        _dir = ReadWriteAttribute(jsObject: jsObject, name: Strings.dir)
        _hidden = ReadWriteAttribute(jsObject: jsObject, name: Strings.hidden)
        _inert = ReadWriteAttribute(jsObject: jsObject, name: Strings.inert)
        _accessKey = ReadWriteAttribute(jsObject: jsObject, name: Strings.accessKey)
        _accessKeyLabel = ReadonlyAttribute(jsObject: jsObject, name: Strings.accessKeyLabel)
        _draggable = ReadWriteAttribute(jsObject: jsObject, name: Strings.draggable)
        _spellcheck = ReadWriteAttribute(jsObject: jsObject, name: Strings.spellcheck)
        _autocapitalize = ReadWriteAttribute(jsObject: jsObject, name: Strings.autocapitalize)
        _innerText = ReadWriteAttribute(jsObject: jsObject, name: Strings.innerText)
        _outerText = ReadWriteAttribute(jsObject: jsObject, name: Strings.outerText)
        _offsetParent = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetParent)
        _offsetTop = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetTop)
        _offsetLeft = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetLeft)
        _offsetWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetWidth)
        _offsetHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetHeight)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var title: String

    @ReadWriteAttribute
    public var lang: String

    @ReadWriteAttribute
    public var translate: Bool

    @ReadWriteAttribute
    public var dir: String

    @ReadWriteAttribute
    public var hidden: Bool

    @ReadWriteAttribute
    public var inert: Bool

    @inlinable public func click() {
        let this = jsObject
        _ = this[Strings.click].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var accessKey: String

    @ReadonlyAttribute
    public var accessKeyLabel: String

    @ReadWriteAttribute
    public var draggable: Bool

    @ReadWriteAttribute
    public var spellcheck: Bool

    @ReadWriteAttribute
    public var autocapitalize: String

    @ReadWriteAttribute
    public var innerText: String

    @ReadWriteAttribute
    public var outerText: String

    @inlinable public func attachInternals() -> ElementInternals {
        let this = jsObject
        return this[Strings.attachInternals].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var offsetParent: Element?

    @ReadonlyAttribute
    public var offsetTop: Int32

    @ReadonlyAttribute
    public var offsetLeft: Int32

    @ReadonlyAttribute
    public var offsetWidth: Int32

    @ReadonlyAttribute
    public var offsetHeight: Int32
}

public class HTMLEmbedElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLEmbedElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var name: String
}

public class HTMLFieldSetElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFieldSetElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: Strings.elements)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var elements: HTMLCollection

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }
}

public class HTMLFontElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFontElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _color = ReadWriteAttribute(jsObject: jsObject, name: Strings.color)
        _face = ReadWriteAttribute(jsObject: jsObject, name: Strings.face)
        _size = ReadWriteAttribute(jsObject: jsObject, name: Strings.size)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var face: String

    @ReadWriteAttribute
    public var size: String
}

public class HTMLFormControlsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFormControlsCollection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList? {
        jsObject[key].fromJSValue()
    }
}

public class HTMLFormElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFormElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _acceptCharset = ReadWriteAttribute(jsObject: jsObject, name: Strings.acceptCharset)
        _action = ReadWriteAttribute(jsObject: jsObject, name: Strings.action)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: Strings.autocomplete)
        _enctype = ReadWriteAttribute(jsObject: jsObject, name: Strings.enctype)
        _encoding = ReadWriteAttribute(jsObject: jsObject, name: Strings.encoding)
        _method = ReadWriteAttribute(jsObject: jsObject, name: Strings.method)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _noValidate = ReadWriteAttribute(jsObject: jsObject, name: Strings.noValidate)
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: Strings.rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: Strings.relList)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: Strings.elements)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var acceptCharset: String

    @ReadWriteAttribute
    public var action: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var enctype: String

    @ReadWriteAttribute
    public var encoding: String

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var noValidate: Bool

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadonlyAttribute
    public var elements: HTMLFormControlsCollection

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func submit() {
        let this = jsObject
        _ = this[Strings.submit].function!(this: this, arguments: [])
    }

    @inlinable public func requestSubmit(submitter: HTMLElement? = nil) {
        let this = jsObject
        _ = this[Strings.requestSubmit].function!(this: this, arguments: [submitter?.jsValue ?? .undefined])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFrameElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrolling)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: Strings.frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: Strings.longDesc)
        _noResize = ReadWriteAttribute(jsObject: jsObject, name: Strings.noResize)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentWindow)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: Strings.marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: Strings.marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var noResize: Bool

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLFrameSetElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLFrameSetElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cols = ReadWriteAttribute(jsObject: jsObject, name: Strings.cols)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: Strings.rows)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cols: String

    @ReadWriteAttribute
    public var rows: String
}

public class HTMLHRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLHRElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _color = ReadWriteAttribute(jsObject: jsObject, name: Strings.color)
        _noShade = ReadWriteAttribute(jsObject: jsObject, name: Strings.noShade)
        _size = ReadWriteAttribute(jsObject: jsObject, name: Strings.size)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var noShade: Bool

    @ReadWriteAttribute
    public var size: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLHeadElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLHeadElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLHeadingElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLHeadingElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLHtmlElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLHtmlElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _version = ReadWriteAttribute(jsObject: jsObject, name: Strings.version)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var version: String
}

public protocol HTMLHyperlinkElementUtils: JSBridgedClass {}
public extension HTMLHyperlinkElementUtils {
    @inlinable var href: String {
        get { ReadWriteAttribute[Strings.href, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.href, in: jsObject] = newValue }
    }

    @inlinable var origin: String { ReadonlyAttribute[Strings.origin, in: jsObject] }

    @inlinable var `protocol`: String {
        get { ReadWriteAttribute[Strings.protocol, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.protocol, in: jsObject] = newValue }
    }

    @inlinable var username: String {
        get { ReadWriteAttribute[Strings.username, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.username, in: jsObject] = newValue }
    }

    @inlinable var password: String {
        get { ReadWriteAttribute[Strings.password, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.password, in: jsObject] = newValue }
    }

    @inlinable var host: String {
        get { ReadWriteAttribute[Strings.host, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.host, in: jsObject] = newValue }
    }

    @inlinable var hostname: String {
        get { ReadWriteAttribute[Strings.hostname, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.hostname, in: jsObject] = newValue }
    }

    @inlinable var port: String {
        get { ReadWriteAttribute[Strings.port, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.port, in: jsObject] = newValue }
    }

    @inlinable var pathname: String {
        get { ReadWriteAttribute[Strings.pathname, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.pathname, in: jsObject] = newValue }
    }

    @inlinable var search: String {
        get { ReadWriteAttribute[Strings.search, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.search, in: jsObject] = newValue }
    }

    @inlinable var hash: String {
        get { ReadWriteAttribute[Strings.hash, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.hash, in: jsObject] = newValue }
    }
}

public class HTMLIFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLIFrameElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _srcdoc = ReadWriteAttribute(jsObject: jsObject, name: Strings.srcdoc)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _sandbox = ReadonlyAttribute(jsObject: jsObject, name: Strings.sandbox)
        _allow = ReadWriteAttribute(jsObject: jsObject, name: Strings.allow)
        _allowFullscreen = ReadWriteAttribute(jsObject: jsObject, name: Strings.allowFullscreen)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: Strings.loading)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentWindow)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrolling)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: Strings.frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: Strings.longDesc)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: Strings.marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: Strings.marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcdoc: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var sandbox: DOMTokenList

    @ReadWriteAttribute
    public var allow: String

    @ReadWriteAttribute
    public var allowFullscreen: Bool

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var loading: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLImageElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLImageElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: Strings.alt)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: Strings.srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: Strings.sizes)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Strings.crossOrigin)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: Strings.useMap)
        _isMap = ReadWriteAttribute(jsObject: jsObject, name: Strings.isMap)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _naturalWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.naturalWidth)
        _naturalHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.naturalHeight)
        _complete = ReadonlyAttribute(jsObject: jsObject, name: Strings.complete)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentSrc)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _decoding = ReadWriteAttribute(jsObject: jsObject, name: Strings.decoding)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: Strings.loading)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _lowsrc = ReadWriteAttribute(jsObject: jsObject, name: Strings.lowsrc)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.hspace)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.vspace)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: Strings.longDesc)
        _border = ReadWriteAttribute(jsObject: jsObject, name: Strings.border)
        _x = ReadonlyAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: Strings.y)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var isMap: Bool

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var naturalWidth: UInt32

    @ReadonlyAttribute
    public var naturalHeight: UInt32

    @ReadonlyAttribute
    public var complete: Bool

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var decoding: String

    @ReadWriteAttribute
    public var loading: String

    @inlinable public func decode() -> JSPromise {
        let this = jsObject
        return this[Strings.decode].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decode() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.decode].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var lowsrc: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var border: String

    @ReadonlyAttribute
    public var x: Int32

    @ReadonlyAttribute
    public var y: Int32
}

public class HTMLInputElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLInputElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _accept = ReadWriteAttribute(jsObject: jsObject, name: Strings.accept)
        _alt = ReadWriteAttribute(jsObject: jsObject, name: Strings.alt)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: Strings.autocomplete)
        _defaultChecked = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultChecked)
        _checked = ReadWriteAttribute(jsObject: jsObject, name: Strings.checked)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: Strings.dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _files = ReadWriteAttribute(jsObject: jsObject, name: Strings.files)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: Strings.formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: Strings.formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: Strings.formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: Strings.formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: Strings.formTarget)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _indeterminate = ReadWriteAttribute(jsObject: jsObject, name: Strings.indeterminate)
        _list = ReadonlyAttribute(jsObject: jsObject, name: Strings.list)
        _max = ReadWriteAttribute(jsObject: jsObject, name: Strings.max)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxLength)
        _min = ReadWriteAttribute(jsObject: jsObject, name: Strings.min)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: Strings.minLength)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: Strings.multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _pattern = ReadWriteAttribute(jsObject: jsObject, name: Strings.pattern)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: Strings.placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: Strings.readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: Strings.required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: Strings.size)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _step = ReadWriteAttribute(jsObject: jsObject, name: Strings.step)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _valueAsDate = ReadWriteAttribute(jsObject: jsObject, name: Strings.valueAsDate)
        _valueAsNumber = ReadWriteAttribute(jsObject: jsObject, name: Strings.valueAsNumber)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionDirection)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: Strings.useMap)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var accept: String

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var defaultChecked: Bool

    @ReadWriteAttribute
    public var checked: Bool

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var files: FileList?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var indeterminate: Bool

    @ReadonlyAttribute
    public var list: HTMLElement?

    @ReadWriteAttribute
    public var max: String

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var min: String

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var pattern: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var step: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var valueAsDate: JSObject?

    @ReadWriteAttribute
    public var valueAsNumber: Double

    @ReadWriteAttribute
    public var width: UInt32

    @inlinable public func stepUp(n: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.stepUp].function!(this: this, arguments: [n?.jsValue ?? .undefined])
    }

    @inlinable public func stepDown(n: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.stepDown].function!(this: this, arguments: [n?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList?

    @inlinable public func select() {
        let this = jsObject
        _ = this[Strings.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32?

    @ReadWriteAttribute
    public var selectionEnd: UInt32?

    @ReadWriteAttribute
    public var selectionDirection: String?

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [replacement.jsValue])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [replacement.jsValue, start.jsValue, end.jsValue, selectionMode?.jsValue ?? .undefined])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[Strings.setSelectionRange].function!(this: this, arguments: [start.jsValue, end.jsValue, direction?.jsValue ?? .undefined])
    }

    @inlinable public func showPicker() {
        let this = jsObject
        _ = this[Strings.showPicker].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var useMap: String
}

public class HTMLLIElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLLIElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Int32

    @ReadWriteAttribute
    public var type: String
}

public class HTMLLabelElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLLabelElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: Strings.htmlFor)
        _control = ReadonlyAttribute(jsObject: jsObject, name: Strings.control)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var htmlFor: String

    @ReadonlyAttribute
    public var control: HTMLElement?
}

public class HTMLLegendElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLLegendElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var align: String
}

public class HTMLLinkElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLLinkElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: Strings.href)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Strings.crossOrigin)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: Strings.rel)
        _as = ReadWriteAttribute(jsObject: jsObject, name: Strings.as)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: Strings.relList)
        _media = ReadWriteAttribute(jsObject: jsObject, name: Strings.media)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: Strings.integrity)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: Strings.hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _sizes = ReadonlyAttribute(jsObject: jsObject, name: Strings.sizes)
        _imageSrcset = ReadWriteAttribute(jsObject: jsObject, name: Strings.imageSrcset)
        _imageSizes = ReadWriteAttribute(jsObject: jsObject, name: Strings.imageSizes)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: Strings.blocking)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: Strings.charset)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: Strings.rev)
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var rel: String

    @ReadWriteAttribute
    public var `as`: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadonlyAttribute
    public var sizes: DOMTokenList

    @ReadWriteAttribute
    public var imageSrcset: String

    @ReadWriteAttribute
    public var imageSizes: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLMapElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMapElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _areas = ReadonlyAttribute(jsObject: jsObject, name: Strings.areas)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var areas: HTMLCollection
}

public class HTMLMarqueeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMarqueeElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _behavior = ReadWriteAttribute(jsObject: jsObject, name: Strings.behavior)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        _direction = ReadWriteAttribute(jsObject: jsObject, name: Strings.direction)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.hspace)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Strings.loop)
        _scrollAmount = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrollAmount)
        _scrollDelay = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrollDelay)
        _trueSpeed = ReadWriteAttribute(jsObject: jsObject, name: Strings.trueSpeed)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.vspace)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var behavior: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var direction: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var loop: Int32

    @ReadWriteAttribute
    public var scrollAmount: UInt32

    @ReadWriteAttribute
    public var scrollDelay: UInt32

    @ReadWriteAttribute
    public var trueSpeed: Bool

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var width: String

    @inlinable public func start() {
        let this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [])
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }
}

public class HTMLMediaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMediaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentSrc)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Strings.crossOrigin)
        _networkState = ReadonlyAttribute(jsObject: jsObject, name: Strings.networkState)
        _preload = ReadWriteAttribute(jsObject: jsObject, name: Strings.preload)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: Strings.buffered)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _seeking = ReadonlyAttribute(jsObject: jsObject, name: Strings.seeking)
        _currentTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.currentTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _paused = ReadonlyAttribute(jsObject: jsObject, name: Strings.paused)
        _defaultPlaybackRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultPlaybackRate)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.playbackRate)
        _preservesPitch = ReadWriteAttribute(jsObject: jsObject, name: Strings.preservesPitch)
        _played = ReadonlyAttribute(jsObject: jsObject, name: Strings.played)
        _seekable = ReadonlyAttribute(jsObject: jsObject, name: Strings.seekable)
        _ended = ReadonlyAttribute(jsObject: jsObject, name: Strings.ended)
        _autoplay = ReadWriteAttribute(jsObject: jsObject, name: Strings.autoplay)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Strings.loop)
        _controls = ReadWriteAttribute(jsObject: jsObject, name: Strings.controls)
        _volume = ReadWriteAttribute(jsObject: jsObject, name: Strings.volume)
        _muted = ReadWriteAttribute(jsObject: jsObject, name: Strings.muted)
        _defaultMuted = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultMuted)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.textTracks)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var error: MediaError?

    @ReadWriteAttribute
    public var src: String

    // XXX: member 'srcObject' is ignored

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    public static let NETWORK_EMPTY: UInt16 = 0

    public static let NETWORK_IDLE: UInt16 = 1

    public static let NETWORK_LOADING: UInt16 = 2

    public static let NETWORK_NO_SOURCE: UInt16 = 3

    @ReadonlyAttribute
    public var networkState: UInt16

    @ReadWriteAttribute
    public var preload: String

    @ReadonlyAttribute
    public var buffered: TimeRanges

    @inlinable public func load() {
        let this = jsObject
        _ = this[Strings.load].function!(this: this, arguments: [])
    }

    @inlinable public func canPlayType(type: String) -> CanPlayTypeResult {
        let this = jsObject
        return this[Strings.canPlayType].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    public static let HAVE_NOTHING: UInt16 = 0

    public static let HAVE_METADATA: UInt16 = 1

    public static let HAVE_CURRENT_DATA: UInt16 = 2

    public static let HAVE_FUTURE_DATA: UInt16 = 3

    public static let HAVE_ENOUGH_DATA: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var seeking: Bool

    @ReadWriteAttribute
    public var currentTime: Double

    @inlinable public func fastSeek(time: Double) {
        let this = jsObject
        _ = this[Strings.fastSeek].function!(this: this, arguments: [time.jsValue])
    }

    @ReadonlyAttribute
    public var duration: Double

    @inlinable public func getStartDate() -> JSObject {
        let this = jsObject
        return this[Strings.getStartDate].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var paused: Bool

    @ReadWriteAttribute
    public var defaultPlaybackRate: Double

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadWriteAttribute
    public var preservesPitch: Bool

    @ReadonlyAttribute
    public var played: TimeRanges

    @ReadonlyAttribute
    public var seekable: TimeRanges

    @ReadonlyAttribute
    public var ended: Bool

    @ReadWriteAttribute
    public var autoplay: Bool

    @ReadWriteAttribute
    public var loop: Bool

    @inlinable public func play() -> JSPromise {
        let this = jsObject
        return this[Strings.play].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func play() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.play].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[Strings.pause].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var controls: Bool

    @ReadWriteAttribute
    public var volume: Double

    @ReadWriteAttribute
    public var muted: Bool

    @ReadWriteAttribute
    public var defaultMuted: Bool

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    @inlinable public func addTextTrack(kind: TextTrackKind, label: String? = nil, language: String? = nil) -> TextTrack {
        let this = jsObject
        return this[Strings.addTextTrack].function!(this: this, arguments: [kind.jsValue, label?.jsValue ?? .undefined, language?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class HTMLMenuElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMenuElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: Strings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLMetaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMetaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _httpEquiv = ReadWriteAttribute(jsObject: jsObject, name: Strings.httpEquiv)
        _content = ReadWriteAttribute(jsObject: jsObject, name: Strings.content)
        _media = ReadWriteAttribute(jsObject: jsObject, name: Strings.media)
        _scheme = ReadWriteAttribute(jsObject: jsObject, name: Strings.scheme)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var httpEquiv: String

    @ReadWriteAttribute
    public var content: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var scheme: String
}

public class HTMLMeterElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLMeterElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _min = ReadWriteAttribute(jsObject: jsObject, name: Strings.min)
        _max = ReadWriteAttribute(jsObject: jsObject, name: Strings.max)
        _low = ReadWriteAttribute(jsObject: jsObject, name: Strings.low)
        _high = ReadWriteAttribute(jsObject: jsObject, name: Strings.high)
        _optimum = ReadWriteAttribute(jsObject: jsObject, name: Strings.optimum)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var min: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadWriteAttribute
    public var low: Double

    @ReadWriteAttribute
    public var high: Double

    @ReadWriteAttribute
    public var optimum: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLModElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLModElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: Strings.cite)
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLOListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLOListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reversed = ReadWriteAttribute(jsObject: jsObject, name: Strings.reversed)
        _start = ReadWriteAttribute(jsObject: jsObject, name: Strings.start)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _compact = ReadWriteAttribute(jsObject: jsObject, name: Strings.compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var reversed: Bool

    @ReadWriteAttribute
    public var start: Int32

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLObjectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLObjectElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: Strings.data)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: Strings.contentWindow)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _archive = ReadWriteAttribute(jsObject: jsObject, name: Strings.archive)
        _code = ReadWriteAttribute(jsObject: jsObject, name: Strings.code)
        _declare = ReadWriteAttribute(jsObject: jsObject, name: Strings.declare)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.hspace)
        _standby = ReadWriteAttribute(jsObject: jsObject, name: Strings.standby)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: Strings.vspace)
        _codeBase = ReadWriteAttribute(jsObject: jsObject, name: Strings.codeBase)
        _codeType = ReadWriteAttribute(jsObject: jsObject, name: Strings.codeType)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: Strings.useMap)
        _border = ReadWriteAttribute(jsObject: jsObject, name: Strings.border)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var data: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var archive: String

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var declare: Bool

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var standby: String

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var codeBase: String

    @ReadWriteAttribute
    public var codeType: String

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var border: String
}

public class HTMLOptGroupElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLOptGroupElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _label = ReadWriteAttribute(jsObject: jsObject, name: Strings.label)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var label: String
}

public class HTMLOptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLOptionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _label = ReadWriteAttribute(jsObject: jsObject, name: Strings.label)
        _defaultSelected = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultSelected)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: Strings.selected)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _text = ReadWriteAttribute(jsObject: jsObject, name: Strings.text)
        _index = ReadonlyAttribute(jsObject: jsObject, name: Strings.index)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var defaultSelected: Bool

    @ReadWriteAttribute
    public var selected: Bool

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var text: String

    @ReadonlyAttribute
    public var index: Int32
}

public class HTMLOptionsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLOptionsCollection].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadWriteAttribute(jsObject: jsObject, name: Strings.length)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectedIndex)
        super.init(unsafelyWrapping: jsObject)
    }

    @usableFromInline let _length: ReadWriteAttribute<UInt32>
    @inlinable override public var length: UInt32 {
        get { _length.wrappedValue }
        set { _length.wrappedValue = newValue }
    }

    // XXX: unsupported setter for keys of type UInt32

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: [element.jsValue, before?.jsValue ?? .undefined])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var selectedIndex: Int32
}

public protocol HTMLOrSVGElement: JSBridgedClass {}
public extension HTMLOrSVGElement {
    @inlinable var dataset: DOMStringMap { ReadonlyAttribute[Strings.dataset, in: jsObject] }

    @inlinable var nonce: String {
        get { ReadWriteAttribute[Strings.nonce, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.nonce, in: jsObject] = newValue }
    }

    @inlinable var autofocus: Bool {
        get { ReadWriteAttribute[Strings.autofocus, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.autofocus, in: jsObject] = newValue }
    }

    @inlinable var tabIndex: Int32 {
        get { ReadWriteAttribute[Strings.tabIndex, in: jsObject] }
        nonmutating set { ReadWriteAttribute[Strings.tabIndex, in: jsObject] = newValue }
    }

    @inlinable func focus(options: FocusOptions? = nil) {
        let this = jsObject
        _ = this[Strings.focus].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable func blur() {
        let this = jsObject
        _ = this[Strings.blur].function!(this: this, arguments: [])
    }
}

public class HTMLOutputElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLOutputElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _htmlFor = ReadonlyAttribute(jsObject: jsObject, name: Strings.htmlFor)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var htmlFor: DOMTokenList

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLParagraphElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLParagraphElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLParamElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLParamElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _valueType = ReadWriteAttribute(jsObject: jsObject, name: Strings.valueType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var valueType: String
}

public class HTMLPictureElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLPictureElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLPreElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLPreElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: Int32
}

public class HTMLProgressElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLProgressElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _max = ReadWriteAttribute(jsObject: jsObject, name: Strings.max)
        _position = ReadonlyAttribute(jsObject: jsObject, name: Strings.position)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadonlyAttribute
    public var position: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLQuoteElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLQuoteElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: Strings.cite)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String
}

public class HTMLScriptElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLScriptElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _noModule = ReadWriteAttribute(jsObject: jsObject, name: Strings.noModule)
        _async = ReadWriteAttribute(jsObject: jsObject, name: Strings.async)
        _defer = ReadWriteAttribute(jsObject: jsObject, name: Strings.defer)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: Strings.crossOrigin)
        _text = ReadWriteAttribute(jsObject: jsObject, name: Strings.text)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: Strings.integrity)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: Strings.blocking)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: Strings.charset)
        _event = ReadWriteAttribute(jsObject: jsObject, name: Strings.event)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: Strings.htmlFor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var noModule: Bool

    @ReadWriteAttribute
    public var async: Bool

    @ReadWriteAttribute
    public var `defer`: Bool

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @inlinable public static func supports(type: String) -> Bool {
        let this = constructor
        return this[Strings.supports].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var event: String

    @ReadWriteAttribute
    public var htmlFor: String
}

public class HTMLSelectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLSelectElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: Strings.autocomplete)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: Strings.multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _required = ReadWriteAttribute(jsObject: jsObject, name: Strings.required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _options = ReadonlyAttribute(jsObject: jsObject, name: Strings.options)
        _length = ReadWriteAttribute(jsObject: jsObject, name: Strings.length)
        _selectedOptions = ReadonlyAttribute(jsObject: jsObject, name: Strings.selectedOptions)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectedIndex)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var options: HTMLOptionsCollection

    @ReadWriteAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> HTMLOptionElement? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> HTMLOptionElement? {
        let this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: [element.jsValue, before?.jsValue ?? .undefined])
    }

    @inlinable public func remove() {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [index.jsValue])
    }

    // XXX: unsupported setter for keys of type UInt32

    @ReadonlyAttribute
    public var selectedOptions: HTMLCollection

    @ReadWriteAttribute
    public var selectedIndex: Int32

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLSlotElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLSlotElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @inlinable public func assignedNodes(options: AssignedNodesOptions? = nil) -> [Node] {
        let this = jsObject
        return this[Strings.assignedNodes].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func assignedElements(options: AssignedNodesOptions? = nil) -> [Element] {
        let this = jsObject
        return this[Strings.assignedElements].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func assign(nodes: Element_or_Text...) {
        let this = jsObject
        _ = this[Strings.assign].function!(this: this, arguments: nodes.map(\.jsValue))
    }
}

public class HTMLSourceElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLSourceElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: Strings.srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: Strings.sizes)
        _media = ReadWriteAttribute(jsObject: jsObject, name: Strings.media)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32
}

public class HTMLSpanElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLSpanElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public class HTMLStyleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLStyleElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadWriteAttribute(jsObject: jsObject, name: Strings.media)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: Strings.blocking)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var media: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var type: String
}

public class HTMLTableCaptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableCaptionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLTableCellElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableCellElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _colSpan = ReadWriteAttribute(jsObject: jsObject, name: Strings.colSpan)
        _rowSpan = ReadWriteAttribute(jsObject: jsObject, name: Strings.rowSpan)
        _headers = ReadWriteAttribute(jsObject: jsObject, name: Strings.headers)
        _cellIndex = ReadonlyAttribute(jsObject: jsObject, name: Strings.cellIndex)
        _scope = ReadWriteAttribute(jsObject: jsObject, name: Strings.scope)
        _abbr = ReadWriteAttribute(jsObject: jsObject, name: Strings.abbr)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _axis = ReadWriteAttribute(jsObject: jsObject, name: Strings.axis)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: Strings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: Strings.chOff)
        _noWrap = ReadWriteAttribute(jsObject: jsObject, name: Strings.noWrap)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: Strings.vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var colSpan: UInt32

    @ReadWriteAttribute
    public var rowSpan: UInt32

    @ReadWriteAttribute
    public var headers: String

    @ReadonlyAttribute
    public var cellIndex: Int32

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var abbr: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var axis: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var noWrap: Bool

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableColElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableColElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _span = ReadWriteAttribute(jsObject: jsObject, name: Strings.span)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: Strings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: Strings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: Strings.vAlign)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var span: UInt32

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLTableElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _caption = ReadWriteAttribute(jsObject: jsObject, name: Strings.caption)
        _tHead = ReadWriteAttribute(jsObject: jsObject, name: Strings.tHead)
        _tFoot = ReadWriteAttribute(jsObject: jsObject, name: Strings.tFoot)
        _tBodies = ReadonlyAttribute(jsObject: jsObject, name: Strings.tBodies)
        _rows = ReadonlyAttribute(jsObject: jsObject, name: Strings.rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _border = ReadWriteAttribute(jsObject: jsObject, name: Strings.border)
        _frame = ReadWriteAttribute(jsObject: jsObject, name: Strings.frame)
        _rules = ReadWriteAttribute(jsObject: jsObject, name: Strings.rules)
        _summary = ReadWriteAttribute(jsObject: jsObject, name: Strings.summary)
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        _cellPadding = ReadWriteAttribute(jsObject: jsObject, name: Strings.cellPadding)
        _cellSpacing = ReadWriteAttribute(jsObject: jsObject, name: Strings.cellSpacing)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var caption: HTMLTableCaptionElement?

    @inlinable public func createCaption() -> HTMLTableCaptionElement {
        let this = jsObject
        return this[Strings.createCaption].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteCaption() {
        let this = jsObject
        _ = this[Strings.deleteCaption].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tHead: HTMLTableSectionElement?

    @inlinable public func createTHead() -> HTMLTableSectionElement {
        let this = jsObject
        return this[Strings.createTHead].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTHead() {
        let this = jsObject
        _ = this[Strings.deleteTHead].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tFoot: HTMLTableSectionElement?

    @inlinable public func createTFoot() -> HTMLTableSectionElement {
        let this = jsObject
        return this[Strings.createTFoot].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTFoot() {
        let this = jsObject
        _ = this[Strings.deleteTFoot].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var tBodies: HTMLCollection

    @inlinable public func createTBody() -> HTMLTableSectionElement {
        let this = jsObject
        return this[Strings.createTBody].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[Strings.insertRow].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[Strings.deleteRow].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var border: String

    @ReadWriteAttribute
    public var frame: String

    @ReadWriteAttribute
    public var rules: String

    @ReadWriteAttribute
    public var summary: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var cellPadding: String

    @ReadWriteAttribute
    public var cellSpacing: String
}

public class HTMLTableRowElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableRowElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rowIndex = ReadonlyAttribute(jsObject: jsObject, name: Strings.rowIndex)
        _sectionRowIndex = ReadonlyAttribute(jsObject: jsObject, name: Strings.sectionRowIndex)
        _cells = ReadonlyAttribute(jsObject: jsObject, name: Strings.cells)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: Strings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: Strings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: Strings.vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: Strings.bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rowIndex: Int32

    @ReadonlyAttribute
    public var sectionRowIndex: Int32

    @ReadonlyAttribute
    public var cells: HTMLCollection

    @inlinable public func insertCell(index: Int32? = nil) -> HTMLTableCellElement {
        let this = jsObject
        return this[Strings.insertCell].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteCell(index: Int32) {
        let this = jsObject
        _ = this[Strings.deleteCell].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableSectionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTableSectionElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rows = ReadonlyAttribute(jsObject: jsObject, name: Strings.rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: Strings.align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: Strings.ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: Strings.chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: Strings.vAlign)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[Strings.insertRow].function!(this: this, arguments: [index?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[Strings.deleteRow].function!(this: this, arguments: [index.jsValue])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String
}

public class HTMLTemplateElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTemplateElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _content = ReadonlyAttribute(jsObject: jsObject, name: Strings.content)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var content: DocumentFragment
}

public class HTMLTextAreaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTextAreaElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: Strings.autocomplete)
        _cols = ReadWriteAttribute(jsObject: jsObject, name: Strings.cols)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: Strings.dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: Strings.form)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxLength)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: Strings.minLength)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: Strings.placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: Strings.readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: Strings.required)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: Strings.rows)
        _wrap = ReadWriteAttribute(jsObject: jsObject, name: Strings.wrap)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _textLength = ReadonlyAttribute(jsObject: jsObject, name: Strings.textLength)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: Strings.willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: Strings.validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: Strings.labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: Strings.selectionDirection)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var cols: UInt32

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var rows: UInt32

    @ReadWriteAttribute
    public var wrap: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var textLength: UInt32

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [error.jsValue])
    }

    @ReadonlyAttribute
    public var labels: NodeList

    @inlinable public func select() {
        let this = jsObject
        _ = this[Strings.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32

    @ReadWriteAttribute
    public var selectionEnd: UInt32

    @ReadWriteAttribute
    public var selectionDirection: String

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [replacement.jsValue])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [replacement.jsValue, start.jsValue, end.jsValue, selectionMode?.jsValue ?? .undefined])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[Strings.setSelectionRange].function!(this: this, arguments: [start.jsValue, end.jsValue, direction?.jsValue ?? .undefined])
    }
}

public class HTMLTimeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTimeElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLTitleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTitleElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: Strings.text)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String
}

public class HTMLTrackElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLTrackElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadWriteAttribute(jsObject: jsObject, name: Strings.kind)
        _src = ReadWriteAttribute(jsObject: jsObject, name: Strings.src)
        _srclang = ReadWriteAttribute(jsObject: jsObject, name: Strings.srclang)
        _label = ReadWriteAttribute(jsObject: jsObject, name: Strings.label)
        _default = ReadWriteAttribute(jsObject: jsObject, name: Strings.default)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _track = ReadonlyAttribute(jsObject: jsObject, name: Strings.track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var kind: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srclang: String

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var `default`: Bool

    public static let NONE: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let LOADED: UInt16 = 2

    public static let ERROR: UInt16 = 3

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var track: TextTrack
}

public class HTMLUListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLUListElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: Strings.compact)
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool

    @ReadWriteAttribute
    public var type: String
}

public class HTMLUnknownElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLUnknownElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class HTMLVideoElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HTMLVideoElement].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _videoWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.videoWidth)
        _videoHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.videoHeight)
        _poster = ReadWriteAttribute(jsObject: jsObject, name: Strings.poster)
        _playsInline = ReadWriteAttribute(jsObject: jsObject, name: Strings.playsInline)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var videoWidth: UInt32

    @ReadonlyAttribute
    public var videoHeight: UInt32

    @ReadWriteAttribute
    public var poster: String

    @ReadWriteAttribute
    public var playsInline: Bool
}

public enum HardwareAcceleration: JSString, JSValueCompatible {
    case noPreference = "no-preference"
    case preferHardware = "prefer-hardware"
    case preferSoftware = "prefer-software"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class HashChangeEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.HashChangeEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _oldURL = ReadonlyAttribute(jsObject: jsObject, name: Strings.oldURL)
        _newURL = ReadonlyAttribute(jsObject: jsObject, name: Strings.newURL)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: HashChangeEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var oldURL: String

    @ReadonlyAttribute
    public var newURL: String
}

public class HashChangeEventInit: BridgedDictionary {
    public convenience init(oldURL: String, newURL: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.oldURL] = oldURL.jsValue
        object[Strings.newURL] = newURL.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _oldURL = ReadWriteAttribute(jsObject: object, name: Strings.oldURL)
        _newURL = ReadWriteAttribute(jsObject: object, name: Strings.newURL)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var oldURL: String

    @ReadWriteAttribute
    public var newURL: String
}

public class Headers: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Headers].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: HeadersInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [name.jsValue])
    }

    @inlinable public func get(name: String) -> String? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<Headers> {
        ValueIterableIterator(sequence: self)
    }
}

public class History: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.History].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _scrollRestoration = ReadWriteAttribute(jsObject: jsObject, name: Strings.scrollRestoration)
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var scrollRestoration: ScrollRestoration

    @ReadonlyAttribute
    public var state: JSValue

    @inlinable public func go(delta: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.go].function!(this: this, arguments: [delta?.jsValue ?? .undefined])
    }

    @inlinable public func back() {
        let this = jsObject
        _ = this[Strings.back].function!(this: this, arguments: [])
    }

    @inlinable public func forward() {
        let this = jsObject
        _ = this[Strings.forward].function!(this: this, arguments: [])
    }

    @inlinable public func pushState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[Strings.pushState].function!(this: this, arguments: [data.jsValue, unused.jsValue, url?.jsValue ?? .undefined])
    }

    @inlinable public func replaceState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[Strings.replaceState].function!(this: this, arguments: [data.jsValue, unused.jsValue, url?.jsValue ?? .undefined])
    }
}

public class IIRFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.IIRFilterNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: IIRFilterOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options.jsValue]))
    }

    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFrequencyResponse].function!(this: this, arguments: [frequencyHz.jsValue, magResponse.jsValue, phaseResponse.jsValue])
    }
}

public class IIRFilterOptions: BridgedDictionary {
    public convenience init(feedforward: [Double], feedback: [Double]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.feedforward] = feedforward.jsValue
        object[Strings.feedback] = feedback.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _feedforward = ReadWriteAttribute(jsObject: object, name: Strings.feedforward)
        _feedback = ReadWriteAttribute(jsObject: object, name: Strings.feedback)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var feedforward: [Double]

    @ReadWriteAttribute
    public var feedback: [Double]
}

public class ImageBitmap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ImageBitmap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: Strings.height)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

public class ImageBitmapOptions: BridgedDictionary {
    public convenience init(imageOrientation: ImageOrientation, premultiplyAlpha: PremultiplyAlpha, colorSpaceConversion: ColorSpaceConversion, resizeWidth: UInt32, resizeHeight: UInt32, resizeQuality: ResizeQuality) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.imageOrientation] = imageOrientation.jsValue
        object[Strings.premultiplyAlpha] = premultiplyAlpha.jsValue
        object[Strings.colorSpaceConversion] = colorSpaceConversion.jsValue
        object[Strings.resizeWidth] = resizeWidth.jsValue
        object[Strings.resizeHeight] = resizeHeight.jsValue
        object[Strings.resizeQuality] = resizeQuality.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _imageOrientation = ReadWriteAttribute(jsObject: object, name: Strings.imageOrientation)
        _premultiplyAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultiplyAlpha)
        _colorSpaceConversion = ReadWriteAttribute(jsObject: object, name: Strings.colorSpaceConversion)
        _resizeWidth = ReadWriteAttribute(jsObject: object, name: Strings.resizeWidth)
        _resizeHeight = ReadWriteAttribute(jsObject: object, name: Strings.resizeHeight)
        _resizeQuality = ReadWriteAttribute(jsObject: object, name: Strings.resizeQuality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var imageOrientation: ImageOrientation

    @ReadWriteAttribute
    public var premultiplyAlpha: PremultiplyAlpha

    @ReadWriteAttribute
    public var colorSpaceConversion: ColorSpaceConversion

    @ReadWriteAttribute
    public var resizeWidth: UInt32

    @ReadWriteAttribute
    public var resizeHeight: UInt32

    @ReadWriteAttribute
    public var resizeQuality: ResizeQuality
}

public class ImageBitmapRenderingContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ImageBitmapRenderingContext].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: Strings.canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement_or_OffscreenCanvas

    @inlinable public func transferFromImageBitmap(bitmap: ImageBitmap?) {
        let this = jsObject
        _ = this[Strings.transferFromImageBitmap].function!(this: this, arguments: [bitmap.jsValue])
    }
}

public class ImageBitmapRenderingContextSettings: BridgedDictionary {
    public convenience init(alpha: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = alpha.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool
}

public class ImageData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ImageData].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: Strings.height)
        _data = ReadonlyAttribute(jsObject: jsObject, name: Strings.data)
        _colorSpace = ReadonlyAttribute(jsObject: jsObject, name: Strings.colorSpace)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(sw: UInt32, sh: UInt32, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [sw.jsValue, sh.jsValue, settings?.jsValue ?? .undefined]))
    }

    @inlinable public convenience init(data: Uint8ClampedArray, sw: UInt32, sh: UInt32? = nil, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data.jsValue, sw.jsValue, sh?.jsValue ?? .undefined, settings?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var data: Uint8ClampedArray

    @ReadonlyAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageDataSettings: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorSpace] = colorSpace.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageDecodeOptions: BridgedDictionary {
    public convenience init(frameIndex: UInt32, completeFramesOnly: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.frameIndex] = frameIndex.jsValue
        object[Strings.completeFramesOnly] = completeFramesOnly.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _frameIndex = ReadWriteAttribute(jsObject: object, name: Strings.frameIndex)
        _completeFramesOnly = ReadWriteAttribute(jsObject: object, name: Strings.completeFramesOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var frameIndex: UInt32

    @ReadWriteAttribute
    public var completeFramesOnly: Bool
}

public class ImageDecodeResult: BridgedDictionary {
    public convenience init(image: VideoFrame, complete: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.image] = image.jsValue
        object[Strings.complete] = complete.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _image = ReadWriteAttribute(jsObject: object, name: Strings.image)
        _complete = ReadWriteAttribute(jsObject: object, name: Strings.complete)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var image: VideoFrame

    @ReadWriteAttribute
    public var complete: Bool
}

public class ImageDecoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ImageDecoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _complete = ReadonlyAttribute(jsObject: jsObject, name: Strings.complete)
        _completed = ReadonlyAttribute(jsObject: jsObject, name: Strings.completed)
        _tracks = ReadonlyAttribute(jsObject: jsObject, name: Strings.tracks)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: ImageDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var complete: Bool

    @ReadonlyAttribute
    public var completed: JSPromise

    @ReadonlyAttribute
    public var tracks: ImageTrackList

    @inlinable public func decode(options: ImageDecodeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.decode].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decode(options: ImageDecodeOptions? = nil) async throws -> ImageDecodeResult {
        let this = jsObject
        let _promise: JSPromise = this[Strings.decode].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public static func isTypeSupported(type: String) -> JSPromise {
        let this = constructor
        return this[Strings.isTypeSupported].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public static func isTypeSupported(type: String) async throws -> Bool {
        let this = constructor
        let _promise: JSPromise = this[Strings.isTypeSupported].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class ImageDecoderInit: BridgedDictionary {
    public convenience init(type: String, data: ImageBufferSource, premultiplyAlpha: PremultiplyAlpha, colorSpaceConversion: ColorSpaceConversion, desiredWidth: UInt32, desiredHeight: UInt32, preferAnimation: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.data] = data.jsValue
        object[Strings.premultiplyAlpha] = premultiplyAlpha.jsValue
        object[Strings.colorSpaceConversion] = colorSpaceConversion.jsValue
        object[Strings.desiredWidth] = desiredWidth.jsValue
        object[Strings.desiredHeight] = desiredHeight.jsValue
        object[Strings.preferAnimation] = preferAnimation.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        _premultiplyAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultiplyAlpha)
        _colorSpaceConversion = ReadWriteAttribute(jsObject: object, name: Strings.colorSpaceConversion)
        _desiredWidth = ReadWriteAttribute(jsObject: object, name: Strings.desiredWidth)
        _desiredHeight = ReadWriteAttribute(jsObject: object, name: Strings.desiredHeight)
        _preferAnimation = ReadWriteAttribute(jsObject: object, name: Strings.preferAnimation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var data: ImageBufferSource

    @ReadWriteAttribute
    public var premultiplyAlpha: PremultiplyAlpha

    @ReadWriteAttribute
    public var colorSpaceConversion: ColorSpaceConversion

    @ReadWriteAttribute
    public var desiredWidth: UInt32

    @ReadWriteAttribute
    public var desiredHeight: UInt32

    @ReadWriteAttribute
    public var preferAnimation: Bool
}

public class ImageEncodeOptions: BridgedDictionary {
    public convenience init(type: String, quality: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.quality] = quality.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _quality = ReadWriteAttribute(jsObject: object, name: Strings.quality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var quality: Double
}

public enum ImageOrientation: JSString, JSValueCompatible {
    case none = "none"
    case flipY = "flipY"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ImageSmoothingQuality: JSString, JSValueCompatible {
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ImageTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ImageTrack].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _animated = ReadonlyAttribute(jsObject: jsObject, name: Strings.animated)
        _frameCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.frameCount)
        _repetitionCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.repetitionCount)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onchange)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: Strings.selected)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var animated: Bool

    @ReadonlyAttribute
    public var frameCount: UInt32

    @ReadonlyAttribute
    public var repetitionCount: Float

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ReadWriteAttribute
    public var selected: Bool
}

public class ImageTrackList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ImageTrackList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _ready = ReadonlyAttribute(jsObject: jsObject, name: Strings.ready)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _selectedIndex = ReadonlyAttribute(jsObject: jsObject, name: Strings.selectedIndex)
        _selectedTrack = ReadonlyAttribute(jsObject: jsObject, name: Strings.selectedTrack)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> ImageTrack {
        jsObject[key].fromJSValue()!
    }

    @ReadonlyAttribute
    public var ready: JSPromise

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var selectedIndex: Int32

    @ReadonlyAttribute
    public var selectedTrack: ImageTrack?
}

public class InputDeviceInfo: MediaDeviceInfo {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.InputDeviceInfo].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func getCapabilities() -> MediaTrackCapabilities {
        let this = jsObject
        return this[Strings.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class InputEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.InputEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: Strings.data)
        _isComposing = ReadonlyAttribute(jsObject: jsObject, name: Strings.isComposing)
        _inputType = ReadonlyAttribute(jsObject: jsObject, name: Strings.inputType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: InputEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var data: String?

    @ReadonlyAttribute
    public var isComposing: Bool

    @ReadonlyAttribute
    public var inputType: String
}

public class InputEventInit: BridgedDictionary {
    public convenience init(data: String?, isComposing: Bool, inputType: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.data] = data.jsValue
        object[Strings.isComposing] = isComposing.jsValue
        object[Strings.inputType] = inputType.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        _isComposing = ReadWriteAttribute(jsObject: object, name: Strings.isComposing)
        _inputType = ReadWriteAttribute(jsObject: object, name: Strings.inputType)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: String?

    @ReadWriteAttribute
    public var isComposing: Bool

    @ReadWriteAttribute
    public var inputType: String
}

public class IsVisibleOptions: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[Strings.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class KeyboardEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.KeyboardEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _key = ReadonlyAttribute(jsObject: jsObject, name: Strings.key)
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        _location = ReadonlyAttribute(jsObject: jsObject, name: Strings.location)
        _ctrlKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.ctrlKey)
        _shiftKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.shiftKey)
        _altKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.altKey)
        _metaKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.metaKey)
        _repeat = ReadonlyAttribute(jsObject: jsObject, name: Strings.repeat)
        _isComposing = ReadonlyAttribute(jsObject: jsObject, name: Strings.isComposing)
        _charCode = ReadonlyAttribute(jsObject: jsObject, name: Strings.charCode)
        _keyCode = ReadonlyAttribute(jsObject: jsObject, name: Strings.keyCode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: KeyboardEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    public static let DOM_KEY_LOCATION_STANDARD: UInt32 = 0x00

    public static let DOM_KEY_LOCATION_LEFT: UInt32 = 0x01

    public static let DOM_KEY_LOCATION_RIGHT: UInt32 = 0x02

    public static let DOM_KEY_LOCATION_NUMPAD: UInt32 = 0x03

    @ReadonlyAttribute
    public var key: String

    @ReadonlyAttribute
    public var code: String

    @ReadonlyAttribute
    public var location: UInt32

    @ReadonlyAttribute
    public var ctrlKey: Bool

    @ReadonlyAttribute
    public var shiftKey: Bool

    @ReadonlyAttribute
    public var altKey: Bool

    @ReadonlyAttribute
    public var metaKey: Bool

    @ReadonlyAttribute
    public var `repeat`: Bool

    @ReadonlyAttribute
    public var isComposing: Bool

    @inlinable public func getModifierState(keyArg: String) -> Bool {
        let this = jsObject
        return this[Strings.getModifierState].function!(this: this, arguments: [keyArg.jsValue]).fromJSValue()!
    }

    @inlinable public func initKeyboardEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, keyArg: String? = nil, locationArg: UInt32? = nil, ctrlKey: Bool? = nil, altKey: Bool? = nil, shiftKey: Bool? = nil, metaKey: Bool? = nil) {
        let _arg0 = typeArg.jsValue
        let _arg1 = bubblesArg?.jsValue ?? .undefined
        let _arg2 = cancelableArg?.jsValue ?? .undefined
        let _arg3 = viewArg?.jsValue ?? .undefined
        let _arg4 = keyArg?.jsValue ?? .undefined
        let _arg5 = locationArg?.jsValue ?? .undefined
        let _arg6 = ctrlKey?.jsValue ?? .undefined
        let _arg7 = altKey?.jsValue ?? .undefined
        let _arg8 = shiftKey?.jsValue ?? .undefined
        let _arg9 = metaKey?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.initKeyboardEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @ReadonlyAttribute
    public var charCode: UInt32

    @ReadonlyAttribute
    public var keyCode: UInt32
}

public class KeyboardEventInit: BridgedDictionary {
    public convenience init(key: String, code: String, location: UInt32, repeat: Bool, isComposing: Bool, charCode: UInt32, keyCode: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.key] = key.jsValue
        object[Strings.code] = code.jsValue
        object[Strings.location] = location.jsValue
        object[Strings.repeat] = `repeat`.jsValue
        object[Strings.isComposing] = isComposing.jsValue
        object[Strings.charCode] = charCode.jsValue
        object[Strings.keyCode] = keyCode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _key = ReadWriteAttribute(jsObject: object, name: Strings.key)
        _code = ReadWriteAttribute(jsObject: object, name: Strings.code)
        _location = ReadWriteAttribute(jsObject: object, name: Strings.location)
        _repeat = ReadWriteAttribute(jsObject: object, name: Strings.repeat)
        _isComposing = ReadWriteAttribute(jsObject: object, name: Strings.isComposing)
        _charCode = ReadWriteAttribute(jsObject: object, name: Strings.charCode)
        _keyCode = ReadWriteAttribute(jsObject: object, name: Strings.keyCode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var key: String

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var location: UInt32

    @ReadWriteAttribute
    public var `repeat`: Bool

    @ReadWriteAttribute
    public var isComposing: Bool

    @ReadWriteAttribute
    public var charCode: UInt32

    @ReadWriteAttribute
    public var keyCode: UInt32
}

public class KeyframeAnimationOptions: BridgedDictionary {
    public convenience init(id: String, timeline: AnimationTimeline?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.id] = id.jsValue
        object[Strings.timeline] = timeline.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _id = ReadWriteAttribute(jsObject: object, name: Strings.id)
        _timeline = ReadWriteAttribute(jsObject: object, name: Strings.timeline)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var timeline: AnimationTimeline?
}

public class KeyframeEffect: AnimationEffect {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.KeyframeEffect].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadWriteAttribute(jsObject: jsObject, name: Strings.target)
        _pseudoElement = ReadWriteAttribute(jsObject: jsObject, name: Strings.pseudoElement)
        _composite = ReadWriteAttribute(jsObject: jsObject, name: Strings.composite)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(target: Element?, keyframes: JSObject?, options: Double_or_KeyframeEffectOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [target.jsValue, keyframes.jsValue, options?.jsValue ?? .undefined]))
    }

    @inlinable public convenience init(source: KeyframeEffect) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [source.jsValue]))
    }

    @ReadWriteAttribute
    public var target: Element?

    @ReadWriteAttribute
    public var pseudoElement: String?

    @ReadWriteAttribute
    public var composite: CompositeOperation

    @inlinable public func getKeyframes() -> [JSObject] {
        let this = jsObject
        return this[Strings.getKeyframes].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setKeyframes(keyframes: JSObject?) {
        let this = jsObject
        _ = this[Strings.setKeyframes].function!(this: this, arguments: [keyframes.jsValue])
    }
}

public class KeyframeEffectOptions: BridgedDictionary {
    public convenience init(composite: CompositeOperation, pseudoElement: String?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.composite] = composite.jsValue
        object[Strings.pseudoElement] = pseudoElement.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _composite = ReadWriteAttribute(jsObject: object, name: Strings.composite)
        _pseudoElement = ReadWriteAttribute(jsObject: object, name: Strings.pseudoElement)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var composite: CompositeOperation

    @ReadWriteAttribute
    public var pseudoElement: String?
}

public enum LatencyMode: JSString, JSValueCompatible {
    case quality = "quality"
    case realtime = "realtime"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Location: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Location].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: Strings.href)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: Strings.origin)
        _protocol = ReadWriteAttribute(jsObject: jsObject, name: Strings.protocol)
        _host = ReadWriteAttribute(jsObject: jsObject, name: Strings.host)
        _hostname = ReadWriteAttribute(jsObject: jsObject, name: Strings.hostname)
        _port = ReadWriteAttribute(jsObject: jsObject, name: Strings.port)
        _pathname = ReadWriteAttribute(jsObject: jsObject, name: Strings.pathname)
        _search = ReadWriteAttribute(jsObject: jsObject, name: Strings.search)
        _hash = ReadWriteAttribute(jsObject: jsObject, name: Strings.hash)
        _ancestorOrigins = ReadonlyAttribute(jsObject: jsObject, name: Strings.ancestorOrigins)
        self.jsObject = jsObject
    }

    @ReadWriteAttribute
    public var href: String

    @ReadonlyAttribute
    public var origin: String

    @ReadWriteAttribute
    public var `protocol`: String

    @ReadWriteAttribute
    public var host: String

    @ReadWriteAttribute
    public var hostname: String

    @ReadWriteAttribute
    public var port: String

    @ReadWriteAttribute
    public var pathname: String

    @ReadWriteAttribute
    public var search: String

    @ReadWriteAttribute
    public var hash: String

    @inlinable public func assign(url: String) {
        let this = jsObject
        _ = this[Strings.assign].function!(this: this, arguments: [url.jsValue])
    }

    @inlinable public func replace(url: String) {
        let this = jsObject
        _ = this[Strings.replace].function!(this: this, arguments: [url.jsValue])
    }

    @inlinable public func reload() {
        let this = jsObject
        _ = this[Strings.reload].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var ancestorOrigins: DOMStringList
}

public class MediaDeviceInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MediaDeviceInfo].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _deviceId = ReadonlyAttribute(jsObject: jsObject, name: Strings.deviceId)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: Strings.label)
        _groupId = ReadonlyAttribute(jsObject: jsObject, name: Strings.groupId)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var deviceId: String

    @ReadonlyAttribute
    public var kind: MediaDeviceKind

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var groupId: String

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum MediaDeviceKind: JSString, JSValueCompatible {
    case audioinput = "audioinput"
    case audiooutput = "audiooutput"
    case videoinput = "videoinput"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class MediaDevices: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaDevices].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _ondevicechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.ondevicechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var ondevicechange: EventHandler

    @inlinable public func enumerateDevices() -> JSPromise {
        let this = jsObject
        return this[Strings.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func enumerateDevices() async throws -> [MediaDeviceInfo] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getSupportedConstraints() -> MediaTrackSupportedConstraints {
        let this = jsObject
        return this[Strings.getSupportedConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getUserMedia(constraints: MediaStreamConstraints? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.getUserMedia].function!(this: this, arguments: [constraints?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getUserMedia(constraints: MediaStreamConstraints? = nil) async throws -> MediaStream {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getUserMedia].function!(this: this, arguments: [constraints?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class MediaElementAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaElementAudioSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mediaElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaElement)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaElementAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options.jsValue]))
    }

    @ReadonlyAttribute
    public var mediaElement: HTMLMediaElement
}

public class MediaElementAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaElement: HTMLMediaElement) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaElement] = mediaElement.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaElement = ReadWriteAttribute(jsObject: object, name: Strings.mediaElement)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaElement: HTMLMediaElement
}

public class MediaError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MediaError].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _code = ReadonlyAttribute(jsObject: jsObject, name: Strings.code)
        _message = ReadonlyAttribute(jsObject: jsObject, name: Strings.message)
        self.jsObject = jsObject
    }

    public static let MEDIA_ERR_ABORTED: UInt16 = 1

    public static let MEDIA_ERR_NETWORK: UInt16 = 2

    public static let MEDIA_ERR_DECODE: UInt16 = 3

    public static let MEDIA_ERR_SRC_NOT_SUPPORTED: UInt16 = 4

    @ReadonlyAttribute
    public var code: UInt16

    @ReadonlyAttribute
    public var message: String
}

public class MediaQueryList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaQueryList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadonlyAttribute(jsObject: jsObject, name: Strings.media)
        _matches = ReadonlyAttribute(jsObject: jsObject, name: Strings.matches)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var media: String

    @ReadonlyAttribute
    public var matches: Bool

    // XXX: member 'addListener' is ignored

    // XXX: member 'removeListener' is ignored

    @ClosureAttribute1Optional
    public var onchange: EventHandler
}

public class MediaQueryListEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaQueryListEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadonlyAttribute(jsObject: jsObject, name: Strings.media)
        _matches = ReadonlyAttribute(jsObject: jsObject, name: Strings.matches)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MediaQueryListEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var media: String

    @ReadonlyAttribute
    public var matches: Bool
}

public class MediaQueryListEventInit: BridgedDictionary {
    public convenience init(media: String, matches: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.media] = media.jsValue
        object[Strings.matches] = matches.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _media = ReadWriteAttribute(jsObject: object, name: Strings.media)
        _matches = ReadWriteAttribute(jsObject: object, name: Strings.matches)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var matches: Bool
}

public class MediaRecorder: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaRecorder].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _stream = ReadonlyAttribute(jsObject: jsObject, name: Strings.stream)
        _mimeType = ReadonlyAttribute(jsObject: jsObject, name: Strings.mimeType)
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _onstart = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onstart)
        _onstop = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onstop)
        _ondataavailable = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.ondataavailable)
        _onpause = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onpause)
        _onresume = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onresume)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        _videoBitsPerSecond = ReadonlyAttribute(jsObject: jsObject, name: Strings.videoBitsPerSecond)
        _audioBitsPerSecond = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioBitsPerSecond)
        _audioBitrateMode = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioBitrateMode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(stream: MediaStream, options: MediaRecorderOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [stream.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var stream: MediaStream

    @ReadonlyAttribute
    public var mimeType: String

    @ReadonlyAttribute
    public var state: RecordingState

    @ClosureAttribute1Optional
    public var onstart: EventHandler

    @ClosureAttribute1Optional
    public var onstop: EventHandler

    @ClosureAttribute1Optional
    public var ondataavailable: EventHandler

    @ClosureAttribute1Optional
    public var onpause: EventHandler

    @ClosureAttribute1Optional
    public var onresume: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ReadonlyAttribute
    public var videoBitsPerSecond: UInt32

    @ReadonlyAttribute
    public var audioBitsPerSecond: UInt32

    @ReadonlyAttribute
    public var audioBitrateMode: BitrateMode

    @inlinable public func start(timeslice: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [timeslice?.jsValue ?? .undefined])
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[Strings.pause].function!(this: this, arguments: [])
    }

    @inlinable public func resume() {
        let this = jsObject
        _ = this[Strings.resume].function!(this: this, arguments: [])
    }

    @inlinable public func requestData() {
        let this = jsObject
        _ = this[Strings.requestData].function!(this: this, arguments: [])
    }

    @inlinable public static func isTypeSupported(type: String) -> Bool {
        let this = constructor
        return this[Strings.isTypeSupported].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }
}

public class MediaRecorderErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaRecorderErrorEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: Strings.error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MediaRecorderErrorEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var error: DOMException
}

public class MediaRecorderErrorEventInit: BridgedDictionary {
    public convenience init(error: DOMException) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.error] = error.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _error = ReadWriteAttribute(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var error: DOMException
}

public class MediaRecorderOptions: BridgedDictionary {
    public convenience init(mimeType: String, audioBitsPerSecond: UInt32, videoBitsPerSecond: UInt32, bitsPerSecond: UInt32, audioBitrateMode: BitrateMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mimeType] = mimeType.jsValue
        object[Strings.audioBitsPerSecond] = audioBitsPerSecond.jsValue
        object[Strings.videoBitsPerSecond] = videoBitsPerSecond.jsValue
        object[Strings.bitsPerSecond] = bitsPerSecond.jsValue
        object[Strings.audioBitrateMode] = audioBitrateMode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mimeType = ReadWriteAttribute(jsObject: object, name: Strings.mimeType)
        _audioBitsPerSecond = ReadWriteAttribute(jsObject: object, name: Strings.audioBitsPerSecond)
        _videoBitsPerSecond = ReadWriteAttribute(jsObject: object, name: Strings.videoBitsPerSecond)
        _bitsPerSecond = ReadWriteAttribute(jsObject: object, name: Strings.bitsPerSecond)
        _audioBitrateMode = ReadWriteAttribute(jsObject: object, name: Strings.audioBitrateMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mimeType: String

    @ReadWriteAttribute
    public var audioBitsPerSecond: UInt32

    @ReadWriteAttribute
    public var videoBitsPerSecond: UInt32

    @ReadWriteAttribute
    public var bitsPerSecond: UInt32

    @ReadWriteAttribute
    public var audioBitrateMode: BitrateMode
}

public class MediaStream: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStream].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: Strings.id)
        _active = ReadonlyAttribute(jsObject: jsObject, name: Strings.active)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public convenience init(stream: MediaStream) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [stream.jsValue]))
    }

    @inlinable public convenience init(tracks: [MediaStreamTrack]) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [tracks.jsValue]))
    }

    @ReadonlyAttribute
    public var id: String

    @inlinable public func getAudioTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[Strings.getAudioTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getVideoTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[Strings.getVideoTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[Strings.getTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getTrackById(trackId: String) -> MediaStreamTrack? {
        let this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [trackId.jsValue]).fromJSValue()!
    }

    @inlinable public func addTrack(track: MediaStreamTrack) {
        let this = jsObject
        _ = this[Strings.addTrack].function!(this: this, arguments: [track.jsValue])
    }

    @inlinable public func removeTrack(track: MediaStreamTrack) {
        let this = jsObject
        _ = this[Strings.removeTrack].function!(this: this, arguments: [track.jsValue])
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var active: Bool

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class MediaStreamAudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStreamAudioDestinationNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _stream = ReadonlyAttribute(jsObject: jsObject, name: Strings.stream)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: AudioNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var stream: MediaStream
}

public class MediaStreamAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStreamAudioSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mediaStream = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaStream)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaStreamAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options.jsValue]))
    }

    @ReadonlyAttribute
    public var mediaStream: MediaStream
}

public class MediaStreamAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStream: MediaStream) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaStream] = mediaStream.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaStream = ReadWriteAttribute(jsObject: object, name: Strings.mediaStream)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaStream: MediaStream
}

public class MediaStreamConstraints: BridgedDictionary {
    public convenience init(video: Bool_or_MediaTrackConstraints, audio: Bool_or_MediaTrackConstraints) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.video] = video.jsValue
        object[Strings.audio] = audio.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _video = ReadWriteAttribute(jsObject: object, name: Strings.video)
        _audio = ReadWriteAttribute(jsObject: object, name: Strings.audio)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var video: Bool_or_MediaTrackConstraints

    @ReadWriteAttribute
    public var audio: Bool_or_MediaTrackConstraints
}

public class MediaStreamTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStreamTrack].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _id = ReadonlyAttribute(jsObject: jsObject, name: Strings.id)
        _label = ReadonlyAttribute(jsObject: jsObject, name: Strings.label)
        _enabled = ReadWriteAttribute(jsObject: jsObject, name: Strings.enabled)
        _muted = ReadonlyAttribute(jsObject: jsObject, name: Strings.muted)
        _onmute = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmute)
        _onunmute = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onunmute)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _onended = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onended)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var label: String

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadonlyAttribute
    public var muted: Bool

    @ClosureAttribute1Optional
    public var onmute: EventHandler

    @ClosureAttribute1Optional
    public var onunmute: EventHandler

    @ReadonlyAttribute
    public var readyState: MediaStreamTrackState

    @ClosureAttribute1Optional
    public var onended: EventHandler

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable public func getCapabilities() -> MediaTrackCapabilities {
        let this = jsObject
        return this[Strings.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getConstraints() -> MediaTrackConstraints {
        let this = jsObject
        return this[Strings.getConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getSettings() -> MediaTrackSettings {
        let this = jsObject
        return this[Strings.getSettings].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func applyConstraints(constraints: MediaTrackConstraints? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.applyConstraints].function!(this: this, arguments: [constraints?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func applyConstraints(constraints: MediaTrackConstraints? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.applyConstraints].function!(this: this, arguments: [constraints?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class MediaStreamTrackAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStreamTrackAudioSourceNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaStreamTrackAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options.jsValue]))
    }
}

public class MediaStreamTrackAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStreamTrack: MediaStreamTrack) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaStreamTrack] = mediaStreamTrack.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaStreamTrack = ReadWriteAttribute(jsObject: object, name: Strings.mediaStreamTrack)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaStreamTrack: MediaStreamTrack
}

public class MediaStreamTrackEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MediaStreamTrackEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: Strings.track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MediaStreamTrackEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var track: MediaStreamTrack
}

public class MediaStreamTrackEventInit: BridgedDictionary {
    public convenience init(track: MediaStreamTrack) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.track] = track.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _track = ReadWriteAttribute(jsObject: object, name: Strings.track)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var track: MediaStreamTrack
}

public enum MediaStreamTrackState: JSString, JSValueCompatible {
    case live = "live"
    case ended = "ended"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class MediaTrackCapabilities: BridgedDictionary {
    public convenience init(width: ULongRange, height: ULongRange, aspectRatio: DoubleRange, frameRate: DoubleRange, facingMode: [String], resizeMode: [String], sampleRate: ULongRange, sampleSize: ULongRange, echoCancellation: [Bool], autoGainControl: [Bool], noiseSuppression: [Bool], latency: DoubleRange, channelCount: ULongRange, deviceId: String, groupId: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.aspectRatio] = aspectRatio.jsValue
        object[Strings.frameRate] = frameRate.jsValue
        object[Strings.facingMode] = facingMode.jsValue
        object[Strings.resizeMode] = resizeMode.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.sampleSize] = sampleSize.jsValue
        object[Strings.echoCancellation] = echoCancellation.jsValue
        object[Strings.autoGainControl] = autoGainControl.jsValue
        object[Strings.noiseSuppression] = noiseSuppression.jsValue
        object[Strings.latency] = latency.jsValue
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.deviceId] = deviceId.jsValue
        object[Strings.groupId] = groupId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: Strings.aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: Strings.frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: Strings.facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: Strings.resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: Strings.sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: Strings.echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: Strings.autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: Strings.noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: Strings.latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: Strings.deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: Strings.groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: ULongRange

    @ReadWriteAttribute
    public var height: ULongRange

    @ReadWriteAttribute
    public var aspectRatio: DoubleRange

    @ReadWriteAttribute
    public var frameRate: DoubleRange

    @ReadWriteAttribute
    public var facingMode: [String]

    @ReadWriteAttribute
    public var resizeMode: [String]

    @ReadWriteAttribute
    public var sampleRate: ULongRange

    @ReadWriteAttribute
    public var sampleSize: ULongRange

    @ReadWriteAttribute
    public var echoCancellation: [Bool]

    @ReadWriteAttribute
    public var autoGainControl: [Bool]

    @ReadWriteAttribute
    public var noiseSuppression: [Bool]

    @ReadWriteAttribute
    public var latency: DoubleRange

    @ReadWriteAttribute
    public var channelCount: ULongRange

    @ReadWriteAttribute
    public var deviceId: String

    @ReadWriteAttribute
    public var groupId: String
}

public class MediaTrackConstraintSet: BridgedDictionary {
    public convenience init(width: ConstrainULong, height: ConstrainULong, aspectRatio: ConstrainDouble, frameRate: ConstrainDouble, facingMode: ConstrainDOMString, resizeMode: ConstrainDOMString, sampleRate: ConstrainULong, sampleSize: ConstrainULong, echoCancellation: ConstrainBoolean, autoGainControl: ConstrainBoolean, noiseSuppression: ConstrainBoolean, latency: ConstrainDouble, channelCount: ConstrainULong, deviceId: ConstrainDOMString, groupId: ConstrainDOMString) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.aspectRatio] = aspectRatio.jsValue
        object[Strings.frameRate] = frameRate.jsValue
        object[Strings.facingMode] = facingMode.jsValue
        object[Strings.resizeMode] = resizeMode.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.sampleSize] = sampleSize.jsValue
        object[Strings.echoCancellation] = echoCancellation.jsValue
        object[Strings.autoGainControl] = autoGainControl.jsValue
        object[Strings.noiseSuppression] = noiseSuppression.jsValue
        object[Strings.latency] = latency.jsValue
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.deviceId] = deviceId.jsValue
        object[Strings.groupId] = groupId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: Strings.aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: Strings.frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: Strings.facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: Strings.resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: Strings.sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: Strings.echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: Strings.autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: Strings.noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: Strings.latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: Strings.deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: Strings.groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: ConstrainULong

    @ReadWriteAttribute
    public var height: ConstrainULong

    @ReadWriteAttribute
    public var aspectRatio: ConstrainDouble

    @ReadWriteAttribute
    public var frameRate: ConstrainDouble

    @ReadWriteAttribute
    public var facingMode: ConstrainDOMString

    @ReadWriteAttribute
    public var resizeMode: ConstrainDOMString

    @ReadWriteAttribute
    public var sampleRate: ConstrainULong

    @ReadWriteAttribute
    public var sampleSize: ConstrainULong

    @ReadWriteAttribute
    public var echoCancellation: ConstrainBoolean

    @ReadWriteAttribute
    public var autoGainControl: ConstrainBoolean

    @ReadWriteAttribute
    public var noiseSuppression: ConstrainBoolean

    @ReadWriteAttribute
    public var latency: ConstrainDouble

    @ReadWriteAttribute
    public var channelCount: ConstrainULong

    @ReadWriteAttribute
    public var deviceId: ConstrainDOMString

    @ReadWriteAttribute
    public var groupId: ConstrainDOMString
}

public class MediaTrackConstraints: BridgedDictionary {
    public convenience init(advanced: [MediaTrackConstraintSet]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.advanced] = advanced.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _advanced = ReadWriteAttribute(jsObject: object, name: Strings.advanced)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var advanced: [MediaTrackConstraintSet]
}

public class MediaTrackSettings: BridgedDictionary {
    public convenience init(width: Int32, height: Int32, aspectRatio: Double, frameRate: Double, facingMode: String, resizeMode: String, sampleRate: Int32, sampleSize: Int32, echoCancellation: Bool, autoGainControl: Bool, noiseSuppression: Bool, latency: Double, channelCount: Int32, deviceId: String, groupId: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.aspectRatio] = aspectRatio.jsValue
        object[Strings.frameRate] = frameRate.jsValue
        object[Strings.facingMode] = facingMode.jsValue
        object[Strings.resizeMode] = resizeMode.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.sampleSize] = sampleSize.jsValue
        object[Strings.echoCancellation] = echoCancellation.jsValue
        object[Strings.autoGainControl] = autoGainControl.jsValue
        object[Strings.noiseSuppression] = noiseSuppression.jsValue
        object[Strings.latency] = latency.jsValue
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.deviceId] = deviceId.jsValue
        object[Strings.groupId] = groupId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: Strings.aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: Strings.frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: Strings.facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: Strings.resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: Strings.sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: Strings.echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: Strings.autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: Strings.noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: Strings.latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: Strings.deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: Strings.groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: Int32

    @ReadWriteAttribute
    public var height: Int32

    @ReadWriteAttribute
    public var aspectRatio: Double

    @ReadWriteAttribute
    public var frameRate: Double

    @ReadWriteAttribute
    public var facingMode: String

    @ReadWriteAttribute
    public var resizeMode: String

    @ReadWriteAttribute
    public var sampleRate: Int32

    @ReadWriteAttribute
    public var sampleSize: Int32

    @ReadWriteAttribute
    public var echoCancellation: Bool

    @ReadWriteAttribute
    public var autoGainControl: Bool

    @ReadWriteAttribute
    public var noiseSuppression: Bool

    @ReadWriteAttribute
    public var latency: Double

    @ReadWriteAttribute
    public var channelCount: Int32

    @ReadWriteAttribute
    public var deviceId: String

    @ReadWriteAttribute
    public var groupId: String
}

public class MediaTrackSupportedConstraints: BridgedDictionary {
    public convenience init(width: Bool, height: Bool, aspectRatio: Bool, frameRate: Bool, facingMode: Bool, resizeMode: Bool, sampleRate: Bool, sampleSize: Bool, echoCancellation: Bool, autoGainControl: Bool, noiseSuppression: Bool, latency: Bool, channelCount: Bool, deviceId: Bool, groupId: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.aspectRatio] = aspectRatio.jsValue
        object[Strings.frameRate] = frameRate.jsValue
        object[Strings.facingMode] = facingMode.jsValue
        object[Strings.resizeMode] = resizeMode.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        object[Strings.sampleSize] = sampleSize.jsValue
        object[Strings.echoCancellation] = echoCancellation.jsValue
        object[Strings.autoGainControl] = autoGainControl.jsValue
        object[Strings.noiseSuppression] = noiseSuppression.jsValue
        object[Strings.latency] = latency.jsValue
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.deviceId] = deviceId.jsValue
        object[Strings.groupId] = groupId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: Strings.aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: Strings.frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: Strings.facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: Strings.resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: Strings.sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: Strings.echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: Strings.autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: Strings.noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: Strings.latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: Strings.deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: Strings.groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: Bool

    @ReadWriteAttribute
    public var height: Bool

    @ReadWriteAttribute
    public var aspectRatio: Bool

    @ReadWriteAttribute
    public var frameRate: Bool

    @ReadWriteAttribute
    public var facingMode: Bool

    @ReadWriteAttribute
    public var resizeMode: Bool

    @ReadWriteAttribute
    public var sampleRate: Bool

    @ReadWriteAttribute
    public var sampleSize: Bool

    @ReadWriteAttribute
    public var echoCancellation: Bool

    @ReadWriteAttribute
    public var autoGainControl: Bool

    @ReadWriteAttribute
    public var noiseSuppression: Bool

    @ReadWriteAttribute
    public var latency: Bool

    @ReadWriteAttribute
    public var channelCount: Bool

    @ReadWriteAttribute
    public var deviceId: Bool

    @ReadWriteAttribute
    public var groupId: Bool
}

public class MessageChannel: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MessageChannel].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port1 = ReadonlyAttribute(jsObject: jsObject, name: Strings.port1)
        _port2 = ReadonlyAttribute(jsObject: jsObject, name: Strings.port2)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var port1: MessagePort

    @ReadonlyAttribute
    public var port2: MessagePort
}

public class MessageEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MessageEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: Strings.data)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: Strings.origin)
        _lastEventId = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastEventId)
        _source = ReadonlyAttribute(jsObject: jsObject, name: Strings.source)
        _ports = ReadonlyAttribute(jsObject: jsObject, name: Strings.ports)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MessageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var data: JSValue

    @ReadonlyAttribute
    public var origin: String

    @ReadonlyAttribute
    public var lastEventId: String

    @ReadonlyAttribute
    public var source: MessageEventSource?

    @ReadonlyAttribute
    public var ports: [MessagePort]

    @inlinable public func initMessageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, data: JSValue? = nil, origin: String? = nil, lastEventId: String? = nil, source: MessageEventSource? = nil, ports: [MessagePort]? = nil) {
        let _arg0 = type.jsValue
        let _arg1 = bubbles?.jsValue ?? .undefined
        let _arg2 = cancelable?.jsValue ?? .undefined
        let _arg3 = data?.jsValue ?? .undefined
        let _arg4 = origin?.jsValue ?? .undefined
        let _arg5 = lastEventId?.jsValue ?? .undefined
        let _arg6 = source?.jsValue ?? .undefined
        let _arg7 = ports?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.initMessageEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class MessageEventInit: BridgedDictionary {
    public convenience init(data: JSValue, origin: String, lastEventId: String, source: MessageEventSource?, ports: [MessagePort]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.data] = data.jsValue
        object[Strings.origin] = origin.jsValue
        object[Strings.lastEventId] = lastEventId.jsValue
        object[Strings.source] = source.jsValue
        object[Strings.ports] = ports.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: Strings.data)
        _origin = ReadWriteAttribute(jsObject: object, name: Strings.origin)
        _lastEventId = ReadWriteAttribute(jsObject: object, name: Strings.lastEventId)
        _source = ReadWriteAttribute(jsObject: object, name: Strings.source)
        _ports = ReadWriteAttribute(jsObject: object, name: Strings.ports)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: JSValue

    @ReadWriteAttribute
    public var origin: String

    @ReadWriteAttribute
    public var lastEventId: String

    @ReadWriteAttribute
    public var source: MessageEventSource?

    @ReadWriteAttribute
    public var ports: [MessagePort]
}

public class MessagePort: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MessagePort].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func start() {
        let this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class MimeType: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MimeType].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _description = ReadonlyAttribute(jsObject: jsObject, name: Strings.description)
        _suffixes = ReadonlyAttribute(jsObject: jsObject, name: Strings.suffixes)
        _enabledPlugin = ReadonlyAttribute(jsObject: jsObject, name: Strings.enabledPlugin)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var suffixes: String

    @ReadonlyAttribute
    public var enabledPlugin: Plugin
}

public class MimeTypeArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MimeTypeArray].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
}

public class MouseEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MouseEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _screenX = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenX)
        _screenY = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenY)
        _clientX = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientX)
        _clientY = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientY)
        _ctrlKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.ctrlKey)
        _shiftKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.shiftKey)
        _altKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.altKey)
        _metaKey = ReadonlyAttribute(jsObject: jsObject, name: Strings.metaKey)
        _button = ReadonlyAttribute(jsObject: jsObject, name: Strings.button)
        _buttons = ReadonlyAttribute(jsObject: jsObject, name: Strings.buttons)
        _relatedTarget = ReadonlyAttribute(jsObject: jsObject, name: Strings.relatedTarget)
        _pageX = ReadonlyAttribute(jsObject: jsObject, name: Strings.pageX)
        _pageY = ReadonlyAttribute(jsObject: jsObject, name: Strings.pageY)
        _x = ReadonlyAttribute(jsObject: jsObject, name: Strings.x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: Strings.y)
        _offsetX = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetX)
        _offsetY = ReadonlyAttribute(jsObject: jsObject, name: Strings.offsetY)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MouseEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var screenX: Int32

    @ReadonlyAttribute
    public var screenY: Int32

    @ReadonlyAttribute
    public var clientX: Int32

    @ReadonlyAttribute
    public var clientY: Int32

    @ReadonlyAttribute
    public var ctrlKey: Bool

    @ReadonlyAttribute
    public var shiftKey: Bool

    @ReadonlyAttribute
    public var altKey: Bool

    @ReadonlyAttribute
    public var metaKey: Bool

    @ReadonlyAttribute
    public var button: Int16

    @ReadonlyAttribute
    public var buttons: UInt16

    @ReadonlyAttribute
    public var relatedTarget: EventTarget?

    @inlinable public func getModifierState(keyArg: String) -> Bool {
        let this = jsObject
        return this[Strings.getModifierState].function!(this: this, arguments: [keyArg.jsValue]).fromJSValue()!
    }

    @inlinable public func initMouseEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, detailArg: Int32? = nil, screenXArg: Int32? = nil, screenYArg: Int32? = nil, clientXArg: Int32? = nil, clientYArg: Int32? = nil, ctrlKeyArg: Bool? = nil, altKeyArg: Bool? = nil, shiftKeyArg: Bool? = nil, metaKeyArg: Bool? = nil, buttonArg: Int16? = nil, relatedTargetArg: EventTarget? = nil) {
        let _arg0 = typeArg.jsValue
        let _arg1 = bubblesArg?.jsValue ?? .undefined
        let _arg2 = cancelableArg?.jsValue ?? .undefined
        let _arg3 = viewArg?.jsValue ?? .undefined
        let _arg4 = detailArg?.jsValue ?? .undefined
        let _arg5 = screenXArg?.jsValue ?? .undefined
        let _arg6 = screenYArg?.jsValue ?? .undefined
        let _arg7 = clientXArg?.jsValue ?? .undefined
        let _arg8 = clientYArg?.jsValue ?? .undefined
        let _arg9 = ctrlKeyArg?.jsValue ?? .undefined
        let _arg10 = altKeyArg?.jsValue ?? .undefined
        let _arg11 = shiftKeyArg?.jsValue ?? .undefined
        let _arg12 = metaKeyArg?.jsValue ?? .undefined
        let _arg13 = buttonArg?.jsValue ?? .undefined
        let _arg14 = relatedTargetArg?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.initMouseEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14])
    }

    @ReadonlyAttribute
    public var pageX: Double

    @ReadonlyAttribute
    public var pageY: Double

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var offsetX: Double

    @ReadonlyAttribute
    public var offsetY: Double
}

public class MouseEventInit: BridgedDictionary {
    public convenience init(screenX: Int32, screenY: Int32, clientX: Int32, clientY: Int32, button: Int16, buttons: UInt16, relatedTarget: EventTarget?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.screenX] = screenX.jsValue
        object[Strings.screenY] = screenY.jsValue
        object[Strings.clientX] = clientX.jsValue
        object[Strings.clientY] = clientY.jsValue
        object[Strings.button] = button.jsValue
        object[Strings.buttons] = buttons.jsValue
        object[Strings.relatedTarget] = relatedTarget.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _screenX = ReadWriteAttribute(jsObject: object, name: Strings.screenX)
        _screenY = ReadWriteAttribute(jsObject: object, name: Strings.screenY)
        _clientX = ReadWriteAttribute(jsObject: object, name: Strings.clientX)
        _clientY = ReadWriteAttribute(jsObject: object, name: Strings.clientY)
        _button = ReadWriteAttribute(jsObject: object, name: Strings.button)
        _buttons = ReadWriteAttribute(jsObject: object, name: Strings.buttons)
        _relatedTarget = ReadWriteAttribute(jsObject: object, name: Strings.relatedTarget)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var screenX: Int32

    @ReadWriteAttribute
    public var screenY: Int32

    @ReadWriteAttribute
    public var clientX: Int32

    @ReadWriteAttribute
    public var clientY: Int32

    @ReadWriteAttribute
    public var button: Int16

    @ReadWriteAttribute
    public var buttons: UInt16

    @ReadWriteAttribute
    public var relatedTarget: EventTarget?
}

public class MultiCacheQueryOptions: BridgedDictionary {
    public convenience init(cacheName: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.cacheName] = cacheName.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _cacheName = ReadWriteAttribute(jsObject: object, name: Strings.cacheName)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var cacheName: String
}

public class MutationEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.MutationEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _relatedNode = ReadonlyAttribute(jsObject: jsObject, name: Strings.relatedNode)
        _prevValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.prevValue)
        _newValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.newValue)
        _attrName = ReadonlyAttribute(jsObject: jsObject, name: Strings.attrName)
        _attrChange = ReadonlyAttribute(jsObject: jsObject, name: Strings.attrChange)
        super.init(unsafelyWrapping: jsObject)
    }

    public static let MODIFICATION: UInt16 = 1

    public static let ADDITION: UInt16 = 2

    public static let REMOVAL: UInt16 = 3

    @ReadonlyAttribute
    public var relatedNode: Node?

    @ReadonlyAttribute
    public var prevValue: String

    @ReadonlyAttribute
    public var newValue: String

    @ReadonlyAttribute
    public var attrName: String

    @ReadonlyAttribute
    public var attrChange: UInt16

    @inlinable public func initMutationEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, relatedNodeArg: Node? = nil, prevValueArg: String? = nil, newValueArg: String? = nil, attrNameArg: String? = nil, attrChangeArg: UInt16? = nil) {
        let _arg0 = typeArg.jsValue
        let _arg1 = bubblesArg?.jsValue ?? .undefined
        let _arg2 = cancelableArg?.jsValue ?? .undefined
        let _arg3 = relatedNodeArg?.jsValue ?? .undefined
        let _arg4 = prevValueArg?.jsValue ?? .undefined
        let _arg5 = newValueArg?.jsValue ?? .undefined
        let _arg6 = attrNameArg?.jsValue ?? .undefined
        let _arg7 = attrChangeArg?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.initMutationEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class MutationObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MutationObserver].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: constructor is ignored

    @inlinable public func observe(target: Node, options: MutationObserverInit? = nil) {
        let this = jsObject
        _ = this[Strings.observe].function!(this: this, arguments: [target.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func takeRecords() -> [MutationRecord] {
        let this = jsObject
        return this[Strings.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class MutationObserverInit: BridgedDictionary {
    public convenience init(childList: Bool, attributes: Bool, characterData: Bool, subtree: Bool, attributeOldValue: Bool, characterDataOldValue: Bool, attributeFilter: [String]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.childList] = childList.jsValue
        object[Strings.attributes] = attributes.jsValue
        object[Strings.characterData] = characterData.jsValue
        object[Strings.subtree] = subtree.jsValue
        object[Strings.attributeOldValue] = attributeOldValue.jsValue
        object[Strings.characterDataOldValue] = characterDataOldValue.jsValue
        object[Strings.attributeFilter] = attributeFilter.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _childList = ReadWriteAttribute(jsObject: object, name: Strings.childList)
        _attributes = ReadWriteAttribute(jsObject: object, name: Strings.attributes)
        _characterData = ReadWriteAttribute(jsObject: object, name: Strings.characterData)
        _subtree = ReadWriteAttribute(jsObject: object, name: Strings.subtree)
        _attributeOldValue = ReadWriteAttribute(jsObject: object, name: Strings.attributeOldValue)
        _characterDataOldValue = ReadWriteAttribute(jsObject: object, name: Strings.characterDataOldValue)
        _attributeFilter = ReadWriteAttribute(jsObject: object, name: Strings.attributeFilter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var childList: Bool

    @ReadWriteAttribute
    public var attributes: Bool

    @ReadWriteAttribute
    public var characterData: Bool

    @ReadWriteAttribute
    public var subtree: Bool

    @ReadWriteAttribute
    public var attributeOldValue: Bool

    @ReadWriteAttribute
    public var characterDataOldValue: Bool

    @ReadWriteAttribute
    public var attributeFilter: [String]
}

public class MutationRecord: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.MutationRecord].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: Strings.target)
        _addedNodes = ReadonlyAttribute(jsObject: jsObject, name: Strings.addedNodes)
        _removedNodes = ReadonlyAttribute(jsObject: jsObject, name: Strings.removedNodes)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: Strings.previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: Strings.nextSibling)
        _attributeName = ReadonlyAttribute(jsObject: jsObject, name: Strings.attributeName)
        _attributeNamespace = ReadonlyAttribute(jsObject: jsObject, name: Strings.attributeNamespace)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.oldValue)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: Node

    @ReadonlyAttribute
    public var addedNodes: NodeList

    @ReadonlyAttribute
    public var removedNodes: NodeList

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadonlyAttribute
    public var attributeName: String?

    @ReadonlyAttribute
    public var attributeNamespace: String?

    @ReadonlyAttribute
    public var oldValue: String?
}

public class NamedNodeMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.NamedNodeMap].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func getNamedItemNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[Strings.getNamedItemNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func setNamedItem(attr: Attr) -> Attr? {
        let this = jsObject
        return this[Strings.setNamedItem].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func setNamedItemNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[Strings.setNamedItemNS].function!(this: this, arguments: [attr.jsValue]).fromJSValue()!
    }

    @inlinable public func removeNamedItem(qualifiedName: String) -> Attr {
        let this = jsObject
        return this[Strings.removeNamedItem].function!(this: this, arguments: [qualifiedName.jsValue]).fromJSValue()!
    }

    @inlinable public func removeNamedItemNS(namespace: String?, localName: String) -> Attr {
        let this = jsObject
        return this[Strings.removeNamedItemNS].function!(this: this, arguments: [namespace.jsValue, localName.jsValue]).fromJSValue()!
    }
}

public class NavigationPreloadManager: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.NavigationPreloadManager].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func enable() -> JSPromise {
        let this = jsObject
        return this[Strings.enable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func enable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.enable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func disable() -> JSPromise {
        let this = jsObject
        return this[Strings.disable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func disable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.disable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func setHeaderValue(value: String) -> JSPromise {
        let this = jsObject
        return this[Strings.setHeaderValue].function!(this: this, arguments: [value.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func setHeaderValue(value: String) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.setHeaderValue].function!(this: this, arguments: [value.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getState() -> JSPromise {
        let this = jsObject
        return this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getState() async throws -> NavigationPreloadState {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class NavigationPreloadState: BridgedDictionary {
    public convenience init(enabled: Bool, headerValue: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.enabled] = enabled.jsValue
        object[Strings.headerValue] = headerValue.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _enabled = ReadWriteAttribute(jsObject: object, name: Strings.enabled)
        _headerValue = ReadWriteAttribute(jsObject: object, name: Strings.headerValue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadWriteAttribute
    public var headerValue: String
}

public class Navigator: JSBridgedClass, NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware, NavigatorGPU {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Navigator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _serviceWorker = ReadonlyAttribute(jsObject: jsObject, name: Strings.serviceWorker)
        _mediaDevices = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaDevices)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var serviceWorker: ServiceWorkerContainer

    @ReadonlyAttribute
    public var mediaDevices: MediaDevices

    // XXX: member 'getUserMedia' is ignored
}

public protocol NavigatorConcurrentHardware: JSBridgedClass {}
public extension NavigatorConcurrentHardware {
    @inlinable var hardwareConcurrency: UInt64 { ReadonlyAttribute[Strings.hardwareConcurrency, in: jsObject] }
}

public protocol NavigatorContentUtils: JSBridgedClass {}
public extension NavigatorContentUtils {
    @inlinable func registerProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[Strings.registerProtocolHandler].function!(this: this, arguments: [scheme.jsValue, url.jsValue])
    }

    @inlinable func unregisterProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[Strings.unregisterProtocolHandler].function!(this: this, arguments: [scheme.jsValue, url.jsValue])
    }
}

public protocol NavigatorCookies: JSBridgedClass {}
public extension NavigatorCookies {
    @inlinable var cookieEnabled: Bool { ReadonlyAttribute[Strings.cookieEnabled, in: jsObject] }
}

public protocol NavigatorGPU: JSBridgedClass {}
public extension NavigatorGPU {
    @inlinable var gpu: GPU { ReadonlyAttribute[Strings.gpu, in: jsObject] }
}

public protocol NavigatorID: JSBridgedClass {}
public extension NavigatorID {
    @inlinable var appCodeName: String { ReadonlyAttribute[Strings.appCodeName, in: jsObject] }

    @inlinable var appName: String { ReadonlyAttribute[Strings.appName, in: jsObject] }

    @inlinable var appVersion: String { ReadonlyAttribute[Strings.appVersion, in: jsObject] }

    @inlinable var platform: String { ReadonlyAttribute[Strings.platform, in: jsObject] }

    @inlinable var product: String { ReadonlyAttribute[Strings.product, in: jsObject] }

    @inlinable var productSub: String { ReadonlyAttribute[Strings.productSub, in: jsObject] }

    @inlinable var userAgent: String { ReadonlyAttribute[Strings.userAgent, in: jsObject] }

    @inlinable var vendor: String { ReadonlyAttribute[Strings.vendor, in: jsObject] }

    @inlinable var vendorSub: String { ReadonlyAttribute[Strings.vendorSub, in: jsObject] }

    @inlinable func taintEnabled() -> Bool {
        let this = jsObject
        return this[Strings.taintEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var oscpu: String { ReadonlyAttribute[Strings.oscpu, in: jsObject] }
}

public protocol NavigatorLanguage: JSBridgedClass {}
public extension NavigatorLanguage {
    @inlinable var language: String { ReadonlyAttribute[Strings.language, in: jsObject] }

    @inlinable var languages: [String] { ReadonlyAttribute[Strings.languages, in: jsObject] }
}

public protocol NavigatorOnLine: JSBridgedClass {}
public extension NavigatorOnLine {
    @inlinable var onLine: Bool { ReadonlyAttribute[Strings.onLine, in: jsObject] }
}

public protocol NavigatorPlugins: JSBridgedClass {}
public extension NavigatorPlugins {
    @inlinable var plugins: PluginArray { ReadonlyAttribute[Strings.plugins, in: jsObject] }

    @inlinable var mimeTypes: MimeTypeArray { ReadonlyAttribute[Strings.mimeTypes, in: jsObject] }

    @inlinable func javaEnabled() -> Bool {
        let this = jsObject
        return this[Strings.javaEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var pdfViewerEnabled: Bool { ReadonlyAttribute[Strings.pdfViewerEnabled, in: jsObject] }
}

public class Node: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Node].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _nodeType = ReadonlyAttribute(jsObject: jsObject, name: Strings.nodeType)
        _nodeName = ReadonlyAttribute(jsObject: jsObject, name: Strings.nodeName)
        _baseURI = ReadonlyAttribute(jsObject: jsObject, name: Strings.baseURI)
        _isConnected = ReadonlyAttribute(jsObject: jsObject, name: Strings.isConnected)
        _ownerDocument = ReadonlyAttribute(jsObject: jsObject, name: Strings.ownerDocument)
        _parentNode = ReadonlyAttribute(jsObject: jsObject, name: Strings.parentNode)
        _parentElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.parentElement)
        _childNodes = ReadonlyAttribute(jsObject: jsObject, name: Strings.childNodes)
        _firstChild = ReadonlyAttribute(jsObject: jsObject, name: Strings.firstChild)
        _lastChild = ReadonlyAttribute(jsObject: jsObject, name: Strings.lastChild)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: Strings.previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: Strings.nextSibling)
        _nodeValue = ReadWriteAttribute(jsObject: jsObject, name: Strings.nodeValue)
        _textContent = ReadWriteAttribute(jsObject: jsObject, name: Strings.textContent)
        super.init(unsafelyWrapping: jsObject)
    }

    public static let ELEMENT_NODE: UInt16 = 1

    public static let ATTRIBUTE_NODE: UInt16 = 2

    public static let TEXT_NODE: UInt16 = 3

    public static let CDATA_SECTION_NODE: UInt16 = 4

    public static let ENTITY_REFERENCE_NODE: UInt16 = 5

    public static let ENTITY_NODE: UInt16 = 6

    public static let PROCESSING_INSTRUCTION_NODE: UInt16 = 7

    public static let COMMENT_NODE: UInt16 = 8

    public static let DOCUMENT_NODE: UInt16 = 9

    public static let DOCUMENT_TYPE_NODE: UInt16 = 10

    public static let DOCUMENT_FRAGMENT_NODE: UInt16 = 11

    public static let NOTATION_NODE: UInt16 = 12

    @ReadonlyAttribute
    public var nodeType: UInt16

    @ReadonlyAttribute
    public var nodeName: String

    @ReadonlyAttribute
    public var baseURI: String

    @ReadonlyAttribute
    public var isConnected: Bool

    @ReadonlyAttribute
    public var ownerDocument: Document?

    @inlinable public func getRootNode(options: GetRootNodeOptions? = nil) -> Self {
        let this = jsObject
        return this[Strings.getRootNode].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var parentNode: Node?

    @ReadonlyAttribute
    public var parentElement: Element?

    @inlinable public func hasChildNodes() -> Bool {
        let this = jsObject
        return this[Strings.hasChildNodes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var childNodes: NodeList

    @ReadonlyAttribute
    public var firstChild: Node?

    @ReadonlyAttribute
    public var lastChild: Node?

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadWriteAttribute
    public var nodeValue: String?

    @ReadWriteAttribute
    public var textContent: String?

    @inlinable public func normalize() {
        let this = jsObject
        _ = this[Strings.normalize].function!(this: this, arguments: [])
    }

    @inlinable public func cloneNode(deep: Bool? = nil) -> Self {
        let this = jsObject
        return this[Strings.cloneNode].function!(this: this, arguments: [deep?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func isEqualNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[Strings.isEqualNode].function!(this: this, arguments: [otherNode.jsValue]).fromJSValue()!
    }

    @inlinable public func isSameNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[Strings.isSameNode].function!(this: this, arguments: [otherNode.jsValue]).fromJSValue()!
    }

    public static let DOCUMENT_POSITION_DISCONNECTED: UInt16 = 0x01

    public static let DOCUMENT_POSITION_PRECEDING: UInt16 = 0x02

    public static let DOCUMENT_POSITION_FOLLOWING: UInt16 = 0x04

    public static let DOCUMENT_POSITION_CONTAINS: UInt16 = 0x08

    public static let DOCUMENT_POSITION_CONTAINED_BY: UInt16 = 0x10

    public static let DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: UInt16 = 0x20

    @inlinable public func compareDocumentPosition(other: Node) -> UInt16 {
        let this = jsObject
        return this[Strings.compareDocumentPosition].function!(this: this, arguments: [other.jsValue]).fromJSValue()!
    }

    @inlinable public func contains(other: Node?) -> Bool {
        let this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [other.jsValue]).fromJSValue()!
    }

    @inlinable public func lookupPrefix(namespace: String?) -> String? {
        let this = jsObject
        return this[Strings.lookupPrefix].function!(this: this, arguments: [namespace.jsValue]).fromJSValue()!
    }

    @inlinable public func lookupNamespaceURI(prefix: String?) -> String? {
        let this = jsObject
        return this[Strings.lookupNamespaceURI].function!(this: this, arguments: [prefix.jsValue]).fromJSValue()!
    }

    @inlinable public func isDefaultNamespace(namespace: String?) -> Bool {
        let this = jsObject
        return this[Strings.isDefaultNamespace].function!(this: this, arguments: [namespace.jsValue]).fromJSValue()!
    }

    @inlinable public func insertBefore(node: Node, child: Node?) -> Self {
        let this = jsObject
        return this[Strings.insertBefore].function!(this: this, arguments: [node.jsValue, child.jsValue]).fromJSValue()!
    }

    @inlinable public func appendChild(node: Node) -> Self {
        let this = jsObject
        return this[Strings.appendChild].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public func replaceChild(node: Node, child: Node) -> Self {
        let this = jsObject
        return this[Strings.replaceChild].function!(this: this, arguments: [node.jsValue, child.jsValue]).fromJSValue()!
    }

    @inlinable public func removeChild(child: Node) -> Self {
        let this = jsObject
        return this[Strings.removeChild].function!(this: this, arguments: [child.jsValue]).fromJSValue()!
    }
}

public class NodeIterator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.NodeIterator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: Strings.root)
        _referenceNode = ReadonlyAttribute(jsObject: jsObject, name: Strings.referenceNode)
        _pointerBeforeReferenceNode = ReadonlyAttribute(jsObject: jsObject, name: Strings.pointerBeforeReferenceNode)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: Strings.whatToShow)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var referenceNode: Node

    @ReadonlyAttribute
    public var pointerBeforeReferenceNode: Bool

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[Strings.nextNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[Strings.previousNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[Strings.detach].function!(this: this, arguments: [])
    }
}

public class NodeList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.NodeList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> Node? {
        jsObject[key].fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32

    public typealias Element = Node
    public func makeIterator() -> ValueIterableIterator<NodeList> {
        ValueIterableIterator(sequence: self)
    }
}

public protocol NonDocumentTypeChildNode: JSBridgedClass {}
public extension NonDocumentTypeChildNode {
    @inlinable var previousElementSibling: Element? { ReadonlyAttribute[Strings.previousElementSibling, in: jsObject] }

    @inlinable var nextElementSibling: Element? { ReadonlyAttribute[Strings.nextElementSibling, in: jsObject] }
}

public protocol NonElementParentNode: JSBridgedClass {}
public extension NonElementParentNode {
    @inlinable func getElementById(elementId: String) -> Element? {
        let this = jsObject
        return this[Strings.getElementById].function!(this: this, arguments: [elementId.jsValue]).fromJSValue()!
    }
}

public class OfflineAudioCompletionEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.OfflineAudioCompletionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _renderedBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.renderedBuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: OfflineAudioCompletionEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var renderedBuffer: AudioBuffer
}

public class OfflineAudioCompletionEventInit: BridgedDictionary {
    public convenience init(renderedBuffer: AudioBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.renderedBuffer] = renderedBuffer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _renderedBuffer = ReadWriteAttribute(jsObject: object, name: Strings.renderedBuffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var renderedBuffer: AudioBuffer
}

public class OfflineAudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.OfflineAudioContext].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _oncomplete = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncomplete)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(contextOptions: OfflineAudioContextOptions) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [contextOptions.jsValue]))
    }

    @inlinable public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [numberOfChannels.jsValue, length.jsValue, sampleRate.jsValue]))
    }

    @inlinable public func startRendering() -> JSPromise {
        let this = jsObject
        return this[Strings.startRendering].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func startRendering() async throws -> AudioBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.startRendering].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func suspend(suspendTime: Double) -> JSPromise {
        let this = jsObject
        return this[Strings.suspend].function!(this: this, arguments: [suspendTime.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend(suspendTime: Double) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.suspend].function!(this: this, arguments: [suspendTime.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ClosureAttribute1Optional
    public var oncomplete: EventHandler
}

public class OfflineAudioContextOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.length] = length.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _length = ReadWriteAttribute(jsObject: object, name: Strings.length)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var sampleRate: Float
}

public class OffscreenCanvas: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.OffscreenCanvas].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: Strings.height)
        _oncontextlost = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncontextlost)
        _oncontextrestored = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncontextrestored)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(width: UInt64, height: UInt64) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [width.jsValue, height.jsValue]))
    }

    @ReadWriteAttribute
    public var width: UInt64

    @ReadWriteAttribute
    public var height: UInt64

    @inlinable public func getContext(contextId: OffscreenRenderingContextId, options: JSValue? = nil) -> OffscreenRenderingContext? {
        let this = jsObject
        return this[Strings.getContext].function!(this: this, arguments: [contextId.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func transferToImageBitmap() -> ImageBitmap {
        let this = jsObject
        return this[Strings.transferToImageBitmap].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.convertToBlob].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[Strings.convertToBlob].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var oncontextlost: EventHandler

    @ClosureAttribute1Optional
    public var oncontextrestored: EventHandler
}

public class OffscreenCanvasRenderingContext2D: JSBridgedClass, CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.OffscreenCanvasRenderingContext2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: Strings.canvas)
        self.jsObject = jsObject
    }

    @inlinable public func commit() {
        let this = jsObject
        _ = this[Strings.commit].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var canvas: OffscreenCanvas
}

public enum OffscreenRenderingContextId: JSString, JSValueCompatible {
    case _2d = "2d"
    case bitmaprenderer = "bitmaprenderer"
    case webgl = "webgl"
    case webgl2 = "webgl2"
    case webgpu = "webgpu"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class OptionalEffectTiming: BridgedDictionary {
    public convenience init(delay: Double, endDelay: Double, fill: FillMode, iterationStart: Double, iterations: Double, duration: Double_or_String, direction: PlaybackDirection, easing: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.delay] = delay.jsValue
        object[Strings.endDelay] = endDelay.jsValue
        object[Strings.fill] = fill.jsValue
        object[Strings.iterationStart] = iterationStart.jsValue
        object[Strings.iterations] = iterations.jsValue
        object[Strings.duration] = duration.jsValue
        object[Strings.direction] = direction.jsValue
        object[Strings.easing] = easing.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _delay = ReadWriteAttribute(jsObject: object, name: Strings.delay)
        _endDelay = ReadWriteAttribute(jsObject: object, name: Strings.endDelay)
        _fill = ReadWriteAttribute(jsObject: object, name: Strings.fill)
        _iterationStart = ReadWriteAttribute(jsObject: object, name: Strings.iterationStart)
        _iterations = ReadWriteAttribute(jsObject: object, name: Strings.iterations)
        _duration = ReadWriteAttribute(jsObject: object, name: Strings.duration)
        _direction = ReadWriteAttribute(jsObject: object, name: Strings.direction)
        _easing = ReadWriteAttribute(jsObject: object, name: Strings.easing)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var delay: Double

    @ReadWriteAttribute
    public var endDelay: Double

    @ReadWriteAttribute
    public var fill: FillMode

    @ReadWriteAttribute
    public var iterationStart: Double

    @ReadWriteAttribute
    public var iterations: Double

    @ReadWriteAttribute
    public var duration: Double_or_String

    @ReadWriteAttribute
    public var direction: PlaybackDirection

    @ReadWriteAttribute
    public var easing: String
}

public class OscillatorNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.OscillatorNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _frequency = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequency)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: OscillatorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var type: OscillatorType

    @ReadonlyAttribute
    public var frequency: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @inlinable public func setPeriodicWave(periodicWave: PeriodicWave) {
        let this = jsObject
        _ = this[Strings.setPeriodicWave].function!(this: this, arguments: [periodicWave.jsValue])
    }
}

public class OscillatorOptions: BridgedDictionary {
    public convenience init(type: OscillatorType, frequency: Float, detune: Float, periodicWave: PeriodicWave) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.frequency] = frequency.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.periodicWave] = periodicWave.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _frequency = ReadWriteAttribute(jsObject: object, name: Strings.frequency)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _periodicWave = ReadWriteAttribute(jsObject: object, name: Strings.periodicWave)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: OscillatorType

    @ReadWriteAttribute
    public var frequency: Float

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var periodicWave: PeriodicWave
}

public enum OscillatorType: JSString, JSValueCompatible {
    case sine = "sine"
    case square = "square"
    case sawtooth = "sawtooth"
    case triangle = "triangle"
    case custom = "custom"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum OverSampleType: JSString, JSValueCompatible {
    case none = "none"
    case _2x = "2x"
    case _4x = "4x"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class OverconstrainedError: DOMException {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.OverconstrainedError].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _constraint = ReadonlyAttribute(jsObject: jsObject, name: Strings.constraint)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(constraint: String, message: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [constraint.jsValue, message?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var constraint: String
}

public class PageTransitionEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.PageTransitionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _persisted = ReadonlyAttribute(jsObject: jsObject, name: Strings.persisted)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PageTransitionEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var persisted: Bool
}

public class PageTransitionEventInit: BridgedDictionary {
    public convenience init(persisted: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.persisted] = persisted.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _persisted = ReadWriteAttribute(jsObject: object, name: Strings.persisted)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var persisted: Bool
}

public class PannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.PannerNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _panningModel = ReadWriteAttribute(jsObject: jsObject, name: Strings.panningModel)
        _positionX = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionX)
        _positionY = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionY)
        _positionZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionZ)
        _orientationX = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationX)
        _orientationY = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationY)
        _orientationZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationZ)
        _distanceModel = ReadWriteAttribute(jsObject: jsObject, name: Strings.distanceModel)
        _refDistance = ReadWriteAttribute(jsObject: jsObject, name: Strings.refDistance)
        _maxDistance = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxDistance)
        _rolloffFactor = ReadWriteAttribute(jsObject: jsObject, name: Strings.rolloffFactor)
        _coneInnerAngle = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneInnerAngle)
        _coneOuterAngle = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneOuterAngle)
        _coneOuterGain = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneOuterGain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: PannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var panningModel: PanningModelType

    @ReadonlyAttribute
    public var positionX: AudioParam

    @ReadonlyAttribute
    public var positionY: AudioParam

    @ReadonlyAttribute
    public var positionZ: AudioParam

    @ReadonlyAttribute
    public var orientationX: AudioParam

    @ReadonlyAttribute
    public var orientationY: AudioParam

    @ReadonlyAttribute
    public var orientationZ: AudioParam

    @ReadWriteAttribute
    public var distanceModel: DistanceModelType

    @ReadWriteAttribute
    public var refDistance: Double

    @ReadWriteAttribute
    public var maxDistance: Double

    @ReadWriteAttribute
    public var rolloffFactor: Double

    @ReadWriteAttribute
    public var coneInnerAngle: Double

    @ReadWriteAttribute
    public var coneOuterAngle: Double

    @ReadWriteAttribute
    public var coneOuterGain: Double

    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setPosition].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable public func setOrientation(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setOrientation].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }
}

public class PannerOptions: BridgedDictionary {
    public convenience init(panningModel: PanningModelType, distanceModel: DistanceModelType, positionX: Float, positionY: Float, positionZ: Float, orientationX: Float, orientationY: Float, orientationZ: Float, refDistance: Double, maxDistance: Double, rolloffFactor: Double, coneInnerAngle: Double, coneOuterAngle: Double, coneOuterGain: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.panningModel] = panningModel.jsValue
        object[Strings.distanceModel] = distanceModel.jsValue
        object[Strings.positionX] = positionX.jsValue
        object[Strings.positionY] = positionY.jsValue
        object[Strings.positionZ] = positionZ.jsValue
        object[Strings.orientationX] = orientationX.jsValue
        object[Strings.orientationY] = orientationY.jsValue
        object[Strings.orientationZ] = orientationZ.jsValue
        object[Strings.refDistance] = refDistance.jsValue
        object[Strings.maxDistance] = maxDistance.jsValue
        object[Strings.rolloffFactor] = rolloffFactor.jsValue
        object[Strings.coneInnerAngle] = coneInnerAngle.jsValue
        object[Strings.coneOuterAngle] = coneOuterAngle.jsValue
        object[Strings.coneOuterGain] = coneOuterGain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _panningModel = ReadWriteAttribute(jsObject: object, name: Strings.panningModel)
        _distanceModel = ReadWriteAttribute(jsObject: object, name: Strings.distanceModel)
        _positionX = ReadWriteAttribute(jsObject: object, name: Strings.positionX)
        _positionY = ReadWriteAttribute(jsObject: object, name: Strings.positionY)
        _positionZ = ReadWriteAttribute(jsObject: object, name: Strings.positionZ)
        _orientationX = ReadWriteAttribute(jsObject: object, name: Strings.orientationX)
        _orientationY = ReadWriteAttribute(jsObject: object, name: Strings.orientationY)
        _orientationZ = ReadWriteAttribute(jsObject: object, name: Strings.orientationZ)
        _refDistance = ReadWriteAttribute(jsObject: object, name: Strings.refDistance)
        _maxDistance = ReadWriteAttribute(jsObject: object, name: Strings.maxDistance)
        _rolloffFactor = ReadWriteAttribute(jsObject: object, name: Strings.rolloffFactor)
        _coneInnerAngle = ReadWriteAttribute(jsObject: object, name: Strings.coneInnerAngle)
        _coneOuterAngle = ReadWriteAttribute(jsObject: object, name: Strings.coneOuterAngle)
        _coneOuterGain = ReadWriteAttribute(jsObject: object, name: Strings.coneOuterGain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var panningModel: PanningModelType

    @ReadWriteAttribute
    public var distanceModel: DistanceModelType

    @ReadWriteAttribute
    public var positionX: Float

    @ReadWriteAttribute
    public var positionY: Float

    @ReadWriteAttribute
    public var positionZ: Float

    @ReadWriteAttribute
    public var orientationX: Float

    @ReadWriteAttribute
    public var orientationY: Float

    @ReadWriteAttribute
    public var orientationZ: Float

    @ReadWriteAttribute
    public var refDistance: Double

    @ReadWriteAttribute
    public var maxDistance: Double

    @ReadWriteAttribute
    public var rolloffFactor: Double

    @ReadWriteAttribute
    public var coneInnerAngle: Double

    @ReadWriteAttribute
    public var coneOuterAngle: Double

    @ReadWriteAttribute
    public var coneOuterGain: Double
}

public enum PanningModelType: JSString, JSValueCompatible {
    case equalpower = "equalpower"
    case hRTF = "HRTF"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol ParentNode: JSBridgedClass {}
public extension ParentNode {
    @inlinable var children: HTMLCollection { ReadonlyAttribute[Strings.children, in: jsObject] }

    @inlinable var firstElementChild: Element? { ReadonlyAttribute[Strings.firstElementChild, in: jsObject] }

    @inlinable var lastElementChild: Element? { ReadonlyAttribute[Strings.lastElementChild, in: jsObject] }

    @inlinable var childElementCount: UInt32 { ReadonlyAttribute[Strings.childElementCount, in: jsObject] }

    @inlinable func prepend(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.prepend].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func append(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func replaceChildren(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[Strings.replaceChildren].function!(this: this, arguments: nodes.map(\.jsValue))
    }

    @inlinable func querySelector(selectors: String) -> Element? {
        let this = jsObject
        return this[Strings.querySelector].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }

    @inlinable func querySelectorAll(selectors: String) -> NodeList {
        let this = jsObject
        return this[Strings.querySelectorAll].function!(this: this, arguments: [selectors.jsValue]).fromJSValue()!
    }
}

public class Path2D: JSBridgedClass, CanvasPath {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Path2D].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(path: Path2D_or_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [path?.jsValue ?? .undefined]))
    }

    @inlinable public func addPath(path: Path2D, transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[Strings.addPath].function!(this: this, arguments: [path.jsValue, transform?.jsValue ?? .undefined])
    }
}

public class Performance: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Performance].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _timeOrigin = ReadonlyAttribute(jsObject: jsObject, name: Strings.timeOrigin)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func now() -> DOMHighResTimeStamp {
        let this = jsObject
        return this[Strings.now].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var timeOrigin: DOMHighResTimeStamp

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class PeriodicWave: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.PeriodicWave].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(context: BaseAudioContext, options: PeriodicWaveOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class PeriodicWaveConstraints: BridgedDictionary {
    public convenience init(disableNormalization: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.disableNormalization] = disableNormalization.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _disableNormalization = ReadWriteAttribute(jsObject: object, name: Strings.disableNormalization)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var disableNormalization: Bool
}

public class PeriodicWaveOptions: BridgedDictionary {
    public convenience init(real: [Float], imag: [Float]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.real] = real.jsValue
        object[Strings.imag] = imag.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _real = ReadWriteAttribute(jsObject: object, name: Strings.real)
        _imag = ReadWriteAttribute(jsObject: object, name: Strings.imag)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var real: [Float]

    @ReadWriteAttribute
    public var imag: [Float]
}

public class PlaneLayout: BridgedDictionary {
    public convenience init(offset: UInt32, stride: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        object[Strings.stride] = stride.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        _stride = ReadWriteAttribute(jsObject: object, name: Strings.stride)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: UInt32

    @ReadWriteAttribute
    public var stride: UInt32
}

public enum PlaybackDirection: JSString, JSValueCompatible {
    case normal = "normal"
    case reverse = "reverse"
    case alternate = "alternate"
    case alternateReverse = "alternate-reverse"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Plugin: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Plugin].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        _description = ReadonlyAttribute(jsObject: jsObject, name: Strings.description)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: Strings.filename)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
}

public class PluginArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.PluginArray].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @inlinable public func refresh() {
        let this = jsObject
        _ = this[Strings.refresh].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Plugin? {
        jsObject[key].fromJSValue()
    }

    @inlinable public subscript(key: String) -> Plugin? {
        jsObject[key].fromJSValue()
    }
}

public class PopStateEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.PopStateEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PopStateEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var state: JSValue
}

public class PopStateEventInit: BridgedDictionary {
    public convenience init(state: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.state] = state.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: Strings.state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue
}

public enum PredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"
    case displayP3 = "display-p3"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum PremultiplyAlpha: JSString, JSValueCompatible {
    case none = "none"
    case premultiply = "premultiply"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ProcessingInstruction: CharacterData {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ProcessingInstruction].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadonlyAttribute(jsObject: jsObject, name: Strings.target)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var target: String
}

public class ProgressEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ProgressEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _lengthComputable = ReadonlyAttribute(jsObject: jsObject, name: Strings.lengthComputable)
        _loaded = ReadonlyAttribute(jsObject: jsObject, name: Strings.loaded)
        _total = ReadonlyAttribute(jsObject: jsObject, name: Strings.total)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ProgressEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var lengthComputable: Bool

    @ReadonlyAttribute
    public var loaded: UInt64

    @ReadonlyAttribute
    public var total: UInt64
}

public class ProgressEventInit: BridgedDictionary {
    public convenience init(lengthComputable: Bool, loaded: UInt64, total: UInt64) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.lengthComputable] = lengthComputable.jsValue
        object[Strings.loaded] = loaded.jsValue
        object[Strings.total] = total.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lengthComputable = ReadWriteAttribute(jsObject: object, name: Strings.lengthComputable)
        _loaded = ReadWriteAttribute(jsObject: object, name: Strings.loaded)
        _total = ReadWriteAttribute(jsObject: object, name: Strings.total)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lengthComputable: Bool

    @ReadWriteAttribute
    public var loaded: UInt64

    @ReadWriteAttribute
    public var total: UInt64
}

public class PromiseRejectionEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.PromiseRejectionEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _promise = ReadonlyAttribute(jsObject: jsObject, name: Strings.promise)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: Strings.reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PromiseRejectionEventInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var promise: JSPromise

    @ReadonlyAttribute
    public var reason: JSValue
}

public class PromiseRejectionEventInit: BridgedDictionary {
    public convenience init(promise: JSPromise, reason: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.promise] = promise.jsValue
        object[Strings.reason] = reason.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _promise = ReadWriteAttribute(jsObject: object, name: Strings.promise)
        _reason = ReadWriteAttribute(jsObject: object, name: Strings.reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var promise: JSPromise

    @ReadWriteAttribute
    public var reason: JSValue
}

public class QueuingStrategy: BridgedDictionary {
    public convenience init(highWaterMark: Double, size: @escaping QueuingStrategySize) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.highWaterMark] = highWaterMark.jsValue
        ClosureAttribute1[Strings.size, in: object] = size
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _highWaterMark = ReadWriteAttribute(jsObject: object, name: Strings.highWaterMark)
        _size = ClosureAttribute1(jsObject: object, name: Strings.size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var highWaterMark: Double

    @ClosureAttribute1
    public var size: QueuingStrategySize
}

public class QueuingStrategyInit: BridgedDictionary {
    public convenience init(highWaterMark: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.highWaterMark] = highWaterMark.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _highWaterMark = ReadWriteAttribute(jsObject: object, name: Strings.highWaterMark)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var highWaterMark: Double
}

public class RadioNodeList: NodeList {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.RadioNodeList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var value: String
}

public class Range: AbstractRange {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Range].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _commonAncestorContainer = ReadonlyAttribute(jsObject: jsObject, name: Strings.commonAncestorContainer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ReadonlyAttribute
    public var commonAncestorContainer: Node

    @inlinable public func setStart(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[Strings.setStart].function!(this: this, arguments: [node.jsValue, offset.jsValue])
    }

    @inlinable public func setEnd(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[Strings.setEnd].function!(this: this, arguments: [node.jsValue, offset.jsValue])
    }

    @inlinable public func setStartBefore(node: Node) {
        let this = jsObject
        _ = this[Strings.setStartBefore].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setStartAfter(node: Node) {
        let this = jsObject
        _ = this[Strings.setStartAfter].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setEndBefore(node: Node) {
        let this = jsObject
        _ = this[Strings.setEndBefore].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func setEndAfter(node: Node) {
        let this = jsObject
        _ = this[Strings.setEndAfter].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func collapse(toStart: Bool? = nil) {
        let this = jsObject
        _ = this[Strings.collapse].function!(this: this, arguments: [toStart?.jsValue ?? .undefined])
    }

    @inlinable public func selectNode(node: Node) {
        let this = jsObject
        _ = this[Strings.selectNode].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func selectNodeContents(node: Node) {
        let this = jsObject
        _ = this[Strings.selectNodeContents].function!(this: this, arguments: [node.jsValue])
    }

    public static let START_TO_START: UInt16 = 0

    public static let START_TO_END: UInt16 = 1

    public static let END_TO_END: UInt16 = 2

    public static let END_TO_START: UInt16 = 3

    @inlinable public func compareBoundaryPoints(how: UInt16, sourceRange: Range) -> Int16 {
        let this = jsObject
        return this[Strings.compareBoundaryPoints].function!(this: this, arguments: [how.jsValue, sourceRange.jsValue]).fromJSValue()!
    }

    @inlinable public func deleteContents() {
        let this = jsObject
        _ = this[Strings.deleteContents].function!(this: this, arguments: [])
    }

    @inlinable public func extractContents() -> DocumentFragment {
        let this = jsObject
        return this[Strings.extractContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func cloneContents() -> DocumentFragment {
        let this = jsObject
        return this[Strings.cloneContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func insertNode(node: Node) {
        let this = jsObject
        _ = this[Strings.insertNode].function!(this: this, arguments: [node.jsValue])
    }

    @inlinable public func surroundContents(newParent: Node) {
        let this = jsObject
        _ = this[Strings.surroundContents].function!(this: this, arguments: [newParent.jsValue])
    }

    @inlinable public func cloneRange() -> Self {
        let this = jsObject
        return this[Strings.cloneRange].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[Strings.detach].function!(this: this, arguments: [])
    }

    @inlinable public func isPointInRange(node: Node, offset: UInt32) -> Bool {
        let this = jsObject
        return this[Strings.isPointInRange].function!(this: this, arguments: [node.jsValue, offset.jsValue]).fromJSValue()!
    }

    @inlinable public func comparePoint(node: Node, offset: UInt32) -> Int16 {
        let this = jsObject
        return this[Strings.comparePoint].function!(this: this, arguments: [node.jsValue, offset.jsValue]).fromJSValue()!
    }

    @inlinable public func intersectsNode(node: Node) -> Bool {
        let this = jsObject
        return this[Strings.intersectsNode].function!(this: this, arguments: [node.jsValue]).fromJSValue()!
    }

    @inlinable public var description: String {
        jsObject[Strings.toString]!().fromJSValue()!
    }

    @inlinable public func getClientRects() -> DOMRectList {
        let this = jsObject
        return this[Strings.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getBoundingClientRect() -> DOMRect {
        let this = jsObject
        return this[Strings.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ReadableByteStreamController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableByteStreamController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _byobRequest = ReadonlyAttribute(jsObject: jsObject, name: Strings.byobRequest)
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var byobRequest: ReadableStreamBYOBRequest?

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public func enqueue(chunk: ArrayBufferView) {
        let this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [chunk.jsValue])
    }

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [e?.jsValue ?? .undefined])
    }
}

public class ReadableStream: JSBridgedClass, AsyncSequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableStream].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _locked = ReadonlyAttribute(jsObject: jsObject, name: Strings.locked)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(underlyingSource: JSObject? = nil, strategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [underlyingSource?.jsValue ?? .undefined, strategy?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var locked: Bool

    @inlinable public func cancel(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.cancel].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func cancel(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.cancel].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getReader(options: ReadableStreamGetReaderOptions? = nil) -> ReadableStreamReader {
        let this = jsObject
        return this[Strings.getReader].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func pipeThrough(transform: ReadableWritablePair, options: StreamPipeOptions? = nil) -> Self {
        let this = jsObject
        return this[Strings.pipeThrough].function!(this: this, arguments: [transform.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func pipeTo(destination: WritableStream, options: StreamPipeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.pipeTo].function!(this: this, arguments: [destination.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func pipeTo(destination: WritableStream, options: StreamPipeOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.pipeTo].function!(this: this, arguments: [destination.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func tee() -> [ReadableStream] {
        let this = jsObject
        return this[Strings.tee].function!(this: this, arguments: []).fromJSValue()!
    }

    public typealias Element = JSValue
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func makeAsyncIterator() -> ValueIterableAsyncIterator<ReadableStream> {
        ValueIterableAsyncIterator(sequence: self)
    }
}

public class ReadableStreamBYOBReadResult: BridgedDictionary {
    public convenience init(value: ArrayBufferView?, done: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.value] = value.jsValue
        object[Strings.done] = done.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _value = ReadWriteAttribute(jsObject: object, name: Strings.value)
        _done = ReadWriteAttribute(jsObject: object, name: Strings.done)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var value: ArrayBufferView?

    @ReadWriteAttribute
    public var done: Bool
}

public class ReadableStreamBYOBReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableStreamBYOBReader].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: ReadableStream) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [stream.jsValue]))
    }

    @inlinable public func read(view: ArrayBufferView) -> JSPromise {
        let this = jsObject
        return this[Strings.read].function!(this: this, arguments: [view.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func read(view: ArrayBufferView) async throws -> ReadableStreamBYOBReadResult {
        let this = jsObject
        let _promise: JSPromise = this[Strings.read].function!(this: this, arguments: [view.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }
}

public class ReadableStreamBYOBRequest: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableStreamBYOBRequest].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _view = ReadonlyAttribute(jsObject: jsObject, name: Strings.view)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var view: ArrayBufferView?

    @inlinable public func respond(bytesWritten: UInt64) {
        let this = jsObject
        _ = this[Strings.respond].function!(this: this, arguments: [bytesWritten.jsValue])
    }

    @inlinable public func respondWithNewView(view: ArrayBufferView) {
        let this = jsObject
        _ = this[Strings.respondWithNewView].function!(this: this, arguments: [view.jsValue])
    }
}

public class ReadableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableStreamDefaultController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public func enqueue(chunk: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [chunk?.jsValue ?? .undefined])
    }

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [e?.jsValue ?? .undefined])
    }
}

public class ReadableStreamDefaultReadResult: BridgedDictionary {
    public convenience init(value: JSValue, done: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.value] = value.jsValue
        object[Strings.done] = done.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _value = ReadWriteAttribute(jsObject: object, name: Strings.value)
        _done = ReadWriteAttribute(jsObject: object, name: Strings.done)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var value: JSValue

    @ReadWriteAttribute
    public var done: Bool
}

public class ReadableStreamDefaultReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ReadableStreamDefaultReader].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: ReadableStream) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [stream.jsValue]))
    }

    @inlinable public func read() -> JSPromise {
        let this = jsObject
        return this[Strings.read].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func read() async throws -> ReadableStreamDefaultReadResult {
        let this = jsObject
        let _promise: JSPromise = this[Strings.read].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }
}

public protocol ReadableStreamGenericReader: JSBridgedClass {}
public extension ReadableStreamGenericReader {
    @inlinable var closed: JSPromise { ReadonlyAttribute[Strings.closed, in: jsObject] }

    @inlinable func cancel(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.cancel].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func cancel(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.cancel].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class ReadableStreamGetReaderOptions: BridgedDictionary {
    public convenience init(mode: ReadableStreamReaderMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = mode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: ReadableStreamReaderMode
}

public class ReadableStreamIteratorOptions: BridgedDictionary {
    public convenience init(preventCancel: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventCancel] = preventCancel.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventCancel = ReadWriteAttribute(jsObject: object, name: Strings.preventCancel)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventCancel: Bool
}

public enum ReadableStreamReaderMode: JSString, JSValueCompatible {
    case byob = "byob"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ReadableStreamType: JSString, JSValueCompatible {
    case bytes = "bytes"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ReadableWritablePair: BridgedDictionary {
    public convenience init(readable: ReadableStream, writable: WritableStream) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.readable] = readable.jsValue
        object[Strings.writable] = writable.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _readable = ReadWriteAttribute(jsObject: object, name: Strings.readable)
        _writable = ReadWriteAttribute(jsObject: object, name: Strings.writable)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var readable: ReadableStream

    @ReadWriteAttribute
    public var writable: WritableStream
}

public enum RecordingState: JSString, JSValueCompatible {
    case inactive = "inactive"
    case recording = "recording"
    case paused = "paused"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ReferrerPolicy: JSString, JSValueCompatible {
    case _empty = ""
    case noReferrer = "no-referrer"
    case noReferrerWhenDowngrade = "no-referrer-when-downgrade"
    case sameOrigin = "same-origin"
    case origin = "origin"
    case strictOrigin = "strict-origin"
    case originWhenCrossOrigin = "origin-when-cross-origin"
    case strictOriginWhenCrossOrigin = "strict-origin-when-cross-origin"
    case unsafeUrl = "unsafe-url"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RegistrationOptions: BridgedDictionary {
    public convenience init(scope: String, type: WorkerType, updateViaCache: ServiceWorkerUpdateViaCache) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.scope] = scope.jsValue
        object[Strings.type] = type.jsValue
        object[Strings.updateViaCache] = updateViaCache.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _scope = ReadWriteAttribute(jsObject: object, name: Strings.scope)
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _updateViaCache = ReadWriteAttribute(jsObject: object, name: Strings.updateViaCache)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache
}

public class Request: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Request].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _method = ReadonlyAttribute(jsObject: jsObject, name: Strings.method)
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: Strings.headers)
        _destination = ReadonlyAttribute(jsObject: jsObject, name: Strings.destination)
        _referrer = ReadonlyAttribute(jsObject: jsObject, name: Strings.referrer)
        _referrerPolicy = ReadonlyAttribute(jsObject: jsObject, name: Strings.referrerPolicy)
        _mode = ReadonlyAttribute(jsObject: jsObject, name: Strings.mode)
        _credentials = ReadonlyAttribute(jsObject: jsObject, name: Strings.credentials)
        _cache = ReadonlyAttribute(jsObject: jsObject, name: Strings.cache)
        _redirect = ReadonlyAttribute(jsObject: jsObject, name: Strings.redirect)
        _integrity = ReadonlyAttribute(jsObject: jsObject, name: Strings.integrity)
        _keepalive = ReadonlyAttribute(jsObject: jsObject, name: Strings.keepalive)
        _isReloadNavigation = ReadonlyAttribute(jsObject: jsObject, name: Strings.isReloadNavigation)
        _isHistoryNavigation = ReadonlyAttribute(jsObject: jsObject, name: Strings.isHistoryNavigation)
        _signal = ReadonlyAttribute(jsObject: jsObject, name: Strings.signal)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(input: RequestInfo, init: RequestInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [input.jsValue, `init`?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var method: String

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var headers: Headers

    @ReadonlyAttribute
    public var destination: RequestDestination

    @ReadonlyAttribute
    public var referrer: String

    @ReadonlyAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadonlyAttribute
    public var mode: RequestMode

    @ReadonlyAttribute
    public var credentials: RequestCredentials

    @ReadonlyAttribute
    public var cache: RequestCache

    @ReadonlyAttribute
    public var redirect: RequestRedirect

    @ReadonlyAttribute
    public var integrity: String

    @ReadonlyAttribute
    public var keepalive: Bool

    @ReadonlyAttribute
    public var isReloadNavigation: Bool

    @ReadonlyAttribute
    public var isHistoryNavigation: Bool

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum RequestCache: JSString, JSValueCompatible {
    case `default` = "default"
    case noStore = "no-store"
    case reload = "reload"
    case noCache = "no-cache"
    case forceCache = "force-cache"
    case onlyIfCached = "only-if-cached"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestCredentials: JSString, JSValueCompatible {
    case omit = "omit"
    case sameOrigin = "same-origin"
    case include = "include"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestDestination: JSString, JSValueCompatible {
    case _empty = ""
    case audio = "audio"
    case audioworklet = "audioworklet"
    case document = "document"
    case embed = "embed"
    case font = "font"
    case frame = "frame"
    case iframe = "iframe"
    case image = "image"
    case manifest = "manifest"
    case object = "object"
    case paintworklet = "paintworklet"
    case report = "report"
    case script = "script"
    case sharedworker = "sharedworker"
    case style = "style"
    case track = "track"
    case video = "video"
    case worker = "worker"
    case xslt = "xslt"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RequestInit: BridgedDictionary {
    public convenience init(method: String, headers: HeadersInit, body: BodyInit?, referrer: String, referrerPolicy: ReferrerPolicy, mode: RequestMode, credentials: RequestCredentials, cache: RequestCache, redirect: RequestRedirect, integrity: String, keepalive: Bool, signal: AbortSignal?, window: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.method] = method.jsValue
        object[Strings.headers] = headers.jsValue
        object[Strings.body] = body.jsValue
        object[Strings.referrer] = referrer.jsValue
        object[Strings.referrerPolicy] = referrerPolicy.jsValue
        object[Strings.mode] = mode.jsValue
        object[Strings.credentials] = credentials.jsValue
        object[Strings.cache] = cache.jsValue
        object[Strings.redirect] = redirect.jsValue
        object[Strings.integrity] = integrity.jsValue
        object[Strings.keepalive] = keepalive.jsValue
        object[Strings.signal] = signal.jsValue
        object[Strings.window] = window.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _method = ReadWriteAttribute(jsObject: object, name: Strings.method)
        _headers = ReadWriteAttribute(jsObject: object, name: Strings.headers)
        _body = ReadWriteAttribute(jsObject: object, name: Strings.body)
        _referrer = ReadWriteAttribute(jsObject: object, name: Strings.referrer)
        _referrerPolicy = ReadWriteAttribute(jsObject: object, name: Strings.referrerPolicy)
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        _credentials = ReadWriteAttribute(jsObject: object, name: Strings.credentials)
        _cache = ReadWriteAttribute(jsObject: object, name: Strings.cache)
        _redirect = ReadWriteAttribute(jsObject: object, name: Strings.redirect)
        _integrity = ReadWriteAttribute(jsObject: object, name: Strings.integrity)
        _keepalive = ReadWriteAttribute(jsObject: object, name: Strings.keepalive)
        _signal = ReadWriteAttribute(jsObject: object, name: Strings.signal)
        _window = ReadWriteAttribute(jsObject: object, name: Strings.window)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var headers: HeadersInit

    @ReadWriteAttribute
    public var body: BodyInit?

    @ReadWriteAttribute
    public var referrer: String

    @ReadWriteAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadWriteAttribute
    public var mode: RequestMode

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var cache: RequestCache

    @ReadWriteAttribute
    public var redirect: RequestRedirect

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var keepalive: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal?

    @ReadWriteAttribute
    public var window: JSValue
}

public enum RequestMode: JSString, JSValueCompatible {
    case navigate = "navigate"
    case sameOrigin = "same-origin"
    case noCors = "no-cors"
    case cors = "cors"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestRedirect: JSString, JSValueCompatible {
    case follow = "follow"
    case error = "error"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ResizeQuality: JSString, JSValueCompatible {
    case pixelated = "pixelated"
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Response: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Response].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _redirected = ReadonlyAttribute(jsObject: jsObject, name: Strings.redirected)
        _status = ReadonlyAttribute(jsObject: jsObject, name: Strings.status)
        _ok = ReadonlyAttribute(jsObject: jsObject, name: Strings.ok)
        _statusText = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusText)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: Strings.headers)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(body: BodyInit? = nil, init: ResponseInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [body?.jsValue ?? .undefined, `init`?.jsValue ?? .undefined]))
    }

    @inlinable public static func error() -> Self {
        let this = constructor
        return this[Strings.error].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public static func redirect(url: String, status: UInt16? = nil) -> Self {
        let this = constructor
        return this[Strings.redirect].function!(this: this, arguments: [url.jsValue, status?.jsValue ?? .undefined]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var type: ResponseType

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var redirected: Bool

    @ReadonlyAttribute
    public var status: UInt16

    @ReadonlyAttribute
    public var ok: Bool

    @ReadonlyAttribute
    public var statusText: String

    @ReadonlyAttribute
    public var headers: Headers

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ResponseInit: BridgedDictionary {
    public convenience init(status: UInt16, statusText: String, headers: HeadersInit) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.status] = status.jsValue
        object[Strings.statusText] = statusText.jsValue
        object[Strings.headers] = headers.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _status = ReadWriteAttribute(jsObject: object, name: Strings.status)
        _statusText = ReadWriteAttribute(jsObject: object, name: Strings.statusText)
        _headers = ReadWriteAttribute(jsObject: object, name: Strings.headers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var status: UInt16

    @ReadWriteAttribute
    public var statusText: String

    @ReadWriteAttribute
    public var headers: HeadersInit
}

public enum ResponseType: JSString, JSValueCompatible {
    case basic = "basic"
    case cors = "cors"
    case `default` = "default"
    case error = "error"
    case opaque = "opaque"
    case opaqueredirect = "opaqueredirect"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Screen: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Screen].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _availWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.availWidth)
        _availHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.availHeight)
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: Strings.height)
        _colorDepth = ReadonlyAttribute(jsObject: jsObject, name: Strings.colorDepth)
        _pixelDepth = ReadonlyAttribute(jsObject: jsObject, name: Strings.pixelDepth)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var availWidth: Int32

    @ReadonlyAttribute
    public var availHeight: Int32

    @ReadonlyAttribute
    public var width: Int32

    @ReadonlyAttribute
    public var height: Int32

    @ReadonlyAttribute
    public var colorDepth: UInt32

    @ReadonlyAttribute
    public var pixelDepth: UInt32
}

public class ScriptProcessorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ScriptProcessorNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onaudioprocess = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaudioprocess)
        _bufferSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.bufferSize)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onaudioprocess: EventHandler

    @ReadonlyAttribute
    public var bufferSize: Int32
}

public enum ScrollBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case smooth = "smooth"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollIntoViewOptions: BridgedDictionary {
    public convenience init(block: ScrollLogicalPosition, inline: ScrollLogicalPosition) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.block] = block.jsValue
        object[Strings.inline] = inline.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _block = ReadWriteAttribute(jsObject: object, name: Strings.block)
        _inline = ReadWriteAttribute(jsObject: object, name: Strings.inline)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var block: ScrollLogicalPosition

    @ReadWriteAttribute
    public var inline: ScrollLogicalPosition
}

public enum ScrollLogicalPosition: JSString, JSValueCompatible {
    case start = "start"
    case center = "center"
    case end = "end"
    case nearest = "nearest"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollOptions: BridgedDictionary {
    public convenience init(behavior: ScrollBehavior) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.behavior] = behavior.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _behavior = ReadWriteAttribute(jsObject: object, name: Strings.behavior)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var behavior: ScrollBehavior
}

public enum ScrollRestoration: JSString, JSValueCompatible {
    case auto = "auto"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollToOptions: BridgedDictionary {
    public convenience init(left: Double, top: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.left] = left.jsValue
        object[Strings.top] = top.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _left = ReadWriteAttribute(jsObject: object, name: Strings.left)
        _top = ReadWriteAttribute(jsObject: object, name: Strings.top)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var left: Double

    @ReadWriteAttribute
    public var top: Double
}

public enum SelectionMode: JSString, JSValueCompatible {
    case select = "select"
    case start = "start"
    case end = "end"
    case preserve = "preserve"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ServiceWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ServiceWorker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _scriptURL = ReadonlyAttribute(jsObject: jsObject, name: Strings.scriptURL)
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _onstatechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var scriptURL: String

    @ReadonlyAttribute
    public var state: ServiceWorkerState

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @ClosureAttribute1Optional
    public var onstatechange: EventHandler
}

public class ServiceWorkerContainer: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ServiceWorkerContainer].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _controller = ReadonlyAttribute(jsObject: jsObject, name: Strings.controller)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: Strings.ready)
        _oncontrollerchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncontrollerchange)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var controller: ServiceWorker?

    @ReadonlyAttribute
    public var ready: JSPromise

    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.register].function!(this: this, arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) async throws -> ServiceWorkerRegistration {
        let this = jsObject
        let _promise: JSPromise = this[Strings.register].function!(this: this, arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistration(clientURL: String? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.getRegistration].function!(this: this, arguments: [clientURL?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistration(clientURL: String? = nil) async throws -> ServiceWorkerRegistration? {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getRegistration].function!(this: this, arguments: [clientURL?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistrations() -> JSPromise {
        let this = jsObject
        return this[Strings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistrations() async throws -> [ServiceWorkerRegistration] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func startMessages() {
        let this = jsObject
        _ = this[Strings.startMessages].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var oncontrollerchange: EventHandler

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class ServiceWorkerRegistration: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ServiceWorkerRegistration].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _installing = ReadonlyAttribute(jsObject: jsObject, name: Strings.installing)
        _waiting = ReadonlyAttribute(jsObject: jsObject, name: Strings.waiting)
        _active = ReadonlyAttribute(jsObject: jsObject, name: Strings.active)
        _navigationPreload = ReadonlyAttribute(jsObject: jsObject, name: Strings.navigationPreload)
        _scope = ReadonlyAttribute(jsObject: jsObject, name: Strings.scope)
        _updateViaCache = ReadonlyAttribute(jsObject: jsObject, name: Strings.updateViaCache)
        _onupdatefound = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onupdatefound)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var installing: ServiceWorker?

    @ReadonlyAttribute
    public var waiting: ServiceWorker?

    @ReadonlyAttribute
    public var active: ServiceWorker?

    @ReadonlyAttribute
    public var navigationPreload: NavigationPreloadManager

    @ReadonlyAttribute
    public var scope: String

    @ReadonlyAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache

    @inlinable public func update() -> JSPromise {
        let this = jsObject
        return this[Strings.update].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func update() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.update].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func unregister() -> JSPromise {
        let this = jsObject
        return this[Strings.unregister].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func unregister() async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[Strings.unregister].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onupdatefound: EventHandler
}

public enum ServiceWorkerState: JSString, JSValueCompatible {
    case parsed = "parsed"
    case installing = "installing"
    case installed = "installed"
    case activating = "activating"
    case activated = "activated"
    case redundant = "redundant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ServiceWorkerUpdateViaCache: JSString, JSValueCompatible {
    case imports = "imports"
    case all = "all"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ShadowRoot: DocumentFragment, DocumentOrShadowRoot {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.ShadowRoot].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mode = ReadonlyAttribute(jsObject: jsObject, name: Strings.mode)
        _delegatesFocus = ReadonlyAttribute(jsObject: jsObject, name: Strings.delegatesFocus)
        _slotAssignment = ReadonlyAttribute(jsObject: jsObject, name: Strings.slotAssignment)
        _host = ReadonlyAttribute(jsObject: jsObject, name: Strings.host)
        _onslotchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onslotchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var mode: ShadowRootMode

    @ReadonlyAttribute
    public var delegatesFocus: Bool

    @ReadonlyAttribute
    public var slotAssignment: SlotAssignmentMode

    @ReadonlyAttribute
    public var host: Element

    @ClosureAttribute1Optional
    public var onslotchange: EventHandler
}

public class ShadowRootInit: BridgedDictionary {
    public convenience init(mode: ShadowRootMode, delegatesFocus: Bool, slotAssignment: SlotAssignmentMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = mode.jsValue
        object[Strings.delegatesFocus] = delegatesFocus.jsValue
        object[Strings.slotAssignment] = slotAssignment.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: Strings.mode)
        _delegatesFocus = ReadWriteAttribute(jsObject: object, name: Strings.delegatesFocus)
        _slotAssignment = ReadWriteAttribute(jsObject: object, name: Strings.slotAssignment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: ShadowRootMode

    @ReadWriteAttribute
    public var delegatesFocus: Bool

    @ReadWriteAttribute
    public var slotAssignment: SlotAssignmentMode
}

public enum ShadowRootMode: JSString, JSValueCompatible {
    case open = "open"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class SharedWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.SharedWorker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port = ReadonlyAttribute(jsObject: jsObject, name: Strings.port)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: String_or_WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var port: MessagePort
}

public enum SlotAssignmentMode: JSString, JSValueCompatible {
    case manual = "manual"
    case named = "named"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol Slottable: JSBridgedClass {}
public extension Slottable {
    @inlinable var assignedSlot: HTMLSlotElement? { ReadonlyAttribute[Strings.assignedSlot, in: jsObject] }
}

public class StaticRange: AbstractRange {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.StaticRange].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: StaticRangeInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }
}

public class StaticRangeInit: BridgedDictionary {
    public convenience init(startContainer: Node, startOffset: UInt32, endContainer: Node, endOffset: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.startContainer] = startContainer.jsValue
        object[Strings.startOffset] = startOffset.jsValue
        object[Strings.endContainer] = endContainer.jsValue
        object[Strings.endOffset] = endOffset.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _startContainer = ReadWriteAttribute(jsObject: object, name: Strings.startContainer)
        _startOffset = ReadWriteAttribute(jsObject: object, name: Strings.startOffset)
        _endContainer = ReadWriteAttribute(jsObject: object, name: Strings.endContainer)
        _endOffset = ReadWriteAttribute(jsObject: object, name: Strings.endOffset)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var startContainer: Node

    @ReadWriteAttribute
    public var startOffset: UInt32

    @ReadWriteAttribute
    public var endContainer: Node

    @ReadWriteAttribute
    public var endOffset: UInt32
}

public class StereoPannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.StereoPannerNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _pan = ReadonlyAttribute(jsObject: jsObject, name: Strings.pan)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: StereoPannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var pan: AudioParam
}

public class StereoPannerOptions: BridgedDictionary {
    public convenience init(pan: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.pan] = pan.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _pan = ReadWriteAttribute(jsObject: object, name: Strings.pan)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var pan: Float
}

public class Storage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Storage].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func key(index: UInt32) -> String? {
        let this = jsObject
        return this[Strings.key].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }

    @inlinable public subscript(key: String) -> String? {
        jsObject[key].fromJSValue()
    }

    // XXX: unsupported setter for keys of type String

    // XXX: unsupported deleter for keys of type String

    @inlinable public func clear() {
        let this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }
}

public class StorageEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.StorageEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _key = ReadonlyAttribute(jsObject: jsObject, name: Strings.key)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.oldValue)
        _newValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.newValue)
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _storageArea = ReadonlyAttribute(jsObject: jsObject, name: Strings.storageArea)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: StorageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var key: String?

    @ReadonlyAttribute
    public var oldValue: String?

    @ReadonlyAttribute
    public var newValue: String?

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var storageArea: Storage?

    @inlinable public func initStorageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, key: String? = nil, oldValue: String? = nil, newValue: String? = nil, url: String? = nil, storageArea: Storage? = nil) {
        let _arg0 = type.jsValue
        let _arg1 = bubbles?.jsValue ?? .undefined
        let _arg2 = cancelable?.jsValue ?? .undefined
        let _arg3 = key?.jsValue ?? .undefined
        let _arg4 = oldValue?.jsValue ?? .undefined
        let _arg5 = newValue?.jsValue ?? .undefined
        let _arg6 = url?.jsValue ?? .undefined
        let _arg7 = storageArea?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.initStorageEvent].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class StorageEventInit: BridgedDictionary {
    public convenience init(key: String?, oldValue: String?, newValue: String?, url: String, storageArea: Storage?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.key] = key.jsValue
        object[Strings.oldValue] = oldValue.jsValue
        object[Strings.newValue] = newValue.jsValue
        object[Strings.url] = url.jsValue
        object[Strings.storageArea] = storageArea.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _key = ReadWriteAttribute(jsObject: object, name: Strings.key)
        _oldValue = ReadWriteAttribute(jsObject: object, name: Strings.oldValue)
        _newValue = ReadWriteAttribute(jsObject: object, name: Strings.newValue)
        _url = ReadWriteAttribute(jsObject: object, name: Strings.url)
        _storageArea = ReadWriteAttribute(jsObject: object, name: Strings.storageArea)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var key: String?

    @ReadWriteAttribute
    public var oldValue: String?

    @ReadWriteAttribute
    public var newValue: String?

    @ReadWriteAttribute
    public var url: String

    @ReadWriteAttribute
    public var storageArea: Storage?
}

public class StreamPipeOptions: BridgedDictionary {
    public convenience init(preventClose: Bool, preventAbort: Bool, preventCancel: Bool, signal: AbortSignal) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventClose] = preventClose.jsValue
        object[Strings.preventAbort] = preventAbort.jsValue
        object[Strings.preventCancel] = preventCancel.jsValue
        object[Strings.signal] = signal.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventClose = ReadWriteAttribute(jsObject: object, name: Strings.preventClose)
        _preventAbort = ReadWriteAttribute(jsObject: object, name: Strings.preventAbort)
        _preventCancel = ReadWriteAttribute(jsObject: object, name: Strings.preventCancel)
        _signal = ReadWriteAttribute(jsObject: object, name: Strings.signal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventClose: Bool

    @ReadWriteAttribute
    public var preventAbort: Bool

    @ReadWriteAttribute
    public var preventCancel: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal
}

public class StructuredSerializeOptions: BridgedDictionary {
    public convenience init(transfer: [JSObject]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.transfer] = transfer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _transfer = ReadWriteAttribute(jsObject: object, name: Strings.transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var transfer: [JSObject]
}

public class SubmitEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.SubmitEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _submitter = ReadonlyAttribute(jsObject: jsObject, name: Strings.submitter)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: SubmitEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var submitter: HTMLElement?
}

public class SubmitEventInit: BridgedDictionary {
    public convenience init(submitter: HTMLElement?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.submitter] = submitter.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _submitter = ReadWriteAttribute(jsObject: object, name: Strings.submitter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var submitter: HTMLElement?
}

public class SvcOutputMetadata: BridgedDictionary {
    public convenience init(temporalLayerId: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.temporalLayerId] = temporalLayerId.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _temporalLayerId = ReadWriteAttribute(jsObject: object, name: Strings.temporalLayerId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var temporalLayerId: UInt32
}

public class Text: CharacterData, Slottable, GeometryUtils {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Text].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wholeText = ReadonlyAttribute(jsObject: jsObject, name: Strings.wholeText)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data?.jsValue ?? .undefined]))
    }

    @inlinable public func splitText(offset: UInt32) -> Self {
        let this = jsObject
        return this[Strings.splitText].function!(this: this, arguments: [offset.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var wholeText: String
}

public class TextMetrics: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TextMetrics].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: Strings.width)
        _actualBoundingBoxLeft = ReadonlyAttribute(jsObject: jsObject, name: Strings.actualBoundingBoxLeft)
        _actualBoundingBoxRight = ReadonlyAttribute(jsObject: jsObject, name: Strings.actualBoundingBoxRight)
        _fontBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: Strings.fontBoundingBoxAscent)
        _fontBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: Strings.fontBoundingBoxDescent)
        _actualBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: Strings.actualBoundingBoxAscent)
        _actualBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: Strings.actualBoundingBoxDescent)
        _emHeightAscent = ReadonlyAttribute(jsObject: jsObject, name: Strings.emHeightAscent)
        _emHeightDescent = ReadonlyAttribute(jsObject: jsObject, name: Strings.emHeightDescent)
        _hangingBaseline = ReadonlyAttribute(jsObject: jsObject, name: Strings.hangingBaseline)
        _alphabeticBaseline = ReadonlyAttribute(jsObject: jsObject, name: Strings.alphabeticBaseline)
        _ideographicBaseline = ReadonlyAttribute(jsObject: jsObject, name: Strings.ideographicBaseline)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var actualBoundingBoxLeft: Double

    @ReadonlyAttribute
    public var actualBoundingBoxRight: Double

    @ReadonlyAttribute
    public var fontBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var fontBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var emHeightAscent: Double

    @ReadonlyAttribute
    public var emHeightDescent: Double

    @ReadonlyAttribute
    public var hangingBaseline: Double

    @ReadonlyAttribute
    public var alphabeticBaseline: Double

    @ReadonlyAttribute
    public var ideographicBaseline: Double
}

public class TextTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.TextTrack].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: Strings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: Strings.language)
        _id = ReadonlyAttribute(jsObject: jsObject, name: Strings.id)
        _inBandMetadataTrackDispatchType = ReadonlyAttribute(jsObject: jsObject, name: Strings.inBandMetadataTrackDispatchType)
        _mode = ReadWriteAttribute(jsObject: jsObject, name: Strings.mode)
        _cues = ReadonlyAttribute(jsObject: jsObject, name: Strings.cues)
        _activeCues = ReadonlyAttribute(jsObject: jsObject, name: Strings.activeCues)
        _oncuechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncuechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var kind: TextTrackKind

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var inBandMetadataTrackDispatchType: String

    @ReadWriteAttribute
    public var mode: TextTrackMode

    @ReadonlyAttribute
    public var cues: TextTrackCueList?

    @ReadonlyAttribute
    public var activeCues: TextTrackCueList?

    @inlinable public func addCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[Strings.addCue].function!(this: this, arguments: [cue.jsValue])
    }

    @inlinable public func removeCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[Strings.removeCue].function!(this: this, arguments: [cue.jsValue])
    }

    @ClosureAttribute1Optional
    public var oncuechange: EventHandler
}

public class TextTrackCue: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.TextTrackCue].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: Strings.track)
        _id = ReadWriteAttribute(jsObject: jsObject, name: Strings.id)
        _startTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.startTime)
        _endTime = ReadWriteAttribute(jsObject: jsObject, name: Strings.endTime)
        _pauseOnExit = ReadWriteAttribute(jsObject: jsObject, name: Strings.pauseOnExit)
        _onenter = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onenter)
        _onexit = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onexit)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var track: TextTrack?

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var startTime: Double

    @ReadWriteAttribute
    public var endTime: Double

    @ReadWriteAttribute
    public var pauseOnExit: Bool

    @ClosureAttribute1Optional
    public var onenter: EventHandler

    @ClosureAttribute1Optional
    public var onexit: EventHandler
}

public class TextTrackCueList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TextTrackCueList].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrackCue {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getCueById(id: String) -> TextTrackCue? {
        let this = jsObject
        return this[Strings.getCueById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }
}

public enum TextTrackKind: JSString, JSValueCompatible {
    case subtitles = "subtitles"
    case captions = "captions"
    case descriptions = "descriptions"
    case chapters = "chapters"
    case metadata = "metadata"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TextTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.TextTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> TextTrack? {
        let this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public enum TextTrackMode: JSString, JSValueCompatible {
    case disabled = "disabled"
    case hidden = "hidden"
    case showing = "showing"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TimeRanges: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TimeRanges].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func start(index: UInt32) -> Double {
        let this = jsObject
        return this[Strings.start].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }

    @inlinable public func end(index: UInt32) -> Double {
        let this = jsObject
        return this[Strings.end].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }
}

public enum TimelinePhase: JSString, JSValueCompatible {
    case inactive = "inactive"
    case before = "before"
    case active = "active"
    case after = "after"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TrackEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.TrackEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: Strings.track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: TrackEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public class TrackEventInit: BridgedDictionary {
    public convenience init(track: AudioTrack_or_TextTrack_or_VideoTrack?) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.track] = track.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _track = ReadWriteAttribute(jsObject: object, name: Strings.track)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public class TransformStream: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TransformStream].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readable = ReadonlyAttribute(jsObject: jsObject, name: Strings.readable)
        _writable = ReadonlyAttribute(jsObject: jsObject, name: Strings.writable)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(transformer: JSObject? = nil, writableStrategy: QueuingStrategy? = nil, readableStrategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [transformer?.jsValue ?? .undefined, writableStrategy?.jsValue ?? .undefined, readableStrategy?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var readable: ReadableStream

    @ReadonlyAttribute
    public var writable: WritableStream
}

public class TransformStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TransformStreamDefaultController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func enqueue(chunk: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [chunk?.jsValue ?? .undefined])
    }

    @inlinable public func error(reason: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [reason?.jsValue ?? .undefined])
    }

    @inlinable public func terminate() {
        let this = jsObject
        _ = this[Strings.terminate].function!(this: this, arguments: [])
    }
}

public class Transformer: BridgedDictionary {
    public convenience init(start: @escaping TransformerStartCallback, transform: @escaping TransformerTransformCallback, flush: @escaping TransformerFlushCallback, readableType: JSValue, writableType: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute1[Strings.start, in: object] = start
        ClosureAttribute2[Strings.transform, in: object] = transform
        ClosureAttribute1[Strings.flush, in: object] = flush
        object[Strings.readableType] = readableType.jsValue
        object[Strings.writableType] = writableType.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: Strings.start)
        _transform = ClosureAttribute2(jsObject: object, name: Strings.transform)
        _flush = ClosureAttribute1(jsObject: object, name: Strings.flush)
        _readableType = ReadWriteAttribute(jsObject: object, name: Strings.readableType)
        _writableType = ReadWriteAttribute(jsObject: object, name: Strings.writableType)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: TransformerStartCallback

    @ClosureAttribute2
    public var transform: TransformerTransformCallback

    @ClosureAttribute1
    public var flush: TransformerFlushCallback

    @ReadWriteAttribute
    public var readableType: JSValue

    @ReadWriteAttribute
    public var writableType: JSValue
}

public class TreeWalker: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.TreeWalker].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: Strings.root)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: Strings.whatToShow)
        _currentNode = ReadWriteAttribute(jsObject: jsObject, name: Strings.currentNode)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @ReadWriteAttribute
    public var currentNode: Node

    @inlinable public func parentNode() -> Node? {
        let this = jsObject
        return this[Strings.parentNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func firstChild() -> Node? {
        let this = jsObject
        return this[Strings.firstChild].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func lastChild() -> Node? {
        let this = jsObject
        return this[Strings.lastChild].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousSibling() -> Node? {
        let this = jsObject
        return this[Strings.previousSibling].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func nextSibling() -> Node? {
        let this = jsObject
        return this[Strings.nextSibling].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[Strings.previousNode].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[Strings.nextNode].function!(this: this, arguments: []).fromJSValue()!
    }
}

public typealias CanvasFilterInput = [String: JSValue]

public typealias EventHandler = EventHandlerNonNull?
public typealias OnErrorEventHandler = OnErrorEventHandlerNonNull?
public typealias OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?

public typealias DOMHighResTimeStamp = Double
public typealias EpochTimeStamp = UInt64

public typealias DOMTimeStamp = UInt64

public typealias GLenum = UInt32
public typealias GLboolean = Bool
public typealias GLbitfield = UInt32
public typealias GLbyte = Int8
public typealias GLshort = Int16
public typealias GLint = Int32
public typealias GLsizei = Int32
public typealias GLsizeiptr = Int64
public typealias GLubyte = UInt8
public typealias GLushort = UInt16
public typealias GLuint = UInt32
public typealias GLfloat = Float
public typealias GLclampf = Float

public typealias GLint64 = Int64
public typealias GLuint64 = UInt64

public typealias GPUBufferUsageFlags = UInt32
public typealias GPUMapModeFlags = UInt32
public typealias GPUTextureUsageFlags = UInt32
public typealias GPUShaderStageFlags = UInt32

public typealias GPUPipelineConstantValue = Double
public typealias GPUColorWriteFlags = UInt32
public typealias GPUComputePassTimestampWrites = [GPUComputePassTimestampWrite]
public typealias GPURenderPassTimestampWrites = [GPURenderPassTimestampWrite]

public typealias GPUBufferDynamicOffset = UInt32
public typealias GPUStencilValue = UInt32
public typealias GPUSampleMask = UInt32
public typealias GPUDepthBias = Int32
public typealias GPUSize64 = UInt64
public typealias GPUIntegerCoordinate = UInt32
public typealias GPUIndex32 = UInt32
public typealias GPUSize32 = UInt32
public typealias GPUSignedOffset32 = Int32
public typealias GPUFlagsConstant = UInt32

public typealias MutationCallback = ([MutationRecord], MutationObserver) -> Void
public typealias BlobCallback = (Blob?) -> Void
public typealias FunctionStringCallback = (String) -> Void
public typealias EventHandlerNonNull = (Event) -> JSValue
public typealias OnErrorEventHandlerNonNull = (Event_or_String, String, UInt32, UInt32, JSValue) -> JSValue
public typealias OnBeforeUnloadEventHandlerNonNull = (Event) -> String?
public typealias FrameRequestCallback = (DOMHighResTimeStamp) -> Void
public typealias VoidFunction = () -> Void
public typealias UnderlyingSourceStartCallback = (ReadableStreamController) -> JSValue
public typealias UnderlyingSourcePullCallback = (ReadableStreamController) -> JSPromise
public typealias UnderlyingSourceCancelCallback = (JSValue) -> JSPromise
public typealias UnderlyingSinkStartCallback = (WritableStreamDefaultController) -> JSValue
public typealias UnderlyingSinkWriteCallback = (JSValue, WritableStreamDefaultController) -> JSPromise
public typealias UnderlyingSinkCloseCallback = () -> JSPromise
public typealias UnderlyingSinkAbortCallback = (JSValue) -> JSPromise
public typealias TransformerStartCallback = (TransformStreamDefaultController) -> JSValue
public typealias TransformerFlushCallback = (TransformStreamDefaultController) -> JSPromise
public typealias TransformerTransformCallback = (JSValue, TransformStreamDefaultController) -> JSPromise
public typealias QueuingStrategySize = (JSValue) -> Double
public typealias DecodeErrorCallback = (DOMException) -> Void
public typealias DecodeSuccessCallback = (AudioBuffer) -> Void
public typealias AudioWorkletProcessCallback = ([[Float32Array]], [[Float32Array]], JSObject) -> Bool
public typealias NavigatorUserMediaSuccessCallback = (MediaStream) -> Void
public typealias NavigatorUserMediaErrorCallback = (DOMException) -> Void
public typealias AudioDataOutputCallback = (AudioData) -> Void
public typealias VideoFrameOutputCallback = (VideoFrame) -> Void
public typealias EncodedAudioChunkOutputCallback = (EncodedAudioChunk, EncodedAudioChunkMetadata) -> Void
public typealias EncodedVideoChunkOutputCallback = (EncodedVideoChunk, EncodedVideoChunkMetadata) -> Void
public typealias WebCodecsErrorCallback = (DOMException) -> Void
public class UIEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.UIEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _view = ReadonlyAttribute(jsObject: jsObject, name: Strings.view)
        _detail = ReadonlyAttribute(jsObject: jsObject, name: Strings.detail)
        _which = ReadonlyAttribute(jsObject: jsObject, name: Strings.which)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: UIEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var view: Window?

    @ReadonlyAttribute
    public var detail: Int32

    @inlinable public func initUIEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, detailArg: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.initUIEvent].function!(this: this, arguments: [typeArg.jsValue, bubblesArg?.jsValue ?? .undefined, cancelableArg?.jsValue ?? .undefined, viewArg?.jsValue ?? .undefined, detailArg?.jsValue ?? .undefined])
    }

    @ReadonlyAttribute
    public var which: UInt32
}

public class UIEventInit: BridgedDictionary {
    public convenience init(view: Window?, detail: Int32, which: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = view.jsValue
        object[Strings.detail] = detail.jsValue
        object[Strings.which] = which.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: Strings.view)
        _detail = ReadWriteAttribute(jsObject: object, name: Strings.detail)
        _which = ReadWriteAttribute(jsObject: object, name: Strings.which)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: Window?

    @ReadWriteAttribute
    public var detail: Int32

    @ReadWriteAttribute
    public var which: UInt32
}

public class ULongRange: BridgedDictionary {
    public convenience init(max: UInt32, min: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = max.jsValue
        object[Strings.min] = min.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _max = ReadWriteAttribute(jsObject: object, name: Strings.max)
        _min = ReadWriteAttribute(jsObject: object, name: Strings.min)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var max: UInt32

    @ReadWriteAttribute
    public var min: UInt32
}

public class URL: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.URL].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: Strings.href)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: Strings.origin)
        _protocol = ReadWriteAttribute(jsObject: jsObject, name: Strings.protocol)
        _username = ReadWriteAttribute(jsObject: jsObject, name: Strings.username)
        _password = ReadWriteAttribute(jsObject: jsObject, name: Strings.password)
        _host = ReadWriteAttribute(jsObject: jsObject, name: Strings.host)
        _hostname = ReadWriteAttribute(jsObject: jsObject, name: Strings.hostname)
        _port = ReadWriteAttribute(jsObject: jsObject, name: Strings.port)
        _pathname = ReadWriteAttribute(jsObject: jsObject, name: Strings.pathname)
        _search = ReadWriteAttribute(jsObject: jsObject, name: Strings.search)
        _searchParams = ReadonlyAttribute(jsObject: jsObject, name: Strings.searchParams)
        _hash = ReadWriteAttribute(jsObject: jsObject, name: Strings.hash)
        self.jsObject = jsObject
    }

    @inlinable public static func createObjectURL(obj: Blob_or_MediaSource) -> String {
        let this = constructor
        return this[Strings.createObjectURL].function!(this: this, arguments: [obj.jsValue]).fromJSValue()!
    }

    @inlinable public static func revokeObjectURL(url: String) {
        let this = constructor
        _ = this[Strings.revokeObjectURL].function!(this: this, arguments: [url.jsValue])
    }

    @inlinable public convenience init(url: String, base: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [url.jsValue, base?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadonlyAttribute
    public var origin: String

    @ReadWriteAttribute
    public var `protocol`: String

    @ReadWriteAttribute
    public var username: String

    @ReadWriteAttribute
    public var password: String

    @ReadWriteAttribute
    public var host: String

    @ReadWriteAttribute
    public var hostname: String

    @ReadWriteAttribute
    public var port: String

    @ReadWriteAttribute
    public var pathname: String

    @ReadWriteAttribute
    public var search: String

    @ReadonlyAttribute
    public var searchParams: URLSearchParams

    @ReadWriteAttribute
    public var hash: String

    @inlinable public func toJSON() -> String {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class URLSearchParams: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.URLSearchParams].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: String_or_record_String_to_String_or_seq_of_seq_of_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [name.jsValue])
    }

    @inlinable public func get(name: String) -> String? {
        let this = jsObject
        return this[Strings.get].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func getAll(name: String) -> [String] {
        let this = jsObject
        return this[Strings.getAll].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[Strings.has].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @inlinable public func sort() {
        let this = jsObject
        _ = this[Strings.sort].function!(this: this, arguments: [])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<URLSearchParams> {
        ValueIterableIterator(sequence: self)
    }

    @inlinable public var description: String {
        jsObject[Strings.toString]!().fromJSValue()!
    }
}

public class UnderlyingSink: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSinkStartCallback, write: @escaping UnderlyingSinkWriteCallback, close: @escaping UnderlyingSinkCloseCallback, abort: @escaping UnderlyingSinkAbortCallback, type: JSValue) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute1[Strings.start, in: object] = start
        ClosureAttribute2[Strings.write, in: object] = write
        ClosureAttribute0[Strings.close, in: object] = close
        ClosureAttribute1[Strings.abort, in: object] = abort
        object[Strings.type] = type.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: Strings.start)
        _write = ClosureAttribute2(jsObject: object, name: Strings.write)
        _close = ClosureAttribute0(jsObject: object, name: Strings.close)
        _abort = ClosureAttribute1(jsObject: object, name: Strings.abort)
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: UnderlyingSinkStartCallback

    @ClosureAttribute2
    public var write: UnderlyingSinkWriteCallback

    @ClosureAttribute0
    public var close: UnderlyingSinkCloseCallback

    @ClosureAttribute1
    public var abort: UnderlyingSinkAbortCallback

    @ReadWriteAttribute
    public var type: JSValue
}

public class UnderlyingSource: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSourceStartCallback, pull: @escaping UnderlyingSourcePullCallback, cancel: @escaping UnderlyingSourceCancelCallback, type: ReadableStreamType, autoAllocateChunkSize: UInt64) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute1[Strings.start, in: object] = start
        ClosureAttribute1[Strings.pull, in: object] = pull
        ClosureAttribute1[Strings.cancel, in: object] = cancel
        object[Strings.type] = type.jsValue
        object[Strings.autoAllocateChunkSize] = autoAllocateChunkSize.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: Strings.start)
        _pull = ClosureAttribute1(jsObject: object, name: Strings.pull)
        _cancel = ClosureAttribute1(jsObject: object, name: Strings.cancel)
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _autoAllocateChunkSize = ReadWriteAttribute(jsObject: object, name: Strings.autoAllocateChunkSize)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: UnderlyingSourceStartCallback

    @ClosureAttribute1
    public var pull: UnderlyingSourcePullCallback

    @ClosureAttribute1
    public var cancel: UnderlyingSourceCancelCallback

    @ReadWriteAttribute
    public var type: ReadableStreamType

    @ReadWriteAttribute
    public var autoAllocateChunkSize: UInt64
}

public class ValidityState: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.ValidityState].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _valueMissing = ReadonlyAttribute(jsObject: jsObject, name: Strings.valueMissing)
        _typeMismatch = ReadonlyAttribute(jsObject: jsObject, name: Strings.typeMismatch)
        _patternMismatch = ReadonlyAttribute(jsObject: jsObject, name: Strings.patternMismatch)
        _tooLong = ReadonlyAttribute(jsObject: jsObject, name: Strings.tooLong)
        _tooShort = ReadonlyAttribute(jsObject: jsObject, name: Strings.tooShort)
        _rangeUnderflow = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeUnderflow)
        _rangeOverflow = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeOverflow)
        _stepMismatch = ReadonlyAttribute(jsObject: jsObject, name: Strings.stepMismatch)
        _badInput = ReadonlyAttribute(jsObject: jsObject, name: Strings.badInput)
        _customError = ReadonlyAttribute(jsObject: jsObject, name: Strings.customError)
        _valid = ReadonlyAttribute(jsObject: jsObject, name: Strings.valid)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var valueMissing: Bool

    @ReadonlyAttribute
    public var typeMismatch: Bool

    @ReadonlyAttribute
    public var patternMismatch: Bool

    @ReadonlyAttribute
    public var tooLong: Bool

    @ReadonlyAttribute
    public var tooShort: Bool

    @ReadonlyAttribute
    public var rangeUnderflow: Bool

    @ReadonlyAttribute
    public var rangeOverflow: Bool

    @ReadonlyAttribute
    public var stepMismatch: Bool

    @ReadonlyAttribute
    public var badInput: Bool

    @ReadonlyAttribute
    public var customError: Bool

    @ReadonlyAttribute
    public var valid: Bool
}

public class ValidityStateFlags: BridgedDictionary {
    public convenience init(valueMissing: Bool, typeMismatch: Bool, patternMismatch: Bool, tooLong: Bool, tooShort: Bool, rangeUnderflow: Bool, rangeOverflow: Bool, stepMismatch: Bool, badInput: Bool, customError: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.valueMissing] = valueMissing.jsValue
        object[Strings.typeMismatch] = typeMismatch.jsValue
        object[Strings.patternMismatch] = patternMismatch.jsValue
        object[Strings.tooLong] = tooLong.jsValue
        object[Strings.tooShort] = tooShort.jsValue
        object[Strings.rangeUnderflow] = rangeUnderflow.jsValue
        object[Strings.rangeOverflow] = rangeOverflow.jsValue
        object[Strings.stepMismatch] = stepMismatch.jsValue
        object[Strings.badInput] = badInput.jsValue
        object[Strings.customError] = customError.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _valueMissing = ReadWriteAttribute(jsObject: object, name: Strings.valueMissing)
        _typeMismatch = ReadWriteAttribute(jsObject: object, name: Strings.typeMismatch)
        _patternMismatch = ReadWriteAttribute(jsObject: object, name: Strings.patternMismatch)
        _tooLong = ReadWriteAttribute(jsObject: object, name: Strings.tooLong)
        _tooShort = ReadWriteAttribute(jsObject: object, name: Strings.tooShort)
        _rangeUnderflow = ReadWriteAttribute(jsObject: object, name: Strings.rangeUnderflow)
        _rangeOverflow = ReadWriteAttribute(jsObject: object, name: Strings.rangeOverflow)
        _stepMismatch = ReadWriteAttribute(jsObject: object, name: Strings.stepMismatch)
        _badInput = ReadWriteAttribute(jsObject: object, name: Strings.badInput)
        _customError = ReadWriteAttribute(jsObject: object, name: Strings.customError)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var valueMissing: Bool

    @ReadWriteAttribute
    public var typeMismatch: Bool

    @ReadWriteAttribute
    public var patternMismatch: Bool

    @ReadWriteAttribute
    public var tooLong: Bool

    @ReadWriteAttribute
    public var tooShort: Bool

    @ReadWriteAttribute
    public var rangeUnderflow: Bool

    @ReadWriteAttribute
    public var rangeOverflow: Bool

    @ReadWriteAttribute
    public var stepMismatch: Bool

    @ReadWriteAttribute
    public var badInput: Bool

    @ReadWriteAttribute
    public var customError: Bool
}

public enum VideoColorPrimaries: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoColorSpace: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.VideoColorSpace].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _primaries = ReadonlyAttribute(jsObject: jsObject, name: Strings.primaries)
        _transfer = ReadonlyAttribute(jsObject: jsObject, name: Strings.transfer)
        _matrix = ReadonlyAttribute(jsObject: jsObject, name: Strings.matrix)
        _fullRange = ReadonlyAttribute(jsObject: jsObject, name: Strings.fullRange)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: VideoColorSpaceInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var primaries: VideoColorPrimaries?

    @ReadonlyAttribute
    public var transfer: VideoTransferCharacteristics?

    @ReadonlyAttribute
    public var matrix: VideoMatrixCoefficients?

    @ReadonlyAttribute
    public var fullRange: Bool?

    @inlinable public func toJSON() -> VideoColorSpaceInit {
        let this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class VideoColorSpaceInit: BridgedDictionary {
    public convenience init(primaries: VideoColorPrimaries, transfer: VideoTransferCharacteristics, matrix: VideoMatrixCoefficients, fullRange: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.primaries] = primaries.jsValue
        object[Strings.transfer] = transfer.jsValue
        object[Strings.matrix] = matrix.jsValue
        object[Strings.fullRange] = fullRange.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _primaries = ReadWriteAttribute(jsObject: object, name: Strings.primaries)
        _transfer = ReadWriteAttribute(jsObject: object, name: Strings.transfer)
        _matrix = ReadWriteAttribute(jsObject: object, name: Strings.matrix)
        _fullRange = ReadWriteAttribute(jsObject: object, name: Strings.fullRange)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var primaries: VideoColorPrimaries

    @ReadWriteAttribute
    public var transfer: VideoTransferCharacteristics

    @ReadWriteAttribute
    public var matrix: VideoMatrixCoefficients

    @ReadWriteAttribute
    public var fullRange: Bool
}

public class VideoDecoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.VideoDecoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _decodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.decodeQueueSize)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: VideoDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var decodeQueueSize: UInt32

    @inlinable public func configure(config: VideoDecoderConfig) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [config.jsValue])
    }

    @inlinable public func decode(chunk: EncodedVideoChunk) {
        let this = jsObject
        _ = this[Strings.decode].function!(this: this, arguments: [chunk.jsValue])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public static func isConfigSupported(config: VideoDecoderConfig) -> JSPromise {
        let this = constructor
        return this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public static func isConfigSupported(config: VideoDecoderConfig) async throws -> VideoDecoderSupport {
        let this = constructor
        let _promise: JSPromise = this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class VideoDecoderConfig: BridgedDictionary {
    public convenience init(codec: String, description: BufferSource, codedWidth: UInt32, codedHeight: UInt32, displayAspectWidth: UInt32, displayAspectHeight: UInt32, colorSpace: VideoColorSpaceInit, hardwareAcceleration: HardwareAcceleration, optimizeForLatency: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = codec.jsValue
        object[Strings.description] = description.jsValue
        object[Strings.codedWidth] = codedWidth.jsValue
        object[Strings.codedHeight] = codedHeight.jsValue
        object[Strings.displayAspectWidth] = displayAspectWidth.jsValue
        object[Strings.displayAspectHeight] = displayAspectHeight.jsValue
        object[Strings.colorSpace] = colorSpace.jsValue
        object[Strings.hardwareAcceleration] = hardwareAcceleration.jsValue
        object[Strings.optimizeForLatency] = optimizeForLatency.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: Strings.codec)
        _description = ReadWriteAttribute(jsObject: object, name: Strings.description)
        _codedWidth = ReadWriteAttribute(jsObject: object, name: Strings.codedWidth)
        _codedHeight = ReadWriteAttribute(jsObject: object, name: Strings.codedHeight)
        _displayAspectWidth = ReadWriteAttribute(jsObject: object, name: Strings.displayAspectWidth)
        _displayAspectHeight = ReadWriteAttribute(jsObject: object, name: Strings.displayAspectHeight)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        _hardwareAcceleration = ReadWriteAttribute(jsObject: object, name: Strings.hardwareAcceleration)
        _optimizeForLatency = ReadWriteAttribute(jsObject: object, name: Strings.optimizeForLatency)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var description: BufferSource

    @ReadWriteAttribute
    public var codedWidth: UInt32

    @ReadWriteAttribute
    public var codedHeight: UInt32

    @ReadWriteAttribute
    public var displayAspectWidth: UInt32

    @ReadWriteAttribute
    public var displayAspectHeight: UInt32

    @ReadWriteAttribute
    public var colorSpace: VideoColorSpaceInit

    @ReadWriteAttribute
    public var hardwareAcceleration: HardwareAcceleration

    @ReadWriteAttribute
    public var optimizeForLatency: Bool
}

public class VideoDecoderInit: BridgedDictionary {
    public convenience init(output: @escaping VideoFrameOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute1Void[Strings.output, in: object] = output
        ClosureAttribute1Void[Strings.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute1Void(jsObject: object, name: Strings.output)
        _error = ClosureAttribute1Void(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1Void
    public var output: VideoFrameOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class VideoDecoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: VideoDecoderConfig) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = supported.jsValue
        object[Strings.config] = config.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: Strings.supported)
        _config = ReadWriteAttribute(jsObject: object, name: Strings.config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: VideoDecoderConfig
}

public class VideoEncoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.VideoEncoder].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _encodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.encodeQueueSize)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: VideoEncoderInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [`init`.jsValue]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var encodeQueueSize: UInt32

    @inlinable public func configure(config: VideoEncoderConfig) {
        let this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [config.jsValue])
    }

    @inlinable public func encode(frame: VideoFrame, options: VideoEncoderEncodeOptions? = nil) {
        let this = jsObject
        _ = this[Strings.encode].function!(this: this, arguments: [frame.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public static func isConfigSupported(config: VideoEncoderConfig) -> JSPromise {
        let this = constructor
        return this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public static func isConfigSupported(config: VideoEncoderConfig) async throws -> VideoEncoderSupport {
        let this = constructor
        let _promise: JSPromise = this[Strings.isConfigSupported].function!(this: this, arguments: [config.jsValue]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class VideoEncoderConfig: BridgedDictionary {
    public convenience init(codec: String, width: UInt32, height: UInt32, displayWidth: UInt32, displayHeight: UInt32, bitrate: UInt64, framerate: Double, hardwareAcceleration: HardwareAcceleration, alpha: AlphaOption, scalabilityMode: String, bitrateMode: BitrateMode, latencyMode: LatencyMode) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = codec.jsValue
        object[Strings.width] = width.jsValue
        object[Strings.height] = height.jsValue
        object[Strings.displayWidth] = displayWidth.jsValue
        object[Strings.displayHeight] = displayHeight.jsValue
        object[Strings.bitrate] = bitrate.jsValue
        object[Strings.framerate] = framerate.jsValue
        object[Strings.hardwareAcceleration] = hardwareAcceleration.jsValue
        object[Strings.alpha] = alpha.jsValue
        object[Strings.scalabilityMode] = scalabilityMode.jsValue
        object[Strings.bitrateMode] = bitrateMode.jsValue
        object[Strings.latencyMode] = latencyMode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: Strings.codec)
        _width = ReadWriteAttribute(jsObject: object, name: Strings.width)
        _height = ReadWriteAttribute(jsObject: object, name: Strings.height)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: Strings.displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: Strings.displayHeight)
        _bitrate = ReadWriteAttribute(jsObject: object, name: Strings.bitrate)
        _framerate = ReadWriteAttribute(jsObject: object, name: Strings.framerate)
        _hardwareAcceleration = ReadWriteAttribute(jsObject: object, name: Strings.hardwareAcceleration)
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        _scalabilityMode = ReadWriteAttribute(jsObject: object, name: Strings.scalabilityMode)
        _bitrateMode = ReadWriteAttribute(jsObject: object, name: Strings.bitrateMode)
        _latencyMode = ReadWriteAttribute(jsObject: object, name: Strings.latencyMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32

    @ReadWriteAttribute
    public var bitrate: UInt64

    @ReadWriteAttribute
    public var framerate: Double

    @ReadWriteAttribute
    public var hardwareAcceleration: HardwareAcceleration

    @ReadWriteAttribute
    public var alpha: AlphaOption

    @ReadWriteAttribute
    public var scalabilityMode: String

    @ReadWriteAttribute
    public var bitrateMode: BitrateMode

    @ReadWriteAttribute
    public var latencyMode: LatencyMode
}

public class VideoEncoderEncodeOptions: BridgedDictionary {
    public convenience init(keyFrame: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.keyFrame] = keyFrame.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _keyFrame = ReadWriteAttribute(jsObject: object, name: Strings.keyFrame)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var keyFrame: Bool
}

public class VideoEncoderInit: BridgedDictionary {
    public convenience init(output: @escaping EncodedVideoChunkOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[Strings.Object].function!.new()
        ClosureAttribute2Void[Strings.output, in: object] = output
        ClosureAttribute1Void[Strings.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute2Void(jsObject: object, name: Strings.output)
        _error = ClosureAttribute1Void(jsObject: object, name: Strings.error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute2Void
    public var output: EncodedVideoChunkOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class VideoEncoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: VideoEncoderConfig) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = supported.jsValue
        object[Strings.config] = config.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: Strings.supported)
        _config = ReadWriteAttribute(jsObject: object, name: Strings.config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: VideoEncoderConfig
}

public enum VideoFacingModeEnum: JSString, JSValueCompatible {
    case user = "user"
    case environment = "environment"
    case left = "left"
    case right = "right"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoFrame: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.VideoFrame].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _format = ReadonlyAttribute(jsObject: jsObject, name: Strings.format)
        _codedWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.codedWidth)
        _codedHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.codedHeight)
        _codedRect = ReadonlyAttribute(jsObject: jsObject, name: Strings.codedRect)
        _visibleRect = ReadonlyAttribute(jsObject: jsObject, name: Strings.visibleRect)
        _displayWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.displayWidth)
        _displayHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.displayHeight)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: Strings.timestamp)
        _colorSpace = ReadonlyAttribute(jsObject: jsObject, name: Strings.colorSpace)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(image: CanvasImageSource, init: VideoFrameInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [image.jsValue, `init`?.jsValue ?? .undefined]))
    }

    @inlinable public convenience init(data: BufferSource, init: VideoFrameBufferInit) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [data.jsValue, `init`.jsValue]))
    }

    @ReadonlyAttribute
    public var format: VideoPixelFormat?

    @ReadonlyAttribute
    public var codedWidth: UInt32

    @ReadonlyAttribute
    public var codedHeight: UInt32

    @ReadonlyAttribute
    public var codedRect: DOMRectReadOnly?

    @ReadonlyAttribute
    public var visibleRect: DOMRectReadOnly?

    @ReadonlyAttribute
    public var displayWidth: UInt32

    @ReadonlyAttribute
    public var displayHeight: UInt32

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var timestamp: Int64?

    @ReadonlyAttribute
    public var colorSpace: VideoColorSpace

    @inlinable public func allocationSize(options: VideoFrameCopyToOptions? = nil) -> UInt32 {
        let this = jsObject
        return this[Strings.allocationSize].function!(this: this, arguments: [options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func copyTo(destination: BufferSource, options: VideoFrameCopyToOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.copyTo].function!(this: this, arguments: [destination.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func copyTo(destination: BufferSource, options: VideoFrameCopyToOptions? = nil) async throws -> [PlaneLayout] {
        let this = jsObject
        let _promise: JSPromise = this[Strings.copyTo].function!(this: this, arguments: [destination.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

public class VideoFrameBufferInit: BridgedDictionary {
    public convenience init(format: VideoPixelFormat, codedWidth: UInt32, codedHeight: UInt32, timestamp: Int64, duration: UInt64, layout: [PlaneLayout], visibleRect: DOMRectInit, displayWidth: UInt32, displayHeight: UInt32, colorSpace: VideoColorSpaceInit) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = format.jsValue
        object[Strings.codedWidth] = codedWidth.jsValue
        object[Strings.codedHeight] = codedHeight.jsValue
        object[Strings.timestamp] = timestamp.jsValue
        object[Strings.duration] = duration.jsValue
        object[Strings.layout] = layout.jsValue
        object[Strings.visibleRect] = visibleRect.jsValue
        object[Strings.displayWidth] = displayWidth.jsValue
        object[Strings.displayHeight] = displayHeight.jsValue
        object[Strings.colorSpace] = colorSpace.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: Strings.format)
        _codedWidth = ReadWriteAttribute(jsObject: object, name: Strings.codedWidth)
        _codedHeight = ReadWriteAttribute(jsObject: object, name: Strings.codedHeight)
        _timestamp = ReadWriteAttribute(jsObject: object, name: Strings.timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: Strings.duration)
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        _visibleRect = ReadWriteAttribute(jsObject: object, name: Strings.visibleRect)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: Strings.displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: Strings.displayHeight)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: Strings.colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: VideoPixelFormat

    @ReadWriteAttribute
    public var codedWidth: UInt32

    @ReadWriteAttribute
    public var codedHeight: UInt32

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var layout: [PlaneLayout]

    @ReadWriteAttribute
    public var visibleRect: DOMRectInit

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32

    @ReadWriteAttribute
    public var colorSpace: VideoColorSpaceInit
}

public class VideoFrameCopyToOptions: BridgedDictionary {
    public convenience init(rect: DOMRectInit, layout: [PlaneLayout]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.rect] = rect.jsValue
        object[Strings.layout] = layout.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _rect = ReadWriteAttribute(jsObject: object, name: Strings.rect)
        _layout = ReadWriteAttribute(jsObject: object, name: Strings.layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var rect: DOMRectInit

    @ReadWriteAttribute
    public var layout: [PlaneLayout]
}

public class VideoFrameInit: BridgedDictionary {
    public convenience init(duration: UInt64, timestamp: Int64, alpha: AlphaOption, visibleRect: DOMRectInit, displayWidth: UInt32, displayHeight: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.duration] = duration.jsValue
        object[Strings.timestamp] = timestamp.jsValue
        object[Strings.alpha] = alpha.jsValue
        object[Strings.visibleRect] = visibleRect.jsValue
        object[Strings.displayWidth] = displayWidth.jsValue
        object[Strings.displayHeight] = displayHeight.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _duration = ReadWriteAttribute(jsObject: object, name: Strings.duration)
        _timestamp = ReadWriteAttribute(jsObject: object, name: Strings.timestamp)
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        _visibleRect = ReadWriteAttribute(jsObject: object, name: Strings.visibleRect)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: Strings.displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: Strings.displayHeight)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var alpha: AlphaOption

    @ReadWriteAttribute
    public var visibleRect: DOMRectInit

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32
}

public enum VideoMatrixCoefficients: JSString, JSValueCompatible {
    case rgb = "rgb"
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum VideoPixelFormat: JSString, JSValueCompatible {
    case i420 = "I420"
    case i420A = "I420A"
    case i422 = "I422"
    case i444 = "I444"
    case nV12 = "NV12"
    case rGBA = "RGBA"
    case rGBX = "RGBX"
    case bGRA = "BGRA"
    case bGRX = "BGRX"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum VideoResizeModeEnum: JSString, JSValueCompatible {
    case none = "none"
    case cropAndScale = "crop-and-scale"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.VideoTrack].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: Strings.id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: Strings.kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: Strings.label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: Strings.language)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: Strings.selected)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var selected: Bool
}

public class VideoTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.VideoTrackList].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _selectedIndex = ReadonlyAttribute(jsObject: jsObject, name: Strings.selectedIndex)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> VideoTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> VideoTrack? {
        let this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [id.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var selectedIndex: Int32

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public enum VideoTransferCharacteristics: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case smpte170m = "smpte170m"
    case iec6196621 = "iec61966-2-1"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class WaveShaperNode: AudioNode {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WaveShaperNode].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _curve = ReadWriteAttribute(jsObject: jsObject, name: Strings.curve)
        _oversample = ReadWriteAttribute(jsObject: jsObject, name: Strings.oversample)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: WaveShaperOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var curve: Float32Array?

    @ReadWriteAttribute
    public var oversample: OverSampleType
}

public class WaveShaperOptions: BridgedDictionary {
    public convenience init(curve: [Float], oversample: OverSampleType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.curve] = curve.jsValue
        object[Strings.oversample] = oversample.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _curve = ReadWriteAttribute(jsObject: object, name: Strings.curve)
        _oversample = ReadWriteAttribute(jsObject: object, name: Strings.oversample)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var curve: [Float]

    @ReadWriteAttribute
    public var oversample: OverSampleType
}

public class WebGL2RenderingContext: JSBridgedClass, WebGLRenderingContextBase, WebGL2RenderingContextBase, WebGL2RenderingContextOverloads {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGL2RenderingContext].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public protocol WebGL2RenderingContextBase: JSBridgedClass {}
public extension WebGL2RenderingContextBase {
    @inlinable static var READ_BUFFER: GLenum { 0x0C02 }

    @inlinable static var UNPACK_ROW_LENGTH: GLenum { 0x0CF2 }

    @inlinable static var UNPACK_SKIP_ROWS: GLenum { 0x0CF3 }

    @inlinable static var UNPACK_SKIP_PIXELS: GLenum { 0x0CF4 }

    @inlinable static var PACK_ROW_LENGTH: GLenum { 0x0D02 }

    @inlinable static var PACK_SKIP_ROWS: GLenum { 0x0D03 }

    @inlinable static var PACK_SKIP_PIXELS: GLenum { 0x0D04 }

    @inlinable static var COLOR: GLenum { 0x1800 }

    @inlinable static var DEPTH: GLenum { 0x1801 }

    @inlinable static var STENCIL: GLenum { 0x1802 }

    @inlinable static var RED: GLenum { 0x1903 }

    @inlinable static var RGB8: GLenum { 0x8051 }

    @inlinable static var RGBA8: GLenum { 0x8058 }

    @inlinable static var RGB10_A2: GLenum { 0x8059 }

    @inlinable static var TEXTURE_BINDING_3D: GLenum { 0x806A }

    @inlinable static var UNPACK_SKIP_IMAGES: GLenum { 0x806D }

    @inlinable static var UNPACK_IMAGE_HEIGHT: GLenum { 0x806E }

    @inlinable static var TEXTURE_3D: GLenum { 0x806F }

    @inlinable static var TEXTURE_WRAP_R: GLenum { 0x8072 }

    @inlinable static var MAX_3D_TEXTURE_SIZE: GLenum { 0x8073 }

    @inlinable static var UNSIGNED_INT_2_10_10_10_REV: GLenum { 0x8368 }

    @inlinable static var MAX_ELEMENTS_VERTICES: GLenum { 0x80E8 }

    @inlinable static var MAX_ELEMENTS_INDICES: GLenum { 0x80E9 }

    @inlinable static var TEXTURE_MIN_LOD: GLenum { 0x813A }

    @inlinable static var TEXTURE_MAX_LOD: GLenum { 0x813B }

    @inlinable static var TEXTURE_BASE_LEVEL: GLenum { 0x813C }

    @inlinable static var TEXTURE_MAX_LEVEL: GLenum { 0x813D }

    @inlinable static var MIN: GLenum { 0x8007 }

    @inlinable static var MAX: GLenum { 0x8008 }

    @inlinable static var DEPTH_COMPONENT24: GLenum { 0x81A6 }

    @inlinable static var MAX_TEXTURE_LOD_BIAS: GLenum { 0x84FD }

    @inlinable static var TEXTURE_COMPARE_MODE: GLenum { 0x884C }

    @inlinable static var TEXTURE_COMPARE_FUNC: GLenum { 0x884D }

    @inlinable static var CURRENT_QUERY: GLenum { 0x8865 }

    @inlinable static var QUERY_RESULT: GLenum { 0x8866 }

    @inlinable static var QUERY_RESULT_AVAILABLE: GLenum { 0x8867 }

    @inlinable static var STREAM_READ: GLenum { 0x88E1 }

    @inlinable static var STREAM_COPY: GLenum { 0x88E2 }

    @inlinable static var STATIC_READ: GLenum { 0x88E5 }

    @inlinable static var STATIC_COPY: GLenum { 0x88E6 }

    @inlinable static var DYNAMIC_READ: GLenum { 0x88E9 }

    @inlinable static var DYNAMIC_COPY: GLenum { 0x88EA }

    @inlinable static var MAX_DRAW_BUFFERS: GLenum { 0x8824 }

    @inlinable static var DRAW_BUFFER0: GLenum { 0x8825 }

    @inlinable static var DRAW_BUFFER1: GLenum { 0x8826 }

    @inlinable static var DRAW_BUFFER2: GLenum { 0x8827 }

    @inlinable static var DRAW_BUFFER3: GLenum { 0x8828 }

    @inlinable static var DRAW_BUFFER4: GLenum { 0x8829 }

    @inlinable static var DRAW_BUFFER5: GLenum { 0x882A }

    @inlinable static var DRAW_BUFFER6: GLenum { 0x882B }

    @inlinable static var DRAW_BUFFER7: GLenum { 0x882C }

    @inlinable static var DRAW_BUFFER8: GLenum { 0x882D }

    @inlinable static var DRAW_BUFFER9: GLenum { 0x882E }

    @inlinable static var DRAW_BUFFER10: GLenum { 0x882F }

    @inlinable static var DRAW_BUFFER11: GLenum { 0x8830 }

    @inlinable static var DRAW_BUFFER12: GLenum { 0x8831 }

    @inlinable static var DRAW_BUFFER13: GLenum { 0x8832 }

    @inlinable static var DRAW_BUFFER14: GLenum { 0x8833 }

    @inlinable static var DRAW_BUFFER15: GLenum { 0x8834 }

    @inlinable static var MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum { 0x8B49 }

    @inlinable static var MAX_VERTEX_UNIFORM_COMPONENTS: GLenum { 0x8B4A }

    @inlinable static var SAMPLER_3D: GLenum { 0x8B5F }

    @inlinable static var SAMPLER_2D_SHADOW: GLenum { 0x8B62 }

    @inlinable static var FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum { 0x8B8B }

    @inlinable static var PIXEL_PACK_BUFFER: GLenum { 0x88EB }

    @inlinable static var PIXEL_UNPACK_BUFFER: GLenum { 0x88EC }

    @inlinable static var PIXEL_PACK_BUFFER_BINDING: GLenum { 0x88ED }

    @inlinable static var PIXEL_UNPACK_BUFFER_BINDING: GLenum { 0x88EF }

    @inlinable static var FLOAT_MAT2x3: GLenum { 0x8B65 }

    @inlinable static var FLOAT_MAT2x4: GLenum { 0x8B66 }

    @inlinable static var FLOAT_MAT3x2: GLenum { 0x8B67 }

    @inlinable static var FLOAT_MAT3x4: GLenum { 0x8B68 }

    @inlinable static var FLOAT_MAT4x2: GLenum { 0x8B69 }

    @inlinable static var FLOAT_MAT4x3: GLenum { 0x8B6A }

    @inlinable static var SRGB: GLenum { 0x8C40 }

    @inlinable static var SRGB8: GLenum { 0x8C41 }

    @inlinable static var SRGB8_ALPHA8: GLenum { 0x8C43 }

    @inlinable static var COMPARE_REF_TO_TEXTURE: GLenum { 0x884E }

    @inlinable static var RGBA32F: GLenum { 0x8814 }

    @inlinable static var RGB32F: GLenum { 0x8815 }

    @inlinable static var RGBA16F: GLenum { 0x881A }

    @inlinable static var RGB16F: GLenum { 0x881B }

    @inlinable static var VERTEX_ATTRIB_ARRAY_INTEGER: GLenum { 0x88FD }

    @inlinable static var MAX_ARRAY_TEXTURE_LAYERS: GLenum { 0x88FF }

    @inlinable static var MIN_PROGRAM_TEXEL_OFFSET: GLenum { 0x8904 }

    @inlinable static var MAX_PROGRAM_TEXEL_OFFSET: GLenum { 0x8905 }

    @inlinable static var MAX_VARYING_COMPONENTS: GLenum { 0x8B4B }

    @inlinable static var TEXTURE_2D_ARRAY: GLenum { 0x8C1A }

    @inlinable static var TEXTURE_BINDING_2D_ARRAY: GLenum { 0x8C1D }

    @inlinable static var R11F_G11F_B10F: GLenum { 0x8C3A }

    @inlinable static var UNSIGNED_INT_10F_11F_11F_REV: GLenum { 0x8C3B }

    @inlinable static var RGB9_E5: GLenum { 0x8C3D }

    @inlinable static var UNSIGNED_INT_5_9_9_9_REV: GLenum { 0x8C3E }

    @inlinable static var TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum { 0x8C7F }

    @inlinable static var MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum { 0x8C80 }

    @inlinable static var TRANSFORM_FEEDBACK_VARYINGS: GLenum { 0x8C83 }

    @inlinable static var TRANSFORM_FEEDBACK_BUFFER_START: GLenum { 0x8C84 }

    @inlinable static var TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum { 0x8C85 }

    @inlinable static var TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum { 0x8C88 }

    @inlinable static var RASTERIZER_DISCARD: GLenum { 0x8C89 }

    @inlinable static var MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum { 0x8C8A }

    @inlinable static var MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum { 0x8C8B }

    @inlinable static var INTERLEAVED_ATTRIBS: GLenum { 0x8C8C }

    @inlinable static var SEPARATE_ATTRIBS: GLenum { 0x8C8D }

    @inlinable static var TRANSFORM_FEEDBACK_BUFFER: GLenum { 0x8C8E }

    @inlinable static var TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum { 0x8C8F }

    @inlinable static var RGBA32UI: GLenum { 0x8D70 }

    @inlinable static var RGB32UI: GLenum { 0x8D71 }

    @inlinable static var RGBA16UI: GLenum { 0x8D76 }

    @inlinable static var RGB16UI: GLenum { 0x8D77 }

    @inlinable static var RGBA8UI: GLenum { 0x8D7C }

    @inlinable static var RGB8UI: GLenum { 0x8D7D }

    @inlinable static var RGBA32I: GLenum { 0x8D82 }

    @inlinable static var RGB32I: GLenum { 0x8D83 }

    @inlinable static var RGBA16I: GLenum { 0x8D88 }

    @inlinable static var RGB16I: GLenum { 0x8D89 }

    @inlinable static var RGBA8I: GLenum { 0x8D8E }

    @inlinable static var RGB8I: GLenum { 0x8D8F }

    @inlinable static var RED_INTEGER: GLenum { 0x8D94 }

    @inlinable static var RGB_INTEGER: GLenum { 0x8D98 }

    @inlinable static var RGBA_INTEGER: GLenum { 0x8D99 }

    @inlinable static var SAMPLER_2D_ARRAY: GLenum { 0x8DC1 }

    @inlinable static var SAMPLER_2D_ARRAY_SHADOW: GLenum { 0x8DC4 }

    @inlinable static var SAMPLER_CUBE_SHADOW: GLenum { 0x8DC5 }

    @inlinable static var UNSIGNED_INT_VEC2: GLenum { 0x8DC6 }

    @inlinable static var UNSIGNED_INT_VEC3: GLenum { 0x8DC7 }

    @inlinable static var UNSIGNED_INT_VEC4: GLenum { 0x8DC8 }

    @inlinable static var INT_SAMPLER_2D: GLenum { 0x8DCA }

    @inlinable static var INT_SAMPLER_3D: GLenum { 0x8DCB }

    @inlinable static var INT_SAMPLER_CUBE: GLenum { 0x8DCC }

    @inlinable static var INT_SAMPLER_2D_ARRAY: GLenum { 0x8DCF }

    @inlinable static var UNSIGNED_INT_SAMPLER_2D: GLenum { 0x8DD2 }

    @inlinable static var UNSIGNED_INT_SAMPLER_3D: GLenum { 0x8DD3 }

    @inlinable static var UNSIGNED_INT_SAMPLER_CUBE: GLenum { 0x8DD4 }

    @inlinable static var UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum { 0x8DD7 }

    @inlinable static var DEPTH_COMPONENT32F: GLenum { 0x8CAC }

    @inlinable static var DEPTH32F_STENCIL8: GLenum { 0x8CAD }

    @inlinable static var FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum { 0x8DAD }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum { 0x8210 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum { 0x8211 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum { 0x8212 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum { 0x8213 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum { 0x8214 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum { 0x8215 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum { 0x8216 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum { 0x8217 }

    @inlinable static var FRAMEBUFFER_DEFAULT: GLenum { 0x8218 }

    @inlinable static var UNSIGNED_INT_24_8: GLenum { 0x84FA }

    @inlinable static var DEPTH24_STENCIL8: GLenum { 0x88F0 }

    @inlinable static var UNSIGNED_NORMALIZED: GLenum { 0x8C17 }

    @inlinable static var DRAW_FRAMEBUFFER_BINDING: GLenum { 0x8CA6 }

    @inlinable static var READ_FRAMEBUFFER: GLenum { 0x8CA8 }

    @inlinable static var DRAW_FRAMEBUFFER: GLenum { 0x8CA9 }

    @inlinable static var READ_FRAMEBUFFER_BINDING: GLenum { 0x8CAA }

    @inlinable static var RENDERBUFFER_SAMPLES: GLenum { 0x8CAB }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum { 0x8CD4 }

    @inlinable static var MAX_COLOR_ATTACHMENTS: GLenum { 0x8CDF }

    @inlinable static var COLOR_ATTACHMENT1: GLenum { 0x8CE1 }

    @inlinable static var COLOR_ATTACHMENT2: GLenum { 0x8CE2 }

    @inlinable static var COLOR_ATTACHMENT3: GLenum { 0x8CE3 }

    @inlinable static var COLOR_ATTACHMENT4: GLenum { 0x8CE4 }

    @inlinable static var COLOR_ATTACHMENT5: GLenum { 0x8CE5 }

    @inlinable static var COLOR_ATTACHMENT6: GLenum { 0x8CE6 }

    @inlinable static var COLOR_ATTACHMENT7: GLenum { 0x8CE7 }

    @inlinable static var COLOR_ATTACHMENT8: GLenum { 0x8CE8 }

    @inlinable static var COLOR_ATTACHMENT9: GLenum { 0x8CE9 }

    @inlinable static var COLOR_ATTACHMENT10: GLenum { 0x8CEA }

    @inlinable static var COLOR_ATTACHMENT11: GLenum { 0x8CEB }

    @inlinable static var COLOR_ATTACHMENT12: GLenum { 0x8CEC }

    @inlinable static var COLOR_ATTACHMENT13: GLenum { 0x8CED }

    @inlinable static var COLOR_ATTACHMENT14: GLenum { 0x8CEE }

    @inlinable static var COLOR_ATTACHMENT15: GLenum { 0x8CEF }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum { 0x8D56 }

    @inlinable static var MAX_SAMPLES: GLenum { 0x8D57 }

    @inlinable static var HALF_FLOAT: GLenum { 0x140B }

    @inlinable static var RG: GLenum { 0x8227 }

    @inlinable static var RG_INTEGER: GLenum { 0x8228 }

    @inlinable static var R8: GLenum { 0x8229 }

    @inlinable static var RG8: GLenum { 0x822B }

    @inlinable static var R16F: GLenum { 0x822D }

    @inlinable static var R32F: GLenum { 0x822E }

    @inlinable static var RG16F: GLenum { 0x822F }

    @inlinable static var RG32F: GLenum { 0x8230 }

    @inlinable static var R8I: GLenum { 0x8231 }

    @inlinable static var R8UI: GLenum { 0x8232 }

    @inlinable static var R16I: GLenum { 0x8233 }

    @inlinable static var R16UI: GLenum { 0x8234 }

    @inlinable static var R32I: GLenum { 0x8235 }

    @inlinable static var R32UI: GLenum { 0x8236 }

    @inlinable static var RG8I: GLenum { 0x8237 }

    @inlinable static var RG8UI: GLenum { 0x8238 }

    @inlinable static var RG16I: GLenum { 0x8239 }

    @inlinable static var RG16UI: GLenum { 0x823A }

    @inlinable static var RG32I: GLenum { 0x823B }

    @inlinable static var RG32UI: GLenum { 0x823C }

    @inlinable static var VERTEX_ARRAY_BINDING: GLenum { 0x85B5 }

    @inlinable static var R8_SNORM: GLenum { 0x8F94 }

    @inlinable static var RG8_SNORM: GLenum { 0x8F95 }

    @inlinable static var RGB8_SNORM: GLenum { 0x8F96 }

    @inlinable static var RGBA8_SNORM: GLenum { 0x8F97 }

    @inlinable static var SIGNED_NORMALIZED: GLenum { 0x8F9C }

    @inlinable static var COPY_READ_BUFFER: GLenum { 0x8F36 }

    @inlinable static var COPY_WRITE_BUFFER: GLenum { 0x8F37 }

    @inlinable static var COPY_READ_BUFFER_BINDING: GLenum { 0x8F36 }

    @inlinable static var COPY_WRITE_BUFFER_BINDING: GLenum { 0x8F37 }

    @inlinable static var UNIFORM_BUFFER: GLenum { 0x8A11 }

    @inlinable static var UNIFORM_BUFFER_BINDING: GLenum { 0x8A28 }

    @inlinable static var UNIFORM_BUFFER_START: GLenum { 0x8A29 }

    @inlinable static var UNIFORM_BUFFER_SIZE: GLenum { 0x8A2A }

    @inlinable static var MAX_VERTEX_UNIFORM_BLOCKS: GLenum { 0x8A2B }

    @inlinable static var MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum { 0x8A2D }

    @inlinable static var MAX_COMBINED_UNIFORM_BLOCKS: GLenum { 0x8A2E }

    @inlinable static var MAX_UNIFORM_BUFFER_BINDINGS: GLenum { 0x8A2F }

    @inlinable static var MAX_UNIFORM_BLOCK_SIZE: GLenum { 0x8A30 }

    @inlinable static var MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum { 0x8A31 }

    @inlinable static var MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum { 0x8A33 }

    @inlinable static var UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum { 0x8A34 }

    @inlinable static var ACTIVE_UNIFORM_BLOCKS: GLenum { 0x8A36 }

    @inlinable static var UNIFORM_TYPE: GLenum { 0x8A37 }

    @inlinable static var UNIFORM_SIZE: GLenum { 0x8A38 }

    @inlinable static var UNIFORM_BLOCK_INDEX: GLenum { 0x8A3A }

    @inlinable static var UNIFORM_OFFSET: GLenum { 0x8A3B }

    @inlinable static var UNIFORM_ARRAY_STRIDE: GLenum { 0x8A3C }

    @inlinable static var UNIFORM_MATRIX_STRIDE: GLenum { 0x8A3D }

    @inlinable static var UNIFORM_IS_ROW_MAJOR: GLenum { 0x8A3E }

    @inlinable static var UNIFORM_BLOCK_BINDING: GLenum { 0x8A3F }

    @inlinable static var UNIFORM_BLOCK_DATA_SIZE: GLenum { 0x8A40 }

    @inlinable static var UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum { 0x8A42 }

    @inlinable static var UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum { 0x8A43 }

    @inlinable static var UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum { 0x8A44 }

    @inlinable static var UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum { 0x8A46 }

    @inlinable static var INVALID_INDEX: GLenum { 0xFFFF_FFFF }

    @inlinable static var MAX_VERTEX_OUTPUT_COMPONENTS: GLenum { 0x9122 }

    @inlinable static var MAX_FRAGMENT_INPUT_COMPONENTS: GLenum { 0x9125 }

    @inlinable static var MAX_SERVER_WAIT_TIMEOUT: GLenum { 0x9111 }

    @inlinable static var OBJECT_TYPE: GLenum { 0x9112 }

    @inlinable static var SYNC_CONDITION: GLenum { 0x9113 }

    @inlinable static var SYNC_STATUS: GLenum { 0x9114 }

    @inlinable static var SYNC_FLAGS: GLenum { 0x9115 }

    @inlinable static var SYNC_FENCE: GLenum { 0x9116 }

    @inlinable static var SYNC_GPU_COMMANDS_COMPLETE: GLenum { 0x9117 }

    @inlinable static var UNSIGNALED: GLenum { 0x9118 }

    @inlinable static var SIGNALED: GLenum { 0x9119 }

    @inlinable static var ALREADY_SIGNALED: GLenum { 0x911A }

    @inlinable static var TIMEOUT_EXPIRED: GLenum { 0x911B }

    @inlinable static var CONDITION_SATISFIED: GLenum { 0x911C }

    @inlinable static var WAIT_FAILED: GLenum { 0x911D }

    @inlinable static var SYNC_FLUSH_COMMANDS_BIT: GLenum { 0x0000_0001 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum { 0x88FE }

    @inlinable static var ANY_SAMPLES_PASSED: GLenum { 0x8C2F }

    @inlinable static var ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum { 0x8D6A }

    @inlinable static var SAMPLER_BINDING: GLenum { 0x8919 }

    @inlinable static var RGB10_A2UI: GLenum { 0x906F }

    @inlinable static var INT_2_10_10_10_REV: GLenum { 0x8D9F }

    @inlinable static var TRANSFORM_FEEDBACK: GLenum { 0x8E22 }

    @inlinable static var TRANSFORM_FEEDBACK_PAUSED: GLenum { 0x8E23 }

    @inlinable static var TRANSFORM_FEEDBACK_ACTIVE: GLenum { 0x8E24 }

    @inlinable static var TRANSFORM_FEEDBACK_BINDING: GLenum { 0x8E25 }

    @inlinable static var TEXTURE_IMMUTABLE_FORMAT: GLenum { 0x912F }

    @inlinable static var MAX_ELEMENT_INDEX: GLenum { 0x8D6B }

    @inlinable static var TEXTURE_IMMUTABLE_LEVELS: GLenum { 0x82DF }

    @inlinable static var TIMEOUT_IGNORED: GLint64 { -1 }

    @inlinable static var MAX_CLIENT_WAIT_TIMEOUT_WEBGL: GLenum { 0x9247 }

    @inlinable func copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) {
        let this = jsObject
        _ = this[Strings.copyBufferSubData].function!(this: this, arguments: [readTarget.jsValue, writeTarget.jsValue, readOffset.jsValue, writeOffset.jsValue, size.jsValue])
    }

    @inlinable func getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint? = nil, length: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.getBufferSubData].function!(this: this, arguments: [target.jsValue, srcByteOffset.jsValue, dstBuffer.jsValue, dstOffset?.jsValue ?? .undefined, length?.jsValue ?? .undefined])
    }

    @inlinable func blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) {
        let _arg0 = srcX0.jsValue
        let _arg1 = srcY0.jsValue
        let _arg2 = srcX1.jsValue
        let _arg3 = srcY1.jsValue
        let _arg4 = dstX0.jsValue
        let _arg5 = dstY0.jsValue
        let _arg6 = dstX1.jsValue
        let _arg7 = dstY1.jsValue
        let _arg8 = mask.jsValue
        let _arg9 = filter.jsValue
        let this = jsObject
        _ = this[Strings.blitFramebuffer].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture?, level: GLint, layer: GLint) {
        let this = jsObject
        _ = this[Strings.framebufferTextureLayer].function!(this: this, arguments: [target.jsValue, attachment.jsValue, texture.jsValue, level.jsValue, layer.jsValue])
    }

    @inlinable func invalidateFramebuffer(target: GLenum, attachments: [GLenum]) {
        let this = jsObject
        _ = this[Strings.invalidateFramebuffer].function!(this: this, arguments: [target.jsValue, attachments.jsValue])
    }

    @inlinable func invalidateSubFramebuffer(target: GLenum, attachments: [GLenum], x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let _arg0 = target.jsValue
        let _arg1 = attachments.jsValue
        let _arg2 = x.jsValue
        let _arg3 = y.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let this = jsObject
        _ = this[Strings.invalidateSubFramebuffer].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func readBuffer(src: GLenum) {
        let this = jsObject
        _ = this[Strings.readBuffer].function!(this: this, arguments: [src.jsValue])
    }

    @inlinable func getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getInternalformatParameter].function!(this: this, arguments: [target.jsValue, internalformat.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.renderbufferStorageMultisample].function!(this: this, arguments: [target.jsValue, samples.jsValue, internalformat.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.texStorage2D].function!(this: this, arguments: [target.jsValue, levels.jsValue, internalformat.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) {
        let _arg0 = target.jsValue
        let _arg1 = levels.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let this = jsObject
        _ = this[Strings.texStorage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = format.jsValue
        let _arg8 = type.jsValue
        let _arg9 = pboOffset.jsValue
        let this = jsObject
        _ = this[Strings.texImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = format.jsValue
        let _arg8 = type.jsValue
        let _arg9 = source.jsValue
        let this = jsObject
        _ = this[Strings.texImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = format.jsValue
        let _arg8 = type.jsValue
        let _arg9 = srcData.jsValue
        let this = jsObject
        _ = this[Strings.texImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = format.jsValue
        let _arg8 = type.jsValue
        let _arg9 = srcData.jsValue
        let _arg10 = srcOffset.jsValue
        let this = jsObject
        _ = this[Strings.texImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10])
    }

    @inlinable func texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = depth.jsValue
        let _arg8 = format.jsValue
        let _arg9 = type.jsValue
        let _arg10 = pboOffset.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10])
    }

    @inlinable func texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = depth.jsValue
        let _arg8 = format.jsValue
        let _arg9 = type.jsValue
        let _arg10 = source.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10])
    }

    @inlinable func texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView?, srcOffset: GLuint? = nil) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = depth.jsValue
        let _arg8 = format.jsValue
        let _arg9 = type.jsValue
        let _arg10 = srcData.jsValue
        let _arg11 = srcOffset?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.texSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11])
    }

    @inlinable func copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = x.jsValue
        let _arg6 = y.jsValue
        let _arg7 = width.jsValue
        let _arg8 = height.jsValue
        let this = jsObject
        _ = this[Strings.copyTexSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = imageSize.jsValue
        let _arg8 = offset.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint? = nil, srcLengthOverride: GLuint? = nil) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = depth.jsValue
        let _arg6 = border.jsValue
        let _arg7 = srcData.jsValue
        let _arg8 = srcOffset?.jsValue ?? .undefined
        let _arg9 = srcLengthOverride?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.compressedTexImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = depth.jsValue
        let _arg8 = format.jsValue
        let _arg9 = imageSize.jsValue
        let _arg10 = offset.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10])
    }

    @inlinable func compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint? = nil, srcLengthOverride: GLuint? = nil) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = zoffset.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = depth.jsValue
        let _arg8 = format.jsValue
        let _arg9 = srcData.jsValue
        let _arg10 = srcOffset?.jsValue ?? .undefined
        let _arg11 = srcLengthOverride?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.compressedTexSubImage3D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11])
    }

    @inlinable func getFragDataLocation(program: WebGLProgram, name: String) -> GLint {
        let this = jsObject
        return this[Strings.getFragDataLocation].function!(this: this, arguments: [program.jsValue, name.jsValue]).fromJSValue()!
    }

    @inlinable func uniform1ui(location: WebGLUniformLocation?, v0: GLuint) {
        let this = jsObject
        _ = this[Strings.uniform1ui].function!(this: this, arguments: [location.jsValue, v0.jsValue])
    }

    @inlinable func uniform2ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint) {
        let this = jsObject
        _ = this[Strings.uniform2ui].function!(this: this, arguments: [location.jsValue, v0.jsValue, v1.jsValue])
    }

    @inlinable func uniform3ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint, v2: GLuint) {
        let this = jsObject
        _ = this[Strings.uniform3ui].function!(this: this, arguments: [location.jsValue, v0.jsValue, v1.jsValue, v2.jsValue])
    }

    @inlinable func uniform4ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) {
        let this = jsObject
        _ = this[Strings.uniform4ui].function!(this: this, arguments: [location.jsValue, v0.jsValue, v1.jsValue, v2.jsValue, v3.jsValue])
    }

    @inlinable func uniform1uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform1uiv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform2uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform2uiv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform3uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform3uiv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform4uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform4uiv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix3x2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix3x2fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix4x2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix4x2fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix2x3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix2x3fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix4x3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix4x3fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix2x4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix2x4fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix3x4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix3x4fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) {
        let this = jsObject
        _ = this[Strings.vertexAttribI4i].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func vertexAttribI4iv(index: GLuint, values: Int32List) {
        let this = jsObject
        _ = this[Strings.vertexAttribI4iv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) {
        let this = jsObject
        _ = this[Strings.vertexAttribI4ui].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func vertexAttribI4uiv(index: GLuint, values: Uint32List) {
        let this = jsObject
        _ = this[Strings.vertexAttribI4uiv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr) {
        let this = jsObject
        _ = this[Strings.vertexAttribIPointer].function!(this: this, arguments: [index.jsValue, size.jsValue, type.jsValue, stride.jsValue, offset.jsValue])
    }

    @inlinable func vertexAttribDivisor(index: GLuint, divisor: GLuint) {
        let this = jsObject
        _ = this[Strings.vertexAttribDivisor].function!(this: this, arguments: [index.jsValue, divisor.jsValue])
    }

    @inlinable func drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei) {
        let this = jsObject
        _ = this[Strings.drawArraysInstanced].function!(this: this, arguments: [mode.jsValue, first.jsValue, count.jsValue, instanceCount.jsValue])
    }

    @inlinable func drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei) {
        let this = jsObject
        _ = this[Strings.drawElementsInstanced].function!(this: this, arguments: [mode.jsValue, count.jsValue, type.jsValue, offset.jsValue, instanceCount.jsValue])
    }

    @inlinable func drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr) {
        let _arg0 = mode.jsValue
        let _arg1 = start.jsValue
        let _arg2 = end.jsValue
        let _arg3 = count.jsValue
        let _arg4 = type.jsValue
        let _arg5 = offset.jsValue
        let this = jsObject
        _ = this[Strings.drawRangeElements].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func drawBuffers(buffers: [GLenum]) {
        let this = jsObject
        _ = this[Strings.drawBuffers].function!(this: this, arguments: [buffers.jsValue])
    }

    @inlinable func clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.clearBufferfv].function!(this: this, arguments: [buffer.jsValue, drawbuffer.jsValue, values.jsValue, srcOffset?.jsValue ?? .undefined])
    }

    @inlinable func clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.clearBufferiv].function!(this: this, arguments: [buffer.jsValue, drawbuffer.jsValue, values.jsValue, srcOffset?.jsValue ?? .undefined])
    }

    @inlinable func clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.clearBufferuiv].function!(this: this, arguments: [buffer.jsValue, drawbuffer.jsValue, values.jsValue, srcOffset?.jsValue ?? .undefined])
    }

    @inlinable func clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) {
        let this = jsObject
        _ = this[Strings.clearBufferfi].function!(this: this, arguments: [buffer.jsValue, drawbuffer.jsValue, depth.jsValue, stencil.jsValue])
    }

    @inlinable func createQuery() -> WebGLQuery? {
        let this = jsObject
        return this[Strings.createQuery].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func deleteQuery(query: WebGLQuery?) {
        let this = jsObject
        _ = this[Strings.deleteQuery].function!(this: this, arguments: [query.jsValue])
    }

    @inlinable func isQuery(query: WebGLQuery?) -> GLboolean {
        let this = jsObject
        return this[Strings.isQuery].function!(this: this, arguments: [query.jsValue]).fromJSValue()!
    }

    @inlinable func beginQuery(target: GLenum, query: WebGLQuery) {
        let this = jsObject
        _ = this[Strings.beginQuery].function!(this: this, arguments: [target.jsValue, query.jsValue])
    }

    @inlinable func endQuery(target: GLenum) {
        let this = jsObject
        _ = this[Strings.endQuery].function!(this: this, arguments: [target.jsValue])
    }

    @inlinable func getQuery(target: GLenum, pname: GLenum) -> WebGLQuery? {
        let this = jsObject
        return this[Strings.getQuery].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getQueryParameter(query: WebGLQuery, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getQueryParameter].function!(this: this, arguments: [query.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func createSampler() -> WebGLSampler? {
        let this = jsObject
        return this[Strings.createSampler].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func deleteSampler(sampler: WebGLSampler?) {
        let this = jsObject
        _ = this[Strings.deleteSampler].function!(this: this, arguments: [sampler.jsValue])
    }

    @inlinable func isSampler(sampler: WebGLSampler?) -> GLboolean {
        let this = jsObject
        return this[Strings.isSampler].function!(this: this, arguments: [sampler.jsValue]).fromJSValue()!
    }

    @inlinable func bindSampler(unit: GLuint, sampler: WebGLSampler?) {
        let this = jsObject
        _ = this[Strings.bindSampler].function!(this: this, arguments: [unit.jsValue, sampler.jsValue])
    }

    @inlinable func samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint) {
        let this = jsObject
        _ = this[Strings.samplerParameteri].function!(this: this, arguments: [sampler.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat) {
        let this = jsObject
        _ = this[Strings.samplerParameterf].function!(this: this, arguments: [sampler.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func getSamplerParameter(sampler: WebGLSampler, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getSamplerParameter].function!(this: this, arguments: [sampler.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func fenceSync(condition: GLenum, flags: GLbitfield) -> WebGLSync? {
        let this = jsObject
        return this[Strings.fenceSync].function!(this: this, arguments: [condition.jsValue, flags.jsValue]).fromJSValue()!
    }

    @inlinable func isSync(sync: WebGLSync?) -> GLboolean {
        let this = jsObject
        return this[Strings.isSync].function!(this: this, arguments: [sync.jsValue]).fromJSValue()!
    }

    @inlinable func deleteSync(sync: WebGLSync?) {
        let this = jsObject
        _ = this[Strings.deleteSync].function!(this: this, arguments: [sync.jsValue])
    }

    @inlinable func clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64) -> GLenum {
        let this = jsObject
        return this[Strings.clientWaitSync].function!(this: this, arguments: [sync.jsValue, flags.jsValue, timeout.jsValue]).fromJSValue()!
    }

    @inlinable func waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64) {
        let this = jsObject
        _ = this[Strings.waitSync].function!(this: this, arguments: [sync.jsValue, flags.jsValue, timeout.jsValue])
    }

    @inlinable func getSyncParameter(sync: WebGLSync, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getSyncParameter].function!(this: this, arguments: [sync.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func createTransformFeedback() -> WebGLTransformFeedback? {
        let this = jsObject
        return this[Strings.createTransformFeedback].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func deleteTransformFeedback(tf: WebGLTransformFeedback?) {
        let this = jsObject
        _ = this[Strings.deleteTransformFeedback].function!(this: this, arguments: [tf.jsValue])
    }

    @inlinable func isTransformFeedback(tf: WebGLTransformFeedback?) -> GLboolean {
        let this = jsObject
        return this[Strings.isTransformFeedback].function!(this: this, arguments: [tf.jsValue]).fromJSValue()!
    }

    @inlinable func bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback?) {
        let this = jsObject
        _ = this[Strings.bindTransformFeedback].function!(this: this, arguments: [target.jsValue, tf.jsValue])
    }

    @inlinable func beginTransformFeedback(primitiveMode: GLenum) {
        let this = jsObject
        _ = this[Strings.beginTransformFeedback].function!(this: this, arguments: [primitiveMode.jsValue])
    }

    @inlinable func endTransformFeedback() {
        let this = jsObject
        _ = this[Strings.endTransformFeedback].function!(this: this, arguments: [])
    }

    @inlinable func transformFeedbackVaryings(program: WebGLProgram, varyings: [String], bufferMode: GLenum) {
        let this = jsObject
        _ = this[Strings.transformFeedbackVaryings].function!(this: this, arguments: [program.jsValue, varyings.jsValue, bufferMode.jsValue])
    }

    @inlinable func getTransformFeedbackVarying(program: WebGLProgram, index: GLuint) -> WebGLActiveInfo? {
        let this = jsObject
        return this[Strings.getTransformFeedbackVarying].function!(this: this, arguments: [program.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func pauseTransformFeedback() {
        let this = jsObject
        _ = this[Strings.pauseTransformFeedback].function!(this: this, arguments: [])
    }

    @inlinable func resumeTransformFeedback() {
        let this = jsObject
        _ = this[Strings.resumeTransformFeedback].function!(this: this, arguments: [])
    }

    @inlinable func bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer?) {
        let this = jsObject
        _ = this[Strings.bindBufferBase].function!(this: this, arguments: [target.jsValue, index.jsValue, buffer.jsValue])
    }

    @inlinable func bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer?, offset: GLintptr, size: GLsizeiptr) {
        let this = jsObject
        _ = this[Strings.bindBufferRange].function!(this: this, arguments: [target.jsValue, index.jsValue, buffer.jsValue, offset.jsValue, size.jsValue])
    }

    @inlinable func getIndexedParameter(target: GLenum, index: GLuint) -> JSValue {
        let this = jsObject
        return this[Strings.getIndexedParameter].function!(this: this, arguments: [target.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func getUniformIndices(program: WebGLProgram, uniformNames: [String]) -> [GLuint]? {
        let this = jsObject
        return this[Strings.getUniformIndices].function!(this: this, arguments: [program.jsValue, uniformNames.jsValue]).fromJSValue()!
    }

    @inlinable func getActiveUniforms(program: WebGLProgram, uniformIndices: [GLuint], pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getActiveUniforms].function!(this: this, arguments: [program.jsValue, uniformIndices.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getUniformBlockIndex(program: WebGLProgram, uniformBlockName: String) -> GLuint {
        let this = jsObject
        return this[Strings.getUniformBlockIndex].function!(this: this, arguments: [program.jsValue, uniformBlockName.jsValue]).fromJSValue()!
    }

    @inlinable func getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getActiveUniformBlockParameter].function!(this: this, arguments: [program.jsValue, uniformBlockIndex.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint) -> String? {
        let this = jsObject
        return this[Strings.getActiveUniformBlockName].function!(this: this, arguments: [program.jsValue, uniformBlockIndex.jsValue]).fromJSValue()!
    }

    @inlinable func uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) {
        let this = jsObject
        _ = this[Strings.uniformBlockBinding].function!(this: this, arguments: [program.jsValue, uniformBlockIndex.jsValue, uniformBlockBinding.jsValue])
    }

    @inlinable func createVertexArray() -> WebGLVertexArrayObject? {
        let this = jsObject
        return this[Strings.createVertexArray].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func deleteVertexArray(vertexArray: WebGLVertexArrayObject?) {
        let this = jsObject
        _ = this[Strings.deleteVertexArray].function!(this: this, arguments: [vertexArray.jsValue])
    }

    @inlinable func isVertexArray(vertexArray: WebGLVertexArrayObject?) -> GLboolean {
        let this = jsObject
        return this[Strings.isVertexArray].function!(this: this, arguments: [vertexArray.jsValue]).fromJSValue()!
    }

    @inlinable func bindVertexArray(array: WebGLVertexArrayObject?) {
        let this = jsObject
        _ = this[Strings.bindVertexArray].function!(this: this, arguments: [array.jsValue])
    }
}

public protocol WebGL2RenderingContextOverloads: JSBridgedClass {}
public extension WebGL2RenderingContextOverloads {
    @inlinable func bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, size.jsValue, usage.jsValue])
    }

    @inlinable func bufferData(target: GLenum, srcData: BufferSource?, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, srcData.jsValue, usage.jsValue])
    }

    @inlinable func bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: BufferSource) {
        let this = jsObject
        _ = this[Strings.bufferSubData].function!(this: this, arguments: [target.jsValue, dstByteOffset.jsValue, srcData.jsValue])
    }

    @inlinable func bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, srcData.jsValue, usage.jsValue, srcOffset.jsValue, length?.jsValue ?? .undefined])
    }

    @inlinable func bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: ArrayBufferView, srcOffset: GLuint, length: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.bufferSubData].function!(this: this, arguments: [target.jsValue, dstByteOffset.jsValue, srcData.jsValue, srcOffset.jsValue, length?.jsValue ?? .undefined])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = format.jsValue
        let _arg4 = type.jsValue
        let _arg5 = source.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = source.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pboOffset.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = source.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = srcData.jsValue
        let _arg9 = srcOffset.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pboOffset.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = source.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = srcData.jsValue
        let _arg9 = srcOffset.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = imageSize.jsValue
        let _arg7 = offset.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint? = nil, srcLengthOverride: GLuint? = nil) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = srcData.jsValue
        let _arg7 = srcOffset?.jsValue ?? .undefined
        let _arg8 = srcLengthOverride?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.compressedTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = imageSize.jsValue
        let _arg8 = offset.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint? = nil, srcLengthOverride: GLuint? = nil) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = srcData.jsValue
        let _arg8 = srcOffset?.jsValue ?? .undefined
        let _arg9 = srcLengthOverride?.jsValue ?? .undefined
        let this = jsObject
        _ = this[Strings.compressedTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9])
    }

    @inlinable func uniform1fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform1fv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform2fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform2fv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform3fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform3fv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform4fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform4fv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform1iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform1iv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform2iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform2iv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform3iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform3iv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniform4iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniform4iv].function!(this: this, arguments: [location.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix2fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix3fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func uniformMatrix4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = nil, srcLength: GLuint? = nil) {
        let this = jsObject
        _ = this[Strings.uniformMatrix4fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, data.jsValue, srcOffset?.jsValue ?? .undefined, srcLength?.jsValue ?? .undefined])
    }

    @inlinable func readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView?) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = dstData.jsValue
        let this = jsObject
        _ = this[Strings.readPixels].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, offset: GLintptr) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = offset.jsValue
        let this = jsObject
        _ = this[Strings.readPixels].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView, dstOffset: GLuint) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = dstData.jsValue
        let _arg7 = dstOffset.jsValue
        let this = jsObject
        _ = this[Strings.readPixels].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }
}

public class WebGLActiveInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGLActiveInfo].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var size: GLint

    @ReadonlyAttribute
    public var type: GLenum

    @ReadonlyAttribute
    public var name: String
}

public class WebGLBuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLBuffer].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLContextAttributes: BridgedDictionary {
    public convenience init(alpha: Bool, depth: Bool, stencil: Bool, antialias: Bool, premultipliedAlpha: Bool, preserveDrawingBuffer: Bool, powerPreference: WebGLPowerPreference, failIfMajorPerformanceCaveat: Bool, desynchronized: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = alpha.jsValue
        object[Strings.depth] = depth.jsValue
        object[Strings.stencil] = stencil.jsValue
        object[Strings.antialias] = antialias.jsValue
        object[Strings.premultipliedAlpha] = premultipliedAlpha.jsValue
        object[Strings.preserveDrawingBuffer] = preserveDrawingBuffer.jsValue
        object[Strings.powerPreference] = powerPreference.jsValue
        object[Strings.failIfMajorPerformanceCaveat] = failIfMajorPerformanceCaveat.jsValue
        object[Strings.desynchronized] = desynchronized.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        _depth = ReadWriteAttribute(jsObject: object, name: Strings.depth)
        _stencil = ReadWriteAttribute(jsObject: object, name: Strings.stencil)
        _antialias = ReadWriteAttribute(jsObject: object, name: Strings.antialias)
        _premultipliedAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultipliedAlpha)
        _preserveDrawingBuffer = ReadWriteAttribute(jsObject: object, name: Strings.preserveDrawingBuffer)
        _powerPreference = ReadWriteAttribute(jsObject: object, name: Strings.powerPreference)
        _failIfMajorPerformanceCaveat = ReadWriteAttribute(jsObject: object, name: Strings.failIfMajorPerformanceCaveat)
        _desynchronized = ReadWriteAttribute(jsObject: object, name: Strings.desynchronized)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool

    @ReadWriteAttribute
    public var depth: Bool

    @ReadWriteAttribute
    public var stencil: Bool

    @ReadWriteAttribute
    public var antialias: Bool

    @ReadWriteAttribute
    public var premultipliedAlpha: Bool

    @ReadWriteAttribute
    public var preserveDrawingBuffer: Bool

    @ReadWriteAttribute
    public var powerPreference: WebGLPowerPreference

    @ReadWriteAttribute
    public var failIfMajorPerformanceCaveat: Bool

    @ReadWriteAttribute
    public var desynchronized: Bool
}

public class WebGLContextEvent: Event {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLContextEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _statusMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusMessage)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInit: WebGLContextEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInit?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var statusMessage: String
}

public class WebGLContextEventInit: BridgedDictionary {
    public convenience init(statusMessage: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.statusMessage] = statusMessage.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _statusMessage = ReadWriteAttribute(jsObject: object, name: Strings.statusMessage)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var statusMessage: String
}

public class WebGLFramebuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLFramebuffer].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLObject: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGLObject].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public enum WebGLPowerPreference: JSString, JSValueCompatible {
    case `default` = "default"
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class WebGLProgram: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLProgram].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLQuery: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLQuery].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLRenderbuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLRenderbuffer].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLRenderingContext: JSBridgedClass, WebGLRenderingContextBase, WebGLRenderingContextOverloads {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGLRenderingContext].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public protocol WebGLRenderingContextBase: JSBridgedClass {}
public extension WebGLRenderingContextBase {
    @inlinable static var DEPTH_BUFFER_BIT: GLenum { 0x0000_0100 }

    @inlinable static var STENCIL_BUFFER_BIT: GLenum { 0x0000_0400 }

    @inlinable static var COLOR_BUFFER_BIT: GLenum { 0x0000_4000 }

    @inlinable static var POINTS: GLenum { 0x0000 }

    @inlinable static var LINES: GLenum { 0x0001 }

    @inlinable static var LINE_LOOP: GLenum { 0x0002 }

    @inlinable static var LINE_STRIP: GLenum { 0x0003 }

    @inlinable static var TRIANGLES: GLenum { 0x0004 }

    @inlinable static var TRIANGLE_STRIP: GLenum { 0x0005 }

    @inlinable static var TRIANGLE_FAN: GLenum { 0x0006 }

    @inlinable static var ZERO: GLenum { 0 }

    @inlinable static var ONE: GLenum { 1 }

    @inlinable static var SRC_COLOR: GLenum { 0x0300 }

    @inlinable static var ONE_MINUS_SRC_COLOR: GLenum { 0x0301 }

    @inlinable static var SRC_ALPHA: GLenum { 0x0302 }

    @inlinable static var ONE_MINUS_SRC_ALPHA: GLenum { 0x0303 }

    @inlinable static var DST_ALPHA: GLenum { 0x0304 }

    @inlinable static var ONE_MINUS_DST_ALPHA: GLenum { 0x0305 }

    @inlinable static var DST_COLOR: GLenum { 0x0306 }

    @inlinable static var ONE_MINUS_DST_COLOR: GLenum { 0x0307 }

    @inlinable static var SRC_ALPHA_SATURATE: GLenum { 0x0308 }

    @inlinable static var FUNC_ADD: GLenum { 0x8006 }

    @inlinable static var BLEND_EQUATION: GLenum { 0x8009 }

    @inlinable static var BLEND_EQUATION_RGB: GLenum { 0x8009 }

    @inlinable static var BLEND_EQUATION_ALPHA: GLenum { 0x883D }

    @inlinable static var FUNC_SUBTRACT: GLenum { 0x800A }

    @inlinable static var FUNC_REVERSE_SUBTRACT: GLenum { 0x800B }

    @inlinable static var BLEND_DST_RGB: GLenum { 0x80C8 }

    @inlinable static var BLEND_SRC_RGB: GLenum { 0x80C9 }

    @inlinable static var BLEND_DST_ALPHA: GLenum { 0x80CA }

    @inlinable static var BLEND_SRC_ALPHA: GLenum { 0x80CB }

    @inlinable static var CONSTANT_COLOR: GLenum { 0x8001 }

    @inlinable static var ONE_MINUS_CONSTANT_COLOR: GLenum { 0x8002 }

    @inlinable static var CONSTANT_ALPHA: GLenum { 0x8003 }

    @inlinable static var ONE_MINUS_CONSTANT_ALPHA: GLenum { 0x8004 }

    @inlinable static var BLEND_COLOR: GLenum { 0x8005 }

    @inlinable static var ARRAY_BUFFER: GLenum { 0x8892 }

    @inlinable static var ELEMENT_ARRAY_BUFFER: GLenum { 0x8893 }

    @inlinable static var ARRAY_BUFFER_BINDING: GLenum { 0x8894 }

    @inlinable static var ELEMENT_ARRAY_BUFFER_BINDING: GLenum { 0x8895 }

    @inlinable static var STREAM_DRAW: GLenum { 0x88E0 }

    @inlinable static var STATIC_DRAW: GLenum { 0x88E4 }

    @inlinable static var DYNAMIC_DRAW: GLenum { 0x88E8 }

    @inlinable static var BUFFER_SIZE: GLenum { 0x8764 }

    @inlinable static var BUFFER_USAGE: GLenum { 0x8765 }

    @inlinable static var CURRENT_VERTEX_ATTRIB: GLenum { 0x8626 }

    @inlinable static var FRONT: GLenum { 0x0404 }

    @inlinable static var BACK: GLenum { 0x0405 }

    @inlinable static var FRONT_AND_BACK: GLenum { 0x0408 }

    @inlinable static var CULL_FACE: GLenum { 0x0B44 }

    @inlinable static var BLEND: GLenum { 0x0BE2 }

    @inlinable static var DITHER: GLenum { 0x0BD0 }

    @inlinable static var STENCIL_TEST: GLenum { 0x0B90 }

    @inlinable static var DEPTH_TEST: GLenum { 0x0B71 }

    @inlinable static var SCISSOR_TEST: GLenum { 0x0C11 }

    @inlinable static var POLYGON_OFFSET_FILL: GLenum { 0x8037 }

    @inlinable static var SAMPLE_ALPHA_TO_COVERAGE: GLenum { 0x809E }

    @inlinable static var SAMPLE_COVERAGE: GLenum { 0x80A0 }

    @inlinable static var NO_ERROR: GLenum { 0 }

    @inlinable static var INVALID_ENUM: GLenum { 0x0500 }

    @inlinable static var INVALID_VALUE: GLenum { 0x0501 }

    @inlinable static var INVALID_OPERATION: GLenum { 0x0502 }

    @inlinable static var OUT_OF_MEMORY: GLenum { 0x0505 }

    @inlinable static var CW: GLenum { 0x0900 }

    @inlinable static var CCW: GLenum { 0x0901 }

    @inlinable static var LINE_WIDTH: GLenum { 0x0B21 }

    @inlinable static var ALIASED_POINT_SIZE_RANGE: GLenum { 0x846D }

    @inlinable static var ALIASED_LINE_WIDTH_RANGE: GLenum { 0x846E }

    @inlinable static var CULL_FACE_MODE: GLenum { 0x0B45 }

    @inlinable static var FRONT_FACE: GLenum { 0x0B46 }

    @inlinable static var DEPTH_RANGE: GLenum { 0x0B70 }

    @inlinable static var DEPTH_WRITEMASK: GLenum { 0x0B72 }

    @inlinable static var DEPTH_CLEAR_VALUE: GLenum { 0x0B73 }

    @inlinable static var DEPTH_FUNC: GLenum { 0x0B74 }

    @inlinable static var STENCIL_CLEAR_VALUE: GLenum { 0x0B91 }

    @inlinable static var STENCIL_FUNC: GLenum { 0x0B92 }

    @inlinable static var STENCIL_FAIL: GLenum { 0x0B94 }

    @inlinable static var STENCIL_PASS_DEPTH_FAIL: GLenum { 0x0B95 }

    @inlinable static var STENCIL_PASS_DEPTH_PASS: GLenum { 0x0B96 }

    @inlinable static var STENCIL_REF: GLenum { 0x0B97 }

    @inlinable static var STENCIL_VALUE_MASK: GLenum { 0x0B93 }

    @inlinable static var STENCIL_WRITEMASK: GLenum { 0x0B98 }

    @inlinable static var STENCIL_BACK_FUNC: GLenum { 0x8800 }

    @inlinable static var STENCIL_BACK_FAIL: GLenum { 0x8801 }

    @inlinable static var STENCIL_BACK_PASS_DEPTH_FAIL: GLenum { 0x8802 }

    @inlinable static var STENCIL_BACK_PASS_DEPTH_PASS: GLenum { 0x8803 }

    @inlinable static var STENCIL_BACK_REF: GLenum { 0x8CA3 }

    @inlinable static var STENCIL_BACK_VALUE_MASK: GLenum { 0x8CA4 }

    @inlinable static var STENCIL_BACK_WRITEMASK: GLenum { 0x8CA5 }

    @inlinable static var VIEWPORT: GLenum { 0x0BA2 }

    @inlinable static var SCISSOR_BOX: GLenum { 0x0C10 }

    @inlinable static var COLOR_CLEAR_VALUE: GLenum { 0x0C22 }

    @inlinable static var COLOR_WRITEMASK: GLenum { 0x0C23 }

    @inlinable static var UNPACK_ALIGNMENT: GLenum { 0x0CF5 }

    @inlinable static var PACK_ALIGNMENT: GLenum { 0x0D05 }

    @inlinable static var MAX_TEXTURE_SIZE: GLenum { 0x0D33 }

    @inlinable static var MAX_VIEWPORT_DIMS: GLenum { 0x0D3A }

    @inlinable static var SUBPIXEL_BITS: GLenum { 0x0D50 }

    @inlinable static var RED_BITS: GLenum { 0x0D52 }

    @inlinable static var GREEN_BITS: GLenum { 0x0D53 }

    @inlinable static var BLUE_BITS: GLenum { 0x0D54 }

    @inlinable static var ALPHA_BITS: GLenum { 0x0D55 }

    @inlinable static var DEPTH_BITS: GLenum { 0x0D56 }

    @inlinable static var STENCIL_BITS: GLenum { 0x0D57 }

    @inlinable static var POLYGON_OFFSET_UNITS: GLenum { 0x2A00 }

    @inlinable static var POLYGON_OFFSET_FACTOR: GLenum { 0x8038 }

    @inlinable static var TEXTURE_BINDING_2D: GLenum { 0x8069 }

    @inlinable static var SAMPLE_BUFFERS: GLenum { 0x80A8 }

    @inlinable static var SAMPLES: GLenum { 0x80A9 }

    @inlinable static var SAMPLE_COVERAGE_VALUE: GLenum { 0x80AA }

    @inlinable static var SAMPLE_COVERAGE_INVERT: GLenum { 0x80AB }

    @inlinable static var COMPRESSED_TEXTURE_FORMATS: GLenum { 0x86A3 }

    @inlinable static var DONT_CARE: GLenum { 0x1100 }

    @inlinable static var FASTEST: GLenum { 0x1101 }

    @inlinable static var NICEST: GLenum { 0x1102 }

    @inlinable static var GENERATE_MIPMAP_HINT: GLenum { 0x8192 }

    @inlinable static var BYTE: GLenum { 0x1400 }

    @inlinable static var UNSIGNED_BYTE: GLenum { 0x1401 }

    @inlinable static var SHORT: GLenum { 0x1402 }

    @inlinable static var UNSIGNED_SHORT: GLenum { 0x1403 }

    @inlinable static var INT: GLenum { 0x1404 }

    @inlinable static var UNSIGNED_INT: GLenum { 0x1405 }

    @inlinable static var FLOAT: GLenum { 0x1406 }

    @inlinable static var DEPTH_COMPONENT: GLenum { 0x1902 }

    @inlinable static var ALPHA: GLenum { 0x1906 }

    @inlinable static var RGB: GLenum { 0x1907 }

    @inlinable static var RGBA: GLenum { 0x1908 }

    @inlinable static var LUMINANCE: GLenum { 0x1909 }

    @inlinable static var LUMINANCE_ALPHA: GLenum { 0x190A }

    @inlinable static var UNSIGNED_SHORT_4_4_4_4: GLenum { 0x8033 }

    @inlinable static var UNSIGNED_SHORT_5_5_5_1: GLenum { 0x8034 }

    @inlinable static var UNSIGNED_SHORT_5_6_5: GLenum { 0x8363 }

    @inlinable static var FRAGMENT_SHADER: GLenum { 0x8B30 }

    @inlinable static var VERTEX_SHADER: GLenum { 0x8B31 }

    @inlinable static var MAX_VERTEX_ATTRIBS: GLenum { 0x8869 }

    @inlinable static var MAX_VERTEX_UNIFORM_VECTORS: GLenum { 0x8DFB }

    @inlinable static var MAX_VARYING_VECTORS: GLenum { 0x8DFC }

    @inlinable static var MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum { 0x8B4D }

    @inlinable static var MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum { 0x8B4C }

    @inlinable static var MAX_TEXTURE_IMAGE_UNITS: GLenum { 0x8872 }

    @inlinable static var MAX_FRAGMENT_UNIFORM_VECTORS: GLenum { 0x8DFD }

    @inlinable static var SHADER_TYPE: GLenum { 0x8B4F }

    @inlinable static var DELETE_STATUS: GLenum { 0x8B80 }

    @inlinable static var LINK_STATUS: GLenum { 0x8B82 }

    @inlinable static var VALIDATE_STATUS: GLenum { 0x8B83 }

    @inlinable static var ATTACHED_SHADERS: GLenum { 0x8B85 }

    @inlinable static var ACTIVE_UNIFORMS: GLenum { 0x8B86 }

    @inlinable static var ACTIVE_ATTRIBUTES: GLenum { 0x8B89 }

    @inlinable static var SHADING_LANGUAGE_VERSION: GLenum { 0x8B8C }

    @inlinable static var CURRENT_PROGRAM: GLenum { 0x8B8D }

    @inlinable static var NEVER: GLenum { 0x0200 }

    @inlinable static var LESS: GLenum { 0x0201 }

    @inlinable static var EQUAL: GLenum { 0x0202 }

    @inlinable static var LEQUAL: GLenum { 0x0203 }

    @inlinable static var GREATER: GLenum { 0x0204 }

    @inlinable static var NOTEQUAL: GLenum { 0x0205 }

    @inlinable static var GEQUAL: GLenum { 0x0206 }

    @inlinable static var ALWAYS: GLenum { 0x0207 }

    @inlinable static var KEEP: GLenum { 0x1E00 }

    @inlinable static var REPLACE: GLenum { 0x1E01 }

    @inlinable static var INCR: GLenum { 0x1E02 }

    @inlinable static var DECR: GLenum { 0x1E03 }

    @inlinable static var INVERT: GLenum { 0x150A }

    @inlinable static var INCR_WRAP: GLenum { 0x8507 }

    @inlinable static var DECR_WRAP: GLenum { 0x8508 }

    @inlinable static var VENDOR: GLenum { 0x1F00 }

    @inlinable static var RENDERER: GLenum { 0x1F01 }

    @inlinable static var VERSION: GLenum { 0x1F02 }

    @inlinable static var NEAREST: GLenum { 0x2600 }

    @inlinable static var LINEAR: GLenum { 0x2601 }

    @inlinable static var NEAREST_MIPMAP_NEAREST: GLenum { 0x2700 }

    @inlinable static var LINEAR_MIPMAP_NEAREST: GLenum { 0x2701 }

    @inlinable static var NEAREST_MIPMAP_LINEAR: GLenum { 0x2702 }

    @inlinable static var LINEAR_MIPMAP_LINEAR: GLenum { 0x2703 }

    @inlinable static var TEXTURE_MAG_FILTER: GLenum { 0x2800 }

    @inlinable static var TEXTURE_MIN_FILTER: GLenum { 0x2801 }

    @inlinable static var TEXTURE_WRAP_S: GLenum { 0x2802 }

    @inlinable static var TEXTURE_WRAP_T: GLenum { 0x2803 }

    @inlinable static var TEXTURE_2D: GLenum { 0x0DE1 }

    @inlinable static var TEXTURE: GLenum { 0x1702 }

    @inlinable static var TEXTURE_CUBE_MAP: GLenum { 0x8513 }

    @inlinable static var TEXTURE_BINDING_CUBE_MAP: GLenum { 0x8514 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_X: GLenum { 0x8515 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum { 0x8516 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum { 0x8517 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum { 0x8518 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum { 0x8519 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum { 0x851A }

    @inlinable static var MAX_CUBE_MAP_TEXTURE_SIZE: GLenum { 0x851C }

    @inlinable static var TEXTURE0: GLenum { 0x84C0 }

    @inlinable static var TEXTURE1: GLenum { 0x84C1 }

    @inlinable static var TEXTURE2: GLenum { 0x84C2 }

    @inlinable static var TEXTURE3: GLenum { 0x84C3 }

    @inlinable static var TEXTURE4: GLenum { 0x84C4 }

    @inlinable static var TEXTURE5: GLenum { 0x84C5 }

    @inlinable static var TEXTURE6: GLenum { 0x84C6 }

    @inlinable static var TEXTURE7: GLenum { 0x84C7 }

    @inlinable static var TEXTURE8: GLenum { 0x84C8 }

    @inlinable static var TEXTURE9: GLenum { 0x84C9 }

    @inlinable static var TEXTURE10: GLenum { 0x84CA }

    @inlinable static var TEXTURE11: GLenum { 0x84CB }

    @inlinable static var TEXTURE12: GLenum { 0x84CC }

    @inlinable static var TEXTURE13: GLenum { 0x84CD }

    @inlinable static var TEXTURE14: GLenum { 0x84CE }

    @inlinable static var TEXTURE15: GLenum { 0x84CF }

    @inlinable static var TEXTURE16: GLenum { 0x84D0 }

    @inlinable static var TEXTURE17: GLenum { 0x84D1 }

    @inlinable static var TEXTURE18: GLenum { 0x84D2 }

    @inlinable static var TEXTURE19: GLenum { 0x84D3 }

    @inlinable static var TEXTURE20: GLenum { 0x84D4 }

    @inlinable static var TEXTURE21: GLenum { 0x84D5 }

    @inlinable static var TEXTURE22: GLenum { 0x84D6 }

    @inlinable static var TEXTURE23: GLenum { 0x84D7 }

    @inlinable static var TEXTURE24: GLenum { 0x84D8 }

    @inlinable static var TEXTURE25: GLenum { 0x84D9 }

    @inlinable static var TEXTURE26: GLenum { 0x84DA }

    @inlinable static var TEXTURE27: GLenum { 0x84DB }

    @inlinable static var TEXTURE28: GLenum { 0x84DC }

    @inlinable static var TEXTURE29: GLenum { 0x84DD }

    @inlinable static var TEXTURE30: GLenum { 0x84DE }

    @inlinable static var TEXTURE31: GLenum { 0x84DF }

    @inlinable static var ACTIVE_TEXTURE: GLenum { 0x84E0 }

    @inlinable static var REPEAT: GLenum { 0x2901 }

    @inlinable static var CLAMP_TO_EDGE: GLenum { 0x812F }

    @inlinable static var MIRRORED_REPEAT: GLenum { 0x8370 }

    @inlinable static var FLOAT_VEC2: GLenum { 0x8B50 }

    @inlinable static var FLOAT_VEC3: GLenum { 0x8B51 }

    @inlinable static var FLOAT_VEC4: GLenum { 0x8B52 }

    @inlinable static var INT_VEC2: GLenum { 0x8B53 }

    @inlinable static var INT_VEC3: GLenum { 0x8B54 }

    @inlinable static var INT_VEC4: GLenum { 0x8B55 }

    @inlinable static var BOOL: GLenum { 0x8B56 }

    @inlinable static var BOOL_VEC2: GLenum { 0x8B57 }

    @inlinable static var BOOL_VEC3: GLenum { 0x8B58 }

    @inlinable static var BOOL_VEC4: GLenum { 0x8B59 }

    @inlinable static var FLOAT_MAT2: GLenum { 0x8B5A }

    @inlinable static var FLOAT_MAT3: GLenum { 0x8B5B }

    @inlinable static var FLOAT_MAT4: GLenum { 0x8B5C }

    @inlinable static var SAMPLER_2D: GLenum { 0x8B5E }

    @inlinable static var SAMPLER_CUBE: GLenum { 0x8B60 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_ENABLED: GLenum { 0x8622 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_SIZE: GLenum { 0x8623 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_STRIDE: GLenum { 0x8624 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_TYPE: GLenum { 0x8625 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum { 0x886A }

    @inlinable static var VERTEX_ATTRIB_ARRAY_POINTER: GLenum { 0x8645 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum { 0x889F }

    @inlinable static var IMPLEMENTATION_COLOR_READ_TYPE: GLenum { 0x8B9A }

    @inlinable static var IMPLEMENTATION_COLOR_READ_FORMAT: GLenum { 0x8B9B }

    @inlinable static var COMPILE_STATUS: GLenum { 0x8B81 }

    @inlinable static var LOW_FLOAT: GLenum { 0x8DF0 }

    @inlinable static var MEDIUM_FLOAT: GLenum { 0x8DF1 }

    @inlinable static var HIGH_FLOAT: GLenum { 0x8DF2 }

    @inlinable static var LOW_INT: GLenum { 0x8DF3 }

    @inlinable static var MEDIUM_INT: GLenum { 0x8DF4 }

    @inlinable static var HIGH_INT: GLenum { 0x8DF5 }

    @inlinable static var FRAMEBUFFER: GLenum { 0x8D40 }

    @inlinable static var RENDERBUFFER: GLenum { 0x8D41 }

    @inlinable static var RGBA4: GLenum { 0x8056 }

    @inlinable static var RGB5_A1: GLenum { 0x8057 }

    @inlinable static var RGB565: GLenum { 0x8D62 }

    @inlinable static var DEPTH_COMPONENT16: GLenum { 0x81A5 }

    @inlinable static var STENCIL_INDEX8: GLenum { 0x8D48 }

    @inlinable static var DEPTH_STENCIL: GLenum { 0x84F9 }

    @inlinable static var RENDERBUFFER_WIDTH: GLenum { 0x8D42 }

    @inlinable static var RENDERBUFFER_HEIGHT: GLenum { 0x8D43 }

    @inlinable static var RENDERBUFFER_INTERNAL_FORMAT: GLenum { 0x8D44 }

    @inlinable static var RENDERBUFFER_RED_SIZE: GLenum { 0x8D50 }

    @inlinable static var RENDERBUFFER_GREEN_SIZE: GLenum { 0x8D51 }

    @inlinable static var RENDERBUFFER_BLUE_SIZE: GLenum { 0x8D52 }

    @inlinable static var RENDERBUFFER_ALPHA_SIZE: GLenum { 0x8D53 }

    @inlinable static var RENDERBUFFER_DEPTH_SIZE: GLenum { 0x8D54 }

    @inlinable static var RENDERBUFFER_STENCIL_SIZE: GLenum { 0x8D55 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum { 0x8CD0 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum { 0x8CD1 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum { 0x8CD2 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum { 0x8CD3 }

    @inlinable static var COLOR_ATTACHMENT0: GLenum { 0x8CE0 }

    @inlinable static var DEPTH_ATTACHMENT: GLenum { 0x8D00 }

    @inlinable static var STENCIL_ATTACHMENT: GLenum { 0x8D20 }

    @inlinable static var DEPTH_STENCIL_ATTACHMENT: GLenum { 0x821A }

    @inlinable static var NONE: GLenum { 0 }

    @inlinable static var FRAMEBUFFER_COMPLETE: GLenum { 0x8CD5 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum { 0x8CD6 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum { 0x8CD7 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum { 0x8CD9 }

    @inlinable static var FRAMEBUFFER_UNSUPPORTED: GLenum { 0x8CDD }

    @inlinable static var FRAMEBUFFER_BINDING: GLenum { 0x8CA6 }

    @inlinable static var RENDERBUFFER_BINDING: GLenum { 0x8CA7 }

    @inlinable static var MAX_RENDERBUFFER_SIZE: GLenum { 0x84E8 }

    @inlinable static var INVALID_FRAMEBUFFER_OPERATION: GLenum { 0x0506 }

    @inlinable static var UNPACK_FLIP_Y_WEBGL: GLenum { 0x9240 }

    @inlinable static var UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum { 0x9241 }

    @inlinable static var CONTEXT_LOST_WEBGL: GLenum { 0x9242 }

    @inlinable static var UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum { 0x9243 }

    @inlinable static var BROWSER_DEFAULT_WEBGL: GLenum { 0x9244 }

    @inlinable var canvas: HTMLCanvasElement_or_OffscreenCanvas { ReadonlyAttribute[Strings.canvas, in: jsObject] }

    @inlinable var drawingBufferWidth: GLsizei { ReadonlyAttribute[Strings.drawingBufferWidth, in: jsObject] }

    @inlinable var drawingBufferHeight: GLsizei { ReadonlyAttribute[Strings.drawingBufferHeight, in: jsObject] }

    @inlinable func getContextAttributes() -> WebGLContextAttributes? {
        let this = jsObject
        return this[Strings.getContextAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func isContextLost() -> Bool {
        let this = jsObject
        return this[Strings.isContextLost].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getSupportedExtensions() -> [String]? {
        let this = jsObject
        return this[Strings.getSupportedExtensions].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getExtension(name: String) -> JSObject? {
        let this = jsObject
        return this[Strings.getExtension].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable func activeTexture(texture: GLenum) {
        let this = jsObject
        _ = this[Strings.activeTexture].function!(this: this, arguments: [texture.jsValue])
    }

    @inlinable func attachShader(program: WebGLProgram, shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.attachShader].function!(this: this, arguments: [program.jsValue, shader.jsValue])
    }

    @inlinable func bindAttribLocation(program: WebGLProgram, index: GLuint, name: String) {
        let this = jsObject
        _ = this[Strings.bindAttribLocation].function!(this: this, arguments: [program.jsValue, index.jsValue, name.jsValue])
    }

    @inlinable func bindBuffer(target: GLenum, buffer: WebGLBuffer?) {
        let this = jsObject
        _ = this[Strings.bindBuffer].function!(this: this, arguments: [target.jsValue, buffer.jsValue])
    }

    @inlinable func bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer?) {
        let this = jsObject
        _ = this[Strings.bindFramebuffer].function!(this: this, arguments: [target.jsValue, framebuffer.jsValue])
    }

    @inlinable func bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.bindRenderbuffer].function!(this: this, arguments: [target.jsValue, renderbuffer.jsValue])
    }

    @inlinable func bindTexture(target: GLenum, texture: WebGLTexture?) {
        let this = jsObject
        _ = this[Strings.bindTexture].function!(this: this, arguments: [target.jsValue, texture.jsValue])
    }

    @inlinable func blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf) {
        let this = jsObject
        _ = this[Strings.blendColor].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func blendEquation(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.blendEquation].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) {
        let this = jsObject
        _ = this[Strings.blendEquationSeparate].function!(this: this, arguments: [modeRGB.jsValue, modeAlpha.jsValue])
    }

    @inlinable func blendFunc(sfactor: GLenum, dfactor: GLenum) {
        let this = jsObject
        _ = this[Strings.blendFunc].function!(this: this, arguments: [sfactor.jsValue, dfactor.jsValue])
    }

    @inlinable func blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) {
        let this = jsObject
        _ = this[Strings.blendFuncSeparate].function!(this: this, arguments: [srcRGB.jsValue, dstRGB.jsValue, srcAlpha.jsValue, dstAlpha.jsValue])
    }

    @inlinable func checkFramebufferStatus(target: GLenum) -> GLenum {
        let this = jsObject
        return this[Strings.checkFramebufferStatus].function!(this: this, arguments: [target.jsValue]).fromJSValue()!
    }

    @inlinable func clear(mask: GLbitfield) {
        let this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [mask.jsValue])
    }

    @inlinable func clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf) {
        let this = jsObject
        _ = this[Strings.clearColor].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func clearDepth(depth: GLclampf) {
        let this = jsObject
        _ = this[Strings.clearDepth].function!(this: this, arguments: [depth.jsValue])
    }

    @inlinable func clearStencil(s: GLint) {
        let this = jsObject
        _ = this[Strings.clearStencil].function!(this: this, arguments: [s.jsValue])
    }

    @inlinable func colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {
        let this = jsObject
        _ = this[Strings.colorMask].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func compileShader(shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.compileShader].function!(this: this, arguments: [shader.jsValue])
    }

    @inlinable func copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = x.jsValue
        let _arg4 = y.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = border.jsValue
        let this = jsObject
        _ = this[Strings.copyTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = x.jsValue
        let _arg5 = y.jsValue
        let _arg6 = width.jsValue
        let _arg7 = height.jsValue
        let this = jsObject
        _ = this[Strings.copyTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func createBuffer() -> WebGLBuffer? {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createFramebuffer() -> WebGLFramebuffer? {
        let this = jsObject
        return this[Strings.createFramebuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createProgram() -> WebGLProgram? {
        let this = jsObject
        return this[Strings.createProgram].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createRenderbuffer() -> WebGLRenderbuffer? {
        let this = jsObject
        return this[Strings.createRenderbuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createShader(type: GLenum) -> WebGLShader? {
        let this = jsObject
        return this[Strings.createShader].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @inlinable func createTexture() -> WebGLTexture? {
        let this = jsObject
        return this[Strings.createTexture].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func cullFace(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.cullFace].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func deleteBuffer(buffer: WebGLBuffer?) {
        let this = jsObject
        _ = this[Strings.deleteBuffer].function!(this: this, arguments: [buffer.jsValue])
    }

    @inlinable func deleteFramebuffer(framebuffer: WebGLFramebuffer?) {
        let this = jsObject
        _ = this[Strings.deleteFramebuffer].function!(this: this, arguments: [framebuffer.jsValue])
    }

    @inlinable func deleteProgram(program: WebGLProgram?) {
        let this = jsObject
        _ = this[Strings.deleteProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.deleteRenderbuffer].function!(this: this, arguments: [renderbuffer.jsValue])
    }

    @inlinable func deleteShader(shader: WebGLShader?) {
        let this = jsObject
        _ = this[Strings.deleteShader].function!(this: this, arguments: [shader.jsValue])
    }

    @inlinable func deleteTexture(texture: WebGLTexture?) {
        let this = jsObject
        _ = this[Strings.deleteTexture].function!(this: this, arguments: [texture.jsValue])
    }

    @inlinable func depthFunc(func: GLenum) {
        let this = jsObject
        _ = this[Strings.depthFunc].function!(this: this, arguments: [`func`.jsValue])
    }

    @inlinable func depthMask(flag: GLboolean) {
        let this = jsObject
        _ = this[Strings.depthMask].function!(this: this, arguments: [flag.jsValue])
    }

    @inlinable func depthRange(zNear: GLclampf, zFar: GLclampf) {
        let this = jsObject
        _ = this[Strings.depthRange].function!(this: this, arguments: [zNear.jsValue, zFar.jsValue])
    }

    @inlinable func detachShader(program: WebGLProgram, shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.detachShader].function!(this: this, arguments: [program.jsValue, shader.jsValue])
    }

    @inlinable func disable(cap: GLenum) {
        let this = jsObject
        _ = this[Strings.disable].function!(this: this, arguments: [cap.jsValue])
    }

    @inlinable func disableVertexAttribArray(index: GLuint) {
        let this = jsObject
        _ = this[Strings.disableVertexAttribArray].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable func drawArrays(mode: GLenum, first: GLint, count: GLsizei) {
        let this = jsObject
        _ = this[Strings.drawArrays].function!(this: this, arguments: [mode.jsValue, first.jsValue, count.jsValue])
    }

    @inlinable func drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr) {
        let this = jsObject
        _ = this[Strings.drawElements].function!(this: this, arguments: [mode.jsValue, count.jsValue, type.jsValue, offset.jsValue])
    }

    @inlinable func enable(cap: GLenum) {
        let this = jsObject
        _ = this[Strings.enable].function!(this: this, arguments: [cap.jsValue])
    }

    @inlinable func enableVertexAttribArray(index: GLuint) {
        let this = jsObject
        _ = this[Strings.enableVertexAttribArray].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable func finish() {
        let this = jsObject
        _ = this[Strings.finish].function!(this: this, arguments: [])
    }

    @inlinable func flush() {
        let this = jsObject
        _ = this[Strings.flush].function!(this: this, arguments: [])
    }

    @inlinable func framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.framebufferRenderbuffer].function!(this: this, arguments: [target.jsValue, attachment.jsValue, renderbuffertarget.jsValue, renderbuffer.jsValue])
    }

    @inlinable func framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture?, level: GLint) {
        let this = jsObject
        _ = this[Strings.framebufferTexture2D].function!(this: this, arguments: [target.jsValue, attachment.jsValue, textarget.jsValue, texture.jsValue, level.jsValue])
    }

    @inlinable func frontFace(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.frontFace].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func generateMipmap(target: GLenum) {
        let this = jsObject
        _ = this[Strings.generateMipmap].function!(this: this, arguments: [target.jsValue])
    }

    @inlinable func getActiveAttrib(program: WebGLProgram, index: GLuint) -> WebGLActiveInfo? {
        let this = jsObject
        return this[Strings.getActiveAttrib].function!(this: this, arguments: [program.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func getActiveUniform(program: WebGLProgram, index: GLuint) -> WebGLActiveInfo? {
        let this = jsObject
        return this[Strings.getActiveUniform].function!(this: this, arguments: [program.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func getAttachedShaders(program: WebGLProgram) -> [WebGLShader]? {
        let this = jsObject
        return this[Strings.getAttachedShaders].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func getAttribLocation(program: WebGLProgram, name: String) -> GLint {
        let this = jsObject
        return this[Strings.getAttribLocation].function!(this: this, arguments: [program.jsValue, name.jsValue]).fromJSValue()!
    }

    @inlinable func getBufferParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getBufferParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getParameter(pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getParameter].function!(this: this, arguments: [pname.jsValue]).fromJSValue()!
    }

    @inlinable func getError() -> GLenum {
        let this = jsObject
        return this[Strings.getError].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getFramebufferAttachmentParameter].function!(this: this, arguments: [target.jsValue, attachment.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getProgramParameter(program: WebGLProgram, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getProgramParameter].function!(this: this, arguments: [program.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getProgramInfoLog(program: WebGLProgram) -> String? {
        let this = jsObject
        return this[Strings.getProgramInfoLog].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func getRenderbufferParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getRenderbufferParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderParameter(shader: WebGLShader, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getShaderParameter].function!(this: this, arguments: [shader.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum) -> WebGLShaderPrecisionFormat? {
        let this = jsObject
        return this[Strings.getShaderPrecisionFormat].function!(this: this, arguments: [shadertype.jsValue, precisiontype.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderInfoLog(shader: WebGLShader) -> String? {
        let this = jsObject
        return this[Strings.getShaderInfoLog].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderSource(shader: WebGLShader) -> String? {
        let this = jsObject
        return this[Strings.getShaderSource].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func getTexParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getTexParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getUniform(program: WebGLProgram, location: WebGLUniformLocation) -> JSValue {
        let this = jsObject
        return this[Strings.getUniform].function!(this: this, arguments: [program.jsValue, location.jsValue]).fromJSValue()!
    }

    @inlinable func getUniformLocation(program: WebGLProgram, name: String) -> WebGLUniformLocation? {
        let this = jsObject
        return this[Strings.getUniformLocation].function!(this: this, arguments: [program.jsValue, name.jsValue]).fromJSValue()!
    }

    @inlinable func getVertexAttrib(index: GLuint, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getVertexAttrib].function!(this: this, arguments: [index.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getVertexAttribOffset(index: GLuint, pname: GLenum) -> GLintptr {
        let this = jsObject
        return this[Strings.getVertexAttribOffset].function!(this: this, arguments: [index.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func hint(target: GLenum, mode: GLenum) {
        let this = jsObject
        _ = this[Strings.hint].function!(this: this, arguments: [target.jsValue, mode.jsValue])
    }

    @inlinable func isBuffer(buffer: WebGLBuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isBuffer].function!(this: this, arguments: [buffer.jsValue]).fromJSValue()!
    }

    @inlinable func isEnabled(cap: GLenum) -> GLboolean {
        let this = jsObject
        return this[Strings.isEnabled].function!(this: this, arguments: [cap.jsValue]).fromJSValue()!
    }

    @inlinable func isFramebuffer(framebuffer: WebGLFramebuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isFramebuffer].function!(this: this, arguments: [framebuffer.jsValue]).fromJSValue()!
    }

    @inlinable func isProgram(program: WebGLProgram?) -> GLboolean {
        let this = jsObject
        return this[Strings.isProgram].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func isRenderbuffer(renderbuffer: WebGLRenderbuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isRenderbuffer].function!(this: this, arguments: [renderbuffer.jsValue]).fromJSValue()!
    }

    @inlinable func isShader(shader: WebGLShader?) -> GLboolean {
        let this = jsObject
        return this[Strings.isShader].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func isTexture(texture: WebGLTexture?) -> GLboolean {
        let this = jsObject
        return this[Strings.isTexture].function!(this: this, arguments: [texture.jsValue]).fromJSValue()!
    }

    @inlinable func lineWidth(width: GLfloat) {
        let this = jsObject
        _ = this[Strings.lineWidth].function!(this: this, arguments: [width.jsValue])
    }

    @inlinable func linkProgram(program: WebGLProgram) {
        let this = jsObject
        _ = this[Strings.linkProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func pixelStorei(pname: GLenum, param: GLint) {
        let this = jsObject
        _ = this[Strings.pixelStorei].function!(this: this, arguments: [pname.jsValue, param.jsValue])
    }

    @inlinable func polygonOffset(factor: GLfloat, units: GLfloat) {
        let this = jsObject
        _ = this[Strings.polygonOffset].function!(this: this, arguments: [factor.jsValue, units.jsValue])
    }

    @inlinable func renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.renderbufferStorage].function!(this: this, arguments: [target.jsValue, internalformat.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func sampleCoverage(value: GLclampf, invert: GLboolean) {
        let this = jsObject
        _ = this[Strings.sampleCoverage].function!(this: this, arguments: [value.jsValue, invert.jsValue])
    }

    @inlinable func scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.scissor].function!(this: this, arguments: [x.jsValue, y.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func shaderSource(shader: WebGLShader, source: String) {
        let this = jsObject
        _ = this[Strings.shaderSource].function!(this: this, arguments: [shader.jsValue, source.jsValue])
    }

    @inlinable func stencilFunc(func: GLenum, ref: GLint, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilFunc].function!(this: this, arguments: [`func`.jsValue, ref.jsValue, mask.jsValue])
    }

    @inlinable func stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilFuncSeparate].function!(this: this, arguments: [face.jsValue, `func`.jsValue, ref.jsValue, mask.jsValue])
    }

    @inlinable func stencilMask(mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilMask].function!(this: this, arguments: [mask.jsValue])
    }

    @inlinable func stencilMaskSeparate(face: GLenum, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilMaskSeparate].function!(this: this, arguments: [face.jsValue, mask.jsValue])
    }

    @inlinable func stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) {
        let this = jsObject
        _ = this[Strings.stencilOp].function!(this: this, arguments: [fail.jsValue, zfail.jsValue, zpass.jsValue])
    }

    @inlinable func stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum) {
        let this = jsObject
        _ = this[Strings.stencilOpSeparate].function!(this: this, arguments: [face.jsValue, fail.jsValue, zfail.jsValue, zpass.jsValue])
    }

    @inlinable func texParameterf(target: GLenum, pname: GLenum, param: GLfloat) {
        let this = jsObject
        _ = this[Strings.texParameterf].function!(this: this, arguments: [target.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func texParameteri(target: GLenum, pname: GLenum, param: GLint) {
        let this = jsObject
        _ = this[Strings.texParameteri].function!(this: this, arguments: [target.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func uniform1f(location: WebGLUniformLocation?, x: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform1f].function!(this: this, arguments: [location.jsValue, x.jsValue])
    }

    @inlinable func uniform2f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform2f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func uniform3f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform3f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func uniform4f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform4f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func uniform1i(location: WebGLUniformLocation?, x: GLint) {
        let this = jsObject
        _ = this[Strings.uniform1i].function!(this: this, arguments: [location.jsValue, x.jsValue])
    }

    @inlinable func uniform2i(location: WebGLUniformLocation?, x: GLint, y: GLint) {
        let this = jsObject
        _ = this[Strings.uniform2i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func uniform3i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint) {
        let this = jsObject
        _ = this[Strings.uniform3i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func uniform4i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint, w: GLint) {
        let this = jsObject
        _ = this[Strings.uniform4i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func useProgram(program: WebGLProgram?) {
        let this = jsObject
        _ = this[Strings.useProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func validateProgram(program: WebGLProgram) {
        let this = jsObject
        _ = this[Strings.validateProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func vertexAttrib1f(index: GLuint, x: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib1f].function!(this: this, arguments: [index.jsValue, x.jsValue])
    }

    @inlinable func vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib2f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib3f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib4f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func vertexAttrib1fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib1fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib2fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib2fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib3fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib3fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib4fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib4fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr) {
        let _arg0 = index.jsValue
        let _arg1 = size.jsValue
        let _arg2 = type.jsValue
        let _arg3 = normalized.jsValue
        let _arg4 = stride.jsValue
        let _arg5 = offset.jsValue
        let this = jsObject
        _ = this[Strings.vertexAttribPointer].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.viewport].function!(this: this, arguments: [x.jsValue, y.jsValue, width.jsValue, height.jsValue])
    }
}

public protocol WebGLRenderingContextOverloads: JSBridgedClass {}
public extension WebGLRenderingContextOverloads {
    @inlinable func bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, size.jsValue, usage.jsValue])
    }

    @inlinable func bufferData(target: GLenum, data: BufferSource?, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, data.jsValue, usage.jsValue])
    }

    @inlinable func bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource) {
        let this = jsObject
        _ = this[Strings.bufferSubData].function!(this: this, arguments: [target.jsValue, offset.jsValue, data.jsValue])
    }

    @inlinable func compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = data.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = data.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.readPixels].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = format.jsValue
        let _arg4 = type.jsValue
        let _arg5 = source.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = source.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func uniform1fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform1fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform2fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform2fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform3fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform3fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform4fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform4fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform1iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform1iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform2iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform2iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform3iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform3iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform4iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform4iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniformMatrix2fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix2fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }

    @inlinable func uniformMatrix3fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix3fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }

    @inlinable func uniformMatrix4fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix4fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }
}

public class WebGLSampler: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLSampler].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLShader: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLShader].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLShaderPrecisionFormat: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGLShaderPrecisionFormat].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rangeMin = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeMin)
        _rangeMax = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeMax)
        _precision = ReadonlyAttribute(jsObject: jsObject, name: Strings.precision)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var rangeMin: GLint

    @ReadonlyAttribute
    public var rangeMax: GLint

    @ReadonlyAttribute
    public var precision: GLint
}

public class WebGLSync: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLSync].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLTexture: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLTexture].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLTransformFeedback: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLTransformFeedback].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLUniformLocation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WebGLUniformLocation].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class WebGLVertexArrayObject: WebGLObject {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebGLVertexArrayObject].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebSocket: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WebSocket].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: Strings.url)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _bufferedAmount = ReadonlyAttribute(jsObject: jsObject, name: Strings.bufferedAmount)
        _onopen = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onopen)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        _onclose = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onclose)
        _extensions = ReadonlyAttribute(jsObject: jsObject, name: Strings.extensions)
        _protocol = ReadonlyAttribute(jsObject: jsObject, name: Strings.protocol)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _binaryType = ReadWriteAttribute(jsObject: jsObject, name: Strings.binaryType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(url: String, protocols: String_or_seq_of_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [url.jsValue, protocols?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var url: String

    public static let CONNECTING: UInt16 = 0

    public static let OPEN: UInt16 = 1

    public static let CLOSING: UInt16 = 2

    public static let CLOSED: UInt16 = 3

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var bufferedAmount: UInt64

    @ClosureAttribute1Optional
    public var onopen: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onclose: EventHandler

    @ReadonlyAttribute
    public var extensions: String

    @ReadonlyAttribute
    public var `protocol`: String

    @inlinable public func close(code: UInt16? = nil, reason: String? = nil) {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [code?.jsValue ?? .undefined, reason?.jsValue ?? .undefined])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ReadWriteAttribute
    public var binaryType: BinaryType

    @inlinable public func send(data: BlobPart) {
        let this = jsObject
        _ = this[Strings.send].function!(this: this, arguments: [data.jsValue])
    }
}

public class WheelEvent: MouseEvent {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.WheelEvent].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _deltaX = ReadonlyAttribute(jsObject: jsObject, name: Strings.deltaX)
        _deltaY = ReadonlyAttribute(jsObject: jsObject, name: Strings.deltaY)
        _deltaZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.deltaZ)
        _deltaMode = ReadonlyAttribute(jsObject: jsObject, name: Strings.deltaMode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: WheelEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [type.jsValue, eventInitDict?.jsValue ?? .undefined]))
    }

    public static let DOM_DELTA_PIXEL: UInt32 = 0x00

    public static let DOM_DELTA_LINE: UInt32 = 0x01

    public static let DOM_DELTA_PAGE: UInt32 = 0x02

    @ReadonlyAttribute
    public var deltaX: Double

    @ReadonlyAttribute
    public var deltaY: Double

    @ReadonlyAttribute
    public var deltaZ: Double

    @ReadonlyAttribute
    public var deltaMode: UInt32
}

public class WheelEventInit: BridgedDictionary {
    public convenience init(deltaX: Double, deltaY: Double, deltaZ: Double, deltaMode: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.deltaX] = deltaX.jsValue
        object[Strings.deltaY] = deltaY.jsValue
        object[Strings.deltaZ] = deltaZ.jsValue
        object[Strings.deltaMode] = deltaMode.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _deltaX = ReadWriteAttribute(jsObject: object, name: Strings.deltaX)
        _deltaY = ReadWriteAttribute(jsObject: object, name: Strings.deltaY)
        _deltaZ = ReadWriteAttribute(jsObject: object, name: Strings.deltaZ)
        _deltaMode = ReadWriteAttribute(jsObject: object, name: Strings.deltaMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var deltaX: Double

    @ReadWriteAttribute
    public var deltaY: Double

    @ReadWriteAttribute
    public var deltaZ: Double

    @ReadWriteAttribute
    public var deltaMode: UInt32
}

public class Window: EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, AnimationFrameProvider, WindowSessionStorage, WindowLocalStorage {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Window].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _event = ReadonlyAttribute(jsObject: jsObject, name: Strings.event)
        _window = ReadonlyAttribute(jsObject: jsObject, name: Strings.window)
        _self = ReadonlyAttribute(jsObject: jsObject, name: Strings._self)
        _document = ReadonlyAttribute(jsObject: jsObject, name: Strings.document)
        _name = ReadWriteAttribute(jsObject: jsObject, name: Strings.name)
        _location = ReadonlyAttribute(jsObject: jsObject, name: Strings.location)
        _history = ReadonlyAttribute(jsObject: jsObject, name: Strings.history)
        _customElements = ReadonlyAttribute(jsObject: jsObject, name: Strings.customElements)
        _locationbar = ReadonlyAttribute(jsObject: jsObject, name: Strings.locationbar)
        _menubar = ReadonlyAttribute(jsObject: jsObject, name: Strings.menubar)
        _personalbar = ReadonlyAttribute(jsObject: jsObject, name: Strings.personalbar)
        _scrollbars = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollbars)
        _statusbar = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusbar)
        _toolbar = ReadonlyAttribute(jsObject: jsObject, name: Strings.toolbar)
        _status = ReadWriteAttribute(jsObject: jsObject, name: Strings.status)
        _closed = ReadonlyAttribute(jsObject: jsObject, name: Strings.closed)
        _frames = ReadonlyAttribute(jsObject: jsObject, name: Strings.frames)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _top = ReadonlyAttribute(jsObject: jsObject, name: Strings.top)
        _opener = ReadWriteAttribute(jsObject: jsObject, name: Strings.opener)
        _parent = ReadonlyAttribute(jsObject: jsObject, name: Strings.parent)
        _frameElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.frameElement)
        _navigator = ReadonlyAttribute(jsObject: jsObject, name: Strings.navigator)
        _clientInformation = ReadonlyAttribute(jsObject: jsObject, name: Strings.clientInformation)
        _originAgentCluster = ReadonlyAttribute(jsObject: jsObject, name: Strings.originAgentCluster)
        _external = ReadonlyAttribute(jsObject: jsObject, name: Strings.external)
        _screen = ReadonlyAttribute(jsObject: jsObject, name: Strings.screen)
        _innerWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.innerWidth)
        _innerHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.innerHeight)
        _scrollX = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollX)
        _pageXOffset = ReadonlyAttribute(jsObject: jsObject, name: Strings.pageXOffset)
        _scrollY = ReadonlyAttribute(jsObject: jsObject, name: Strings.scrollY)
        _pageYOffset = ReadonlyAttribute(jsObject: jsObject, name: Strings.pageYOffset)
        _screenX = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenX)
        _screenLeft = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenLeft)
        _screenY = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenY)
        _screenTop = ReadonlyAttribute(jsObject: jsObject, name: Strings.screenTop)
        _outerWidth = ReadonlyAttribute(jsObject: jsObject, name: Strings.outerWidth)
        _outerHeight = ReadonlyAttribute(jsObject: jsObject, name: Strings.outerHeight)
        _devicePixelRatio = ReadonlyAttribute(jsObject: jsObject, name: Strings.devicePixelRatio)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var event: Event?

    @ReadonlyAttribute
    public var window: WindowProxy

    @ReadonlyAttribute
    public var `self`: WindowProxy

    @ReadonlyAttribute
    public var document: Document

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var location: Location

    @ReadonlyAttribute
    public var history: History

    @ReadonlyAttribute
    public var customElements: CustomElementRegistry

    @ReadonlyAttribute
    public var locationbar: BarProp

    @ReadonlyAttribute
    public var menubar: BarProp

    @ReadonlyAttribute
    public var personalbar: BarProp

    @ReadonlyAttribute
    public var scrollbars: BarProp

    @ReadonlyAttribute
    public var statusbar: BarProp

    @ReadonlyAttribute
    public var toolbar: BarProp

    @ReadWriteAttribute
    public var status: String

    @inlinable public func close() {
        let this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var closed: Bool

    @inlinable public func stop() {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable public func focus() {
        let this = jsObject
        _ = this[Strings.focus].function!(this: this, arguments: [])
    }

    @inlinable public func blur() {
        let this = jsObject
        _ = this[Strings.blur].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var frames: WindowProxy

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var top: WindowProxy?

    @ReadWriteAttribute
    public var opener: JSValue

    @ReadonlyAttribute
    public var parent: WindowProxy?

    @ReadonlyAttribute
    public var frameElement: Element?

    @inlinable public func open(url: String? = nil, target: String? = nil, features: String? = nil) -> WindowProxy? {
        let this = jsObject
        return this[Strings.open].function!(this: this, arguments: [url?.jsValue ?? .undefined, target?.jsValue ?? .undefined, features?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public subscript(key: String) -> JSObject {
        jsObject[key].fromJSValue()!
    }

    @ReadonlyAttribute
    public var navigator: Navigator

    @ReadonlyAttribute
    public var clientInformation: Navigator

    @ReadonlyAttribute
    public var originAgentCluster: Bool

    @inlinable public func alert() {
        let this = jsObject
        _ = this[Strings.alert].function!(this: this, arguments: [])
    }

    @inlinable public func alert(message: String) {
        let this = jsObject
        _ = this[Strings.alert].function!(this: this, arguments: [message.jsValue])
    }

    @inlinable public func confirm(message: String? = nil) -> Bool {
        let this = jsObject
        return this[Strings.confirm].function!(this: this, arguments: [message?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func prompt(message: String? = nil, default: String? = nil) -> String? {
        let this = jsObject
        return this[Strings.prompt].function!(this: this, arguments: [message?.jsValue ?? .undefined, `default`?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func print() {
        let this = jsObject
        _ = this[Strings.print].function!(this: this, arguments: [])
    }

    @inlinable public func postMessage(message: JSValue, targetOrigin: String, transfer: [JSObject]? = nil) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, targetOrigin.jsValue, transfer?.jsValue ?? .undefined])
    }

    @inlinable public func postMessage(message: JSValue, options: WindowPostMessageOptions? = nil) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @inlinable public func captureEvents() {
        let this = jsObject
        _ = this[Strings.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable public func releaseEvents() {
        let this = jsObject
        _ = this[Strings.releaseEvents].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var external: External

    @inlinable public func matchMedia(query: String) -> MediaQueryList {
        let this = jsObject
        return this[Strings.matchMedia].function!(this: this, arguments: [query.jsValue]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var screen: Screen

    @inlinable public func moveTo(x: Int32, y: Int32) {
        let this = jsObject
        _ = this[Strings.moveTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func moveBy(x: Int32, y: Int32) {
        let this = jsObject
        _ = this[Strings.moveBy].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func resizeTo(width: Int32, height: Int32) {
        let this = jsObject
        _ = this[Strings.resizeTo].function!(this: this, arguments: [width.jsValue, height.jsValue])
    }

    @inlinable public func resizeBy(x: Int32, y: Int32) {
        let this = jsObject
        _ = this[Strings.resizeBy].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @ReadonlyAttribute
    public var innerWidth: Int32

    @ReadonlyAttribute
    public var innerHeight: Int32

    @ReadonlyAttribute
    public var scrollX: Double

    @ReadonlyAttribute
    public var pageXOffset: Double

    @ReadonlyAttribute
    public var scrollY: Double

    @ReadonlyAttribute
    public var pageYOffset: Double

    @inlinable public func scroll(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scroll(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func scrollTo(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scrollTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @inlinable public func scrollBy(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [options?.jsValue ?? .undefined])
    }

    @inlinable public func scrollBy(x: Double, y: Double) {
        let this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [x.jsValue, y.jsValue])
    }

    @ReadonlyAttribute
    public var screenX: Int32

    @ReadonlyAttribute
    public var screenLeft: Int32

    @ReadonlyAttribute
    public var screenY: Int32

    @ReadonlyAttribute
    public var screenTop: Int32

    @ReadonlyAttribute
    public var outerWidth: Int32

    @ReadonlyAttribute
    public var outerHeight: Int32

    @ReadonlyAttribute
    public var devicePixelRatio: Double
}

public protocol WindowEventHandlers: JSBridgedClass {}
public extension WindowEventHandlers {
    @inlinable var onafterprint: EventHandler {
        get { ClosureAttribute1Optional[Strings.onafterprint, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onafterprint, in: jsObject] = newValue }
    }

    @inlinable var onbeforeprint: EventHandler {
        get { ClosureAttribute1Optional[Strings.onbeforeprint, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onbeforeprint, in: jsObject] = newValue }
    }

    @inlinable var onbeforeunload: OnBeforeUnloadEventHandler {
        get { ClosureAttribute1Optional[Strings.onbeforeunload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onbeforeunload, in: jsObject] = newValue }
    }

    @inlinable var onhashchange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onhashchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onhashchange, in: jsObject] = newValue }
    }

    @inlinable var onlanguagechange: EventHandler {
        get { ClosureAttribute1Optional[Strings.onlanguagechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onlanguagechange, in: jsObject] = newValue }
    }

    @inlinable var onmessage: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmessage, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmessage, in: jsObject] = newValue }
    }

    @inlinable var onmessageerror: EventHandler {
        get { ClosureAttribute1Optional[Strings.onmessageerror, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onmessageerror, in: jsObject] = newValue }
    }

    @inlinable var onoffline: EventHandler {
        get { ClosureAttribute1Optional[Strings.onoffline, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onoffline, in: jsObject] = newValue }
    }

    @inlinable var ononline: EventHandler {
        get { ClosureAttribute1Optional[Strings.ononline, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.ononline, in: jsObject] = newValue }
    }

    @inlinable var onpagehide: EventHandler {
        get { ClosureAttribute1Optional[Strings.onpagehide, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onpagehide, in: jsObject] = newValue }
    }

    @inlinable var onpageshow: EventHandler {
        get { ClosureAttribute1Optional[Strings.onpageshow, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onpageshow, in: jsObject] = newValue }
    }

    @inlinable var onpopstate: EventHandler {
        get { ClosureAttribute1Optional[Strings.onpopstate, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onpopstate, in: jsObject] = newValue }
    }

    @inlinable var onrejectionhandled: EventHandler {
        get { ClosureAttribute1Optional[Strings.onrejectionhandled, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onrejectionhandled, in: jsObject] = newValue }
    }

    @inlinable var onstorage: EventHandler {
        get { ClosureAttribute1Optional[Strings.onstorage, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onstorage, in: jsObject] = newValue }
    }

    @inlinable var onunhandledrejection: EventHandler {
        get { ClosureAttribute1Optional[Strings.onunhandledrejection, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onunhandledrejection, in: jsObject] = newValue }
    }

    @inlinable var onunload: EventHandler {
        get { ClosureAttribute1Optional[Strings.onunload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[Strings.onunload, in: jsObject] = newValue }
    }
}

public protocol WindowLocalStorage: JSBridgedClass {}
public extension WindowLocalStorage {
    @inlinable var localStorage: Storage { ReadonlyAttribute[Strings.localStorage, in: jsObject] }
}

public protocol WindowOrWorkerGlobalScope: JSBridgedClass {}
public extension WindowOrWorkerGlobalScope {
    @inlinable func fetch(input: RequestInfo, init: RequestInit? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.fetch].function!(this: this, arguments: [input.jsValue, `init`?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func fetch(input: RequestInfo, init: RequestInit? = nil) async throws -> Response {
        let this = jsObject
        let _promise: JSPromise = this[Strings.fetch].function!(this: this, arguments: [input.jsValue, `init`?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable var origin: String { ReadonlyAttribute[Strings.origin, in: jsObject] }

    @inlinable var isSecureContext: Bool { ReadonlyAttribute[Strings.isSecureContext, in: jsObject] }

    @inlinable var crossOriginIsolated: Bool { ReadonlyAttribute[Strings.crossOriginIsolated, in: jsObject] }

    @inlinable func reportError(e: JSValue) {
        let this = jsObject
        _ = this[Strings.reportError].function!(this: this, arguments: [e.jsValue])
    }

    @inlinable func btoa(data: String) -> String {
        let this = jsObject
        return this[Strings.btoa].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable func atob(data: String) -> String {
        let this = jsObject
        return this[Strings.atob].function!(this: this, arguments: [data.jsValue]).fromJSValue()!
    }

    @inlinable func setTimeout(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        let this = jsObject
        return this[Strings.setTimeout].function!(this: this, arguments: [handler.jsValue, timeout?.jsValue ?? .undefined] + arguments.map(\.jsValue)).fromJSValue()!
    }

    @inlinable func clearTimeout(id: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.clearTimeout].function!(this: this, arguments: [id?.jsValue ?? .undefined])
    }

    @inlinable func setInterval(handler: TimerHandler, timeout: Int32? = nil, arguments: JSValue...) -> Int32 {
        let this = jsObject
        return this[Strings.setInterval].function!(this: this, arguments: [handler.jsValue, timeout?.jsValue ?? .undefined] + arguments.map(\.jsValue)).fromJSValue()!
    }

    @inlinable func clearInterval(id: Int32? = nil) {
        let this = jsObject
        _ = this[Strings.clearInterval].function!(this: this, arguments: [id?.jsValue ?? .undefined])
    }

    // XXX: method 'queueMicrotask' is ignored

    @inlinable func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.createImageBitmap].function!(this: this, arguments: [image.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let this = jsObject
        let _promise: JSPromise = this[Strings.createImageBitmap].function!(this: this, arguments: [image.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) -> JSPromise {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = options?.jsValue ?? .undefined
        let this = jsObject
        return this[Strings.createImageBitmap].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func createImageBitmap(image: ImageBitmapSource, sx: Int32, sy: Int32, sw: Int32, sh: Int32, options: ImageBitmapOptions? = nil) async throws -> ImageBitmap {
        let _arg0 = image.jsValue
        let _arg1 = sx.jsValue
        let _arg2 = sy.jsValue
        let _arg3 = sw.jsValue
        let _arg4 = sh.jsValue
        let _arg5 = options?.jsValue ?? .undefined
        let this = jsObject
        let _promise: JSPromise = this[Strings.createImageBitmap].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func structuredClone(value: JSValue, options: StructuredSerializeOptions? = nil) -> JSValue {
        let this = jsObject
        return this[Strings.structuredClone].function!(this: this, arguments: [value.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable var performance: Performance { ReadonlyAttribute[Strings.performance, in: jsObject] }

    @inlinable var caches: CacheStorage { ReadonlyAttribute[Strings.caches, in: jsObject] }
}

public class WindowPostMessageOptions: BridgedDictionary {
    public convenience init(targetOrigin: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.targetOrigin] = targetOrigin.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _targetOrigin = ReadWriteAttribute(jsObject: object, name: Strings.targetOrigin)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var targetOrigin: String
}

public protocol WindowSessionStorage: JSBridgedClass {}
public extension WindowSessionStorage {
    @inlinable var sessionStorage: Storage { ReadonlyAttribute[Strings.sessionStorage, in: jsObject] }
}

public class Worker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.Worker].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [scriptURL.jsValue, options?.jsValue ?? .undefined]))
    }

    @inlinable public func terminate() {
        let this = jsObject
        _ = this[Strings.terminate].function!(this: this, arguments: [])
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, transfer.jsValue])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [message.jsValue, options?.jsValue ?? .undefined])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class WorkerOptions: BridgedDictionary {
    public convenience init(type: WorkerType, credentials: RequestCredentials, name: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.credentials] = credentials.jsValue
        object[Strings.name] = name.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _credentials = ReadWriteAttribute(jsObject: object, name: Strings.credentials)
        _name = ReadWriteAttribute(jsObject: object, name: Strings.name)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var name: String
}

public enum WorkerType: JSString, JSValueCompatible {
    case classic = "classic"
    case module = "module"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Worklet: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.Worklet].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.addModule].function!(this: this, arguments: [moduleURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.addModule].function!(this: this, arguments: [moduleURL.jsValue, options?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class WorkletOptions: BridgedDictionary {
    public convenience init(credentials: RequestCredentials) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.credentials] = credentials.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _credentials = ReadWriteAttribute(jsObject: object, name: Strings.credentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var credentials: RequestCredentials
}

public class WritableStream: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WritableStream].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _locked = ReadonlyAttribute(jsObject: jsObject, name: Strings.locked)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(underlyingSink: JSObject? = nil, strategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [underlyingSink?.jsValue ?? .undefined, strategy?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var locked: Bool

    @inlinable public func abort(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func abort(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getWriter() -> WritableStreamDefaultWriter {
        let this = jsObject
        return this[Strings.getWriter].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class WritableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WritableStreamDefaultController].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _signal = ReadonlyAttribute(jsObject: jsObject, name: Strings.signal)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [e?.jsValue ?? .undefined])
    }
}

public class WritableStreamDefaultWriter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.WritableStreamDefaultWriter].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _closed = ReadonlyAttribute(jsObject: jsObject, name: Strings.closed)
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.desiredSize)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: Strings.ready)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: WritableStream) {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: [stream.jsValue]))
    }

    @ReadonlyAttribute
    public var closed: JSPromise

    @ReadonlyAttribute
    public var desiredSize: Double?

    @ReadonlyAttribute
    public var ready: JSPromise

    @inlinable public func abort(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func abort(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.abort].function!(this: this, arguments: [reason?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }

    @inlinable public func write(chunk: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[Strings.write].function!(this: this, arguments: [chunk?.jsValue ?? .undefined]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func write(chunk: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.write].function!(this: this, arguments: [chunk?.jsValue ?? .undefined]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class XMLDocument: Document {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.XMLDocument].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class XMLHttpRequest: XMLHttpRequestEventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.XMLHttpRequest].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onreadystatechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onreadystatechange)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: Strings.readyState)
        _timeout = ReadWriteAttribute(jsObject: jsObject, name: Strings.timeout)
        _withCredentials = ReadWriteAttribute(jsObject: jsObject, name: Strings.withCredentials)
        _upload = ReadonlyAttribute(jsObject: jsObject, name: Strings.upload)
        _responseURL = ReadonlyAttribute(jsObject: jsObject, name: Strings.responseURL)
        _status = ReadonlyAttribute(jsObject: jsObject, name: Strings.status)
        _statusText = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusText)
        _responseType = ReadWriteAttribute(jsObject: jsObject, name: Strings.responseType)
        _response = ReadonlyAttribute(jsObject: jsObject, name: Strings.response)
        _responseText = ReadonlyAttribute(jsObject: jsObject, name: Strings.responseText)
        _responseXML = ReadonlyAttribute(jsObject: jsObject, name: Strings.responseXML)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @ClosureAttribute1Optional
    public var onreadystatechange: EventHandler

    public static let UNSENT: UInt16 = 0

    public static let OPENED: UInt16 = 1

    public static let HEADERS_RECEIVED: UInt16 = 2

    public static let LOADING: UInt16 = 3

    public static let DONE: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @inlinable public func open(method: String, url: String) {
        let this = jsObject
        _ = this[Strings.open].function!(this: this, arguments: [method.jsValue, url.jsValue])
    }

    @inlinable public func open(method: String, url: String, async: Bool, username: String? = nil, password: String? = nil) {
        let this = jsObject
        _ = this[Strings.open].function!(this: this, arguments: [method.jsValue, url.jsValue, async.jsValue, username?.jsValue ?? .undefined, password?.jsValue ?? .undefined])
    }

    @inlinable public func setRequestHeader(name: String, value: String) {
        let this = jsObject
        _ = this[Strings.setRequestHeader].function!(this: this, arguments: [name.jsValue, value.jsValue])
    }

    @ReadWriteAttribute
    public var timeout: UInt32

    @ReadWriteAttribute
    public var withCredentials: Bool

    @ReadonlyAttribute
    public var upload: XMLHttpRequestUpload

    @inlinable public func send(body: Document_or_XMLHttpRequestBodyInit? = nil) {
        let this = jsObject
        _ = this[Strings.send].function!(this: this, arguments: [body?.jsValue ?? .undefined])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var responseURL: String

    @ReadonlyAttribute
    public var status: UInt16

    @ReadonlyAttribute
    public var statusText: String

    @inlinable public func getResponseHeader(name: String) -> String? {
        let this = jsObject
        return this[Strings.getResponseHeader].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable public func getAllResponseHeaders() -> String {
        let this = jsObject
        return this[Strings.getAllResponseHeaders].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func overrideMimeType(mime: String) {
        let this = jsObject
        _ = this[Strings.overrideMimeType].function!(this: this, arguments: [mime.jsValue])
    }

    @ReadWriteAttribute
    public var responseType: XMLHttpRequestResponseType

    @ReadonlyAttribute
    public var response: JSValue

    @ReadonlyAttribute
    public var responseText: String

    @ReadonlyAttribute
    public var responseXML: Document?
}

public class XMLHttpRequestEventTarget: EventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.XMLHttpRequestEventTarget].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onloadstart = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onloadstart)
        _onprogress = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onprogress)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onabort)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onerror)
        _onload = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onload)
        _ontimeout = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.ontimeout)
        _onloadend = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onloadstart: EventHandler

    @ClosureAttribute1Optional
    public var onprogress: EventHandler

    @ClosureAttribute1Optional
    public var onabort: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onload: EventHandler

    @ClosureAttribute1Optional
    public var ontimeout: EventHandler

    @ClosureAttribute1Optional
    public var onloadend: EventHandler
}

public enum XMLHttpRequestResponseType: JSString, JSValueCompatible {
    case _empty = ""
    case arraybuffer = "arraybuffer"
    case blob = "blob"
    case document = "document"
    case json = "json"
    case text = "text"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class XMLHttpRequestUpload: XMLHttpRequestEventTarget {
    @inlinable override public class var constructor: JSFunction { JSObject.global[Strings.XMLHttpRequestUpload].function! }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class XPathEvaluator: JSBridgedClass, XPathEvaluatorBase {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.XPathEvaluator].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }
}

public protocol XPathEvaluatorBase: JSBridgedClass {}
public extension XPathEvaluatorBase {
    // XXX: method 'createExpression' is ignored

    // XXX: method 'createNSResolver' is ignored

    // XXX: method 'evaluate' is ignored
}

public class XPathExpression: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.XPathExpression].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func evaluate(contextNode: Node, type: UInt16? = nil, result: XPathResult? = nil) -> XPathResult {
        let this = jsObject
        return this[Strings.evaluate].function!(this: this, arguments: [contextNode.jsValue, type?.jsValue ?? .undefined, result?.jsValue ?? .undefined]).fromJSValue()!
    }
}

public class XPathResult: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.XPathResult].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _resultType = ReadonlyAttribute(jsObject: jsObject, name: Strings.resultType)
        _numberValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberValue)
        _stringValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.stringValue)
        _booleanValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.booleanValue)
        _singleNodeValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.singleNodeValue)
        _invalidIteratorState = ReadonlyAttribute(jsObject: jsObject, name: Strings.invalidIteratorState)
        _snapshotLength = ReadonlyAttribute(jsObject: jsObject, name: Strings.snapshotLength)
        self.jsObject = jsObject
    }

    public static let ANY_TYPE: UInt16 = 0

    public static let NUMBER_TYPE: UInt16 = 1

    public static let STRING_TYPE: UInt16 = 2

    public static let BOOLEAN_TYPE: UInt16 = 3

    public static let UNORDERED_NODE_ITERATOR_TYPE: UInt16 = 4

    public static let ORDERED_NODE_ITERATOR_TYPE: UInt16 = 5

    public static let UNORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 6

    public static let ORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 7

    public static let ANY_UNORDERED_NODE_TYPE: UInt16 = 8

    public static let FIRST_ORDERED_NODE_TYPE: UInt16 = 9

    @ReadonlyAttribute
    public var resultType: UInt16

    @ReadonlyAttribute
    public var numberValue: Double

    @ReadonlyAttribute
    public var stringValue: String

    @ReadonlyAttribute
    public var booleanValue: Bool

    @ReadonlyAttribute
    public var singleNodeValue: Node?

    @ReadonlyAttribute
    public var invalidIteratorState: Bool

    @ReadonlyAttribute
    public var snapshotLength: UInt32

    @inlinable public func iterateNext() -> Node? {
        let this = jsObject
        return this[Strings.iterateNext].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func snapshotItem(index: UInt32) -> Node? {
        let this = jsObject
        return this[Strings.snapshotItem].function!(this: this, arguments: [index.jsValue]).fromJSValue()!
    }
}

public class XSLTProcessor: JSBridgedClass {
    @inlinable public class var constructor: JSFunction { JSObject.global[Strings.XSLTProcessor].function! }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor.new(arguments: []))
    }

    @inlinable public func importStylesheet(style: Node) {
        let this = jsObject
        _ = this[Strings.importStylesheet].function!(this: this, arguments: [style.jsValue])
    }

    @inlinable public func transformToFragment(source: Node, output: Document) -> DocumentFragment {
        let this = jsObject
        return this[Strings.transformToFragment].function!(this: this, arguments: [source.jsValue, output.jsValue]).fromJSValue()!
    }

    @inlinable public func transformToDocument(source: Node) -> Document {
        let this = jsObject
        return this[Strings.transformToDocument].function!(this: this, arguments: [source.jsValue]).fromJSValue()!
    }

    @inlinable public func setParameter(namespaceURI: String, localName: String, value: JSValue) {
        let this = jsObject
        _ = this[Strings.setParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue, value.jsValue])
    }

    @inlinable public func getParameter(namespaceURI: String, localName: String) -> JSValue {
        let this = jsObject
        return this[Strings.getParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue]).fromJSValue()!
    }

    @inlinable public func removeParameter(namespaceURI: String, localName: String) {
        let this = jsObject
        _ = this[Strings.removeParameter].function!(this: this, arguments: [namespaceURI.jsValue, localName.jsValue])
    }

    @inlinable public func clearParameters() {
        let this = jsObject
        _ = this[Strings.clearParameters].function!(this: this, arguments: [])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }
}

public enum console {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[Strings.console].object!
    }

    @inlinable public static func assert(condition: Bool? = nil, data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.assert].function!(this: this, arguments: [condition?.jsValue ?? .undefined] + data.map(\.jsValue))
    }

    @inlinable public static func clear() {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }

    @inlinable public static func debug(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.debug].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func error(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.error].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func info(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.info].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func log(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.log].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func table(tabularData: JSValue? = nil, properties: [String]? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.table].function!(this: this, arguments: [tabularData?.jsValue ?? .undefined, properties?.jsValue ?? .undefined])
    }

    @inlinable public static func trace(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.trace].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func warn(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.warn].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func dir(item: JSValue? = nil, options: JSObject? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.dir].function!(this: this, arguments: [item?.jsValue ?? .undefined, options?.jsValue ?? .undefined])
    }

    @inlinable public static func dirxml(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.dirxml].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func count(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.count].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func countReset(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.countReset].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func group(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.group].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func groupCollapsed(data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.groupCollapsed].function!(this: this, arguments: data.map(\.jsValue))
    }

    @inlinable public static func groupEnd() {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.groupEnd].function!(this: this, arguments: [])
    }

    @inlinable public static func time(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.time].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }

    @inlinable public static func timeLog(label: String? = nil, data: JSValue...) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.timeLog].function!(this: this, arguments: [label?.jsValue ?? .undefined] + data.map(\.jsValue))
    }

    @inlinable public static func timeEnd(label: String? = nil) {
        let this = JSObject.global[Strings.console].object!
        _ = this[Strings.timeEnd].function!(this: this, arguments: [label?.jsValue ?? .undefined])
    }
}

/* variadic generics please */
@propertyWrapper public final class ClosureAttribute0<ReturnType>
    where ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: () -> ReturnType {
        get { ClosureAttribute0[name, in: jsObject] }
        set { ClosureAttribute0[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> () -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function().fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure { _ in
                newValue().jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute0Optional<ReturnType>
    where ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (() -> ReturnType)? {
        get { ClosureAttribute0Optional[name, in: jsObject] }
        set { ClosureAttribute0Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (() -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function().fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure { _ in
                    newValue().jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute0OptionalVoid {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (() -> Void)? {
        get { ClosureAttribute0OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute0OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (() -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function() }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure { _ in
                    newValue()
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute0Void {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: () -> Void {
        get { ClosureAttribute0Void[name, in: jsObject] }
        set { ClosureAttribute0Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> () -> Void {
        get {
            let function = jsObject[name].function!
            return { function() }
        }
        set {
            jsObject[name] = JSClosure { _ in
                newValue()
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute1<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> ReturnType {
        get { ClosureAttribute1[name, in: jsObject] }
        set { ClosureAttribute1[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Optional<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> ReturnType)? {
        get { ClosureAttribute1Optional[name, in: jsObject] }
        set { ClosureAttribute1Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1OptionalVoid<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> Void)? {
        get { ClosureAttribute1OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute1OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Void<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> Void {
        get { ClosureAttribute1Void[name, in: jsObject] }
        set { ClosureAttribute1Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute2<A0, A1, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1) -> ReturnType {
        get { ClosureAttribute2[name, in: jsObject] }
        set { ClosureAttribute2[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute2Optional<A0, A1, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1) -> ReturnType)? {
        get { ClosureAttribute2Optional[name, in: jsObject] }
        set { ClosureAttribute2Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute2OptionalVoid<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1) -> Void)? {
        get { ClosureAttribute2OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute2OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute2Void<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1) -> Void {
        get { ClosureAttribute2Void[name, in: jsObject] }
        set { ClosureAttribute2Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute3<A0, A1, A2, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1, A2) -> ReturnType {
        get { ClosureAttribute3[name, in: jsObject] }
        set { ClosureAttribute3[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1, A2) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue, $2.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute3Optional<A0, A1, A2, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1, A2) -> ReturnType)? {
        get { ClosureAttribute3Optional[name, in: jsObject] }
        set { ClosureAttribute3Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1, A2) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue, $2.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute5<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1, A2, A3, A4) -> ReturnType {
        get { ClosureAttribute5[name, in: jsObject] }
        set { ClosureAttribute5[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1, A2, A3, A4) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute5Optional<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get { ClosureAttribute5Optional[name, in: jsObject] }
        set { ClosureAttribute5Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let AbortController: JSString = "AbortController"
    @usableFromInline static let AbortSignal: JSString = "AbortSignal"
    @usableFromInline static let AbstractRange: JSString = "AbstractRange"
    @usableFromInline static let AddSearchProvider: JSString = "AddSearchProvider"
    @usableFromInline static let AnalyserNode: JSString = "AnalyserNode"
    @usableFromInline static let Animation: JSString = "Animation"
    @usableFromInline static let AnimationEffect: JSString = "AnimationEffect"
    @usableFromInline static let AnimationTimeline: JSString = "AnimationTimeline"
    @usableFromInline static let Attr: JSString = "Attr"
    @usableFromInline static let AudioBuffer: JSString = "AudioBuffer"
    @usableFromInline static let AudioBufferSourceNode: JSString = "AudioBufferSourceNode"
    @usableFromInline static let AudioContext: JSString = "AudioContext"
    @usableFromInline static let AudioData: JSString = "AudioData"
    @usableFromInline static let AudioDecoder: JSString = "AudioDecoder"
    @usableFromInline static let AudioDestinationNode: JSString = "AudioDestinationNode"
    @usableFromInline static let AudioEncoder: JSString = "AudioEncoder"
    @usableFromInline static let AudioListener: JSString = "AudioListener"
    @usableFromInline static let AudioNode: JSString = "AudioNode"
    @usableFromInline static let AudioParam: JSString = "AudioParam"
    @usableFromInline static let AudioParamMap: JSString = "AudioParamMap"
    @usableFromInline static let AudioProcessingEvent: JSString = "AudioProcessingEvent"
    @usableFromInline static let AudioScheduledSourceNode: JSString = "AudioScheduledSourceNode"
    @usableFromInline static let AudioTrack: JSString = "AudioTrack"
    @usableFromInline static let AudioTrackList: JSString = "AudioTrackList"
    @usableFromInline static let AudioWorklet: JSString = "AudioWorklet"
    @usableFromInline static let AudioWorkletNode: JSString = "AudioWorkletNode"
    @usableFromInline static let BarProp: JSString = "BarProp"
    @usableFromInline static let BaseAudioContext: JSString = "BaseAudioContext"
    @usableFromInline static let BeforeUnloadEvent: JSString = "BeforeUnloadEvent"
    @usableFromInline static let BiquadFilterNode: JSString = "BiquadFilterNode"
    @usableFromInline static let Blob: JSString = "Blob"
    @usableFromInline static let BlobEvent: JSString = "BlobEvent"
    @usableFromInline static let BroadcastChannel: JSString = "BroadcastChannel"
    @usableFromInline static let ByteLengthQueuingStrategy: JSString = "ByteLengthQueuingStrategy"
    @usableFromInline static let CDATASection: JSString = "CDATASection"
    @usableFromInline static let CSSPseudoElement: JSString = "CSSPseudoElement"
    @usableFromInline static let Cache: JSString = "Cache"
    @usableFromInline static let CacheStorage: JSString = "CacheStorage"
    @usableFromInline static let CanvasFilter: JSString = "CanvasFilter"
    @usableFromInline static let CanvasGradient: JSString = "CanvasGradient"
    @usableFromInline static let CanvasPattern: JSString = "CanvasPattern"
    @usableFromInline static let CanvasRenderingContext2D: JSString = "CanvasRenderingContext2D"
    @usableFromInline static let CaretPosition: JSString = "CaretPosition"
    @usableFromInline static let ChannelMergerNode: JSString = "ChannelMergerNode"
    @usableFromInline static let ChannelSplitterNode: JSString = "ChannelSplitterNode"
    @usableFromInline static let CharacterData: JSString = "CharacterData"
    @usableFromInline static let CloseEvent: JSString = "CloseEvent"
    @usableFromInline static let Comment: JSString = "Comment"
    @usableFromInline static let CompositionEvent: JSString = "CompositionEvent"
    @usableFromInline static let ConstantSourceNode: JSString = "ConstantSourceNode"
    @usableFromInline static let ConvolverNode: JSString = "ConvolverNode"
    @usableFromInline static let CountQueuingStrategy: JSString = "CountQueuingStrategy"
    @usableFromInline static let CustomElementRegistry: JSString = "CustomElementRegistry"
    @usableFromInline static let CustomEvent: JSString = "CustomEvent"
    @usableFromInline static let DOMException: JSString = "DOMException"
    @usableFromInline static let DOMImplementation: JSString = "DOMImplementation"
    @usableFromInline static let DOMMatrix: JSString = "DOMMatrix"
    @usableFromInline static let DOMMatrixReadOnly: JSString = "DOMMatrixReadOnly"
    @usableFromInline static let DOMParser: JSString = "DOMParser"
    @usableFromInline static let DOMPoint: JSString = "DOMPoint"
    @usableFromInline static let DOMPointReadOnly: JSString = "DOMPointReadOnly"
    @usableFromInline static let DOMQuad: JSString = "DOMQuad"
    @usableFromInline static let DOMRect: JSString = "DOMRect"
    @usableFromInline static let DOMRectList: JSString = "DOMRectList"
    @usableFromInline static let DOMRectReadOnly: JSString = "DOMRectReadOnly"
    @usableFromInline static let DOMStringList: JSString = "DOMStringList"
    @usableFromInline static let DOMStringMap: JSString = "DOMStringMap"
    @usableFromInline static let DOMTokenList: JSString = "DOMTokenList"
    @usableFromInline static let DataTransfer: JSString = "DataTransfer"
    @usableFromInline static let DataTransferItem: JSString = "DataTransferItem"
    @usableFromInline static let DataTransferItemList: JSString = "DataTransferItemList"
    @usableFromInline static let DelayNode: JSString = "DelayNode"
    @usableFromInline static let Document: JSString = "Document"
    @usableFromInline static let DocumentFragment: JSString = "DocumentFragment"
    @usableFromInline static let DocumentTimeline: JSString = "DocumentTimeline"
    @usableFromInline static let DocumentType: JSString = "DocumentType"
    @usableFromInline static let DragEvent: JSString = "DragEvent"
    @usableFromInline static let DynamicsCompressorNode: JSString = "DynamicsCompressorNode"
    @usableFromInline static let Element: JSString = "Element"
    @usableFromInline static let ElementInternals: JSString = "ElementInternals"
    @usableFromInline static let EncodedAudioChunk: JSString = "EncodedAudioChunk"
    @usableFromInline static let EncodedVideoChunk: JSString = "EncodedVideoChunk"
    @usableFromInline static let ErrorEvent: JSString = "ErrorEvent"
    @usableFromInline static let Event: JSString = "Event"
    @usableFromInline static let EventSource: JSString = "EventSource"
    @usableFromInline static let EventTarget: JSString = "EventTarget"
    @usableFromInline static let External: JSString = "External"
    @usableFromInline static let File: JSString = "File"
    @usableFromInline static let FileList: JSString = "FileList"
    @usableFromInline static let FileReader: JSString = "FileReader"
    @usableFromInline static let FocusEvent: JSString = "FocusEvent"
    @usableFromInline static let FormData: JSString = "FormData"
    @usableFromInline static let FormDataEvent: JSString = "FormDataEvent"
    @usableFromInline static let GPU: JSString = "GPU"
    @usableFromInline static let GPUAdapter: JSString = "GPUAdapter"
    @usableFromInline static let GPUBindGroup: JSString = "GPUBindGroup"
    @usableFromInline static let GPUBindGroupLayout: JSString = "GPUBindGroupLayout"
    @usableFromInline static let GPUBuffer: JSString = "GPUBuffer"
    @usableFromInline static let GPUBufferUsage: JSString = "GPUBufferUsage"
    @usableFromInline static let GPUCanvasContext: JSString = "GPUCanvasContext"
    @usableFromInline static let GPUColorWrite: JSString = "GPUColorWrite"
    @usableFromInline static let GPUCommandBuffer: JSString = "GPUCommandBuffer"
    @usableFromInline static let GPUCommandEncoder: JSString = "GPUCommandEncoder"
    @usableFromInline static let GPUCompilationInfo: JSString = "GPUCompilationInfo"
    @usableFromInline static let GPUCompilationMessage: JSString = "GPUCompilationMessage"
    @usableFromInline static let GPUComputePassEncoder: JSString = "GPUComputePassEncoder"
    @usableFromInline static let GPUComputePipeline: JSString = "GPUComputePipeline"
    @usableFromInline static let GPUDevice: JSString = "GPUDevice"
    @usableFromInline static let GPUDeviceLostInfo: JSString = "GPUDeviceLostInfo"
    @usableFromInline static let GPUExternalTexture: JSString = "GPUExternalTexture"
    @usableFromInline static let GPUMapMode: JSString = "GPUMapMode"
    @usableFromInline static let GPUOutOfMemoryError: JSString = "GPUOutOfMemoryError"
    @usableFromInline static let GPUPipelineLayout: JSString = "GPUPipelineLayout"
    @usableFromInline static let GPUQuerySet: JSString = "GPUQuerySet"
    @usableFromInline static let GPUQueue: JSString = "GPUQueue"
    @usableFromInline static let GPURenderBundle: JSString = "GPURenderBundle"
    @usableFromInline static let GPURenderBundleEncoder: JSString = "GPURenderBundleEncoder"
    @usableFromInline static let GPURenderPassEncoder: JSString = "GPURenderPassEncoder"
    @usableFromInline static let GPURenderPipeline: JSString = "GPURenderPipeline"
    @usableFromInline static let GPUSampler: JSString = "GPUSampler"
    @usableFromInline static let GPUShaderModule: JSString = "GPUShaderModule"
    @usableFromInline static let GPUShaderStage: JSString = "GPUShaderStage"
    @usableFromInline static let GPUSupportedFeatures: JSString = "GPUSupportedFeatures"
    @usableFromInline static let GPUSupportedLimits: JSString = "GPUSupportedLimits"
    @usableFromInline static let GPUTexture: JSString = "GPUTexture"
    @usableFromInline static let GPUTextureUsage: JSString = "GPUTextureUsage"
    @usableFromInline static let GPUTextureView: JSString = "GPUTextureView"
    @usableFromInline static let GPUUncapturedErrorEvent: JSString = "GPUUncapturedErrorEvent"
    @usableFromInline static let GPUValidationError: JSString = "GPUValidationError"
    @usableFromInline static let GainNode: JSString = "GainNode"
    @usableFromInline static let HTMLAllCollection: JSString = "HTMLAllCollection"
    @usableFromInline static let HTMLAnchorElement: JSString = "HTMLAnchorElement"
    @usableFromInline static let HTMLAreaElement: JSString = "HTMLAreaElement"
    @usableFromInline static let HTMLAudioElement: JSString = "HTMLAudioElement"
    @usableFromInline static let HTMLBRElement: JSString = "HTMLBRElement"
    @usableFromInline static let HTMLBaseElement: JSString = "HTMLBaseElement"
    @usableFromInline static let HTMLBodyElement: JSString = "HTMLBodyElement"
    @usableFromInline static let HTMLButtonElement: JSString = "HTMLButtonElement"
    @usableFromInline static let HTMLCanvasElement: JSString = "HTMLCanvasElement"
    @usableFromInline static let HTMLCollection: JSString = "HTMLCollection"
    @usableFromInline static let HTMLDListElement: JSString = "HTMLDListElement"
    @usableFromInline static let HTMLDataElement: JSString = "HTMLDataElement"
    @usableFromInline static let HTMLDataListElement: JSString = "HTMLDataListElement"
    @usableFromInline static let HTMLDetailsElement: JSString = "HTMLDetailsElement"
    @usableFromInline static let HTMLDialogElement: JSString = "HTMLDialogElement"
    @usableFromInline static let HTMLDirectoryElement: JSString = "HTMLDirectoryElement"
    @usableFromInline static let HTMLDivElement: JSString = "HTMLDivElement"
    @usableFromInline static let HTMLElement: JSString = "HTMLElement"
    @usableFromInline static let HTMLEmbedElement: JSString = "HTMLEmbedElement"
    @usableFromInline static let HTMLFieldSetElement: JSString = "HTMLFieldSetElement"
    @usableFromInline static let HTMLFontElement: JSString = "HTMLFontElement"
    @usableFromInline static let HTMLFormControlsCollection: JSString = "HTMLFormControlsCollection"
    @usableFromInline static let HTMLFormElement: JSString = "HTMLFormElement"
    @usableFromInline static let HTMLFrameElement: JSString = "HTMLFrameElement"
    @usableFromInline static let HTMLFrameSetElement: JSString = "HTMLFrameSetElement"
    @usableFromInline static let HTMLHRElement: JSString = "HTMLHRElement"
    @usableFromInline static let HTMLHeadElement: JSString = "HTMLHeadElement"
    @usableFromInline static let HTMLHeadingElement: JSString = "HTMLHeadingElement"
    @usableFromInline static let HTMLHtmlElement: JSString = "HTMLHtmlElement"
    @usableFromInline static let HTMLIFrameElement: JSString = "HTMLIFrameElement"
    @usableFromInline static let HTMLImageElement: JSString = "HTMLImageElement"
    @usableFromInline static let HTMLInputElement: JSString = "HTMLInputElement"
    @usableFromInline static let HTMLLIElement: JSString = "HTMLLIElement"
    @usableFromInline static let HTMLLabelElement: JSString = "HTMLLabelElement"
    @usableFromInline static let HTMLLegendElement: JSString = "HTMLLegendElement"
    @usableFromInline static let HTMLLinkElement: JSString = "HTMLLinkElement"
    @usableFromInline static let HTMLMapElement: JSString = "HTMLMapElement"
    @usableFromInline static let HTMLMarqueeElement: JSString = "HTMLMarqueeElement"
    @usableFromInline static let HTMLMediaElement: JSString = "HTMLMediaElement"
    @usableFromInline static let HTMLMenuElement: JSString = "HTMLMenuElement"
    @usableFromInline static let HTMLMetaElement: JSString = "HTMLMetaElement"
    @usableFromInline static let HTMLMeterElement: JSString = "HTMLMeterElement"
    @usableFromInline static let HTMLModElement: JSString = "HTMLModElement"
    @usableFromInline static let HTMLOListElement: JSString = "HTMLOListElement"
    @usableFromInline static let HTMLObjectElement: JSString = "HTMLObjectElement"
    @usableFromInline static let HTMLOptGroupElement: JSString = "HTMLOptGroupElement"
    @usableFromInline static let HTMLOptionElement: JSString = "HTMLOptionElement"
    @usableFromInline static let HTMLOptionsCollection: JSString = "HTMLOptionsCollection"
    @usableFromInline static let HTMLOutputElement: JSString = "HTMLOutputElement"
    @usableFromInline static let HTMLParagraphElement: JSString = "HTMLParagraphElement"
    @usableFromInline static let HTMLParamElement: JSString = "HTMLParamElement"
    @usableFromInline static let HTMLPictureElement: JSString = "HTMLPictureElement"
    @usableFromInline static let HTMLPreElement: JSString = "HTMLPreElement"
    @usableFromInline static let HTMLProgressElement: JSString = "HTMLProgressElement"
    @usableFromInline static let HTMLQuoteElement: JSString = "HTMLQuoteElement"
    @usableFromInline static let HTMLScriptElement: JSString = "HTMLScriptElement"
    @usableFromInline static let HTMLSelectElement: JSString = "HTMLSelectElement"
    @usableFromInline static let HTMLSlotElement: JSString = "HTMLSlotElement"
    @usableFromInline static let HTMLSourceElement: JSString = "HTMLSourceElement"
    @usableFromInline static let HTMLSpanElement: JSString = "HTMLSpanElement"
    @usableFromInline static let HTMLStyleElement: JSString = "HTMLStyleElement"
    @usableFromInline static let HTMLTableCaptionElement: JSString = "HTMLTableCaptionElement"
    @usableFromInline static let HTMLTableCellElement: JSString = "HTMLTableCellElement"
    @usableFromInline static let HTMLTableColElement: JSString = "HTMLTableColElement"
    @usableFromInline static let HTMLTableElement: JSString = "HTMLTableElement"
    @usableFromInline static let HTMLTableRowElement: JSString = "HTMLTableRowElement"
    @usableFromInline static let HTMLTableSectionElement: JSString = "HTMLTableSectionElement"
    @usableFromInline static let HTMLTemplateElement: JSString = "HTMLTemplateElement"
    @usableFromInline static let HTMLTextAreaElement: JSString = "HTMLTextAreaElement"
    @usableFromInline static let HTMLTimeElement: JSString = "HTMLTimeElement"
    @usableFromInline static let HTMLTitleElement: JSString = "HTMLTitleElement"
    @usableFromInline static let HTMLTrackElement: JSString = "HTMLTrackElement"
    @usableFromInline static let HTMLUListElement: JSString = "HTMLUListElement"
    @usableFromInline static let HTMLUnknownElement: JSString = "HTMLUnknownElement"
    @usableFromInline static let HTMLVideoElement: JSString = "HTMLVideoElement"
    @usableFromInline static let HashChangeEvent: JSString = "HashChangeEvent"
    @usableFromInline static let Headers: JSString = "Headers"
    @usableFromInline static let History: JSString = "History"
    @usableFromInline static let IIRFilterNode: JSString = "IIRFilterNode"
    @usableFromInline static let ImageBitmap: JSString = "ImageBitmap"
    @usableFromInline static let ImageBitmapRenderingContext: JSString = "ImageBitmapRenderingContext"
    @usableFromInline static let ImageData: JSString = "ImageData"
    @usableFromInline static let ImageDecoder: JSString = "ImageDecoder"
    @usableFromInline static let ImageTrack: JSString = "ImageTrack"
    @usableFromInline static let ImageTrackList: JSString = "ImageTrackList"
    @usableFromInline static let InputDeviceInfo: JSString = "InputDeviceInfo"
    @usableFromInline static let InputEvent: JSString = "InputEvent"
    @usableFromInline static let IsSearchProviderInstalled: JSString = "IsSearchProviderInstalled"
    @usableFromInline static let KeyboardEvent: JSString = "KeyboardEvent"
    @usableFromInline static let KeyframeEffect: JSString = "KeyframeEffect"
    @usableFromInline static let Location: JSString = "Location"
    @usableFromInline static let MediaDeviceInfo: JSString = "MediaDeviceInfo"
    @usableFromInline static let MediaDevices: JSString = "MediaDevices"
    @usableFromInline static let MediaElementAudioSourceNode: JSString = "MediaElementAudioSourceNode"
    @usableFromInline static let MediaError: JSString = "MediaError"
    @usableFromInline static let MediaQueryList: JSString = "MediaQueryList"
    @usableFromInline static let MediaQueryListEvent: JSString = "MediaQueryListEvent"
    @usableFromInline static let MediaRecorder: JSString = "MediaRecorder"
    @usableFromInline static let MediaRecorderErrorEvent: JSString = "MediaRecorderErrorEvent"
    @usableFromInline static let MediaStream: JSString = "MediaStream"
    @usableFromInline static let MediaStreamAudioDestinationNode: JSString = "MediaStreamAudioDestinationNode"
    @usableFromInline static let MediaStreamAudioSourceNode: JSString = "MediaStreamAudioSourceNode"
    @usableFromInline static let MediaStreamTrack: JSString = "MediaStreamTrack"
    @usableFromInline static let MediaStreamTrackAudioSourceNode: JSString = "MediaStreamTrackAudioSourceNode"
    @usableFromInline static let MediaStreamTrackEvent: JSString = "MediaStreamTrackEvent"
    @usableFromInline static let MessageChannel: JSString = "MessageChannel"
    @usableFromInline static let MessageEvent: JSString = "MessageEvent"
    @usableFromInline static let MessagePort: JSString = "MessagePort"
    @usableFromInline static let MimeType: JSString = "MimeType"
    @usableFromInline static let MimeTypeArray: JSString = "MimeTypeArray"
    @usableFromInline static let MouseEvent: JSString = "MouseEvent"
    @usableFromInline static let MutationEvent: JSString = "MutationEvent"
    @usableFromInline static let MutationObserver: JSString = "MutationObserver"
    @usableFromInline static let MutationRecord: JSString = "MutationRecord"
    @usableFromInline static let NamedNodeMap: JSString = "NamedNodeMap"
    @usableFromInline static let NavigationPreloadManager: JSString = "NavigationPreloadManager"
    @usableFromInline static let Navigator: JSString = "Navigator"
    @usableFromInline static let Node: JSString = "Node"
    @usableFromInline static let NodeIterator: JSString = "NodeIterator"
    @usableFromInline static let NodeList: JSString = "NodeList"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let OfflineAudioCompletionEvent: JSString = "OfflineAudioCompletionEvent"
    @usableFromInline static let OfflineAudioContext: JSString = "OfflineAudioContext"
    @usableFromInline static let OffscreenCanvas: JSString = "OffscreenCanvas"
    @usableFromInline static let OffscreenCanvasRenderingContext2D: JSString = "OffscreenCanvasRenderingContext2D"
    @usableFromInline static let OscillatorNode: JSString = "OscillatorNode"
    @usableFromInline static let OverconstrainedError: JSString = "OverconstrainedError"
    @usableFromInline static let PageTransitionEvent: JSString = "PageTransitionEvent"
    @usableFromInline static let PannerNode: JSString = "PannerNode"
    @usableFromInline static let Path2D: JSString = "Path2D"
    @usableFromInline static let Performance: JSString = "Performance"
    @usableFromInline static let PeriodicWave: JSString = "PeriodicWave"
    @usableFromInline static let Plugin: JSString = "Plugin"
    @usableFromInline static let PluginArray: JSString = "PluginArray"
    @usableFromInline static let PopStateEvent: JSString = "PopStateEvent"
    @usableFromInline static let ProcessingInstruction: JSString = "ProcessingInstruction"
    @usableFromInline static let ProgressEvent: JSString = "ProgressEvent"
    @usableFromInline static let PromiseRejectionEvent: JSString = "PromiseRejectionEvent"
    @usableFromInline static let Q: JSString = "Q"
    @usableFromInline static let RadioNodeList: JSString = "RadioNodeList"
    @usableFromInline static let Range: JSString = "Range"
    @usableFromInline static let ReadableByteStreamController: JSString = "ReadableByteStreamController"
    @usableFromInline static let ReadableStream: JSString = "ReadableStream"
    @usableFromInline static let ReadableStreamBYOBReader: JSString = "ReadableStreamBYOBReader"
    @usableFromInline static let ReadableStreamBYOBRequest: JSString = "ReadableStreamBYOBRequest"
    @usableFromInline static let ReadableStreamDefaultController: JSString = "ReadableStreamDefaultController"
    @usableFromInline static let ReadableStreamDefaultReader: JSString = "ReadableStreamDefaultReader"
    @usableFromInline static let Request: JSString = "Request"
    @usableFromInline static let Response: JSString = "Response"
    @usableFromInline static let Screen: JSString = "Screen"
    @usableFromInline static let ScriptProcessorNode: JSString = "ScriptProcessorNode"
    @usableFromInline static let ServiceWorker: JSString = "ServiceWorker"
    @usableFromInline static let ServiceWorkerContainer: JSString = "ServiceWorkerContainer"
    @usableFromInline static let ServiceWorkerRegistration: JSString = "ServiceWorkerRegistration"
    @usableFromInline static let ShadowRoot: JSString = "ShadowRoot"
    @usableFromInline static let SharedWorker: JSString = "SharedWorker"
    @usableFromInline static let StaticRange: JSString = "StaticRange"
    @usableFromInline static let StereoPannerNode: JSString = "StereoPannerNode"
    @usableFromInline static let Storage: JSString = "Storage"
    @usableFromInline static let StorageEvent: JSString = "StorageEvent"
    @usableFromInline static let SubmitEvent: JSString = "SubmitEvent"
    @usableFromInline static let Text: JSString = "Text"
    @usableFromInline static let TextMetrics: JSString = "TextMetrics"
    @usableFromInline static let TextTrack: JSString = "TextTrack"
    @usableFromInline static let TextTrackCue: JSString = "TextTrackCue"
    @usableFromInline static let TextTrackCueList: JSString = "TextTrackCueList"
    @usableFromInline static let TextTrackList: JSString = "TextTrackList"
    @usableFromInline static let TimeRanges: JSString = "TimeRanges"
    @usableFromInline static let TrackEvent: JSString = "TrackEvent"
    @usableFromInline static let TransformStream: JSString = "TransformStream"
    @usableFromInline static let TransformStreamDefaultController: JSString = "TransformStreamDefaultController"
    @usableFromInline static let TreeWalker: JSString = "TreeWalker"
    @usableFromInline static let UIEvent: JSString = "UIEvent"
    @usableFromInline static let URL: JSString = "URL"
    @usableFromInline static let URLSearchParams: JSString = "URLSearchParams"
    @usableFromInline static let ValidityState: JSString = "ValidityState"
    @usableFromInline static let VideoColorSpace: JSString = "VideoColorSpace"
    @usableFromInline static let VideoDecoder: JSString = "VideoDecoder"
    @usableFromInline static let VideoEncoder: JSString = "VideoEncoder"
    @usableFromInline static let VideoFrame: JSString = "VideoFrame"
    @usableFromInline static let VideoTrack: JSString = "VideoTrack"
    @usableFromInline static let VideoTrackList: JSString = "VideoTrackList"
    @usableFromInline static let WaveShaperNode: JSString = "WaveShaperNode"
    @usableFromInline static let WebGL2RenderingContext: JSString = "WebGL2RenderingContext"
    @usableFromInline static let WebGLActiveInfo: JSString = "WebGLActiveInfo"
    @usableFromInline static let WebGLBuffer: JSString = "WebGLBuffer"
    @usableFromInline static let WebGLContextEvent: JSString = "WebGLContextEvent"
    @usableFromInline static let WebGLFramebuffer: JSString = "WebGLFramebuffer"
    @usableFromInline static let WebGLObject: JSString = "WebGLObject"
    @usableFromInline static let WebGLProgram: JSString = "WebGLProgram"
    @usableFromInline static let WebGLQuery: JSString = "WebGLQuery"
    @usableFromInline static let WebGLRenderbuffer: JSString = "WebGLRenderbuffer"
    @usableFromInline static let WebGLRenderingContext: JSString = "WebGLRenderingContext"
    @usableFromInline static let WebGLSampler: JSString = "WebGLSampler"
    @usableFromInline static let WebGLShader: JSString = "WebGLShader"
    @usableFromInline static let WebGLShaderPrecisionFormat: JSString = "WebGLShaderPrecisionFormat"
    @usableFromInline static let WebGLSync: JSString = "WebGLSync"
    @usableFromInline static let WebGLTexture: JSString = "WebGLTexture"
    @usableFromInline static let WebGLTransformFeedback: JSString = "WebGLTransformFeedback"
    @usableFromInline static let WebGLUniformLocation: JSString = "WebGLUniformLocation"
    @usableFromInline static let WebGLVertexArrayObject: JSString = "WebGLVertexArrayObject"
    @usableFromInline static let WebSocket: JSString = "WebSocket"
    @usableFromInline static let WheelEvent: JSString = "WheelEvent"
    @usableFromInline static let Window: JSString = "Window"
    @usableFromInline static let Worker: JSString = "Worker"
    @usableFromInline static let Worklet: JSString = "Worklet"
    @usableFromInline static let WritableStream: JSString = "WritableStream"
    @usableFromInline static let WritableStreamDefaultController: JSString = "WritableStreamDefaultController"
    @usableFromInline static let WritableStreamDefaultWriter: JSString = "WritableStreamDefaultWriter"
    @usableFromInline static let XMLDocument: JSString = "XMLDocument"
    @usableFromInline static let XMLHttpRequest: JSString = "XMLHttpRequest"
    @usableFromInline static let XMLHttpRequestEventTarget: JSString = "XMLHttpRequestEventTarget"
    @usableFromInline static let XMLHttpRequestUpload: JSString = "XMLHttpRequestUpload"
    @usableFromInline static let XPathEvaluator: JSString = "XPathEvaluator"
    @usableFromInline static let XPathExpression: JSString = "XPathExpression"
    @usableFromInline static let XPathResult: JSString = "XPathResult"
    @usableFromInline static let XSLTProcessor: JSString = "XSLTProcessor"
    @usableFromInline static let a: JSString = "a"
    @usableFromInline static let aLink: JSString = "aLink"
    @usableFromInline static let abbr: JSString = "abbr"
    @usableFromInline static let abort: JSString = "abort"
    @usableFromInline static let aborted: JSString = "aborted"
    @usableFromInline static let accept: JSString = "accept"
    @usableFromInline static let acceptCharset: JSString = "acceptCharset"
    @usableFromInline static let access: JSString = "access"
    @usableFromInline static let accessKey: JSString = "accessKey"
    @usableFromInline static let accessKeyLabel: JSString = "accessKeyLabel"
    @usableFromInline static let action: JSString = "action"
    @usableFromInline static let active: JSString = "active"
    @usableFromInline static let activeCues: JSString = "activeCues"
    @usableFromInline static let activeElement: JSString = "activeElement"
    @usableFromInline static let activeTexture: JSString = "activeTexture"
    @usableFromInline static let actualBoundingBoxAscent: JSString = "actualBoundingBoxAscent"
    @usableFromInline static let actualBoundingBoxDescent: JSString = "actualBoundingBoxDescent"
    @usableFromInline static let actualBoundingBoxLeft: JSString = "actualBoundingBoxLeft"
    @usableFromInline static let actualBoundingBoxRight: JSString = "actualBoundingBoxRight"
    @usableFromInline static let add: JSString = "add"
    @usableFromInline static let addAll: JSString = "addAll"
    @usableFromInline static let addColorStop: JSString = "addColorStop"
    @usableFromInline static let addCue: JSString = "addCue"
    @usableFromInline static let addModule: JSString = "addModule"
    @usableFromInline static let addPath: JSString = "addPath"
    @usableFromInline static let addTextTrack: JSString = "addTextTrack"
    @usableFromInline static let addTrack: JSString = "addTrack"
    @usableFromInline static let addedNodes: JSString = "addedNodes"
    @usableFromInline static let addressModeU: JSString = "addressModeU"
    @usableFromInline static let addressModeV: JSString = "addressModeV"
    @usableFromInline static let addressModeW: JSString = "addressModeW"
    @usableFromInline static let adoptNode: JSString = "adoptNode"
    @usableFromInline static let advanced: JSString = "advanced"
    @usableFromInline static let after: JSString = "after"
    @usableFromInline static let alert: JSString = "alert"
    @usableFromInline static let align: JSString = "align"
    @usableFromInline static let alinkColor: JSString = "alinkColor"
    @usableFromInline static let all: JSString = "all"
    @usableFromInline static let allocationSize: JSString = "allocationSize"
    @usableFromInline static let allow: JSString = "allow"
    @usableFromInline static let allowFullscreen: JSString = "allowFullscreen"
    @usableFromInline static let alpha: JSString = "alpha"
    @usableFromInline static let alphaSideData: JSString = "alphaSideData"
    @usableFromInline static let alphaToCoverageEnabled: JSString = "alphaToCoverageEnabled"
    @usableFromInline static let alphabeticBaseline: JSString = "alphabeticBaseline"
    @usableFromInline static let alt: JSString = "alt"
    @usableFromInline static let altKey: JSString = "altKey"
    @usableFromInline static let ancestorOrigins: JSString = "ancestorOrigins"
    @usableFromInline static let anchors: JSString = "anchors"
    @usableFromInline static let animate: JSString = "animate"
    @usableFromInline static let animated: JSString = "animated"
    @usableFromInline static let antialias: JSString = "antialias"
    @usableFromInline static let appCodeName: JSString = "appCodeName"
    @usableFromInline static let appName: JSString = "appName"
    @usableFromInline static let appVersion: JSString = "appVersion"
    @usableFromInline static let append: JSString = "append"
    @usableFromInline static let appendChild: JSString = "appendChild"
    @usableFromInline static let appendData: JSString = "appendData"
    @usableFromInline static let applets: JSString = "applets"
    @usableFromInline static let applyConstraints: JSString = "applyConstraints"
    @usableFromInline static let arc: JSString = "arc"
    @usableFromInline static let arcTo: JSString = "arcTo"
    @usableFromInline static let archive: JSString = "archive"
    @usableFromInline static let areas: JSString = "areas"
    @usableFromInline static let ariaAtomic: JSString = "ariaAtomic"
    @usableFromInline static let ariaAutoComplete: JSString = "ariaAutoComplete"
    @usableFromInline static let ariaBusy: JSString = "ariaBusy"
    @usableFromInline static let ariaChecked: JSString = "ariaChecked"
    @usableFromInline static let ariaColCount: JSString = "ariaColCount"
    @usableFromInline static let ariaColIndex: JSString = "ariaColIndex"
    @usableFromInline static let ariaColIndexText: JSString = "ariaColIndexText"
    @usableFromInline static let ariaColSpan: JSString = "ariaColSpan"
    @usableFromInline static let ariaCurrent: JSString = "ariaCurrent"
    @usableFromInline static let ariaDescription: JSString = "ariaDescription"
    @usableFromInline static let ariaDisabled: JSString = "ariaDisabled"
    @usableFromInline static let ariaExpanded: JSString = "ariaExpanded"
    @usableFromInline static let ariaHasPopup: JSString = "ariaHasPopup"
    @usableFromInline static let ariaHidden: JSString = "ariaHidden"
    @usableFromInline static let ariaInvalid: JSString = "ariaInvalid"
    @usableFromInline static let ariaKeyShortcuts: JSString = "ariaKeyShortcuts"
    @usableFromInline static let ariaLabel: JSString = "ariaLabel"
    @usableFromInline static let ariaLevel: JSString = "ariaLevel"
    @usableFromInline static let ariaLive: JSString = "ariaLive"
    @usableFromInline static let ariaModal: JSString = "ariaModal"
    @usableFromInline static let ariaMultiLine: JSString = "ariaMultiLine"
    @usableFromInline static let ariaMultiSelectable: JSString = "ariaMultiSelectable"
    @usableFromInline static let ariaOrientation: JSString = "ariaOrientation"
    @usableFromInline static let ariaPlaceholder: JSString = "ariaPlaceholder"
    @usableFromInline static let ariaPosInSet: JSString = "ariaPosInSet"
    @usableFromInline static let ariaPressed: JSString = "ariaPressed"
    @usableFromInline static let ariaReadOnly: JSString = "ariaReadOnly"
    @usableFromInline static let ariaRequired: JSString = "ariaRequired"
    @usableFromInline static let ariaRoleDescription: JSString = "ariaRoleDescription"
    @usableFromInline static let ariaRowCount: JSString = "ariaRowCount"
    @usableFromInline static let ariaRowIndex: JSString = "ariaRowIndex"
    @usableFromInline static let ariaRowIndexText: JSString = "ariaRowIndexText"
    @usableFromInline static let ariaRowSpan: JSString = "ariaRowSpan"
    @usableFromInline static let ariaSelected: JSString = "ariaSelected"
    @usableFromInline static let ariaSetSize: JSString = "ariaSetSize"
    @usableFromInline static let ariaSort: JSString = "ariaSort"
    @usableFromInline static let ariaValueMax: JSString = "ariaValueMax"
    @usableFromInline static let ariaValueMin: JSString = "ariaValueMin"
    @usableFromInline static let ariaValueNow: JSString = "ariaValueNow"
    @usableFromInline static let ariaValueText: JSString = "ariaValueText"
    @usableFromInline static let arrayBuffer: JSString = "arrayBuffer"
    @usableFromInline static let arrayLayerCount: JSString = "arrayLayerCount"
    @usableFromInline static let arrayStride: JSString = "arrayStride"
    @usableFromInline static let `as`: JSString = "as"
    @usableFromInline static let aspect: JSString = "aspect"
    @usableFromInline static let aspectRatio: JSString = "aspectRatio"
    @usableFromInline static let assert: JSString = "assert"
    @usableFromInline static let assign: JSString = "assign"
    @usableFromInline static let assignedElements: JSString = "assignedElements"
    @usableFromInline static let assignedNodes: JSString = "assignedNodes"
    @usableFromInline static let assignedSlot: JSString = "assignedSlot"
    @usableFromInline static let async: JSString = "async"
    @usableFromInline static let atob: JSString = "atob"
    @usableFromInline static let attachInternals: JSString = "attachInternals"
    @usableFromInline static let attachShader: JSString = "attachShader"
    @usableFromInline static let attachShadow: JSString = "attachShadow"
    @usableFromInline static let attack: JSString = "attack"
    @usableFromInline static let attrChange: JSString = "attrChange"
    @usableFromInline static let attrName: JSString = "attrName"
    @usableFromInline static let attributeFilter: JSString = "attributeFilter"
    @usableFromInline static let attributeName: JSString = "attributeName"
    @usableFromInline static let attributeNamespace: JSString = "attributeNamespace"
    @usableFromInline static let attributeOldValue: JSString = "attributeOldValue"
    @usableFromInline static let attributes: JSString = "attributes"
    @usableFromInline static let audio: JSString = "audio"
    @usableFromInline static let audioBitrateMode: JSString = "audioBitrateMode"
    @usableFromInline static let audioBitsPerSecond: JSString = "audioBitsPerSecond"
    @usableFromInline static let audioTracks: JSString = "audioTracks"
    @usableFromInline static let audioWorklet: JSString = "audioWorklet"
    @usableFromInline static let autoAllocateChunkSize: JSString = "autoAllocateChunkSize"
    @usableFromInline static let autoGainControl: JSString = "autoGainControl"
    @usableFromInline static let autocapitalize: JSString = "autocapitalize"
    @usableFromInline static let autocomplete: JSString = "autocomplete"
    @usableFromInline static let autofocus: JSString = "autofocus"
    @usableFromInline static let automationRate: JSString = "automationRate"
    @usableFromInline static let autoplay: JSString = "autoplay"
    @usableFromInline static let availHeight: JSString = "availHeight"
    @usableFromInline static let availWidth: JSString = "availWidth"
    @usableFromInline static let axis: JSString = "axis"
    @usableFromInline static let b: JSString = "b"
    @usableFromInline static let back: JSString = "back"
    @usableFromInline static let background: JSString = "background"
    @usableFromInline static let badInput: JSString = "badInput"
    @usableFromInline static let baseArrayLayer: JSString = "baseArrayLayer"
    @usableFromInline static let baseLatency: JSString = "baseLatency"
    @usableFromInline static let baseMipLevel: JSString = "baseMipLevel"
    @usableFromInline static let baseURI: JSString = "baseURI"
    @usableFromInline static let before: JSString = "before"
    @usableFromInline static let beginComputePass: JSString = "beginComputePass"
    @usableFromInline static let beginOcclusionQuery: JSString = "beginOcclusionQuery"
    @usableFromInline static let beginPath: JSString = "beginPath"
    @usableFromInline static let beginQuery: JSString = "beginQuery"
    @usableFromInline static let beginRenderPass: JSString = "beginRenderPass"
    @usableFromInline static let beginTransformFeedback: JSString = "beginTransformFeedback"
    @usableFromInline static let behavior: JSString = "behavior"
    @usableFromInline static let bezierCurveTo: JSString = "bezierCurveTo"
    @usableFromInline static let bgColor: JSString = "bgColor"
    @usableFromInline static let binaryType: JSString = "binaryType"
    @usableFromInline static let bindAttribLocation: JSString = "bindAttribLocation"
    @usableFromInline static let bindBuffer: JSString = "bindBuffer"
    @usableFromInline static let bindBufferBase: JSString = "bindBufferBase"
    @usableFromInline static let bindBufferRange: JSString = "bindBufferRange"
    @usableFromInline static let bindFramebuffer: JSString = "bindFramebuffer"
    @usableFromInline static let bindGroupLayouts: JSString = "bindGroupLayouts"
    @usableFromInline static let bindRenderbuffer: JSString = "bindRenderbuffer"
    @usableFromInline static let bindSampler: JSString = "bindSampler"
    @usableFromInline static let bindTexture: JSString = "bindTexture"
    @usableFromInline static let bindTransformFeedback: JSString = "bindTransformFeedback"
    @usableFromInline static let bindVertexArray: JSString = "bindVertexArray"
    @usableFromInline static let binding: JSString = "binding"
    @usableFromInline static let bitrate: JSString = "bitrate"
    @usableFromInline static let bitrateMode: JSString = "bitrateMode"
    @usableFromInline static let bitsPerSecond: JSString = "bitsPerSecond"
    @usableFromInline static let blend: JSString = "blend"
    @usableFromInline static let blendColor: JSString = "blendColor"
    @usableFromInline static let blendEquation: JSString = "blendEquation"
    @usableFromInline static let blendEquationSeparate: JSString = "blendEquationSeparate"
    @usableFromInline static let blendFunc: JSString = "blendFunc"
    @usableFromInline static let blendFuncSeparate: JSString = "blendFuncSeparate"
    @usableFromInline static let blitFramebuffer: JSString = "blitFramebuffer"
    @usableFromInline static let blob: JSString = "blob"
    @usableFromInline static let block: JSString = "block"
    @usableFromInline static let blocking: JSString = "blocking"
    @usableFromInline static let blur: JSString = "blur"
    @usableFromInline static let body: JSString = "body"
    @usableFromInline static let bodyUsed: JSString = "bodyUsed"
    @usableFromInline static let booleanValue: JSString = "booleanValue"
    @usableFromInline static let border: JSString = "border"
    @usableFromInline static let bottom: JSString = "bottom"
    @usableFromInline static let box: JSString = "box"
    @usableFromInline static let btoa: JSString = "btoa"
    @usableFromInline static let bubbles: JSString = "bubbles"
    @usableFromInline static let buffer: JSString = "buffer"
    @usableFromInline static let bufferData: JSString = "bufferData"
    @usableFromInline static let bufferSize: JSString = "bufferSize"
    @usableFromInline static let bufferSubData: JSString = "bufferSubData"
    @usableFromInline static let buffered: JSString = "buffered"
    @usableFromInline static let bufferedAmount: JSString = "bufferedAmount"
    @usableFromInline static let buffers: JSString = "buffers"
    @usableFromInline static let button: JSString = "button"
    @usableFromInline static let buttons: JSString = "buttons"
    @usableFromInline static let byobRequest: JSString = "byobRequest"
    @usableFromInline static let byteLength: JSString = "byteLength"
    @usableFromInline static let bytesPerRow: JSString = "bytesPerRow"
    @usableFromInline static let c: JSString = "c"
    @usableFromInline static let cache: JSString = "cache"
    @usableFromInline static let cacheName: JSString = "cacheName"
    @usableFromInline static let caches: JSString = "caches"
    @usableFromInline static let canPlayType: JSString = "canPlayType"
    @usableFromInline static let cancel: JSString = "cancel"
    @usableFromInline static let cancelAndHoldAtTime: JSString = "cancelAndHoldAtTime"
    @usableFromInline static let cancelAnimationFrame: JSString = "cancelAnimationFrame"
    @usableFromInline static let cancelBubble: JSString = "cancelBubble"
    @usableFromInline static let cancelScheduledValues: JSString = "cancelScheduledValues"
    @usableFromInline static let cancelable: JSString = "cancelable"
    @usableFromInline static let canvas: JSString = "canvas"
    @usableFromInline static let caption: JSString = "caption"
    @usableFromInline static let capture: JSString = "capture"
    @usableFromInline static let captureEvents: JSString = "captureEvents"
    @usableFromInline static let caretPositionFromPoint: JSString = "caretPositionFromPoint"
    @usableFromInline static let cellIndex: JSString = "cellIndex"
    @usableFromInline static let cellPadding: JSString = "cellPadding"
    @usableFromInline static let cellSpacing: JSString = "cellSpacing"
    @usableFromInline static let cells: JSString = "cells"
    @usableFromInline static let ch: JSString = "ch"
    @usableFromInline static let chOff: JSString = "chOff"
    @usableFromInline static let channelCount: JSString = "channelCount"
    @usableFromInline static let channelCountMode: JSString = "channelCountMode"
    @usableFromInline static let channelInterpretation: JSString = "channelInterpretation"
    @usableFromInline static let charCode: JSString = "charCode"
    @usableFromInline static let characterData: JSString = "characterData"
    @usableFromInline static let characterDataOldValue: JSString = "characterDataOldValue"
    @usableFromInline static let characterSet: JSString = "characterSet"
    @usableFromInline static let charset: JSString = "charset"
    @usableFromInline static let checkFramebufferStatus: JSString = "checkFramebufferStatus"
    @usableFromInline static let checkValidity: JSString = "checkValidity"
    @usableFromInline static let checked: JSString = "checked"
    @usableFromInline static let childElementCount: JSString = "childElementCount"
    @usableFromInline static let childList: JSString = "childList"
    @usableFromInline static let childNodes: JSString = "childNodes"
    @usableFromInline static let children: JSString = "children"
    @usableFromInline static let cite: JSString = "cite"
    @usableFromInline static let classList: JSString = "classList"
    @usableFromInline static let className: JSString = "className"
    @usableFromInline static let clear: JSString = "clear"
    @usableFromInline static let clearBuffer: JSString = "clearBuffer"
    @usableFromInline static let clearBufferfi: JSString = "clearBufferfi"
    @usableFromInline static let clearBufferfv: JSString = "clearBufferfv"
    @usableFromInline static let clearBufferiv: JSString = "clearBufferiv"
    @usableFromInline static let clearBufferuiv: JSString = "clearBufferuiv"
    @usableFromInline static let clearColor: JSString = "clearColor"
    @usableFromInline static let clearData: JSString = "clearData"
    @usableFromInline static let clearDepth: JSString = "clearDepth"
    @usableFromInline static let clearInterval: JSString = "clearInterval"
    @usableFromInline static let clearParameters: JSString = "clearParameters"
    @usableFromInline static let clearRect: JSString = "clearRect"
    @usableFromInline static let clearStencil: JSString = "clearStencil"
    @usableFromInline static let clearTimeout: JSString = "clearTimeout"
    @usableFromInline static let clearValue: JSString = "clearValue"
    @usableFromInline static let click: JSString = "click"
    @usableFromInline static let clientHeight: JSString = "clientHeight"
    @usableFromInline static let clientId: JSString = "clientId"
    @usableFromInline static let clientInformation: JSString = "clientInformation"
    @usableFromInline static let clientLeft: JSString = "clientLeft"
    @usableFromInline static let clientTop: JSString = "clientTop"
    @usableFromInline static let clientWaitSync: JSString = "clientWaitSync"
    @usableFromInline static let clientWidth: JSString = "clientWidth"
    @usableFromInline static let clientX: JSString = "clientX"
    @usableFromInline static let clientY: JSString = "clientY"
    @usableFromInline static let clip: JSString = "clip"
    @usableFromInline static let clone: JSString = "clone"
    @usableFromInline static let cloneContents: JSString = "cloneContents"
    @usableFromInline static let cloneNode: JSString = "cloneNode"
    @usableFromInline static let cloneRange: JSString = "cloneRange"
    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let closePath: JSString = "closePath"
    @usableFromInline static let closed: JSString = "closed"
    @usableFromInline static let closest: JSString = "closest"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let codeBase: JSString = "codeBase"
    @usableFromInline static let codeType: JSString = "codeType"
    @usableFromInline static let codec: JSString = "codec"
    @usableFromInline static let codedHeight: JSString = "codedHeight"
    @usableFromInline static let codedRect: JSString = "codedRect"
    @usableFromInline static let codedWidth: JSString = "codedWidth"
    @usableFromInline static let colSpan: JSString = "colSpan"
    @usableFromInline static let collapse: JSString = "collapse"
    @usableFromInline static let collapsed: JSString = "collapsed"
    @usableFromInline static let colno: JSString = "colno"
    @usableFromInline static let color: JSString = "color"
    @usableFromInline static let colorAttachments: JSString = "colorAttachments"
    @usableFromInline static let colorDepth: JSString = "colorDepth"
    @usableFromInline static let colorFormats: JSString = "colorFormats"
    @usableFromInline static let colorMask: JSString = "colorMask"
    @usableFromInline static let colorSpace: JSString = "colorSpace"
    @usableFromInline static let colorSpaceConversion: JSString = "colorSpaceConversion"
    @usableFromInline static let cols: JSString = "cols"
    @usableFromInline static let commit: JSString = "commit"
    @usableFromInline static let commitStyles: JSString = "commitStyles"
    @usableFromInline static let commonAncestorContainer: JSString = "commonAncestorContainer"
    @usableFromInline static let compact: JSString = "compact"
    @usableFromInline static let compare: JSString = "compare"
    @usableFromInline static let compareBoundaryPoints: JSString = "compareBoundaryPoints"
    @usableFromInline static let compareDocumentPosition: JSString = "compareDocumentPosition"
    @usableFromInline static let comparePoint: JSString = "comparePoint"
    @usableFromInline static let compatMode: JSString = "compatMode"
    @usableFromInline static let compilationInfo: JSString = "compilationInfo"
    @usableFromInline static let compileShader: JSString = "compileShader"
    @usableFromInline static let complete: JSString = "complete"
    @usableFromInline static let completeFramesOnly: JSString = "completeFramesOnly"
    @usableFromInline static let completed: JSString = "completed"
    @usableFromInline static let composed: JSString = "composed"
    @usableFromInline static let composedPath: JSString = "composedPath"
    @usableFromInline static let composite: JSString = "composite"
    @usableFromInline static let compositingAlphaMode: JSString = "compositingAlphaMode"
    @usableFromInline static let compressedTexImage2D: JSString = "compressedTexImage2D"
    @usableFromInline static let compressedTexImage3D: JSString = "compressedTexImage3D"
    @usableFromInline static let compressedTexSubImage2D: JSString = "compressedTexSubImage2D"
    @usableFromInline static let compressedTexSubImage3D: JSString = "compressedTexSubImage3D"
    @usableFromInline static let compute: JSString = "compute"
    @usableFromInline static let computedOffset: JSString = "computedOffset"
    @usableFromInline static let coneInnerAngle: JSString = "coneInnerAngle"
    @usableFromInline static let coneOuterAngle: JSString = "coneOuterAngle"
    @usableFromInline static let coneOuterGain: JSString = "coneOuterGain"
    @usableFromInline static let config: JSString = "config"
    @usableFromInline static let configure: JSString = "configure"
    @usableFromInline static let confirm: JSString = "confirm"
    @usableFromInline static let connect: JSString = "connect"
    @usableFromInline static let console: JSString = "console"
    @usableFromInline static let constants: JSString = "constants"
    @usableFromInline static let constraint: JSString = "constraint"
    @usableFromInline static let contains: JSString = "contains"
    @usableFromInline static let content: JSString = "content"
    @usableFromInline static let contentDocument: JSString = "contentDocument"
    @usableFromInline static let contentEditable: JSString = "contentEditable"
    @usableFromInline static let contentType: JSString = "contentType"
    @usableFromInline static let contentWindow: JSString = "contentWindow"
    @usableFromInline static let context: JSString = "context"
    @usableFromInline static let contextTime: JSString = "contextTime"
    @usableFromInline static let control: JSString = "control"
    @usableFromInline static let controller: JSString = "controller"
    @usableFromInline static let controls: JSString = "controls"
    @usableFromInline static let convertPointFromNode: JSString = "convertPointFromNode"
    @usableFromInline static let convertQuadFromNode: JSString = "convertQuadFromNode"
    @usableFromInline static let convertRectFromNode: JSString = "convertRectFromNode"
    @usableFromInline static let convertToBlob: JSString = "convertToBlob"
    @usableFromInline static let cookie: JSString = "cookie"
    @usableFromInline static let cookieEnabled: JSString = "cookieEnabled"
    @usableFromInline static let coords: JSString = "coords"
    @usableFromInline static let copyBufferSubData: JSString = "copyBufferSubData"
    @usableFromInline static let copyBufferToBuffer: JSString = "copyBufferToBuffer"
    @usableFromInline static let copyBufferToTexture: JSString = "copyBufferToTexture"
    @usableFromInline static let copyExternalImageToTexture: JSString = "copyExternalImageToTexture"
    @usableFromInline static let copyFromChannel: JSString = "copyFromChannel"
    @usableFromInline static let copyTexImage2D: JSString = "copyTexImage2D"
    @usableFromInline static let copyTexSubImage2D: JSString = "copyTexSubImage2D"
    @usableFromInline static let copyTexSubImage3D: JSString = "copyTexSubImage3D"
    @usableFromInline static let copyTextureToBuffer: JSString = "copyTextureToBuffer"
    @usableFromInline static let copyTextureToTexture: JSString = "copyTextureToTexture"
    @usableFromInline static let copyTo: JSString = "copyTo"
    @usableFromInline static let copyToChannel: JSString = "copyToChannel"
    @usableFromInline static let count: JSString = "count"
    @usableFromInline static let countReset: JSString = "countReset"
    @usableFromInline static let createAnalyser: JSString = "createAnalyser"
    @usableFromInline static let createAttribute: JSString = "createAttribute"
    @usableFromInline static let createAttributeNS: JSString = "createAttributeNS"
    @usableFromInline static let createBindGroup: JSString = "createBindGroup"
    @usableFromInline static let createBindGroupLayout: JSString = "createBindGroupLayout"
    @usableFromInline static let createBiquadFilter: JSString = "createBiquadFilter"
    @usableFromInline static let createBuffer: JSString = "createBuffer"
    @usableFromInline static let createBufferSource: JSString = "createBufferSource"
    @usableFromInline static let createCDATASection: JSString = "createCDATASection"
    @usableFromInline static let createCaption: JSString = "createCaption"
    @usableFromInline static let createChannelMerger: JSString = "createChannelMerger"
    @usableFromInline static let createChannelSplitter: JSString = "createChannelSplitter"
    @usableFromInline static let createCommandEncoder: JSString = "createCommandEncoder"
    @usableFromInline static let createComment: JSString = "createComment"
    @usableFromInline static let createComputePipeline: JSString = "createComputePipeline"
    @usableFromInline static let createComputePipelineAsync: JSString = "createComputePipelineAsync"
    @usableFromInline static let createConicGradient: JSString = "createConicGradient"
    @usableFromInline static let createConstantSource: JSString = "createConstantSource"
    @usableFromInline static let createConvolver: JSString = "createConvolver"
    @usableFromInline static let createDelay: JSString = "createDelay"
    @usableFromInline static let createDocument: JSString = "createDocument"
    @usableFromInline static let createDocumentFragment: JSString = "createDocumentFragment"
    @usableFromInline static let createDocumentType: JSString = "createDocumentType"
    @usableFromInline static let createDynamicsCompressor: JSString = "createDynamicsCompressor"
    @usableFromInline static let createElement: JSString = "createElement"
    @usableFromInline static let createElementNS: JSString = "createElementNS"
    @usableFromInline static let createEvent: JSString = "createEvent"
    @usableFromInline static let createFramebuffer: JSString = "createFramebuffer"
    @usableFromInline static let createGain: JSString = "createGain"
    @usableFromInline static let createHTMLDocument: JSString = "createHTMLDocument"
    @usableFromInline static let createIIRFilter: JSString = "createIIRFilter"
    @usableFromInline static let createImageBitmap: JSString = "createImageBitmap"
    @usableFromInline static let createImageData: JSString = "createImageData"
    @usableFromInline static let createLinearGradient: JSString = "createLinearGradient"
    @usableFromInline static let createMediaElementSource: JSString = "createMediaElementSource"
    @usableFromInline static let createMediaStreamDestination: JSString = "createMediaStreamDestination"
    @usableFromInline static let createMediaStreamSource: JSString = "createMediaStreamSource"
    @usableFromInline static let createMediaStreamTrackSource: JSString = "createMediaStreamTrackSource"
    @usableFromInline static let createObjectURL: JSString = "createObjectURL"
    @usableFromInline static let createOscillator: JSString = "createOscillator"
    @usableFromInline static let createPanner: JSString = "createPanner"
    @usableFromInline static let createPattern: JSString = "createPattern"
    @usableFromInline static let createPeriodicWave: JSString = "createPeriodicWave"
    @usableFromInline static let createPipelineLayout: JSString = "createPipelineLayout"
    @usableFromInline static let createProcessingInstruction: JSString = "createProcessingInstruction"
    @usableFromInline static let createProgram: JSString = "createProgram"
    @usableFromInline static let createQuery: JSString = "createQuery"
    @usableFromInline static let createQuerySet: JSString = "createQuerySet"
    @usableFromInline static let createRadialGradient: JSString = "createRadialGradient"
    @usableFromInline static let createRange: JSString = "createRange"
    @usableFromInline static let createRenderBundleEncoder: JSString = "createRenderBundleEncoder"
    @usableFromInline static let createRenderPipeline: JSString = "createRenderPipeline"
    @usableFromInline static let createRenderPipelineAsync: JSString = "createRenderPipelineAsync"
    @usableFromInline static let createRenderbuffer: JSString = "createRenderbuffer"
    @usableFromInline static let createSampler: JSString = "createSampler"
    @usableFromInline static let createScriptProcessor: JSString = "createScriptProcessor"
    @usableFromInline static let createShader: JSString = "createShader"
    @usableFromInline static let createShaderModule: JSString = "createShaderModule"
    @usableFromInline static let createStereoPanner: JSString = "createStereoPanner"
    @usableFromInline static let createTBody: JSString = "createTBody"
    @usableFromInline static let createTFoot: JSString = "createTFoot"
    @usableFromInline static let createTHead: JSString = "createTHead"
    @usableFromInline static let createTextNode: JSString = "createTextNode"
    @usableFromInline static let createTexture: JSString = "createTexture"
    @usableFromInline static let createTransformFeedback: JSString = "createTransformFeedback"
    @usableFromInline static let createVertexArray: JSString = "createVertexArray"
    @usableFromInline static let createView: JSString = "createView"
    @usableFromInline static let createWaveShaper: JSString = "createWaveShaper"
    @usableFromInline static let credentials: JSString = "credentials"
    @usableFromInline static let crossOrigin: JSString = "crossOrigin"
    @usableFromInline static let crossOriginIsolated: JSString = "crossOriginIsolated"
    @usableFromInline static let ctrlKey: JSString = "ctrlKey"
    @usableFromInline static let cues: JSString = "cues"
    @usableFromInline static let cullFace: JSString = "cullFace"
    @usableFromInline static let cullMode: JSString = "cullMode"
    @usableFromInline static let currentIteration: JSString = "currentIteration"
    @usableFromInline static let currentNode: JSString = "currentNode"
    @usableFromInline static let currentScript: JSString = "currentScript"
    @usableFromInline static let currentSrc: JSString = "currentSrc"
    @usableFromInline static let currentTarget: JSString = "currentTarget"
    @usableFromInline static let currentTime: JSString = "currentTime"
    @usableFromInline static let curve: JSString = "curve"
    @usableFromInline static let customElements: JSString = "customElements"
    @usableFromInline static let customError: JSString = "customError"
    @usableFromInline static let d: JSString = "d"
    @usableFromInline static let data: JSString = "data"
    @usableFromInline static let dataTransfer: JSString = "dataTransfer"
    @usableFromInline static let dataset: JSString = "dataset"
    @usableFromInline static let dateTime: JSString = "dateTime"
    @usableFromInline static let debug: JSString = "debug"
    @usableFromInline static let declare: JSString = "declare"
    @usableFromInline static let decode: JSString = "decode"
    @usableFromInline static let decodeQueueSize: JSString = "decodeQueueSize"
    @usableFromInline static let decoderConfig: JSString = "decoderConfig"
    @usableFromInline static let decoding: JSString = "decoding"
    @usableFromInline static let `default`: JSString = "default"
    @usableFromInline static let defaultChecked: JSString = "defaultChecked"
    @usableFromInline static let defaultMuted: JSString = "defaultMuted"
    @usableFromInline static let defaultPlaybackRate: JSString = "defaultPlaybackRate"
    @usableFromInline static let defaultPrevented: JSString = "defaultPrevented"
    @usableFromInline static let defaultQueue: JSString = "defaultQueue"
    @usableFromInline static let defaultSelected: JSString = "defaultSelected"
    @usableFromInline static let defaultValue: JSString = "defaultValue"
    @usableFromInline static let defaultView: JSString = "defaultView"
    @usableFromInline static let `defer`: JSString = "defer"
    @usableFromInline static let define: JSString = "define"
    @usableFromInline static let delay: JSString = "delay"
    @usableFromInline static let delayTime: JSString = "delayTime"
    @usableFromInline static let delegatesFocus: JSString = "delegatesFocus"
    @usableFromInline static let delete: JSString = "delete"
    @usableFromInline static let deleteBuffer: JSString = "deleteBuffer"
    @usableFromInline static let deleteCaption: JSString = "deleteCaption"
    @usableFromInline static let deleteCell: JSString = "deleteCell"
    @usableFromInline static let deleteContents: JSString = "deleteContents"
    @usableFromInline static let deleteData: JSString = "deleteData"
    @usableFromInline static let deleteFramebuffer: JSString = "deleteFramebuffer"
    @usableFromInline static let deleteProgram: JSString = "deleteProgram"
    @usableFromInline static let deleteQuery: JSString = "deleteQuery"
    @usableFromInline static let deleteRenderbuffer: JSString = "deleteRenderbuffer"
    @usableFromInline static let deleteRow: JSString = "deleteRow"
    @usableFromInline static let deleteSampler: JSString = "deleteSampler"
    @usableFromInline static let deleteShader: JSString = "deleteShader"
    @usableFromInline static let deleteSync: JSString = "deleteSync"
    @usableFromInline static let deleteTFoot: JSString = "deleteTFoot"
    @usableFromInline static let deleteTHead: JSString = "deleteTHead"
    @usableFromInline static let deleteTexture: JSString = "deleteTexture"
    @usableFromInline static let deleteTransformFeedback: JSString = "deleteTransformFeedback"
    @usableFromInline static let deleteVertexArray: JSString = "deleteVertexArray"
    @usableFromInline static let deltaMode: JSString = "deltaMode"
    @usableFromInline static let deltaX: JSString = "deltaX"
    @usableFromInline static let deltaY: JSString = "deltaY"
    @usableFromInline static let deltaZ: JSString = "deltaZ"
    @usableFromInline static let depth: JSString = "depth"
    @usableFromInline static let depthBias: JSString = "depthBias"
    @usableFromInline static let depthBiasClamp: JSString = "depthBiasClamp"
    @usableFromInline static let depthBiasSlopeScale: JSString = "depthBiasSlopeScale"
    @usableFromInline static let depthClearValue: JSString = "depthClearValue"
    @usableFromInline static let depthCompare: JSString = "depthCompare"
    @usableFromInline static let depthFailOp: JSString = "depthFailOp"
    @usableFromInline static let depthFunc: JSString = "depthFunc"
    @usableFromInline static let depthLoadOp: JSString = "depthLoadOp"
    @usableFromInline static let depthMask: JSString = "depthMask"
    @usableFromInline static let depthOrArrayLayers: JSString = "depthOrArrayLayers"
    @usableFromInline static let depthRange: JSString = "depthRange"
    @usableFromInline static let depthReadOnly: JSString = "depthReadOnly"
    @usableFromInline static let depthStencil: JSString = "depthStencil"
    @usableFromInline static let depthStencilAttachment: JSString = "depthStencilAttachment"
    @usableFromInline static let depthStencilFormat: JSString = "depthStencilFormat"
    @usableFromInline static let depthStoreOp: JSString = "depthStoreOp"
    @usableFromInline static let depthWriteEnabled: JSString = "depthWriteEnabled"
    @usableFromInline static let description: JSString = "description"
    @usableFromInline static let designMode: JSString = "designMode"
    @usableFromInline static let desiredHeight: JSString = "desiredHeight"
    @usableFromInline static let desiredSize: JSString = "desiredSize"
    @usableFromInline static let desiredWidth: JSString = "desiredWidth"
    @usableFromInline static let destination: JSString = "destination"
    @usableFromInline static let destroy: JSString = "destroy"
    @usableFromInline static let desynchronized: JSString = "desynchronized"
    @usableFromInline static let detach: JSString = "detach"
    @usableFromInline static let detachShader: JSString = "detachShader"
    @usableFromInline static let detail: JSString = "detail"
    @usableFromInline static let detune: JSString = "detune"
    @usableFromInline static let device: JSString = "device"
    @usableFromInline static let deviceId: JSString = "deviceId"
    @usableFromInline static let devicePixelRatio: JSString = "devicePixelRatio"
    @usableFromInline static let dimension: JSString = "dimension"
    @usableFromInline static let dir: JSString = "dir"
    @usableFromInline static let dirName: JSString = "dirName"
    @usableFromInline static let direction: JSString = "direction"
    @usableFromInline static let dirxml: JSString = "dirxml"
    @usableFromInline static let disable: JSString = "disable"
    @usableFromInline static let disableNormalization: JSString = "disableNormalization"
    @usableFromInline static let disableVertexAttribArray: JSString = "disableVertexAttribArray"
    @usableFromInline static let disabled: JSString = "disabled"
    @usableFromInline static let disconnect: JSString = "disconnect"
    @usableFromInline static let dispatch: JSString = "dispatch"
    @usableFromInline static let dispatchEvent: JSString = "dispatchEvent"
    @usableFromInline static let dispatchIndirect: JSString = "dispatchIndirect"
    @usableFromInline static let displayAspectHeight: JSString = "displayAspectHeight"
    @usableFromInline static let displayAspectWidth: JSString = "displayAspectWidth"
    @usableFromInline static let displayHeight: JSString = "displayHeight"
    @usableFromInline static let displayWidth: JSString = "displayWidth"
    @usableFromInline static let distanceModel: JSString = "distanceModel"
    @usableFromInline static let doctype: JSString = "doctype"
    @usableFromInline static let document: JSString = "document"
    @usableFromInline static let documentElement: JSString = "documentElement"
    @usableFromInline static let documentURI: JSString = "documentURI"
    @usableFromInline static let domain: JSString = "domain"
    @usableFromInline static let done: JSString = "done"
    @usableFromInline static let download: JSString = "download"
    @usableFromInline static let draggable: JSString = "draggable"
    @usableFromInline static let draw: JSString = "draw"
    @usableFromInline static let drawArrays: JSString = "drawArrays"
    @usableFromInline static let drawArraysInstanced: JSString = "drawArraysInstanced"
    @usableFromInline static let drawBuffers: JSString = "drawBuffers"
    @usableFromInline static let drawElements: JSString = "drawElements"
    @usableFromInline static let drawElementsInstanced: JSString = "drawElementsInstanced"
    @usableFromInline static let drawFocusIfNeeded: JSString = "drawFocusIfNeeded"
    @usableFromInline static let drawImage: JSString = "drawImage"
    @usableFromInline static let drawIndexed: JSString = "drawIndexed"
    @usableFromInline static let drawIndexedIndirect: JSString = "drawIndexedIndirect"
    @usableFromInline static let drawIndirect: JSString = "drawIndirect"
    @usableFromInline static let drawRangeElements: JSString = "drawRangeElements"
    @usableFromInline static let drawingBufferHeight: JSString = "drawingBufferHeight"
    @usableFromInline static let drawingBufferWidth: JSString = "drawingBufferWidth"
    @usableFromInline static let dropEffect: JSString = "dropEffect"
    @usableFromInline static let dstFactor: JSString = "dstFactor"
    @usableFromInline static let duration: JSString = "duration"
    @usableFromInline static let e: JSString = "e"
    @usableFromInline static let easing: JSString = "easing"
    @usableFromInline static let echoCancellation: JSString = "echoCancellation"
    @usableFromInline static let effect: JSString = "effect"
    @usableFromInline static let effectAllowed: JSString = "effectAllowed"
    @usableFromInline static let element: JSString = "element"
    @usableFromInline static let elementFromPoint: JSString = "elementFromPoint"
    @usableFromInline static let elements: JSString = "elements"
    @usableFromInline static let elementsFromPoint: JSString = "elementsFromPoint"
    @usableFromInline static let ellipse: JSString = "ellipse"
    @usableFromInline static let emHeightAscent: JSString = "emHeightAscent"
    @usableFromInline static let emHeightDescent: JSString = "emHeightDescent"
    @usableFromInline static let embeds: JSString = "embeds"
    @usableFromInline static let enable: JSString = "enable"
    @usableFromInline static let enableVertexAttribArray: JSString = "enableVertexAttribArray"
    @usableFromInline static let enabled: JSString = "enabled"
    @usableFromInline static let enabledPlugin: JSString = "enabledPlugin"
    @usableFromInline static let encode: JSString = "encode"
    @usableFromInline static let encodeQueueSize: JSString = "encodeQueueSize"
    @usableFromInline static let encoding: JSString = "encoding"
    @usableFromInline static let enctype: JSString = "enctype"
    @usableFromInline static let end: JSString = "end"
    @usableFromInline static let endContainer: JSString = "endContainer"
    @usableFromInline static let endDelay: JSString = "endDelay"
    @usableFromInline static let endOcclusionQuery: JSString = "endOcclusionQuery"
    @usableFromInline static let endOffset: JSString = "endOffset"
    @usableFromInline static let endQuery: JSString = "endQuery"
    @usableFromInline static let endTime: JSString = "endTime"
    @usableFromInline static let endTransformFeedback: JSString = "endTransformFeedback"
    @usableFromInline static let ended: JSString = "ended"
    @usableFromInline static let endings: JSString = "endings"
    @usableFromInline static let enqueue: JSString = "enqueue"
    @usableFromInline static let enterKeyHint: JSString = "enterKeyHint"
    @usableFromInline static let entries: JSString = "entries"
    @usableFromInline static let entryPoint: JSString = "entryPoint"
    @usableFromInline static let enumerateDevices: JSString = "enumerateDevices"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let evaluate: JSString = "evaluate"
    @usableFromInline static let event: JSString = "event"
    @usableFromInline static let eventPhase: JSString = "eventPhase"
    @usableFromInline static let exact: JSString = "exact"
    @usableFromInline static let execCommand: JSString = "execCommand"
    @usableFromInline static let executeBundles: JSString = "executeBundles"
    @usableFromInline static let expired: JSString = "expired"
    @usableFromInline static let exponentialRampToValueAtTime: JSString = "exponentialRampToValueAtTime"
    @usableFromInline static let extends: JSString = "extends"
    @usableFromInline static let extensions: JSString = "extensions"
    @usableFromInline static let external: JSString = "external"
    @usableFromInline static let externalTexture: JSString = "externalTexture"
    @usableFromInline static let extractContents: JSString = "extractContents"
    @usableFromInline static let f: JSString = "f"
    @usableFromInline static let face: JSString = "face"
    @usableFromInline static let facingMode: JSString = "facingMode"
    @usableFromInline static let failIfMajorPerformanceCaveat: JSString = "failIfMajorPerformanceCaveat"
    @usableFromInline static let failOp: JSString = "failOp"
    @usableFromInline static let fastSeek: JSString = "fastSeek"
    @usableFromInline static let features: JSString = "features"
    @usableFromInline static let feedback: JSString = "feedback"
    @usableFromInline static let feedforward: JSString = "feedforward"
    @usableFromInline static let fenceSync: JSString = "fenceSync"
    @usableFromInline static let fetch: JSString = "fetch"
    @usableFromInline static let fftSize: JSString = "fftSize"
    @usableFromInline static let fgColor: JSString = "fgColor"
    @usableFromInline static let filename: JSString = "filename"
    @usableFromInline static let files: JSString = "files"
    @usableFromInline static let fill: JSString = "fill"
    @usableFromInline static let fillRect: JSString = "fillRect"
    @usableFromInline static let fillStyle: JSString = "fillStyle"
    @usableFromInline static let fillText: JSString = "fillText"
    @usableFromInline static let filter: JSString = "filter"
    @usableFromInline static let finish: JSString = "finish"
    @usableFromInline static let finished: JSString = "finished"
    @usableFromInline static let firstChild: JSString = "firstChild"
    @usableFromInline static let firstElementChild: JSString = "firstElementChild"
    @usableFromInline static let flatten: JSString = "flatten"
    @usableFromInline static let flipX: JSString = "flipX"
    @usableFromInline static let flipY: JSString = "flipY"
    @usableFromInline static let flush: JSString = "flush"
    @usableFromInline static let focus: JSString = "focus"
    @usableFromInline static let font: JSString = "font"
    @usableFromInline static let fontBoundingBoxAscent: JSString = "fontBoundingBoxAscent"
    @usableFromInline static let fontBoundingBoxDescent: JSString = "fontBoundingBoxDescent"
    @usableFromInline static let fontKerning: JSString = "fontKerning"
    @usableFromInline static let fontStretch: JSString = "fontStretch"
    @usableFromInline static let fontVariantCaps: JSString = "fontVariantCaps"
    @usableFromInline static let forceFallbackAdapter: JSString = "forceFallbackAdapter"
    @usableFromInline static let form: JSString = "form"
    @usableFromInline static let formAction: JSString = "formAction"
    @usableFromInline static let formData: JSString = "formData"
    @usableFromInline static let formEnctype: JSString = "formEnctype"
    @usableFromInline static let formMethod: JSString = "formMethod"
    @usableFromInline static let formNoValidate: JSString = "formNoValidate"
    @usableFromInline static let formTarget: JSString = "formTarget"
    @usableFromInline static let format: JSString = "format"
    @usableFromInline static let forms: JSString = "forms"
    @usableFromInline static let forward: JSString = "forward"
    @usableFromInline static let forwardX: JSString = "forwardX"
    @usableFromInline static let forwardY: JSString = "forwardY"
    @usableFromInline static let forwardZ: JSString = "forwardZ"
    @usableFromInline static let fragment: JSString = "fragment"
    @usableFromInline static let frame: JSString = "frame"
    @usableFromInline static let frameBorder: JSString = "frameBorder"
    @usableFromInline static let frameCount: JSString = "frameCount"
    @usableFromInline static let frameElement: JSString = "frameElement"
    @usableFromInline static let frameIndex: JSString = "frameIndex"
    @usableFromInline static let frameOffset: JSString = "frameOffset"
    @usableFromInline static let frameRate: JSString = "frameRate"
    @usableFromInline static let framebufferRenderbuffer: JSString = "framebufferRenderbuffer"
    @usableFromInline static let framebufferTexture2D: JSString = "framebufferTexture2D"
    @usableFromInline static let framebufferTextureLayer: JSString = "framebufferTextureLayer"
    @usableFromInline static let framerate: JSString = "framerate"
    @usableFromInline static let frames: JSString = "frames"
    @usableFromInline static let frequency: JSString = "frequency"
    @usableFromInline static let frequencyBinCount: JSString = "frequencyBinCount"
    @usableFromInline static let fromBox: JSString = "fromBox"
    @usableFromInline static let fromFloat32Array: JSString = "fromFloat32Array"
    @usableFromInline static let fromFloat64Array: JSString = "fromFloat64Array"
    @usableFromInline static let fromMatrix: JSString = "fromMatrix"
    @usableFromInline static let fromPoint: JSString = "fromPoint"
    @usableFromInline static let fromQuad: JSString = "fromQuad"
    @usableFromInline static let fromRect: JSString = "fromRect"
    @usableFromInline static let frontFace: JSString = "frontFace"
    @usableFromInline static let fullRange: JSString = "fullRange"
    @usableFromInline static let g: JSString = "g"
    @usableFromInline static let gain: JSString = "gain"
    @usableFromInline static let generateMipmap: JSString = "generateMipmap"
    @usableFromInline static let get: JSString = "get"
    @usableFromInline static let getActiveAttrib: JSString = "getActiveAttrib"
    @usableFromInline static let getActiveUniform: JSString = "getActiveUniform"
    @usableFromInline static let getActiveUniformBlockName: JSString = "getActiveUniformBlockName"
    @usableFromInline static let getActiveUniformBlockParameter: JSString = "getActiveUniformBlockParameter"
    @usableFromInline static let getActiveUniforms: JSString = "getActiveUniforms"
    @usableFromInline static let getAll: JSString = "getAll"
    @usableFromInline static let getAllResponseHeaders: JSString = "getAllResponseHeaders"
    @usableFromInline static let getAnimations: JSString = "getAnimations"
    @usableFromInline static let getAsFile: JSString = "getAsFile"
    @usableFromInline static let getAttachedShaders: JSString = "getAttachedShaders"
    @usableFromInline static let getAttribLocation: JSString = "getAttribLocation"
    @usableFromInline static let getAttribute: JSString = "getAttribute"
    @usableFromInline static let getAttributeNS: JSString = "getAttributeNS"
    @usableFromInline static let getAttributeNames: JSString = "getAttributeNames"
    @usableFromInline static let getAttributeNode: JSString = "getAttributeNode"
    @usableFromInline static let getAttributeNodeNS: JSString = "getAttributeNodeNS"
    @usableFromInline static let getAudioTracks: JSString = "getAudioTracks"
    @usableFromInline static let getBindGroupLayout: JSString = "getBindGroupLayout"
    @usableFromInline static let getBoundingClientRect: JSString = "getBoundingClientRect"
    @usableFromInline static let getBounds: JSString = "getBounds"
    @usableFromInline static let getBoxQuads: JSString = "getBoxQuads"
    @usableFromInline static let getBufferParameter: JSString = "getBufferParameter"
    @usableFromInline static let getBufferSubData: JSString = "getBufferSubData"
    @usableFromInline static let getByteFrequencyData: JSString = "getByteFrequencyData"
    @usableFromInline static let getByteTimeDomainData: JSString = "getByteTimeDomainData"
    @usableFromInline static let getCapabilities: JSString = "getCapabilities"
    @usableFromInline static let getChannelData: JSString = "getChannelData"
    @usableFromInline static let getClientRect: JSString = "getClientRect"
    @usableFromInline static let getClientRects: JSString = "getClientRects"
    @usableFromInline static let getComputedTiming: JSString = "getComputedTiming"
    @usableFromInline static let getConstraints: JSString = "getConstraints"
    @usableFromInline static let getContext: JSString = "getContext"
    @usableFromInline static let getContextAttributes: JSString = "getContextAttributes"
    @usableFromInline static let getCueById: JSString = "getCueById"
    @usableFromInline static let getCurrentTexture: JSString = "getCurrentTexture"
    @usableFromInline static let getData: JSString = "getData"
    @usableFromInline static let getElementById: JSString = "getElementById"
    @usableFromInline static let getElementsByClassName: JSString = "getElementsByClassName"
    @usableFromInline static let getElementsByName: JSString = "getElementsByName"
    @usableFromInline static let getElementsByTagName: JSString = "getElementsByTagName"
    @usableFromInline static let getElementsByTagNameNS: JSString = "getElementsByTagNameNS"
    @usableFromInline static let getError: JSString = "getError"
    @usableFromInline static let getExtension: JSString = "getExtension"
    @usableFromInline static let getFloatFrequencyData: JSString = "getFloatFrequencyData"
    @usableFromInline static let getFloatTimeDomainData: JSString = "getFloatTimeDomainData"
    @usableFromInline static let getFragDataLocation: JSString = "getFragDataLocation"
    @usableFromInline static let getFramebufferAttachmentParameter: JSString = "getFramebufferAttachmentParameter"
    @usableFromInline static let getFrequencyResponse: JSString = "getFrequencyResponse"
    @usableFromInline static let getImageData: JSString = "getImageData"
    @usableFromInline static let getIndexedParameter: JSString = "getIndexedParameter"
    @usableFromInline static let getInternalformatParameter: JSString = "getInternalformatParameter"
    @usableFromInline static let getKeyframes: JSString = "getKeyframes"
    @usableFromInline static let getLineDash: JSString = "getLineDash"
    @usableFromInline static let getMappedRange: JSString = "getMappedRange"
    @usableFromInline static let getModifierState: JSString = "getModifierState"
    @usableFromInline static let getNamedItemNS: JSString = "getNamedItemNS"
    @usableFromInline static let getOutputTimestamp: JSString = "getOutputTimestamp"
    @usableFromInline static let getParameter: JSString = "getParameter"
    @usableFromInline static let getPreferredFormat: JSString = "getPreferredFormat"
    @usableFromInline static let getProgramInfoLog: JSString = "getProgramInfoLog"
    @usableFromInline static let getProgramParameter: JSString = "getProgramParameter"
    @usableFromInline static let getQuery: JSString = "getQuery"
    @usableFromInline static let getQueryParameter: JSString = "getQueryParameter"
    @usableFromInline static let getReader: JSString = "getReader"
    @usableFromInline static let getRegistration: JSString = "getRegistration"
    @usableFromInline static let getRegistrations: JSString = "getRegistrations"
    @usableFromInline static let getRenderbufferParameter: JSString = "getRenderbufferParameter"
    @usableFromInline static let getResponseHeader: JSString = "getResponseHeader"
    @usableFromInline static let getRootNode: JSString = "getRootNode"
    @usableFromInline static let getSVGDocument: JSString = "getSVGDocument"
    @usableFromInline static let getSamplerParameter: JSString = "getSamplerParameter"
    @usableFromInline static let getSettings: JSString = "getSettings"
    @usableFromInline static let getShaderInfoLog: JSString = "getShaderInfoLog"
    @usableFromInline static let getShaderParameter: JSString = "getShaderParameter"
    @usableFromInline static let getShaderPrecisionFormat: JSString = "getShaderPrecisionFormat"
    @usableFromInline static let getShaderSource: JSString = "getShaderSource"
    @usableFromInline static let getStartDate: JSString = "getStartDate"
    @usableFromInline static let getState: JSString = "getState"
    @usableFromInline static let getSupportedConstraints: JSString = "getSupportedConstraints"
    @usableFromInline static let getSupportedExtensions: JSString = "getSupportedExtensions"
    @usableFromInline static let getSyncParameter: JSString = "getSyncParameter"
    @usableFromInline static let getTexParameter: JSString = "getTexParameter"
    @usableFromInline static let getTiming: JSString = "getTiming"
    @usableFromInline static let getTrackById: JSString = "getTrackById"
    @usableFromInline static let getTracks: JSString = "getTracks"
    @usableFromInline static let getTransform: JSString = "getTransform"
    @usableFromInline static let getTransformFeedbackVarying: JSString = "getTransformFeedbackVarying"
    @usableFromInline static let getUniform: JSString = "getUniform"
    @usableFromInline static let getUniformBlockIndex: JSString = "getUniformBlockIndex"
    @usableFromInline static let getUniformIndices: JSString = "getUniformIndices"
    @usableFromInline static let getUniformLocation: JSString = "getUniformLocation"
    @usableFromInline static let getUserMedia: JSString = "getUserMedia"
    @usableFromInline static let getVertexAttrib: JSString = "getVertexAttrib"
    @usableFromInline static let getVertexAttribOffset: JSString = "getVertexAttribOffset"
    @usableFromInline static let getVideoTracks: JSString = "getVideoTracks"
    @usableFromInline static let getWriter: JSString = "getWriter"
    @usableFromInline static let globalAlpha: JSString = "globalAlpha"
    @usableFromInline static let globalCompositeOperation: JSString = "globalCompositeOperation"
    @usableFromInline static let go: JSString = "go"
    @usableFromInline static let gpu: JSString = "gpu"
    @usableFromInline static let group: JSString = "group"
    @usableFromInline static let groupCollapsed: JSString = "groupCollapsed"
    @usableFromInline static let groupEnd: JSString = "groupEnd"
    @usableFromInline static let groupId: JSString = "groupId"
    @usableFromInline static let handled: JSString = "handled"
    @usableFromInline static let hangingBaseline: JSString = "hangingBaseline"
    @usableFromInline static let hardwareAcceleration: JSString = "hardwareAcceleration"
    @usableFromInline static let hardwareConcurrency: JSString = "hardwareConcurrency"
    @usableFromInline static let has: JSString = "has"
    @usableFromInline static let hasAttribute: JSString = "hasAttribute"
    @usableFromInline static let hasAttributeNS: JSString = "hasAttributeNS"
    @usableFromInline static let hasAttributes: JSString = "hasAttributes"
    @usableFromInline static let hasChildNodes: JSString = "hasChildNodes"
    @usableFromInline static let hasDynamicOffset: JSString = "hasDynamicOffset"
    @usableFromInline static let hasFeature: JSString = "hasFeature"
    @usableFromInline static let hasFocus: JSString = "hasFocus"
    @usableFromInline static let hash: JSString = "hash"
    @usableFromInline static let head: JSString = "head"
    @usableFromInline static let headerValue: JSString = "headerValue"
    @usableFromInline static let headers: JSString = "headers"
    @usableFromInline static let height: JSString = "height"
    @usableFromInline static let hidden: JSString = "hidden"
    @usableFromInline static let high: JSString = "high"
    @usableFromInline static let highWaterMark: JSString = "highWaterMark"
    @usableFromInline static let hint: JSString = "hint"
    @usableFromInline static let hints: JSString = "hints"
    @usableFromInline static let history: JSString = "history"
    @usableFromInline static let host: JSString = "host"
    @usableFromInline static let hostname: JSString = "hostname"
    @usableFromInline static let href: JSString = "href"
    @usableFromInline static let hreflang: JSString = "hreflang"
    @usableFromInline static let hspace: JSString = "hspace"
    @usableFromInline static let htmlFor: JSString = "htmlFor"
    @usableFromInline static let httpEquiv: JSString = "httpEquiv"
    @usableFromInline static let id: JSString = "id"
    @usableFromInline static let ideal: JSString = "ideal"
    @usableFromInline static let ideographicBaseline: JSString = "ideographicBaseline"
    @usableFromInline static let ignoreMethod: JSString = "ignoreMethod"
    @usableFromInline static let ignoreSearch: JSString = "ignoreSearch"
    @usableFromInline static let ignoreVary: JSString = "ignoreVary"
    @usableFromInline static let imag: JSString = "imag"
    @usableFromInline static let image: JSString = "image"
    @usableFromInline static let imageOrientation: JSString = "imageOrientation"
    @usableFromInline static let imageSizes: JSString = "imageSizes"
    @usableFromInline static let imageSmoothingEnabled: JSString = "imageSmoothingEnabled"
    @usableFromInline static let imageSmoothingQuality: JSString = "imageSmoothingQuality"
    @usableFromInline static let imageSrcset: JSString = "imageSrcset"
    @usableFromInline static let images: JSString = "images"
    @usableFromInline static let implementation: JSString = "implementation"
    @usableFromInline static let importExternalTexture: JSString = "importExternalTexture"
    @usableFromInline static let importNode: JSString = "importNode"
    @usableFromInline static let importStylesheet: JSString = "importStylesheet"
    @usableFromInline static let inBandMetadataTrackDispatchType: JSString = "inBandMetadataTrackDispatchType"
    @usableFromInline static let includeUncontrolled: JSString = "includeUncontrolled"
    @usableFromInline static let indeterminate: JSString = "indeterminate"
    @usableFromInline static let index: JSString = "index"
    @usableFromInline static let inert: JSString = "inert"
    @usableFromInline static let info: JSString = "info"
    @usableFromInline static let initCompositionEvent: JSString = "initCompositionEvent"
    @usableFromInline static let initCustomEvent: JSString = "initCustomEvent"
    @usableFromInline static let initEvent: JSString = "initEvent"
    @usableFromInline static let initKeyboardEvent: JSString = "initKeyboardEvent"
    @usableFromInline static let initMessageEvent: JSString = "initMessageEvent"
    @usableFromInline static let initMouseEvent: JSString = "initMouseEvent"
    @usableFromInline static let initMutationEvent: JSString = "initMutationEvent"
    @usableFromInline static let initStorageEvent: JSString = "initStorageEvent"
    @usableFromInline static let initUIEvent: JSString = "initUIEvent"
    @usableFromInline static let inline: JSString = "inline"
    @usableFromInline static let innerHeight: JSString = "innerHeight"
    @usableFromInline static let innerText: JSString = "innerText"
    @usableFromInline static let innerWidth: JSString = "innerWidth"
    @usableFromInline static let inputBuffer: JSString = "inputBuffer"
    @usableFromInline static let inputEncoding: JSString = "inputEncoding"
    @usableFromInline static let inputMode: JSString = "inputMode"
    @usableFromInline static let inputType: JSString = "inputType"
    @usableFromInline static let insertAdjacentElement: JSString = "insertAdjacentElement"
    @usableFromInline static let insertAdjacentText: JSString = "insertAdjacentText"
    @usableFromInline static let insertBefore: JSString = "insertBefore"
    @usableFromInline static let insertCell: JSString = "insertCell"
    @usableFromInline static let insertData: JSString = "insertData"
    @usableFromInline static let insertDebugMarker: JSString = "insertDebugMarker"
    @usableFromInline static let insertNode: JSString = "insertNode"
    @usableFromInline static let insertRow: JSString = "insertRow"
    @usableFromInline static let installing: JSString = "installing"
    @usableFromInline static let integrity: JSString = "integrity"
    @usableFromInline static let intersectsNode: JSString = "intersectsNode"
    @usableFromInline static let invalidIteratorState: JSString = "invalidIteratorState"
    @usableFromInline static let invalidateFramebuffer: JSString = "invalidateFramebuffer"
    @usableFromInline static let invalidateSubFramebuffer: JSString = "invalidateSubFramebuffer"
    @usableFromInline static let inverse: JSString = "inverse"
    @usableFromInline static let invertSelf: JSString = "invertSelf"
    @usableFromInline static let `is`: JSString = "is"
    @usableFromInline static let is2D: JSString = "is2D"
    @usableFromInline static let isBuffer: JSString = "isBuffer"
    @usableFromInline static let isComposing: JSString = "isComposing"
    @usableFromInline static let isConfigSupported: JSString = "isConfigSupported"
    @usableFromInline static let isConnected: JSString = "isConnected"
    @usableFromInline static let isContentEditable: JSString = "isContentEditable"
    @usableFromInline static let isContextLost: JSString = "isContextLost"
    @usableFromInline static let isDefaultNamespace: JSString = "isDefaultNamespace"
    @usableFromInline static let isEnabled: JSString = "isEnabled"
    @usableFromInline static let isEqualNode: JSString = "isEqualNode"
    @usableFromInline static let isFallbackAdapter: JSString = "isFallbackAdapter"
    @usableFromInline static let isFramebuffer: JSString = "isFramebuffer"
    @usableFromInline static let isHistoryNavigation: JSString = "isHistoryNavigation"
    @usableFromInline static let isIdentity: JSString = "isIdentity"
    @usableFromInline static let isMap: JSString = "isMap"
    @usableFromInline static let isPointInPath: JSString = "isPointInPath"
    @usableFromInline static let isPointInRange: JSString = "isPointInRange"
    @usableFromInline static let isPointInStroke: JSString = "isPointInStroke"
    @usableFromInline static let isProgram: JSString = "isProgram"
    @usableFromInline static let isQuery: JSString = "isQuery"
    @usableFromInline static let isReloadNavigation: JSString = "isReloadNavigation"
    @usableFromInline static let isRenderbuffer: JSString = "isRenderbuffer"
    @usableFromInline static let isSameNode: JSString = "isSameNode"
    @usableFromInline static let isSampler: JSString = "isSampler"
    @usableFromInline static let isSecureContext: JSString = "isSecureContext"
    @usableFromInline static let isShader: JSString = "isShader"
    @usableFromInline static let isSync: JSString = "isSync"
    @usableFromInline static let isTexture: JSString = "isTexture"
    @usableFromInline static let isTransformFeedback: JSString = "isTransformFeedback"
    @usableFromInline static let isTrusted: JSString = "isTrusted"
    @usableFromInline static let isTypeSupported: JSString = "isTypeSupported"
    @usableFromInline static let isVertexArray: JSString = "isVertexArray"
    @usableFromInline static let isVisible: JSString = "isVisible"
    @usableFromInline static let item: JSString = "item"
    @usableFromInline static let items: JSString = "items"
    @usableFromInline static let iterateNext: JSString = "iterateNext"
    @usableFromInline static let iterationStart: JSString = "iterationStart"
    @usableFromInline static let iterations: JSString = "iterations"
    @usableFromInline static let javaEnabled: JSString = "javaEnabled"
    @usableFromInline static let json: JSString = "json"
    @usableFromInline static let keepalive: JSString = "keepalive"
    @usableFromInline static let key: JSString = "key"
    @usableFromInline static let keyCode: JSString = "keyCode"
    @usableFromInline static let keyFrame: JSString = "keyFrame"
    @usableFromInline static let keys: JSString = "keys"
    @usableFromInline static let kind: JSString = "kind"
    @usableFromInline static let knee: JSString = "knee"
    @usableFromInline static let label: JSString = "label"
    @usableFromInline static let labels: JSString = "labels"
    @usableFromInline static let lang: JSString = "lang"
    @usableFromInline static let language: JSString = "language"
    @usableFromInline static let languages: JSString = "languages"
    @usableFromInline static let lastChild: JSString = "lastChild"
    @usableFromInline static let lastElementChild: JSString = "lastElementChild"
    @usableFromInline static let lastEventId: JSString = "lastEventId"
    @usableFromInline static let lastModified: JSString = "lastModified"
    @usableFromInline static let latency: JSString = "latency"
    @usableFromInline static let latencyHint: JSString = "latencyHint"
    @usableFromInline static let latencyMode: JSString = "latencyMode"
    @usableFromInline static let layout: JSString = "layout"
    @usableFromInline static let left: JSString = "left"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let lengthComputable: JSString = "lengthComputable"
    @usableFromInline static let letterSpacing: JSString = "letterSpacing"
    @usableFromInline static let limits: JSString = "limits"
    @usableFromInline static let lineCap: JSString = "lineCap"
    @usableFromInline static let lineDashOffset: JSString = "lineDashOffset"
    @usableFromInline static let lineJoin: JSString = "lineJoin"
    @usableFromInline static let lineNum: JSString = "lineNum"
    @usableFromInline static let linePos: JSString = "linePos"
    @usableFromInline static let lineTo: JSString = "lineTo"
    @usableFromInline static let lineWidth: JSString = "lineWidth"
    @usableFromInline static let linearRampToValueAtTime: JSString = "linearRampToValueAtTime"
    @usableFromInline static let lineno: JSString = "lineno"
    @usableFromInline static let link: JSString = "link"
    @usableFromInline static let linkColor: JSString = "linkColor"
    @usableFromInline static let linkProgram: JSString = "linkProgram"
    @usableFromInline static let links: JSString = "links"
    @usableFromInline static let list: JSString = "list"
    @usableFromInline static let listener: JSString = "listener"
    @usableFromInline static let load: JSString = "load"
    @usableFromInline static let loadOp: JSString = "loadOp"
    @usableFromInline static let loaded: JSString = "loaded"
    @usableFromInline static let loading: JSString = "loading"
    @usableFromInline static let localName: JSString = "localName"
    @usableFromInline static let localStorage: JSString = "localStorage"
    @usableFromInline static let location: JSString = "location"
    @usableFromInline static let locationbar: JSString = "locationbar"
    @usableFromInline static let locked: JSString = "locked"
    @usableFromInline static let lodMaxClamp: JSString = "lodMaxClamp"
    @usableFromInline static let lodMinClamp: JSString = "lodMinClamp"
    @usableFromInline static let log: JSString = "log"
    @usableFromInline static let longDesc: JSString = "longDesc"
    @usableFromInline static let lookupNamespaceURI: JSString = "lookupNamespaceURI"
    @usableFromInline static let lookupPrefix: JSString = "lookupPrefix"
    @usableFromInline static let loop: JSString = "loop"
    @usableFromInline static let loopEnd: JSString = "loopEnd"
    @usableFromInline static let loopStart: JSString = "loopStart"
    @usableFromInline static let lost: JSString = "lost"
    @usableFromInline static let low: JSString = "low"
    @usableFromInline static let lowsrc: JSString = "lowsrc"
    @usableFromInline static let m11: JSString = "m11"
    @usableFromInline static let m12: JSString = "m12"
    @usableFromInline static let m13: JSString = "m13"
    @usableFromInline static let m14: JSString = "m14"
    @usableFromInline static let m21: JSString = "m21"
    @usableFromInline static let m22: JSString = "m22"
    @usableFromInline static let m23: JSString = "m23"
    @usableFromInline static let m24: JSString = "m24"
    @usableFromInline static let m31: JSString = "m31"
    @usableFromInline static let m32: JSString = "m32"
    @usableFromInline static let m33: JSString = "m33"
    @usableFromInline static let m34: JSString = "m34"
    @usableFromInline static let m41: JSString = "m41"
    @usableFromInline static let m42: JSString = "m42"
    @usableFromInline static let m43: JSString = "m43"
    @usableFromInline static let m44: JSString = "m44"
    @usableFromInline static let magFilter: JSString = "magFilter"
    @usableFromInline static let mapAsync: JSString = "mapAsync"
    @usableFromInline static let mappedAtCreation: JSString = "mappedAtCreation"
    @usableFromInline static let marginHeight: JSString = "marginHeight"
    @usableFromInline static let marginWidth: JSString = "marginWidth"
    @usableFromInline static let mask: JSString = "mask"
    @usableFromInline static let match: JSString = "match"
    @usableFromInline static let matchAll: JSString = "matchAll"
    @usableFromInline static let matchMedia: JSString = "matchMedia"
    @usableFromInline static let matches: JSString = "matches"
    @usableFromInline static let matrix: JSString = "matrix"
    @usableFromInline static let matrixTransform: JSString = "matrixTransform"
    @usableFromInline static let max: JSString = "max"
    @usableFromInline static let maxAnisotropy: JSString = "maxAnisotropy"
    @usableFromInline static let maxBindGroups: JSString = "maxBindGroups"
    @usableFromInline static let maxChannelCount: JSString = "maxChannelCount"
    @usableFromInline static let maxComputeInvocationsPerWorkgroup: JSString = "maxComputeInvocationsPerWorkgroup"
    @usableFromInline static let maxComputeWorkgroupSizeX: JSString = "maxComputeWorkgroupSizeX"
    @usableFromInline static let maxComputeWorkgroupSizeY: JSString = "maxComputeWorkgroupSizeY"
    @usableFromInline static let maxComputeWorkgroupSizeZ: JSString = "maxComputeWorkgroupSizeZ"
    @usableFromInline static let maxComputeWorkgroupStorageSize: JSString = "maxComputeWorkgroupStorageSize"
    @usableFromInline static let maxComputeWorkgroupsPerDimension: JSString = "maxComputeWorkgroupsPerDimension"
    @usableFromInline static let maxDecibels: JSString = "maxDecibels"
    @usableFromInline static let maxDelayTime: JSString = "maxDelayTime"
    @usableFromInline static let maxDistance: JSString = "maxDistance"
    @usableFromInline static let maxDynamicStorageBuffersPerPipelineLayout: JSString = "maxDynamicStorageBuffersPerPipelineLayout"
    @usableFromInline static let maxDynamicUniformBuffersPerPipelineLayout: JSString = "maxDynamicUniformBuffersPerPipelineLayout"
    @usableFromInline static let maxInterStageShaderComponents: JSString = "maxInterStageShaderComponents"
    @usableFromInline static let maxLength: JSString = "maxLength"
    @usableFromInline static let maxSampledTexturesPerShaderStage: JSString = "maxSampledTexturesPerShaderStage"
    @usableFromInline static let maxSamplersPerShaderStage: JSString = "maxSamplersPerShaderStage"
    @usableFromInline static let maxStorageBufferBindingSize: JSString = "maxStorageBufferBindingSize"
    @usableFromInline static let maxStorageBuffersPerShaderStage: JSString = "maxStorageBuffersPerShaderStage"
    @usableFromInline static let maxStorageTexturesPerShaderStage: JSString = "maxStorageTexturesPerShaderStage"
    @usableFromInline static let maxTextureArrayLayers: JSString = "maxTextureArrayLayers"
    @usableFromInline static let maxTextureDimension1D: JSString = "maxTextureDimension1D"
    @usableFromInline static let maxTextureDimension2D: JSString = "maxTextureDimension2D"
    @usableFromInline static let maxTextureDimension3D: JSString = "maxTextureDimension3D"
    @usableFromInline static let maxUniformBufferBindingSize: JSString = "maxUniformBufferBindingSize"
    @usableFromInline static let maxUniformBuffersPerShaderStage: JSString = "maxUniformBuffersPerShaderStage"
    @usableFromInline static let maxValue: JSString = "maxValue"
    @usableFromInline static let maxVertexAttributes: JSString = "maxVertexAttributes"
    @usableFromInline static let maxVertexBufferArrayStride: JSString = "maxVertexBufferArrayStride"
    @usableFromInline static let maxVertexBuffers: JSString = "maxVertexBuffers"
    @usableFromInline static let measureText: JSString = "measureText"
    @usableFromInline static let media: JSString = "media"
    @usableFromInline static let mediaDevices: JSString = "mediaDevices"
    @usableFromInline static let mediaElement: JSString = "mediaElement"
    @usableFromInline static let mediaStream: JSString = "mediaStream"
    @usableFromInline static let mediaStreamTrack: JSString = "mediaStreamTrack"
    @usableFromInline static let menubar: JSString = "menubar"
    @usableFromInline static let message: JSString = "message"
    @usableFromInline static let messages: JSString = "messages"
    @usableFromInline static let metaKey: JSString = "metaKey"
    @usableFromInline static let method: JSString = "method"
    @usableFromInline static let mimeType: JSString = "mimeType"
    @usableFromInline static let mimeTypes: JSString = "mimeTypes"
    @usableFromInline static let min: JSString = "min"
    @usableFromInline static let minBindingSize: JSString = "minBindingSize"
    @usableFromInline static let minDecibels: JSString = "minDecibels"
    @usableFromInline static let minFilter: JSString = "minFilter"
    @usableFromInline static let minLength: JSString = "minLength"
    @usableFromInline static let minStorageBufferOffsetAlignment: JSString = "minStorageBufferOffsetAlignment"
    @usableFromInline static let minUniformBufferOffsetAlignment: JSString = "minUniformBufferOffsetAlignment"
    @usableFromInline static let minValue: JSString = "minValue"
    @usableFromInline static let mipLevel: JSString = "mipLevel"
    @usableFromInline static let mipLevelCount: JSString = "mipLevelCount"
    @usableFromInline static let mipmapFilter: JSString = "mipmapFilter"
    @usableFromInline static let miterLimit: JSString = "miterLimit"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let modifierAltGraph: JSString = "modifierAltGraph"
    @usableFromInline static let modifierCapsLock: JSString = "modifierCapsLock"
    @usableFromInline static let modifierFn: JSString = "modifierFn"
    @usableFromInline static let modifierFnLock: JSString = "modifierFnLock"
    @usableFromInline static let modifierHyper: JSString = "modifierHyper"
    @usableFromInline static let modifierNumLock: JSString = "modifierNumLock"
    @usableFromInline static let modifierScrollLock: JSString = "modifierScrollLock"
    @usableFromInline static let modifierSuper: JSString = "modifierSuper"
    @usableFromInline static let modifierSymbol: JSString = "modifierSymbol"
    @usableFromInline static let modifierSymbolLock: JSString = "modifierSymbolLock"
    @usableFromInline static let module: JSString = "module"
    @usableFromInline static let moveBy: JSString = "moveBy"
    @usableFromInline static let moveTo: JSString = "moveTo"
    @usableFromInline static let multiple: JSString = "multiple"
    @usableFromInline static let multiply: JSString = "multiply"
    @usableFromInline static let multiplySelf: JSString = "multiplySelf"
    @usableFromInline static let multisample: JSString = "multisample"
    @usableFromInline static let multisampled: JSString = "multisampled"
    @usableFromInline static let muted: JSString = "muted"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let namedItem: JSString = "namedItem"
    @usableFromInline static let namespaceURI: JSString = "namespaceURI"
    @usableFromInline static let naturalHeight: JSString = "naturalHeight"
    @usableFromInline static let naturalWidth: JSString = "naturalWidth"
    @usableFromInline static let navigationPreload: JSString = "navigationPreload"
    @usableFromInline static let navigator: JSString = "navigator"
    @usableFromInline static let networkState: JSString = "networkState"
    @usableFromInline static let newURL: JSString = "newURL"
    @usableFromInline static let newValue: JSString = "newValue"
    @usableFromInline static let nextElementSibling: JSString = "nextElementSibling"
    @usableFromInline static let nextNode: JSString = "nextNode"
    @usableFromInline static let nextSibling: JSString = "nextSibling"
    @usableFromInline static let noHref: JSString = "noHref"
    @usableFromInline static let noModule: JSString = "noModule"
    @usableFromInline static let noResize: JSString = "noResize"
    @usableFromInline static let noShade: JSString = "noShade"
    @usableFromInline static let noValidate: JSString = "noValidate"
    @usableFromInline static let noWrap: JSString = "noWrap"
    @usableFromInline static let nodeName: JSString = "nodeName"
    @usableFromInline static let nodeType: JSString = "nodeType"
    @usableFromInline static let nodeValue: JSString = "nodeValue"
    @usableFromInline static let noiseSuppression: JSString = "noiseSuppression"
    @usableFromInline static let nonce: JSString = "nonce"
    @usableFromInline static let normalize: JSString = "normalize"
    @usableFromInline static let now: JSString = "now"
    @usableFromInline static let numberOfChannels: JSString = "numberOfChannels"
    @usableFromInline static let numberOfFrames: JSString = "numberOfFrames"
    @usableFromInline static let numberOfInputs: JSString = "numberOfInputs"
    @usableFromInline static let numberOfOutputs: JSString = "numberOfOutputs"
    @usableFromInline static let numberValue: JSString = "numberValue"
    @usableFromInline static let observe: JSString = "observe"
    @usableFromInline static let occlusionQuerySet: JSString = "occlusionQuerySet"
    @usableFromInline static let offset: JSString = "offset"
    @usableFromInline static let offsetHeight: JSString = "offsetHeight"
    @usableFromInline static let offsetLeft: JSString = "offsetLeft"
    @usableFromInline static let offsetNode: JSString = "offsetNode"
    @usableFromInline static let offsetParent: JSString = "offsetParent"
    @usableFromInline static let offsetTop: JSString = "offsetTop"
    @usableFromInline static let offsetWidth: JSString = "offsetWidth"
    @usableFromInline static let offsetX: JSString = "offsetX"
    @usableFromInline static let offsetY: JSString = "offsetY"
    @usableFromInline static let ok: JSString = "ok"
    @usableFromInline static let oldURL: JSString = "oldURL"
    @usableFromInline static let oldValue: JSString = "oldValue"
    @usableFromInline static let onLine: JSString = "onLine"
    @usableFromInline static let onSubmittedWorkDone: JSString = "onSubmittedWorkDone"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let onaddtrack: JSString = "onaddtrack"
    @usableFromInline static let onafterprint: JSString = "onafterprint"
    @usableFromInline static let onaudioprocess: JSString = "onaudioprocess"
    @usableFromInline static let onauxclick: JSString = "onauxclick"
    @usableFromInline static let onbeforeprint: JSString = "onbeforeprint"
    @usableFromInline static let onbeforeunload: JSString = "onbeforeunload"
    @usableFromInline static let onblur: JSString = "onblur"
    @usableFromInline static let oncancel: JSString = "oncancel"
    @usableFromInline static let oncanplay: JSString = "oncanplay"
    @usableFromInline static let oncanplaythrough: JSString = "oncanplaythrough"
    @usableFromInline static let once: JSString = "once"
    @usableFromInline static let onchange: JSString = "onchange"
    @usableFromInline static let onclick: JSString = "onclick"
    @usableFromInline static let onclose: JSString = "onclose"
    @usableFromInline static let oncomplete: JSString = "oncomplete"
    @usableFromInline static let oncontextlost: JSString = "oncontextlost"
    @usableFromInline static let oncontextmenu: JSString = "oncontextmenu"
    @usableFromInline static let oncontextrestored: JSString = "oncontextrestored"
    @usableFromInline static let oncontrollerchange: JSString = "oncontrollerchange"
    @usableFromInline static let oncopy: JSString = "oncopy"
    @usableFromInline static let oncuechange: JSString = "oncuechange"
    @usableFromInline static let oncut: JSString = "oncut"
    @usableFromInline static let ondataavailable: JSString = "ondataavailable"
    @usableFromInline static let ondblclick: JSString = "ondblclick"
    @usableFromInline static let ondevicechange: JSString = "ondevicechange"
    @usableFromInline static let ondrag: JSString = "ondrag"
    @usableFromInline static let ondragend: JSString = "ondragend"
    @usableFromInline static let ondragenter: JSString = "ondragenter"
    @usableFromInline static let ondragleave: JSString = "ondragleave"
    @usableFromInline static let ondragover: JSString = "ondragover"
    @usableFromInline static let ondragstart: JSString = "ondragstart"
    @usableFromInline static let ondrop: JSString = "ondrop"
    @usableFromInline static let ondurationchange: JSString = "ondurationchange"
    @usableFromInline static let onemptied: JSString = "onemptied"
    @usableFromInline static let onended: JSString = "onended"
    @usableFromInline static let onenter: JSString = "onenter"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onexit: JSString = "onexit"
    @usableFromInline static let onfinish: JSString = "onfinish"
    @usableFromInline static let onfocus: JSString = "onfocus"
    @usableFromInline static let onformdata: JSString = "onformdata"
    @usableFromInline static let onhashchange: JSString = "onhashchange"
    @usableFromInline static let oninput: JSString = "oninput"
    @usableFromInline static let oninvalid: JSString = "oninvalid"
    @usableFromInline static let onkeydown: JSString = "onkeydown"
    @usableFromInline static let onkeypress: JSString = "onkeypress"
    @usableFromInline static let onkeyup: JSString = "onkeyup"
    @usableFromInline static let onlanguagechange: JSString = "onlanguagechange"
    @usableFromInline static let onload: JSString = "onload"
    @usableFromInline static let onloadeddata: JSString = "onloadeddata"
    @usableFromInline static let onloadedmetadata: JSString = "onloadedmetadata"
    @usableFromInline static let onloadend: JSString = "onloadend"
    @usableFromInline static let onloadstart: JSString = "onloadstart"
    @usableFromInline static let onmessage: JSString = "onmessage"
    @usableFromInline static let onmessageerror: JSString = "onmessageerror"
    @usableFromInline static let onmousedown: JSString = "onmousedown"
    @usableFromInline static let onmouseenter: JSString = "onmouseenter"
    @usableFromInline static let onmouseleave: JSString = "onmouseleave"
    @usableFromInline static let onmousemove: JSString = "onmousemove"
    @usableFromInline static let onmouseout: JSString = "onmouseout"
    @usableFromInline static let onmouseover: JSString = "onmouseover"
    @usableFromInline static let onmouseup: JSString = "onmouseup"
    @usableFromInline static let onmute: JSString = "onmute"
    @usableFromInline static let onoffline: JSString = "onoffline"
    @usableFromInline static let ononline: JSString = "ononline"
    @usableFromInline static let onopen: JSString = "onopen"
    @usableFromInline static let onpagehide: JSString = "onpagehide"
    @usableFromInline static let onpageshow: JSString = "onpageshow"
    @usableFromInline static let onpaste: JSString = "onpaste"
    @usableFromInline static let onpause: JSString = "onpause"
    @usableFromInline static let onplay: JSString = "onplay"
    @usableFromInline static let onplaying: JSString = "onplaying"
    @usableFromInline static let onpopstate: JSString = "onpopstate"
    @usableFromInline static let onprocessorerror: JSString = "onprocessorerror"
    @usableFromInline static let onprogress: JSString = "onprogress"
    @usableFromInline static let onratechange: JSString = "onratechange"
    @usableFromInline static let onreadystatechange: JSString = "onreadystatechange"
    @usableFromInline static let onrejectionhandled: JSString = "onrejectionhandled"
    @usableFromInline static let onremove: JSString = "onremove"
    @usableFromInline static let onremovetrack: JSString = "onremovetrack"
    @usableFromInline static let onreset: JSString = "onreset"
    @usableFromInline static let onresize: JSString = "onresize"
    @usableFromInline static let onresume: JSString = "onresume"
    @usableFromInline static let onscroll: JSString = "onscroll"
    @usableFromInline static let onsecuritypolicyviolation: JSString = "onsecuritypolicyviolation"
    @usableFromInline static let onseeked: JSString = "onseeked"
    @usableFromInline static let onseeking: JSString = "onseeking"
    @usableFromInline static let onselect: JSString = "onselect"
    @usableFromInline static let onslotchange: JSString = "onslotchange"
    @usableFromInline static let onstalled: JSString = "onstalled"
    @usableFromInline static let onstart: JSString = "onstart"
    @usableFromInline static let onstatechange: JSString = "onstatechange"
    @usableFromInline static let onstop: JSString = "onstop"
    @usableFromInline static let onstorage: JSString = "onstorage"
    @usableFromInline static let onsubmit: JSString = "onsubmit"
    @usableFromInline static let onsuspend: JSString = "onsuspend"
    @usableFromInline static let ontimeout: JSString = "ontimeout"
    @usableFromInline static let ontimeupdate: JSString = "ontimeupdate"
    @usableFromInline static let ontoggle: JSString = "ontoggle"
    @usableFromInline static let onuncapturederror: JSString = "onuncapturederror"
    @usableFromInline static let onunhandledrejection: JSString = "onunhandledrejection"
    @usableFromInline static let onunload: JSString = "onunload"
    @usableFromInline static let onunmute: JSString = "onunmute"
    @usableFromInline static let onupdatefound: JSString = "onupdatefound"
    @usableFromInline static let onvisibilitychange: JSString = "onvisibilitychange"
    @usableFromInline static let onvolumechange: JSString = "onvolumechange"
    @usableFromInline static let onwaiting: JSString = "onwaiting"
    @usableFromInline static let onwebkitanimationend: JSString = "onwebkitanimationend"
    @usableFromInline static let onwebkitanimationiteration: JSString = "onwebkitanimationiteration"
    @usableFromInline static let onwebkitanimationstart: JSString = "onwebkitanimationstart"
    @usableFromInline static let onwebkittransitionend: JSString = "onwebkittransitionend"
    @usableFromInline static let onwheel: JSString = "onwheel"
    @usableFromInline static let open: JSString = "open"
    @usableFromInline static let opener: JSString = "opener"
    @usableFromInline static let operation: JSString = "operation"
    @usableFromInline static let optimizeForLatency: JSString = "optimizeForLatency"
    @usableFromInline static let optimum: JSString = "optimum"
    @usableFromInline static let options: JSString = "options"
    @usableFromInline static let orientationX: JSString = "orientationX"
    @usableFromInline static let orientationY: JSString = "orientationY"
    @usableFromInline static let orientationZ: JSString = "orientationZ"
    @usableFromInline static let origin: JSString = "origin"
    @usableFromInline static let originAgentCluster: JSString = "originAgentCluster"
    @usableFromInline static let originTime: JSString = "originTime"
    @usableFromInline static let oscpu: JSString = "oscpu"
    @usableFromInline static let outerHeight: JSString = "outerHeight"
    @usableFromInline static let outerText: JSString = "outerText"
    @usableFromInline static let outerWidth: JSString = "outerWidth"
    @usableFromInline static let output: JSString = "output"
    @usableFromInline static let outputBuffer: JSString = "outputBuffer"
    @usableFromInline static let outputChannelCount: JSString = "outputChannelCount"
    @usableFromInline static let outputLatency: JSString = "outputLatency"
    @usableFromInline static let overrideMimeType: JSString = "overrideMimeType"
    @usableFromInline static let oversample: JSString = "oversample"
    @usableFromInline static let ownerDocument: JSString = "ownerDocument"
    @usableFromInline static let ownerElement: JSString = "ownerElement"
    @usableFromInline static let p1: JSString = "p1"
    @usableFromInline static let p2: JSString = "p2"
    @usableFromInline static let p3: JSString = "p3"
    @usableFromInline static let p4: JSString = "p4"
    @usableFromInline static let pageX: JSString = "pageX"
    @usableFromInline static let pageXOffset: JSString = "pageXOffset"
    @usableFromInline static let pageY: JSString = "pageY"
    @usableFromInline static let pageYOffset: JSString = "pageYOffset"
    @usableFromInline static let pan: JSString = "pan"
    @usableFromInline static let panTiltZoom: JSString = "panTiltZoom"
    @usableFromInline static let panningModel: JSString = "panningModel"
    @usableFromInline static let parameterData: JSString = "parameterData"
    @usableFromInline static let parameters: JSString = "parameters"
    @usableFromInline static let parent: JSString = "parent"
    @usableFromInline static let parentElement: JSString = "parentElement"
    @usableFromInline static let parentNode: JSString = "parentNode"
    @usableFromInline static let parseFromString: JSString = "parseFromString"
    @usableFromInline static let passOp: JSString = "passOp"
    @usableFromInline static let passive: JSString = "passive"
    @usableFromInline static let password: JSString = "password"
    @usableFromInline static let pathname: JSString = "pathname"
    @usableFromInline static let pattern: JSString = "pattern"
    @usableFromInline static let patternMismatch: JSString = "patternMismatch"
    @usableFromInline static let pause: JSString = "pause"
    @usableFromInline static let pauseOnExit: JSString = "pauseOnExit"
    @usableFromInline static let pauseTransformFeedback: JSString = "pauseTransformFeedback"
    @usableFromInline static let paused: JSString = "paused"
    @usableFromInline static let pdfViewerEnabled: JSString = "pdfViewerEnabled"
    @usableFromInline static let pending: JSString = "pending"
    @usableFromInline static let performance: JSString = "performance"
    @usableFromInline static let performanceTime: JSString = "performanceTime"
    @usableFromInline static let periodicWave: JSString = "periodicWave"
    @usableFromInline static let persist: JSString = "persist"
    @usableFromInline static let persisted: JSString = "persisted"
    @usableFromInline static let personalbar: JSString = "personalbar"
    @usableFromInline static let phase: JSString = "phase"
    @usableFromInline static let ping: JSString = "ping"
    @usableFromInline static let pipeThrough: JSString = "pipeThrough"
    @usableFromInline static let pipeTo: JSString = "pipeTo"
    @usableFromInline static let pixelDepth: JSString = "pixelDepth"
    @usableFromInline static let pixelStorei: JSString = "pixelStorei"
    @usableFromInline static let placeholder: JSString = "placeholder"
    @usableFromInline static let planeIndex: JSString = "planeIndex"
    @usableFromInline static let platform: JSString = "platform"
    @usableFromInline static let play: JSString = "play"
    @usableFromInline static let playState: JSString = "playState"
    @usableFromInline static let playbackRate: JSString = "playbackRate"
    @usableFromInline static let playbackTime: JSString = "playbackTime"
    @usableFromInline static let played: JSString = "played"
    @usableFromInline static let playsInline: JSString = "playsInline"
    @usableFromInline static let plugins: JSString = "plugins"
    @usableFromInline static let pointerBeforeReferenceNode: JSString = "pointerBeforeReferenceNode"
    @usableFromInline static let polygonOffset: JSString = "polygonOffset"
    @usableFromInline static let popDebugGroup: JSString = "popDebugGroup"
    @usableFromInline static let popErrorScope: JSString = "popErrorScope"
    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let port1: JSString = "port1"
    @usableFromInline static let port2: JSString = "port2"
    @usableFromInline static let ports: JSString = "ports"
    @usableFromInline static let position: JSString = "position"
    @usableFromInline static let positionX: JSString = "positionX"
    @usableFromInline static let positionY: JSString = "positionY"
    @usableFromInline static let positionZ: JSString = "positionZ"
    @usableFromInline static let postMessage: JSString = "postMessage"
    @usableFromInline static let poster: JSString = "poster"
    @usableFromInline static let powerPreference: JSString = "powerPreference"
    @usableFromInline static let preMultiplySelf: JSString = "preMultiplySelf"
    @usableFromInline static let precision: JSString = "precision"
    @usableFromInline static let preferAnimation: JSString = "preferAnimation"
    @usableFromInline static let prefix: JSString = "prefix"
    @usableFromInline static let preload: JSString = "preload"
    @usableFromInline static let preloadResponse: JSString = "preloadResponse"
    @usableFromInline static let premultipliedAlpha: JSString = "premultipliedAlpha"
    @usableFromInline static let premultiplyAlpha: JSString = "premultiplyAlpha"
    @usableFromInline static let prepend: JSString = "prepend"
    @usableFromInline static let preserveDrawingBuffer: JSString = "preserveDrawingBuffer"
    @usableFromInline static let preservesPitch: JSString = "preservesPitch"
    @usableFromInline static let prevValue: JSString = "prevValue"
    @usableFromInline static let preventAbort: JSString = "preventAbort"
    @usableFromInline static let preventCancel: JSString = "preventCancel"
    @usableFromInline static let preventClose: JSString = "preventClose"
    @usableFromInline static let preventDefault: JSString = "preventDefault"
    @usableFromInline static let preventScroll: JSString = "preventScroll"
    @usableFromInline static let previousElementSibling: JSString = "previousElementSibling"
    @usableFromInline static let previousNode: JSString = "previousNode"
    @usableFromInline static let previousSibling: JSString = "previousSibling"
    @usableFromInline static let primaries: JSString = "primaries"
    @usableFromInline static let primitive: JSString = "primitive"
    @usableFromInline static let print: JSString = "print"
    @usableFromInline static let processorOptions: JSString = "processorOptions"
    @usableFromInline static let product: JSString = "product"
    @usableFromInline static let productSub: JSString = "productSub"
    @usableFromInline static let progress: JSString = "progress"
    @usableFromInline static let promise: JSString = "promise"
    @usableFromInline static let prompt: JSString = "prompt"
    @usableFromInline static let `protocol`: JSString = "protocol"
    @usableFromInline static let pseudo: JSString = "pseudo"
    @usableFromInline static let pseudoElement: JSString = "pseudoElement"
    @usableFromInline static let publicId: JSString = "publicId"
    @usableFromInline static let pull: JSString = "pull"
    @usableFromInline static let pushDebugGroup: JSString = "pushDebugGroup"
    @usableFromInline static let pushErrorScope: JSString = "pushErrorScope"
    @usableFromInline static let pushState: JSString = "pushState"
    @usableFromInline static let put: JSString = "put"
    @usableFromInline static let putImageData: JSString = "putImageData"
    @usableFromInline static let quadraticCurveTo: JSString = "quadraticCurveTo"
    @usableFromInline static let quality: JSString = "quality"
    @usableFromInline static let queryCommandEnabled: JSString = "queryCommandEnabled"
    @usableFromInline static let queryCommandIndeterm: JSString = "queryCommandIndeterm"
    @usableFromInline static let queryCommandState: JSString = "queryCommandState"
    @usableFromInline static let queryCommandSupported: JSString = "queryCommandSupported"
    @usableFromInline static let queryCommandValue: JSString = "queryCommandValue"
    @usableFromInline static let queryIndex: JSString = "queryIndex"
    @usableFromInline static let querySelector: JSString = "querySelector"
    @usableFromInline static let querySelectorAll: JSString = "querySelectorAll"
    @usableFromInline static let querySet: JSString = "querySet"
    @usableFromInline static let queue: JSString = "queue"
    @usableFromInline static let r: JSString = "r"
    @usableFromInline static let rangeMax: JSString = "rangeMax"
    @usableFromInline static let rangeMin: JSString = "rangeMin"
    @usableFromInline static let rangeOverflow: JSString = "rangeOverflow"
    @usableFromInline static let rangeUnderflow: JSString = "rangeUnderflow"
    @usableFromInline static let ratio: JSString = "ratio"
    @usableFromInline static let read: JSString = "read"
    @usableFromInline static let readAsArrayBuffer: JSString = "readAsArrayBuffer"
    @usableFromInline static let readAsBinaryString: JSString = "readAsBinaryString"
    @usableFromInline static let readAsDataURL: JSString = "readAsDataURL"
    @usableFromInline static let readAsText: JSString = "readAsText"
    @usableFromInline static let readBuffer: JSString = "readBuffer"
    @usableFromInline static let readOnly: JSString = "readOnly"
    @usableFromInline static let readPixels: JSString = "readPixels"
    @usableFromInline static let readable: JSString = "readable"
    @usableFromInline static let readableType: JSString = "readableType"
    @usableFromInline static let ready: JSString = "ready"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let real: JSString = "real"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let rect: JSString = "rect"
    @usableFromInline static let redirect: JSString = "redirect"
    @usableFromInline static let redirected: JSString = "redirected"
    @usableFromInline static let reduction: JSString = "reduction"
    @usableFromInline static let refDistance: JSString = "refDistance"
    @usableFromInline static let referenceNode: JSString = "referenceNode"
    @usableFromInline static let referrer: JSString = "referrer"
    @usableFromInline static let referrerPolicy: JSString = "referrerPolicy"
    @usableFromInline static let refresh: JSString = "refresh"
    @usableFromInline static let register: JSString = "register"
    @usableFromInline static let registerProtocolHandler: JSString = "registerProtocolHandler"
    @usableFromInline static let rel: JSString = "rel"
    @usableFromInline static let relList: JSString = "relList"
    @usableFromInline static let relatedNode: JSString = "relatedNode"
    @usableFromInline static let relatedTarget: JSString = "relatedTarget"
    @usableFromInline static let relativeTo: JSString = "relativeTo"
    @usableFromInline static let release: JSString = "release"
    @usableFromInline static let releaseEvents: JSString = "releaseEvents"
    @usableFromInline static let releaseLock: JSString = "releaseLock"
    @usableFromInline static let reload: JSString = "reload"
    @usableFromInline static let remove: JSString = "remove"
    @usableFromInline static let removeAttribute: JSString = "removeAttribute"
    @usableFromInline static let removeAttributeNS: JSString = "removeAttributeNS"
    @usableFromInline static let removeAttributeNode: JSString = "removeAttributeNode"
    @usableFromInline static let removeChild: JSString = "removeChild"
    @usableFromInline static let removeCue: JSString = "removeCue"
    @usableFromInline static let removeNamedItem: JSString = "removeNamedItem"
    @usableFromInline static let removeNamedItemNS: JSString = "removeNamedItemNS"
    @usableFromInline static let removeParameter: JSString = "removeParameter"
    @usableFromInline static let removeTrack: JSString = "removeTrack"
    @usableFromInline static let removedNodes: JSString = "removedNodes"
    @usableFromInline static let renderbufferStorage: JSString = "renderbufferStorage"
    @usableFromInline static let renderbufferStorageMultisample: JSString = "renderbufferStorageMultisample"
    @usableFromInline static let renderedBuffer: JSString = "renderedBuffer"
    @usableFromInline static let `repeat`: JSString = "repeat"
    @usableFromInline static let repetitionCount: JSString = "repetitionCount"
    @usableFromInline static let replace: JSString = "replace"
    @usableFromInline static let replaceChild: JSString = "replaceChild"
    @usableFromInline static let replaceChildren: JSString = "replaceChildren"
    @usableFromInline static let replaceData: JSString = "replaceData"
    @usableFromInline static let replaceState: JSString = "replaceState"
    @usableFromInline static let replaceWith: JSString = "replaceWith"
    @usableFromInline static let replacesClientId: JSString = "replacesClientId"
    @usableFromInline static let reportError: JSString = "reportError"
    @usableFromInline static let reportValidity: JSString = "reportValidity"
    @usableFromInline static let request: JSString = "request"
    @usableFromInline static let requestAdapter: JSString = "requestAdapter"
    @usableFromInline static let requestData: JSString = "requestData"
    @usableFromInline static let requestDevice: JSString = "requestDevice"
    @usableFromInline static let requestSubmit: JSString = "requestSubmit"
    @usableFromInline static let required: JSString = "required"
    @usableFromInline static let requiredFeatures: JSString = "requiredFeatures"
    @usableFromInline static let requiredLimits: JSString = "requiredLimits"
    @usableFromInline static let reset: JSString = "reset"
    @usableFromInline static let resetTransform: JSString = "resetTransform"
    @usableFromInline static let resizeBy: JSString = "resizeBy"
    @usableFromInline static let resizeHeight: JSString = "resizeHeight"
    @usableFromInline static let resizeMode: JSString = "resizeMode"
    @usableFromInline static let resizeQuality: JSString = "resizeQuality"
    @usableFromInline static let resizeTo: JSString = "resizeTo"
    @usableFromInline static let resizeWidth: JSString = "resizeWidth"
    @usableFromInline static let resolveQuerySet: JSString = "resolveQuerySet"
    @usableFromInline static let resolveTarget: JSString = "resolveTarget"
    @usableFromInline static let resource: JSString = "resource"
    @usableFromInline static let respond: JSString = "respond"
    @usableFromInline static let respondWithNewView: JSString = "respondWithNewView"
    @usableFromInline static let response: JSString = "response"
    @usableFromInline static let responseText: JSString = "responseText"
    @usableFromInline static let responseType: JSString = "responseType"
    @usableFromInline static let responseURL: JSString = "responseURL"
    @usableFromInline static let responseXML: JSString = "responseXML"
    @usableFromInline static let restore: JSString = "restore"
    @usableFromInline static let result: JSString = "result"
    @usableFromInline static let resultType: JSString = "resultType"
    @usableFromInline static let resultingClientId: JSString = "resultingClientId"
    @usableFromInline static let resume: JSString = "resume"
    @usableFromInline static let resumeTransformFeedback: JSString = "resumeTransformFeedback"
    @usableFromInline static let returnValue: JSString = "returnValue"
    @usableFromInline static let rev: JSString = "rev"
    @usableFromInline static let reverse: JSString = "reverse"
    @usableFromInline static let reversed: JSString = "reversed"
    @usableFromInline static let revokeObjectURL: JSString = "revokeObjectURL"
    @usableFromInline static let right: JSString = "right"
    @usableFromInline static let role: JSString = "role"
    @usableFromInline static let rolloffFactor: JSString = "rolloffFactor"
    @usableFromInline static let root: JSString = "root"
    @usableFromInline static let rotate: JSString = "rotate"
    @usableFromInline static let rotateAxisAngle: JSString = "rotateAxisAngle"
    @usableFromInline static let rotateAxisAngleSelf: JSString = "rotateAxisAngleSelf"
    @usableFromInline static let rotateFromVector: JSString = "rotateFromVector"
    @usableFromInline static let rotateFromVectorSelf: JSString = "rotateFromVectorSelf"
    @usableFromInline static let rotateSelf: JSString = "rotateSelf"
    @usableFromInline static let roundRect: JSString = "roundRect"
    @usableFromInline static let rowIndex: JSString = "rowIndex"
    @usableFromInline static let rowSpan: JSString = "rowSpan"
    @usableFromInline static let rows: JSString = "rows"
    @usableFromInline static let rowsPerImage: JSString = "rowsPerImage"
    @usableFromInline static let rules: JSString = "rules"
    @usableFromInline static let sampleCount: JSString = "sampleCount"
    @usableFromInline static let sampleCoverage: JSString = "sampleCoverage"
    @usableFromInline static let sampleRate: JSString = "sampleRate"
    @usableFromInline static let sampleSize: JSString = "sampleSize"
    @usableFromInline static let sampleType: JSString = "sampleType"
    @usableFromInline static let sampler: JSString = "sampler"
    @usableFromInline static let samplerParameterf: JSString = "samplerParameterf"
    @usableFromInline static let samplerParameteri: JSString = "samplerParameteri"
    @usableFromInline static let sandbox: JSString = "sandbox"
    @usableFromInline static let save: JSString = "save"
    @usableFromInline static let scalabilityMode: JSString = "scalabilityMode"
    @usableFromInline static let scale: JSString = "scale"
    @usableFromInline static let scale3d: JSString = "scale3d"
    @usableFromInline static let scale3dSelf: JSString = "scale3dSelf"
    @usableFromInline static let scaleNonUniform: JSString = "scaleNonUniform"
    @usableFromInline static let scaleSelf: JSString = "scaleSelf"
    @usableFromInline static let scheme: JSString = "scheme"
    @usableFromInline static let scissor: JSString = "scissor"
    @usableFromInline static let scope: JSString = "scope"
    @usableFromInline static let screen: JSString = "screen"
    @usableFromInline static let screenLeft: JSString = "screenLeft"
    @usableFromInline static let screenTop: JSString = "screenTop"
    @usableFromInline static let screenX: JSString = "screenX"
    @usableFromInline static let screenY: JSString = "screenY"
    @usableFromInline static let scriptURL: JSString = "scriptURL"
    @usableFromInline static let scripts: JSString = "scripts"
    @usableFromInline static let scroll: JSString = "scroll"
    @usableFromInline static let scrollAmount: JSString = "scrollAmount"
    @usableFromInline static let scrollBy: JSString = "scrollBy"
    @usableFromInline static let scrollDelay: JSString = "scrollDelay"
    @usableFromInline static let scrollHeight: JSString = "scrollHeight"
    @usableFromInline static let scrollIntoView: JSString = "scrollIntoView"
    @usableFromInline static let scrollLeft: JSString = "scrollLeft"
    @usableFromInline static let scrollPathIntoView: JSString = "scrollPathIntoView"
    @usableFromInline static let scrollRestoration: JSString = "scrollRestoration"
    @usableFromInline static let scrollTo: JSString = "scrollTo"
    @usableFromInline static let scrollTop: JSString = "scrollTop"
    @usableFromInline static let scrollWidth: JSString = "scrollWidth"
    @usableFromInline static let scrollX: JSString = "scrollX"
    @usableFromInline static let scrollY: JSString = "scrollY"
    @usableFromInline static let scrollbars: JSString = "scrollbars"
    @usableFromInline static let scrolling: JSString = "scrolling"
    @usableFromInline static let scrollingElement: JSString = "scrollingElement"
    @usableFromInline static let search: JSString = "search"
    @usableFromInline static let searchParams: JSString = "searchParams"
    @usableFromInline static let sectionRowIndex: JSString = "sectionRowIndex"
    @usableFromInline static let seekable: JSString = "seekable"
    @usableFromInline static let seeking: JSString = "seeking"
    @usableFromInline static let select: JSString = "select"
    @usableFromInline static let selectNode: JSString = "selectNode"
    @usableFromInline static let selectNodeContents: JSString = "selectNodeContents"
    @usableFromInline static let selected: JSString = "selected"
    @usableFromInline static let selectedIndex: JSString = "selectedIndex"
    @usableFromInline static let selectedOptions: JSString = "selectedOptions"
    @usableFromInline static let selectedTrack: JSString = "selectedTrack"
    @usableFromInline static let selectionDirection: JSString = "selectionDirection"
    @usableFromInline static let selectionEnd: JSString = "selectionEnd"
    @usableFromInline static let selectionStart: JSString = "selectionStart"
    @usableFromInline static let send: JSString = "send"
    @usableFromInline static let serviceWorker: JSString = "serviceWorker"
    @usableFromInline static let sessionStorage: JSString = "sessionStorage"
    @usableFromInline static let set: JSString = "set"
    @usableFromInline static let setAttribute: JSString = "setAttribute"
    @usableFromInline static let setAttributeNS: JSString = "setAttributeNS"
    @usableFromInline static let setAttributeNode: JSString = "setAttributeNode"
    @usableFromInline static let setAttributeNodeNS: JSString = "setAttributeNodeNS"
    @usableFromInline static let setBindGroup: JSString = "setBindGroup"
    @usableFromInline static let setBlendConstant: JSString = "setBlendConstant"
    @usableFromInline static let setCustomValidity: JSString = "setCustomValidity"
    @usableFromInline static let setData: JSString = "setData"
    @usableFromInline static let setDragImage: JSString = "setDragImage"
    @usableFromInline static let setEnd: JSString = "setEnd"
    @usableFromInline static let setEndAfter: JSString = "setEndAfter"
    @usableFromInline static let setEndBefore: JSString = "setEndBefore"
    @usableFromInline static let setFormValue: JSString = "setFormValue"
    @usableFromInline static let setHeaderValue: JSString = "setHeaderValue"
    @usableFromInline static let setIndexBuffer: JSString = "setIndexBuffer"
    @usableFromInline static let setInterval: JSString = "setInterval"
    @usableFromInline static let setKeyframes: JSString = "setKeyframes"
    @usableFromInline static let setLineDash: JSString = "setLineDash"
    @usableFromInline static let setMatrixValue: JSString = "setMatrixValue"
    @usableFromInline static let setNamedItem: JSString = "setNamedItem"
    @usableFromInline static let setNamedItemNS: JSString = "setNamedItemNS"
    @usableFromInline static let setOrientation: JSString = "setOrientation"
    @usableFromInline static let setParameter: JSString = "setParameter"
    @usableFromInline static let setPeriodicWave: JSString = "setPeriodicWave"
    @usableFromInline static let setPipeline: JSString = "setPipeline"
    @usableFromInline static let setPosition: JSString = "setPosition"
    @usableFromInline static let setRangeText: JSString = "setRangeText"
    @usableFromInline static let setRequestHeader: JSString = "setRequestHeader"
    @usableFromInline static let setScissorRect: JSString = "setScissorRect"
    @usableFromInline static let setSelectionRange: JSString = "setSelectionRange"
    @usableFromInline static let setStart: JSString = "setStart"
    @usableFromInline static let setStartAfter: JSString = "setStartAfter"
    @usableFromInline static let setStartBefore: JSString = "setStartBefore"
    @usableFromInline static let setStencilReference: JSString = "setStencilReference"
    @usableFromInline static let setTargetAtTime: JSString = "setTargetAtTime"
    @usableFromInline static let setTimeout: JSString = "setTimeout"
    @usableFromInline static let setTransform: JSString = "setTransform"
    @usableFromInline static let setValidity: JSString = "setValidity"
    @usableFromInline static let setValueAtTime: JSString = "setValueAtTime"
    @usableFromInline static let setValueCurveAtTime: JSString = "setValueCurveAtTime"
    @usableFromInline static let setVertexBuffer: JSString = "setVertexBuffer"
    @usableFromInline static let setViewport: JSString = "setViewport"
    @usableFromInline static let shaderLocation: JSString = "shaderLocation"
    @usableFromInline static let shaderSource: JSString = "shaderSource"
    @usableFromInline static let shadowBlur: JSString = "shadowBlur"
    @usableFromInline static let shadowColor: JSString = "shadowColor"
    @usableFromInline static let shadowOffsetX: JSString = "shadowOffsetX"
    @usableFromInline static let shadowOffsetY: JSString = "shadowOffsetY"
    @usableFromInline static let shadowRoot: JSString = "shadowRoot"
    @usableFromInline static let shape: JSString = "shape"
    @usableFromInline static let shiftKey: JSString = "shiftKey"
    @usableFromInline static let show: JSString = "show"
    @usableFromInline static let showModal: JSString = "showModal"
    @usableFromInline static let showPicker: JSString = "showPicker"
    @usableFromInline static let signal: JSString = "signal"
    @usableFromInline static let singleNodeValue: JSString = "singleNodeValue"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let sizes: JSString = "sizes"
    @usableFromInline static let skewX: JSString = "skewX"
    @usableFromInline static let skewXSelf: JSString = "skewXSelf"
    @usableFromInline static let skewY: JSString = "skewY"
    @usableFromInline static let skewYSelf: JSString = "skewYSelf"
    @usableFromInline static let slice: JSString = "slice"
    @usableFromInline static let slot: JSString = "slot"
    @usableFromInline static let slotAssignment: JSString = "slotAssignment"
    @usableFromInline static let smoothingTimeConstant: JSString = "smoothingTimeConstant"
    @usableFromInline static let snapshotItem: JSString = "snapshotItem"
    @usableFromInline static let snapshotLength: JSString = "snapshotLength"
    @usableFromInline static let sort: JSString = "sort"
    @usableFromInline static let source: JSString = "source"
    @usableFromInline static let sourceMap: JSString = "sourceMap"
    @usableFromInline static let span: JSString = "span"
    @usableFromInline static let specified: JSString = "specified"
    @usableFromInline static let spellcheck: JSString = "spellcheck"
    @usableFromInline static let splitText: JSString = "splitText"
    @usableFromInline static let src: JSString = "src"
    @usableFromInline static let srcElement: JSString = "srcElement"
    @usableFromInline static let srcFactor: JSString = "srcFactor"
    @usableFromInline static let srcdoc: JSString = "srcdoc"
    @usableFromInline static let srclang: JSString = "srclang"
    @usableFromInline static let srcset: JSString = "srcset"
    @usableFromInline static let standby: JSString = "standby"
    @usableFromInline static let start: JSString = "start"
    @usableFromInline static let startContainer: JSString = "startContainer"
    @usableFromInline static let startMessages: JSString = "startMessages"
    @usableFromInline static let startOffset: JSString = "startOffset"
    @usableFromInline static let startRendering: JSString = "startRendering"
    @usableFromInline static let startTime: JSString = "startTime"
    @usableFromInline static let state: JSString = "state"
    @usableFromInline static let status: JSString = "status"
    @usableFromInline static let statusMessage: JSString = "statusMessage"
    @usableFromInline static let statusText: JSString = "statusText"
    @usableFromInline static let statusbar: JSString = "statusbar"
    @usableFromInline static let stencil: JSString = "stencil"
    @usableFromInline static let stencilBack: JSString = "stencilBack"
    @usableFromInline static let stencilClearValue: JSString = "stencilClearValue"
    @usableFromInline static let stencilFront: JSString = "stencilFront"
    @usableFromInline static let stencilFunc: JSString = "stencilFunc"
    @usableFromInline static let stencilFuncSeparate: JSString = "stencilFuncSeparate"
    @usableFromInline static let stencilLoadOp: JSString = "stencilLoadOp"
    @usableFromInline static let stencilMask: JSString = "stencilMask"
    @usableFromInline static let stencilMaskSeparate: JSString = "stencilMaskSeparate"
    @usableFromInline static let stencilOp: JSString = "stencilOp"
    @usableFromInline static let stencilOpSeparate: JSString = "stencilOpSeparate"
    @usableFromInline static let stencilReadMask: JSString = "stencilReadMask"
    @usableFromInline static let stencilReadOnly: JSString = "stencilReadOnly"
    @usableFromInline static let stencilStoreOp: JSString = "stencilStoreOp"
    @usableFromInline static let stencilWriteMask: JSString = "stencilWriteMask"
    @usableFromInline static let step: JSString = "step"
    @usableFromInline static let stepDown: JSString = "stepDown"
    @usableFromInline static let stepMismatch: JSString = "stepMismatch"
    @usableFromInline static let stepMode: JSString = "stepMode"
    @usableFromInline static let stepUp: JSString = "stepUp"
    @usableFromInline static let stop: JSString = "stop"
    @usableFromInline static let stopImmediatePropagation: JSString = "stopImmediatePropagation"
    @usableFromInline static let stopPropagation: JSString = "stopPropagation"
    @usableFromInline static let storageArea: JSString = "storageArea"
    @usableFromInline static let storageTexture: JSString = "storageTexture"
    @usableFromInline static let storeOp: JSString = "storeOp"
    @usableFromInline static let stream: JSString = "stream"
    @usableFromInline static let stride: JSString = "stride"
    @usableFromInline static let stringValue: JSString = "stringValue"
    @usableFromInline static let stripIndexFormat: JSString = "stripIndexFormat"
    @usableFromInline static let stroke: JSString = "stroke"
    @usableFromInline static let strokeRect: JSString = "strokeRect"
    @usableFromInline static let strokeStyle: JSString = "strokeStyle"
    @usableFromInline static let strokeText: JSString = "strokeText"
    @usableFromInline static let structuredClone: JSString = "structuredClone"
    @usableFromInline static let submit: JSString = "submit"
    @usableFromInline static let submitter: JSString = "submitter"
    @usableFromInline static let substringData: JSString = "substringData"
    @usableFromInline static let subtree: JSString = "subtree"
    @usableFromInline static let suffixes: JSString = "suffixes"
    @usableFromInline static let summary: JSString = "summary"
    @usableFromInline static let supported: JSString = "supported"
    @usableFromInline static let supports: JSString = "supports"
    @usableFromInline static let surroundContents: JSString = "surroundContents"
    @usableFromInline static let suspend: JSString = "suspend"
    @usableFromInline static let svc: JSString = "svc"
    @usableFromInline static let systemId: JSString = "systemId"
    @usableFromInline static let tBodies: JSString = "tBodies"
    @usableFromInline static let tFoot: JSString = "tFoot"
    @usableFromInline static let tHead: JSString = "tHead"
    @usableFromInline static let tabIndex: JSString = "tabIndex"
    @usableFromInline static let table: JSString = "table"
    @usableFromInline static let tagName: JSString = "tagName"
    @usableFromInline static let taintEnabled: JSString = "taintEnabled"
    @usableFromInline static let takeRecords: JSString = "takeRecords"
    @usableFromInline static let target: JSString = "target"
    @usableFromInline static let targetOrigin: JSString = "targetOrigin"
    @usableFromInline static let targets: JSString = "targets"
    @usableFromInline static let tee: JSString = "tee"
    @usableFromInline static let temporalLayerId: JSString = "temporalLayerId"
    @usableFromInline static let terminate: JSString = "terminate"
    @usableFromInline static let texImage2D: JSString = "texImage2D"
    @usableFromInline static let texImage3D: JSString = "texImage3D"
    @usableFromInline static let texParameterf: JSString = "texParameterf"
    @usableFromInline static let texParameteri: JSString = "texParameteri"
    @usableFromInline static let texStorage2D: JSString = "texStorage2D"
    @usableFromInline static let texStorage3D: JSString = "texStorage3D"
    @usableFromInline static let texSubImage2D: JSString = "texSubImage2D"
    @usableFromInline static let texSubImage3D: JSString = "texSubImage3D"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let textAlign: JSString = "textAlign"
    @usableFromInline static let textBaseline: JSString = "textBaseline"
    @usableFromInline static let textContent: JSString = "textContent"
    @usableFromInline static let textLength: JSString = "textLength"
    @usableFromInline static let textRendering: JSString = "textRendering"
    @usableFromInline static let textTracks: JSString = "textTracks"
    @usableFromInline static let texture: JSString = "texture"
    @usableFromInline static let threshold: JSString = "threshold"
    @usableFromInline static let throwIfAborted: JSString = "throwIfAborted"
    @usableFromInline static let time: JSString = "time"
    @usableFromInline static let timeEnd: JSString = "timeEnd"
    @usableFromInline static let timeLog: JSString = "timeLog"
    @usableFromInline static let timeOrigin: JSString = "timeOrigin"
    @usableFromInline static let timeStamp: JSString = "timeStamp"
    @usableFromInline static let timecode: JSString = "timecode"
    @usableFromInline static let timeline: JSString = "timeline"
    @usableFromInline static let timeout: JSString = "timeout"
    @usableFromInline static let timestamp: JSString = "timestamp"
    @usableFromInline static let timestampWrites: JSString = "timestampWrites"
    @usableFromInline static let title: JSString = "title"
    @usableFromInline static let toBox: JSString = "toBox"
    @usableFromInline static let toDataURL: JSString = "toDataURL"
    @usableFromInline static let toFloat32Array: JSString = "toFloat32Array"
    @usableFromInline static let toFloat64Array: JSString = "toFloat64Array"
    @usableFromInline static let toJSON: JSString = "toJSON"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let toggle: JSString = "toggle"
    @usableFromInline static let toggleAttribute: JSString = "toggleAttribute"
    @usableFromInline static let tooLong: JSString = "tooLong"
    @usableFromInline static let tooShort: JSString = "tooShort"
    @usableFromInline static let toolbar: JSString = "toolbar"
    @usableFromInline static let top: JSString = "top"
    @usableFromInline static let topology: JSString = "topology"
    @usableFromInline static let total: JSString = "total"
    @usableFromInline static let trace: JSString = "trace"
    @usableFromInline static let track: JSString = "track"
    @usableFromInline static let tracks: JSString = "tracks"
    @usableFromInline static let transfer: JSString = "transfer"
    @usableFromInline static let transferControlToOffscreen: JSString = "transferControlToOffscreen"
    @usableFromInline static let transferFromImageBitmap: JSString = "transferFromImageBitmap"
    @usableFromInline static let transferToImageBitmap: JSString = "transferToImageBitmap"
    @usableFromInline static let transform: JSString = "transform"
    @usableFromInline static let transformFeedbackVaryings: JSString = "transformFeedbackVaryings"
    @usableFromInline static let transformPoint: JSString = "transformPoint"
    @usableFromInline static let transformToDocument: JSString = "transformToDocument"
    @usableFromInline static let transformToFragment: JSString = "transformToFragment"
    @usableFromInline static let translate: JSString = "translate"
    @usableFromInline static let translateSelf: JSString = "translateSelf"
    @usableFromInline static let trueSpeed: JSString = "trueSpeed"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let typeMismatch: JSString = "typeMismatch"
    @usableFromInline static let types: JSString = "types"
    @usableFromInline static let unclippedDepth: JSString = "unclippedDepth"
    @usableFromInline static let unconfigure: JSString = "unconfigure"
    @usableFromInline static let uniform1f: JSString = "uniform1f"
    @usableFromInline static let uniform1fv: JSString = "uniform1fv"
    @usableFromInline static let uniform1i: JSString = "uniform1i"
    @usableFromInline static let uniform1iv: JSString = "uniform1iv"
    @usableFromInline static let uniform1ui: JSString = "uniform1ui"
    @usableFromInline static let uniform1uiv: JSString = "uniform1uiv"
    @usableFromInline static let uniform2f: JSString = "uniform2f"
    @usableFromInline static let uniform2fv: JSString = "uniform2fv"
    @usableFromInline static let uniform2i: JSString = "uniform2i"
    @usableFromInline static let uniform2iv: JSString = "uniform2iv"
    @usableFromInline static let uniform2ui: JSString = "uniform2ui"
    @usableFromInline static let uniform2uiv: JSString = "uniform2uiv"
    @usableFromInline static let uniform3f: JSString = "uniform3f"
    @usableFromInline static let uniform3fv: JSString = "uniform3fv"
    @usableFromInline static let uniform3i: JSString = "uniform3i"
    @usableFromInline static let uniform3iv: JSString = "uniform3iv"
    @usableFromInline static let uniform3ui: JSString = "uniform3ui"
    @usableFromInline static let uniform3uiv: JSString = "uniform3uiv"
    @usableFromInline static let uniform4f: JSString = "uniform4f"
    @usableFromInline static let uniform4fv: JSString = "uniform4fv"
    @usableFromInline static let uniform4i: JSString = "uniform4i"
    @usableFromInline static let uniform4iv: JSString = "uniform4iv"
    @usableFromInline static let uniform4ui: JSString = "uniform4ui"
    @usableFromInline static let uniform4uiv: JSString = "uniform4uiv"
    @usableFromInline static let uniformBlockBinding: JSString = "uniformBlockBinding"
    @usableFromInline static let uniformMatrix2fv: JSString = "uniformMatrix2fv"
    @usableFromInline static let uniformMatrix2x3fv: JSString = "uniformMatrix2x3fv"
    @usableFromInline static let uniformMatrix2x4fv: JSString = "uniformMatrix2x4fv"
    @usableFromInline static let uniformMatrix3fv: JSString = "uniformMatrix3fv"
    @usableFromInline static let uniformMatrix3x2fv: JSString = "uniformMatrix3x2fv"
    @usableFromInline static let uniformMatrix3x4fv: JSString = "uniformMatrix3x4fv"
    @usableFromInline static let uniformMatrix4fv: JSString = "uniformMatrix4fv"
    @usableFromInline static let uniformMatrix4x2fv: JSString = "uniformMatrix4x2fv"
    @usableFromInline static let uniformMatrix4x3fv: JSString = "uniformMatrix4x3fv"
    @usableFromInline static let unmap: JSString = "unmap"
    @usableFromInline static let unregister: JSString = "unregister"
    @usableFromInline static let unregisterProtocolHandler: JSString = "unregisterProtocolHandler"
    @usableFromInline static let upX: JSString = "upX"
    @usableFromInline static let upY: JSString = "upY"
    @usableFromInline static let upZ: JSString = "upZ"
    @usableFromInline static let update: JSString = "update"
    @usableFromInline static let updatePlaybackRate: JSString = "updatePlaybackRate"
    @usableFromInline static let updateTiming: JSString = "updateTiming"
    @usableFromInline static let updateViaCache: JSString = "updateViaCache"
    @usableFromInline static let upgrade: JSString = "upgrade"
    @usableFromInline static let upload: JSString = "upload"
    @usableFromInline static let url: JSString = "url"
    @usableFromInline static let usage: JSString = "usage"
    @usableFromInline static let useMap: JSString = "useMap"
    @usableFromInline static let useProgram: JSString = "useProgram"
    @usableFromInline static let userAgent: JSString = "userAgent"
    @usableFromInline static let username: JSString = "username"
    @usableFromInline static let vAlign: JSString = "vAlign"
    @usableFromInline static let vLink: JSString = "vLink"
    @usableFromInline static let valid: JSString = "valid"
    @usableFromInline static let validateProgram: JSString = "validateProgram"
    @usableFromInline static let validationMessage: JSString = "validationMessage"
    @usableFromInline static let validity: JSString = "validity"
    @usableFromInline static let value: JSString = "value"
    @usableFromInline static let valueAsDate: JSString = "valueAsDate"
    @usableFromInline static let valueAsNumber: JSString = "valueAsNumber"
    @usableFromInline static let valueMissing: JSString = "valueMissing"
    @usableFromInline static let valueType: JSString = "valueType"
    @usableFromInline static let vendor: JSString = "vendor"
    @usableFromInline static let vendorSub: JSString = "vendorSub"
    @usableFromInline static let version: JSString = "version"
    @usableFromInline static let vertex: JSString = "vertex"
    @usableFromInline static let vertexAttrib1f: JSString = "vertexAttrib1f"
    @usableFromInline static let vertexAttrib1fv: JSString = "vertexAttrib1fv"
    @usableFromInline static let vertexAttrib2f: JSString = "vertexAttrib2f"
    @usableFromInline static let vertexAttrib2fv: JSString = "vertexAttrib2fv"
    @usableFromInline static let vertexAttrib3f: JSString = "vertexAttrib3f"
    @usableFromInline static let vertexAttrib3fv: JSString = "vertexAttrib3fv"
    @usableFromInline static let vertexAttrib4f: JSString = "vertexAttrib4f"
    @usableFromInline static let vertexAttrib4fv: JSString = "vertexAttrib4fv"
    @usableFromInline static let vertexAttribDivisor: JSString = "vertexAttribDivisor"
    @usableFromInline static let vertexAttribI4i: JSString = "vertexAttribI4i"
    @usableFromInline static let vertexAttribI4iv: JSString = "vertexAttribI4iv"
    @usableFromInline static let vertexAttribI4ui: JSString = "vertexAttribI4ui"
    @usableFromInline static let vertexAttribI4uiv: JSString = "vertexAttribI4uiv"
    @usableFromInline static let vertexAttribIPointer: JSString = "vertexAttribIPointer"
    @usableFromInline static let vertexAttribPointer: JSString = "vertexAttribPointer"
    @usableFromInline static let video: JSString = "video"
    @usableFromInline static let videoBitsPerSecond: JSString = "videoBitsPerSecond"
    @usableFromInline static let videoHeight: JSString = "videoHeight"
    @usableFromInline static let videoTracks: JSString = "videoTracks"
    @usableFromInline static let videoWidth: JSString = "videoWidth"
    @usableFromInline static let view: JSString = "view"
    @usableFromInline static let viewDimension: JSString = "viewDimension"
    @usableFromInline static let viewFormats: JSString = "viewFormats"
    @usableFromInline static let viewport: JSString = "viewport"
    @usableFromInline static let visibility: JSString = "visibility"
    @usableFromInline static let visibilityState: JSString = "visibilityState"
    @usableFromInline static let visible: JSString = "visible"
    @usableFromInline static let visibleRect: JSString = "visibleRect"
    @usableFromInline static let vlinkColor: JSString = "vlinkColor"
    @usableFromInline static let volume: JSString = "volume"
    @usableFromInline static let vspace: JSString = "vspace"
    @usableFromInline static let w: JSString = "w"
    @usableFromInline static let waitSync: JSString = "waitSync"
    @usableFromInline static let waiting: JSString = "waiting"
    @usableFromInline static let warn: JSString = "warn"
    @usableFromInline static let wasClean: JSString = "wasClean"
    @usableFromInline static let webkitMatchesSelector: JSString = "webkitMatchesSelector"
    @usableFromInline static let whatToShow: JSString = "whatToShow"
    @usableFromInline static let whenDefined: JSString = "whenDefined"
    @usableFromInline static let which: JSString = "which"
    @usableFromInline static let wholeText: JSString = "wholeText"
    @usableFromInline static let width: JSString = "width"
    @usableFromInline static let willReadFrequently: JSString = "willReadFrequently"
    @usableFromInline static let willValidate: JSString = "willValidate"
    @usableFromInline static let window: JSString = "window"
    @usableFromInline static let withCredentials: JSString = "withCredentials"
    @usableFromInline static let wordSpacing: JSString = "wordSpacing"
    @usableFromInline static let wrap: JSString = "wrap"
    @usableFromInline static let writable: JSString = "writable"
    @usableFromInline static let writableType: JSString = "writableType"
    @usableFromInline static let write: JSString = "write"
    @usableFromInline static let writeBuffer: JSString = "writeBuffer"
    @usableFromInline static let writeMask: JSString = "writeMask"
    @usableFromInline static let writeTexture: JSString = "writeTexture"
    @usableFromInline static let writeTimestamp: JSString = "writeTimestamp"
    @usableFromInline static let writeln: JSString = "writeln"
    @usableFromInline static let x: JSString = "x"
    @usableFromInline static let y: JSString = "y"
    @usableFromInline static let z: JSString = "z"
}

public protocol Any_ArrayBuffer_or_String: ConvertibleToJSValue {}
extension ArrayBuffer: Any_ArrayBuffer_or_String {}
extension String: Any_ArrayBuffer_or_String {}

public enum ArrayBuffer_or_String: JSValueCompatible, Any_ArrayBuffer_or_String {
    case arrayBuffer(ArrayBuffer)
    case string(String)

    var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_AudioContextLatencyCategory_or_Double: ConvertibleToJSValue {}
extension AudioContextLatencyCategory: Any_AudioContextLatencyCategory_or_Double {}
extension Double: Any_AudioContextLatencyCategory_or_Double {}

public enum AudioContextLatencyCategory_or_Double: JSValueCompatible, Any_AudioContextLatencyCategory_or_Double {
    case audioContextLatencyCategory(AudioContextLatencyCategory)
    case double(Double)

    var audioContextLatencyCategory: AudioContextLatencyCategory? {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory): return audioContextLatencyCategory
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioContextLatencyCategory: AudioContextLatencyCategory = value.fromJSValue() {
            return .audioContextLatencyCategory(audioContextLatencyCategory)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory):
            return audioContextLatencyCategory.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_AudioTrack_or_TextTrack_or_VideoTrack: ConvertibleToJSValue {}
extension AudioTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension TextTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension VideoTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}

public enum AudioTrack_or_TextTrack_or_VideoTrack: JSValueCompatible, Any_AudioTrack_or_TextTrack_or_VideoTrack {
    case audioTrack(AudioTrack)
    case textTrack(TextTrack)
    case videoTrack(VideoTrack)

    var audioTrack: AudioTrack? {
        switch self {
        case let .audioTrack(audioTrack): return audioTrack
        default: return nil
        }
    }

    var textTrack: TextTrack? {
        switch self {
        case let .textTrack(textTrack): return textTrack
        default: return nil
        }
    }

    var videoTrack: VideoTrack? {
        switch self {
        case let .videoTrack(videoTrack): return videoTrack
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioTrack: AudioTrack = value.fromJSValue() {
            return .audioTrack(audioTrack)
        }
        if let textTrack: TextTrack = value.fromJSValue() {
            return .textTrack(textTrack)
        }
        if let videoTrack: VideoTrack = value.fromJSValue() {
            return .videoTrack(videoTrack)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioTrack(audioTrack):
            return audioTrack.jsValue
        case let .textTrack(textTrack):
            return textTrack.jsValue
        case let .videoTrack(videoTrack):
            return videoTrack.jsValue
        }
    }
}

public protocol Any_BlobPart: ConvertibleToJSValue {}
extension Blob: Any_BlobPart {}
extension BufferSource: Any_BlobPart {}
extension String: Any_BlobPart {}

public enum BlobPart: JSValueCompatible, Any_BlobPart {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Bool_or_MediaTrackConstraints: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_MediaTrackConstraints {}
extension MediaTrackConstraints: Any_Bool_or_MediaTrackConstraints {}

public enum Bool_or_MediaTrackConstraints: JSValueCompatible, Any_Bool_or_MediaTrackConstraints {
    case bool(Bool)
    case mediaTrackConstraints(MediaTrackConstraints)

    var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    var mediaTrackConstraints: MediaTrackConstraints? {
        switch self {
        case let .mediaTrackConstraints(mediaTrackConstraints): return mediaTrackConstraints
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let mediaTrackConstraints: MediaTrackConstraints = value.fromJSValue() {
            return .mediaTrackConstraints(mediaTrackConstraints)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .mediaTrackConstraints(mediaTrackConstraints):
            return mediaTrackConstraints.jsValue
        }
    }
}

public protocol Any_Bool_or_ScrollIntoViewOptions: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_ScrollIntoViewOptions {}
extension ScrollIntoViewOptions: Any_Bool_or_ScrollIntoViewOptions {}

public enum Bool_or_ScrollIntoViewOptions: JSValueCompatible, Any_Bool_or_ScrollIntoViewOptions {
    case bool(Bool)
    case scrollIntoViewOptions(ScrollIntoViewOptions)

    var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    var scrollIntoViewOptions: ScrollIntoViewOptions? {
        switch self {
        case let .scrollIntoViewOptions(scrollIntoViewOptions): return scrollIntoViewOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let scrollIntoViewOptions: ScrollIntoViewOptions = value.fromJSValue() {
            return .scrollIntoViewOptions(scrollIntoViewOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .scrollIntoViewOptions(scrollIntoViewOptions):
            return scrollIntoViewOptions.jsValue
        }
    }
}

public protocol Any_BufferSource: ConvertibleToJSValue {}
extension ArrayBuffer: Any_BufferSource {}
extension ArrayBufferView: Any_BufferSource {}

public enum BufferSource: JSValueCompatible, Any_BufferSource {
    case arrayBuffer(ArrayBuffer)
    case arrayBufferView(ArrayBufferView)

    var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    var arrayBufferView: ArrayBufferView? {
        switch self {
        case let .arrayBufferView(arrayBufferView): return arrayBufferView
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let arrayBufferView: ArrayBufferView = value.fromJSValue() {
            return .arrayBufferView(arrayBufferView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .arrayBufferView(arrayBufferView):
            return arrayBufferView.jsValue
        }
    }
}

public protocol Any_CSSPseudoElement_or_Element: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_CSSPseudoElement_or_Element {}
extension Element: Any_CSSPseudoElement_or_Element {}

public enum CSSPseudoElement_or_Element: JSValueCompatible, Any_CSSPseudoElement_or_Element {
    case cssPseudoElement(CSSPseudoElement)
    case element(Element)

    var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .element(element):
            return element.jsValue
        }
    }
}

public protocol Any_CanvasFilterInput_or_seq_of_CanvasFilterInput: ConvertibleToJSValue {}
extension CanvasFilterInput: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {}
extension Array: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput where Element == CanvasFilterInput {}

public enum CanvasFilterInput_or_seq_of_CanvasFilterInput: JSValueCompatible, Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {
    case canvasFilterInput(CanvasFilterInput)
    case seq_of_CanvasFilterInput([CanvasFilterInput])

    var canvasFilterInput: CanvasFilterInput? {
        switch self {
        case let .canvasFilterInput(canvasFilterInput): return canvasFilterInput
        default: return nil
        }
    }

    var seq_of_CanvasFilterInput: [CanvasFilterInput]? {
        switch self {
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput): return seq_of_CanvasFilterInput
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilterInput: CanvasFilterInput = value.fromJSValue() {
            return .canvasFilterInput(canvasFilterInput)
        }
        if let seq_of_CanvasFilterInput: [CanvasFilterInput] = value.fromJSValue() {
            return .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilterInput(canvasFilterInput):
            return canvasFilterInput.jsValue
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput):
            return seq_of_CanvasFilterInput.jsValue
        }
    }
}

public protocol Any_CanvasFilter_or_String: ConvertibleToJSValue {}
extension CanvasFilter: Any_CanvasFilter_or_String {}
extension String: Any_CanvasFilter_or_String {}

public enum CanvasFilter_or_String: JSValueCompatible, Any_CanvasFilter_or_String {
    case canvasFilter(CanvasFilter)
    case string(String)

    var canvasFilter: CanvasFilter? {
        switch self {
        case let .canvasFilter(canvasFilter): return canvasFilter
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilter: CanvasFilter = value.fromJSValue() {
            return .canvasFilter(canvasFilter)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilter(canvasFilter):
            return canvasFilter.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CanvasGradient_or_CanvasPattern_or_String: ConvertibleToJSValue {}
extension CanvasGradient: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension CanvasPattern: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension String: Any_CanvasGradient_or_CanvasPattern_or_String {}

public enum CanvasGradient_or_CanvasPattern_or_String: JSValueCompatible, Any_CanvasGradient_or_CanvasPattern_or_String {
    case canvasGradient(CanvasGradient)
    case canvasPattern(CanvasPattern)
    case string(String)

    var canvasGradient: CanvasGradient? {
        switch self {
        case let .canvasGradient(canvasGradient): return canvasGradient
        default: return nil
        }
    }

    var canvasPattern: CanvasPattern? {
        switch self {
        case let .canvasPattern(canvasPattern): return canvasPattern
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasGradient: CanvasGradient = value.fromJSValue() {
            return .canvasGradient(canvasGradient)
        }
        if let canvasPattern: CanvasPattern = value.fromJSValue() {
            return .canvasPattern(canvasPattern)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasGradient(canvasGradient):
            return canvasGradient.jsValue
        case let .canvasPattern(canvasPattern):
            return canvasPattern.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CanvasImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_CanvasImageSource {}
extension HTMLOrSVGImageElement: Any_CanvasImageSource {}
extension HTMLVideoElement: Any_CanvasImageSource {}
extension ImageBitmap: Any_CanvasImageSource {}
extension OffscreenCanvas: Any_CanvasImageSource {}
extension VideoFrame: Any_CanvasImageSource {}

public enum CanvasImageSource: JSValueCompatible, Any_CanvasImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlOrSVGImageElement(HTMLOrSVGImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    var htmlOrSVGImageElement: HTMLOrSVGImageElement? {
        switch self {
        case let .htmlOrSVGImageElement(htmlOrSVGImageElement): return htmlOrSVGImageElement
        default: return nil
        }
    }

    var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlOrSVGImageElement: HTMLOrSVGImageElement = value.fromJSValue() {
            return .htmlOrSVGImageElement(htmlOrSVGImageElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlOrSVGImageElement(htmlOrSVGImageElement):
            return htmlOrSVGImageElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto: ConvertibleToJSValue {}
extension CompositeOperationOrAuto: Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto {}
extension Array: Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto where Element == CompositeOperationOrAuto {}

public enum CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto: JSValueCompatible, Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto {
    case compositeOperationOrAuto(CompositeOperationOrAuto)
    case seq_of_CompositeOperationOrAuto([CompositeOperationOrAuto])

    var compositeOperationOrAuto: CompositeOperationOrAuto? {
        switch self {
        case let .compositeOperationOrAuto(compositeOperationOrAuto): return compositeOperationOrAuto
        default: return nil
        }
    }

    var seq_of_CompositeOperationOrAuto: [CompositeOperationOrAuto]? {
        switch self {
        case let .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto): return seq_of_CompositeOperationOrAuto
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let compositeOperationOrAuto: CompositeOperationOrAuto = value.fromJSValue() {
            return .compositeOperationOrAuto(compositeOperationOrAuto)
        }
        if let seq_of_CompositeOperationOrAuto: [CompositeOperationOrAuto] = value.fromJSValue() {
            return .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .compositeOperationOrAuto(compositeOperationOrAuto):
            return compositeOperationOrAuto.jsValue
        case let .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto):
            return seq_of_CompositeOperationOrAuto.jsValue
        }
    }
}

public protocol Any_ConstrainBoolean: ConvertibleToJSValue {}
extension Bool: Any_ConstrainBoolean {}
extension ConstrainBooleanParameters: Any_ConstrainBoolean {}

public enum ConstrainBoolean: JSValueCompatible, Any_ConstrainBoolean {
    case bool(Bool)
    case constrainBooleanParameters(ConstrainBooleanParameters)

    var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    var constrainBooleanParameters: ConstrainBooleanParameters? {
        switch self {
        case let .constrainBooleanParameters(constrainBooleanParameters): return constrainBooleanParameters
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let constrainBooleanParameters: ConstrainBooleanParameters = value.fromJSValue() {
            return .constrainBooleanParameters(constrainBooleanParameters)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .constrainBooleanParameters(constrainBooleanParameters):
            return constrainBooleanParameters.jsValue
        }
    }
}

public protocol Any_ConstrainDOMString: ConvertibleToJSValue {}
extension ConstrainDOMStringParameters: Any_ConstrainDOMString {}
extension String: Any_ConstrainDOMString {}
extension Array: Any_ConstrainDOMString where Element == String {}

public enum ConstrainDOMString: JSValueCompatible, Any_ConstrainDOMString {
    case constrainDOMStringParameters(ConstrainDOMStringParameters)
    case string(String)
    case seq_of_String([String])

    var constrainDOMStringParameters: ConstrainDOMStringParameters? {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters): return constrainDOMStringParameters
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDOMStringParameters: ConstrainDOMStringParameters = value.fromJSValue() {
            return .constrainDOMStringParameters(constrainDOMStringParameters)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters):
            return constrainDOMStringParameters.jsValue
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_ConstrainDouble: ConvertibleToJSValue {}
extension ConstrainDoubleRange: Any_ConstrainDouble {}
extension Double: Any_ConstrainDouble {}

public enum ConstrainDouble: JSValueCompatible, Any_ConstrainDouble {
    case constrainDoubleRange(ConstrainDoubleRange)
    case double(Double)

    var constrainDoubleRange: ConstrainDoubleRange? {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange): return constrainDoubleRange
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDoubleRange: ConstrainDoubleRange = value.fromJSValue() {
            return .constrainDoubleRange(constrainDoubleRange)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange):
            return constrainDoubleRange.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_ConstrainULong: ConvertibleToJSValue {}
extension ConstrainULongRange: Any_ConstrainULong {}
extension UInt32: Any_ConstrainULong {}

public enum ConstrainULong: JSValueCompatible, Any_ConstrainULong {
    case constrainULongRange(ConstrainULongRange)
    case uInt32(UInt32)

    var constrainULongRange: ConstrainULongRange? {
        switch self {
        case let .constrainULongRange(constrainULongRange): return constrainULongRange
        default: return nil
        }
    }

    var uInt32: UInt32? {
        switch self {
        case let .uInt32(uInt32): return uInt32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainULongRange: ConstrainULongRange = value.fromJSValue() {
            return .constrainULongRange(constrainULongRange)
        }
        if let uInt32: UInt32 = value.fromJSValue() {
            return .uInt32(uInt32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainULongRange(constrainULongRange):
            return constrainULongRange.jsValue
        case let .uInt32(uInt32):
            return uInt32.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)

    var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Array: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double where Element == DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)
    case seq_of_DOMPointInit_or_Double([DOMPointInit_or_Double])

    var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    var seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]? {
        switch self {
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double): return seq_of_DOMPointInit_or_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double] = value.fromJSValue() {
            return .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double):
            return seq_of_DOMPointInit_or_Double.jsValue
        }
    }
}

public protocol Any_Document_or_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Document: Any_Document_or_XMLHttpRequestBodyInit {}
extension XMLHttpRequestBodyInit: Any_Document_or_XMLHttpRequestBodyInit {}

public enum Document_or_XMLHttpRequestBodyInit: JSValueCompatible, Any_Document_or_XMLHttpRequestBodyInit {
    case document(Document)
    case xmlHttpRequestBodyInit(XMLHttpRequestBodyInit)

    var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    var xmlHttpRequestBodyInit: XMLHttpRequestBodyInit? {
        switch self {
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit): return xmlHttpRequestBodyInit
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let xmlHttpRequestBodyInit: XMLHttpRequestBodyInit = value.fromJSValue() {
            return .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .document(document):
            return document.jsValue
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit):
            return xmlHttpRequestBodyInit.jsValue
        }
    }
}

public protocol Any_Double_or_KeyframeAnimationOptions: ConvertibleToJSValue {}
extension Double: Any_Double_or_KeyframeAnimationOptions {}
extension KeyframeAnimationOptions: Any_Double_or_KeyframeAnimationOptions {}

public enum Double_or_KeyframeAnimationOptions: JSValueCompatible, Any_Double_or_KeyframeAnimationOptions {
    case double(Double)
    case keyframeAnimationOptions(KeyframeAnimationOptions)

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    var keyframeAnimationOptions: KeyframeAnimationOptions? {
        switch self {
        case let .keyframeAnimationOptions(keyframeAnimationOptions): return keyframeAnimationOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeAnimationOptions: KeyframeAnimationOptions = value.fromJSValue() {
            return .keyframeAnimationOptions(keyframeAnimationOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeAnimationOptions(keyframeAnimationOptions):
            return keyframeAnimationOptions.jsValue
        }
    }
}

public protocol Any_Double_or_KeyframeEffectOptions: ConvertibleToJSValue {}
extension Double: Any_Double_or_KeyframeEffectOptions {}
extension KeyframeEffectOptions: Any_Double_or_KeyframeEffectOptions {}

public enum Double_or_KeyframeEffectOptions: JSValueCompatible, Any_Double_or_KeyframeEffectOptions {
    case double(Double)
    case keyframeEffectOptions(KeyframeEffectOptions)

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    var keyframeEffectOptions: KeyframeEffectOptions? {
        switch self {
        case let .keyframeEffectOptions(keyframeEffectOptions): return keyframeEffectOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeEffectOptions: KeyframeEffectOptions = value.fromJSValue() {
            return .keyframeEffectOptions(keyframeEffectOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeEffectOptions(keyframeEffectOptions):
            return keyframeEffectOptions.jsValue
        }
    }
}

public protocol Any_Double_or_String: ConvertibleToJSValue {}
extension Double: Any_Double_or_String {}
extension String: Any_Double_or_String {}

public enum Double_or_String: JSValueCompatible, Any_Double_or_String {
    case double(Double)
    case string(String)

    var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_ElementCreationOptions_or_String: ConvertibleToJSValue {}
extension ElementCreationOptions: Any_ElementCreationOptions_or_String {}
extension String: Any_ElementCreationOptions_or_String {}

public enum ElementCreationOptions_or_String: JSValueCompatible, Any_ElementCreationOptions_or_String {
    case elementCreationOptions(ElementCreationOptions)
    case string(String)

    var elementCreationOptions: ElementCreationOptions? {
        switch self {
        case let .elementCreationOptions(elementCreationOptions): return elementCreationOptions
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let elementCreationOptions: ElementCreationOptions = value.fromJSValue() {
            return .elementCreationOptions(elementCreationOptions)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .elementCreationOptions(elementCreationOptions):
            return elementCreationOptions.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Element_or_HTMLCollection: ConvertibleToJSValue {}
extension Element: Any_Element_or_HTMLCollection {}
extension HTMLCollection: Any_Element_or_HTMLCollection {}

public enum Element_or_HTMLCollection: JSValueCompatible, Any_Element_or_HTMLCollection {
    case element(Element)
    case htmlCollection(HTMLCollection)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var htmlCollection: HTMLCollection? {
        switch self {
        case let .htmlCollection(htmlCollection): return htmlCollection
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let htmlCollection: HTMLCollection = value.fromJSValue() {
            return .htmlCollection(htmlCollection)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .htmlCollection(htmlCollection):
            return htmlCollection.jsValue
        }
    }
}

public protocol Any_Element_or_RadioNodeList: ConvertibleToJSValue {}
extension Element: Any_Element_or_RadioNodeList {}
extension RadioNodeList: Any_Element_or_RadioNodeList {}

public enum Element_or_RadioNodeList: JSValueCompatible, Any_Element_or_RadioNodeList {
    case element(Element)
    case radioNodeList(RadioNodeList)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var radioNodeList: RadioNodeList? {
        switch self {
        case let .radioNodeList(radioNodeList): return radioNodeList
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let radioNodeList: RadioNodeList = value.fromJSValue() {
            return .radioNodeList(radioNodeList)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .radioNodeList(radioNodeList):
            return radioNodeList.jsValue
        }
    }
}

public protocol Any_Element_or_Text: ConvertibleToJSValue {}
extension Element: Any_Element_or_Text {}
extension Text: Any_Element_or_Text {}

public enum Element_or_Text: JSValueCompatible, Any_Element_or_Text {
    case element(Element)
    case text(Text)

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_Event_or_String: ConvertibleToJSValue {}
extension Event: Any_Event_or_String {}
extension String: Any_Event_or_String {}

public enum Event_or_String: JSValueCompatible, Any_Event_or_String {
    case event(Event)
    case string(String)

    var event: Event? {
        switch self {
        case let .event(event): return event
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let event: Event = value.fromJSValue() {
            return .event(event)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .event(event):
            return event.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_File_or_FormData_or_String: ConvertibleToJSValue {}
extension File: Any_File_or_FormData_or_String {}
extension FormData: Any_File_or_FormData_or_String {}
extension String: Any_File_or_FormData_or_String {}

public enum File_or_FormData_or_String: JSValueCompatible, Any_File_or_FormData_or_String {
    case file(File)
    case formData(FormData)
    case string(String)

    var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Float32List: ConvertibleToJSValue {}
extension Float32Array: Any_Float32List {}
extension Array: Any_Float32List where Element == GLfloat {}

public enum Float32List: JSValueCompatible, Any_Float32List {
    case float32Array(Float32Array)
    case seq_of_GLfloat([GLfloat])

    var float32Array: Float32Array? {
        switch self {
        case let .float32Array(float32Array): return float32Array
        default: return nil
        }
    }

    var seq_of_GLfloat: [GLfloat]? {
        switch self {
        case let .seq_of_GLfloat(seq_of_GLfloat): return seq_of_GLfloat
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let float32Array: Float32Array = value.fromJSValue() {
            return .float32Array(float32Array)
        }
        if let seq_of_GLfloat: [GLfloat] = value.fromJSValue() {
            return .seq_of_GLfloat(seq_of_GLfloat)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .float32Array(float32Array):
            return float32Array.jsValue
        case let .seq_of_GLfloat(seq_of_GLfloat):
            return seq_of_GLfloat.jsValue
        }
    }
}

public protocol Any_FormDataEntryValue: ConvertibleToJSValue {}
extension File: Any_FormDataEntryValue {}
extension String: Any_FormDataEntryValue {}

public enum FormDataEntryValue: JSValueCompatible, Any_FormDataEntryValue {
    case file(File)
    case string(String)

    var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_GPUBindingResource: ConvertibleToJSValue {}
extension GPUBufferBinding: Any_GPUBindingResource {}
extension GPUExternalTexture: Any_GPUBindingResource {}
extension GPUSampler: Any_GPUBindingResource {}
extension GPUTextureView: Any_GPUBindingResource {}

public enum GPUBindingResource: JSValueCompatible, Any_GPUBindingResource {
    case gpuBufferBinding(GPUBufferBinding)
    case gpuExternalTexture(GPUExternalTexture)
    case gpuSampler(GPUSampler)
    case gpuTextureView(GPUTextureView)

    var gpuBufferBinding: GPUBufferBinding? {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding): return gpuBufferBinding
        default: return nil
        }
    }

    var gpuExternalTexture: GPUExternalTexture? {
        switch self {
        case let .gpuExternalTexture(gpuExternalTexture): return gpuExternalTexture
        default: return nil
        }
    }

    var gpuSampler: GPUSampler? {
        switch self {
        case let .gpuSampler(gpuSampler): return gpuSampler
        default: return nil
        }
    }

    var gpuTextureView: GPUTextureView? {
        switch self {
        case let .gpuTextureView(gpuTextureView): return gpuTextureView
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuBufferBinding: GPUBufferBinding = value.fromJSValue() {
            return .gpuBufferBinding(gpuBufferBinding)
        }
        if let gpuExternalTexture: GPUExternalTexture = value.fromJSValue() {
            return .gpuExternalTexture(gpuExternalTexture)
        }
        if let gpuSampler: GPUSampler = value.fromJSValue() {
            return .gpuSampler(gpuSampler)
        }
        if let gpuTextureView: GPUTextureView = value.fromJSValue() {
            return .gpuTextureView(gpuTextureView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding):
            return gpuBufferBinding.jsValue
        case let .gpuExternalTexture(gpuExternalTexture):
            return gpuExternalTexture.jsValue
        case let .gpuSampler(gpuSampler):
            return gpuSampler.jsValue
        case let .gpuTextureView(gpuTextureView):
            return gpuTextureView.jsValue
        }
    }
}

public protocol Any_GPUColor: ConvertibleToJSValue {}
extension GPUColorDict: Any_GPUColor {}
extension Array: Any_GPUColor where Element == Double {}

public enum GPUColor: JSValueCompatible, Any_GPUColor {
    case gpuColorDict(GPUColorDict)
    case seq_of_Double([Double])

    var gpuColorDict: GPUColorDict? {
        switch self {
        case let .gpuColorDict(gpuColorDict): return gpuColorDict
        default: return nil
        }
    }

    var seq_of_Double: [Double]? {
        switch self {
        case let .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuColorDict: GPUColorDict = value.fromJSValue() {
            return .gpuColorDict(gpuColorDict)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuColorDict(gpuColorDict):
            return gpuColorDict.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public protocol Any_GPUError: ConvertibleToJSValue {}
extension GPUOutOfMemoryError: Any_GPUError {}
extension GPUValidationError: Any_GPUError {}

public enum GPUError: JSValueCompatible, Any_GPUError {
    case gpuOutOfMemoryError(GPUOutOfMemoryError)
    case gpuValidationError(GPUValidationError)

    var gpuOutOfMemoryError: GPUOutOfMemoryError? {
        switch self {
        case let .gpuOutOfMemoryError(gpuOutOfMemoryError): return gpuOutOfMemoryError
        default: return nil
        }
    }

    var gpuValidationError: GPUValidationError? {
        switch self {
        case let .gpuValidationError(gpuValidationError): return gpuValidationError
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOutOfMemoryError: GPUOutOfMemoryError = value.fromJSValue() {
            return .gpuOutOfMemoryError(gpuOutOfMemoryError)
        }
        if let gpuValidationError: GPUValidationError = value.fromJSValue() {
            return .gpuValidationError(gpuValidationError)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOutOfMemoryError(gpuOutOfMemoryError):
            return gpuOutOfMemoryError.jsValue
        case let .gpuValidationError(gpuValidationError):
            return gpuValidationError.jsValue
        }
    }
}

public protocol Any_GPUExtent3D: ConvertibleToJSValue {}
extension GPUExtent3DDict: Any_GPUExtent3D {}
extension Array: Any_GPUExtent3D where Element == GPUIntegerCoordinate {}

public enum GPUExtent3D: JSValueCompatible, Any_GPUExtent3D {
    case gpuExtent3DDict(GPUExtent3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    var gpuExtent3DDict: GPUExtent3DDict? {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict): return gpuExtent3DDict
        default: return nil
        }
    }

    var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuExtent3DDict: GPUExtent3DDict = value.fromJSValue() {
            return .gpuExtent3DDict(gpuExtent3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict):
            return gpuExtent3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_GPUOrigin2D: ConvertibleToJSValue {}
extension GPUOrigin2DDict: Any_GPUOrigin2D {}
extension Array: Any_GPUOrigin2D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin2D: JSValueCompatible, Any_GPUOrigin2D {
    case gpuOrigin2DDict(GPUOrigin2DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    var gpuOrigin2DDict: GPUOrigin2DDict? {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict): return gpuOrigin2DDict
        default: return nil
        }
    }

    var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin2DDict: GPUOrigin2DDict = value.fromJSValue() {
            return .gpuOrigin2DDict(gpuOrigin2DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict):
            return gpuOrigin2DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_GPUOrigin3D: ConvertibleToJSValue {}
extension GPUOrigin3DDict: Any_GPUOrigin3D {}
extension Array: Any_GPUOrigin3D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin3D: JSValueCompatible, Any_GPUOrigin3D {
    case gpuOrigin3DDict(GPUOrigin3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    var gpuOrigin3DDict: GPUOrigin3DDict? {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict): return gpuOrigin3DDict
        default: return nil
        }
    }

    var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch self {
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin3DDict: GPUOrigin3DDict = value.fromJSValue() {
            return .gpuOrigin3DDict(gpuOrigin3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict):
            return gpuOrigin3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public protocol Any_GeometryNode: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_GeometryNode {}
extension Document: Any_GeometryNode {}
extension Element: Any_GeometryNode {}
extension Text: Any_GeometryNode {}

public enum GeometryNode: JSValueCompatible, Any_GeometryNode {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)

    var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .document(document):
            return document.jsValue
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas {}
extension ImageBitmap: Any_HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_ImageBitmap_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)

    var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLElement_or_Int32: ConvertibleToJSValue {}
extension HTMLElement: Any_HTMLElement_or_Int32 {}
extension Int32: Any_HTMLElement_or_Int32 {}

public enum HTMLElement_or_Int32: JSValueCompatible, Any_HTMLElement_or_Int32 {
    case htmlElement(HTMLElement)
    case int32(Int32)

    var htmlElement: HTMLElement? {
        switch self {
        case let .htmlElement(htmlElement): return htmlElement
        default: return nil
        }
    }

    var int32: Int32? {
        switch self {
        case let .int32(int32): return int32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlElement: HTMLElement = value.fromJSValue() {
            return .htmlElement(htmlElement)
        }
        if let int32: Int32 = value.fromJSValue() {
            return .int32(int32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlElement(htmlElement):
            return htmlElement.jsValue
        case let .int32(int32):
            return int32.jsValue
        }
    }
}

public protocol Any_HTMLOptGroupElement_or_HTMLOptionElement: ConvertibleToJSValue {}
extension HTMLOptGroupElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}
extension HTMLOptionElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}

public enum HTMLOptGroupElement_or_HTMLOptionElement: JSValueCompatible, Any_HTMLOptGroupElement_or_HTMLOptionElement {
    case htmlOptGroupElement(HTMLOptGroupElement)
    case htmlOptionElement(HTMLOptionElement)

    var htmlOptGroupElement: HTMLOptGroupElement? {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement
        default: return nil
        }
    }

    var htmlOptionElement: HTMLOptionElement? {
        switch self {
        case let .htmlOptionElement(htmlOptionElement): return htmlOptionElement
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlOptGroupElement: HTMLOptGroupElement = value.fromJSValue() {
            return .htmlOptGroupElement(htmlOptGroupElement)
        }
        if let htmlOptionElement: HTMLOptionElement = value.fromJSValue() {
            return .htmlOptionElement(htmlOptionElement)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement):
            return htmlOptGroupElement.jsValue
        case let .htmlOptionElement(htmlOptionElement):
            return htmlOptionElement.jsValue
        }
    }
}

public protocol Any_HeadersInit: ConvertibleToJSValue {}
extension Dictionary: Any_HeadersInit where Key == String, Value == String {}
extension Array: Any_HeadersInit where Element == [String] {}

public enum HeadersInit: JSValueCompatible, Any_HeadersInit {
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_ImageBitmapSource: ConvertibleToJSValue {}
extension Blob: Any_ImageBitmapSource {}
extension CanvasImageSource: Any_ImageBitmapSource {}
extension ImageData: Any_ImageBitmapSource {}

public enum ImageBitmapSource: JSValueCompatible, Any_ImageBitmapSource {
    case blob(Blob)
    case canvasImageSource(CanvasImageSource)
    case imageData(ImageData)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var canvasImageSource: CanvasImageSource? {
        switch self {
        case let .canvasImageSource(canvasImageSource): return canvasImageSource
        default: return nil
        }
    }

    var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let canvasImageSource: CanvasImageSource = value.fromJSValue() {
            return .canvasImageSource(canvasImageSource)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .canvasImageSource(canvasImageSource):
            return canvasImageSource.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        }
    }
}

public protocol Any_ImageBufferSource: ConvertibleToJSValue {}
extension BufferSource: Any_ImageBufferSource {}
extension ReadableStream: Any_ImageBufferSource {}

public enum ImageBufferSource: JSValueCompatible, Any_ImageBufferSource {
    case bufferSource(BufferSource)
    case readableStream(ReadableStream)

    var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    var readableStream: ReadableStream? {
        switch self {
        case let .readableStream(readableStream): return readableStream
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let readableStream: ReadableStream = value.fromJSValue() {
            return .readableStream(readableStream)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .readableStream(readableStream):
            return readableStream.jsValue
        }
    }
}

public protocol Any_Int32List: ConvertibleToJSValue {}
extension Int32Array: Any_Int32List {}
extension Array: Any_Int32List where Element == GLint {}

public enum Int32List: JSValueCompatible, Any_Int32List {
    case int32Array(Int32Array)
    case seq_of_GLint([GLint])

    var int32Array: Int32Array? {
        switch self {
        case let .int32Array(int32Array): return int32Array
        default: return nil
        }
    }

    var seq_of_GLint: [GLint]? {
        switch self {
        case let .seq_of_GLint(seq_of_GLint): return seq_of_GLint
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let int32Array: Int32Array = value.fromJSValue() {
            return .int32Array(int32Array)
        }
        if let seq_of_GLint: [GLint] = value.fromJSValue() {
            return .seq_of_GLint(seq_of_GLint)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .int32Array(int32Array):
            return int32Array.jsValue
        case let .seq_of_GLint(seq_of_GLint):
            return seq_of_GLint.jsValue
        }
    }
}

public protocol Any_MessageEventSource: ConvertibleToJSValue {}
extension MessagePort: Any_MessageEventSource {}
extension ServiceWorker: Any_MessageEventSource {}
extension WindowProxy: Any_MessageEventSource {}

public enum MessageEventSource: JSValueCompatible, Any_MessageEventSource {
    case messagePort(MessagePort)
    case serviceWorker(ServiceWorker)
    case windowProxy(WindowProxy)

    var messagePort: MessagePort? {
        switch self {
        case let .messagePort(messagePort): return messagePort
        default: return nil
        }
    }

    var serviceWorker: ServiceWorker? {
        switch self {
        case let .serviceWorker(serviceWorker): return serviceWorker
        default: return nil
        }
    }

    var windowProxy: WindowProxy? {
        switch self {
        case let .windowProxy(windowProxy): return windowProxy
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let messagePort: MessagePort = value.fromJSValue() {
            return .messagePort(messagePort)
        }
        if let serviceWorker: ServiceWorker = value.fromJSValue() {
            return .serviceWorker(serviceWorker)
        }
        if let windowProxy: WindowProxy = value.fromJSValue() {
            return .windowProxy(windowProxy)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .messagePort(messagePort):
            return messagePort.jsValue
        case let .serviceWorker(serviceWorker):
            return serviceWorker.jsValue
        case let .windowProxy(windowProxy):
            return windowProxy.jsValue
        }
    }
}

public protocol Any_Node_or_String: ConvertibleToJSValue {}
extension Node: Any_Node_or_String {}
extension String: Any_Node_or_String {}

public enum Node_or_String: JSValueCompatible, Any_Node_or_String {
    case node(Node)
    case string(String)

    var node: Node? {
        switch self {
        case let .node(node): return node
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let node: Node = value.fromJSValue() {
            return .node(node)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .node(node):
            return node.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_OffscreenRenderingContext: ConvertibleToJSValue {}
extension GPUCanvasContext: Any_OffscreenRenderingContext {}
extension ImageBitmapRenderingContext: Any_OffscreenRenderingContext {}
extension OffscreenCanvasRenderingContext2D: Any_OffscreenRenderingContext {}
extension WebGL2RenderingContext: Any_OffscreenRenderingContext {}
extension WebGLRenderingContext: Any_OffscreenRenderingContext {}

public enum OffscreenRenderingContext: JSValueCompatible, Any_OffscreenRenderingContext {
    case gpuCanvasContext(GPUCanvasContext)
    case imageBitmapRenderingContext(ImageBitmapRenderingContext)
    case offscreenCanvasRenderingContext2D(OffscreenCanvasRenderingContext2D)
    case webGL2RenderingContext(WebGL2RenderingContext)
    case webGLRenderingContext(WebGLRenderingContext)

    var gpuCanvasContext: GPUCanvasContext? {
        switch self {
        case let .gpuCanvasContext(gpuCanvasContext): return gpuCanvasContext
        default: return nil
        }
    }

    var imageBitmapRenderingContext: ImageBitmapRenderingContext? {
        switch self {
        case let .imageBitmapRenderingContext(imageBitmapRenderingContext): return imageBitmapRenderingContext
        default: return nil
        }
    }

    var offscreenCanvasRenderingContext2D: OffscreenCanvasRenderingContext2D? {
        switch self {
        case let .offscreenCanvasRenderingContext2D(offscreenCanvasRenderingContext2D): return offscreenCanvasRenderingContext2D
        default: return nil
        }
    }

    var webGL2RenderingContext: WebGL2RenderingContext? {
        switch self {
        case let .webGL2RenderingContext(webGL2RenderingContext): return webGL2RenderingContext
        default: return nil
        }
    }

    var webGLRenderingContext: WebGLRenderingContext? {
        switch self {
        case let .webGLRenderingContext(webGLRenderingContext): return webGLRenderingContext
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let gpuCanvasContext: GPUCanvasContext = value.fromJSValue() {
            return .gpuCanvasContext(gpuCanvasContext)
        }
        if let imageBitmapRenderingContext: ImageBitmapRenderingContext = value.fromJSValue() {
            return .imageBitmapRenderingContext(imageBitmapRenderingContext)
        }
        if let offscreenCanvasRenderingContext2D: OffscreenCanvasRenderingContext2D = value.fromJSValue() {
            return .offscreenCanvasRenderingContext2D(offscreenCanvasRenderingContext2D)
        }
        if let webGL2RenderingContext: WebGL2RenderingContext = value.fromJSValue() {
            return .webGL2RenderingContext(webGL2RenderingContext)
        }
        if let webGLRenderingContext: WebGLRenderingContext = value.fromJSValue() {
            return .webGLRenderingContext(webGLRenderingContext)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuCanvasContext(gpuCanvasContext):
            return gpuCanvasContext.jsValue
        case let .imageBitmapRenderingContext(imageBitmapRenderingContext):
            return imageBitmapRenderingContext.jsValue
        case let .offscreenCanvasRenderingContext2D(offscreenCanvasRenderingContext2D):
            return offscreenCanvasRenderingContext2D.jsValue
        case let .webGL2RenderingContext(webGL2RenderingContext):
            return webGL2RenderingContext.jsValue
        case let .webGLRenderingContext(webGLRenderingContext):
            return webGLRenderingContext.jsValue
        }
    }
}

public protocol Any_Path2D_or_String: ConvertibleToJSValue {}
extension Path2D: Any_Path2D_or_String {}
extension String: Any_Path2D_or_String {}

public enum Path2D_or_String: JSValueCompatible, Any_Path2D_or_String {
    case path2D(Path2D)
    case string(String)

    var path2D: Path2D? {
        switch self {
        case let .path2D(path2D): return path2D
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let path2D: Path2D = value.fromJSValue() {
            return .path2D(path2D)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .path2D(path2D):
            return path2D.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_ReadableStreamController: ConvertibleToJSValue {}
extension ReadableByteStreamController: Any_ReadableStreamController {}
extension ReadableStreamDefaultController: Any_ReadableStreamController {}

public enum ReadableStreamController: JSValueCompatible, Any_ReadableStreamController {
    case readableByteStreamController(ReadableByteStreamController)
    case readableStreamDefaultController(ReadableStreamDefaultController)

    var readableByteStreamController: ReadableByteStreamController? {
        switch self {
        case let .readableByteStreamController(readableByteStreamController): return readableByteStreamController
        default: return nil
        }
    }

    var readableStreamDefaultController: ReadableStreamDefaultController? {
        switch self {
        case let .readableStreamDefaultController(readableStreamDefaultController): return readableStreamDefaultController
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableByteStreamController: ReadableByteStreamController = value.fromJSValue() {
            return .readableByteStreamController(readableByteStreamController)
        }
        if let readableStreamDefaultController: ReadableStreamDefaultController = value.fromJSValue() {
            return .readableStreamDefaultController(readableStreamDefaultController)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableByteStreamController(readableByteStreamController):
            return readableByteStreamController.jsValue
        case let .readableStreamDefaultController(readableStreamDefaultController):
            return readableStreamDefaultController.jsValue
        }
    }
}

public protocol Any_ReadableStreamReader: ConvertibleToJSValue {}
extension ReadableStreamBYOBReader: Any_ReadableStreamReader {}
extension ReadableStreamDefaultReader: Any_ReadableStreamReader {}

public enum ReadableStreamReader: JSValueCompatible, Any_ReadableStreamReader {
    case readableStreamBYOBReader(ReadableStreamBYOBReader)
    case readableStreamDefaultReader(ReadableStreamDefaultReader)

    var readableStreamBYOBReader: ReadableStreamBYOBReader? {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader): return readableStreamBYOBReader
        default: return nil
        }
    }

    var readableStreamDefaultReader: ReadableStreamDefaultReader? {
        switch self {
        case let .readableStreamDefaultReader(readableStreamDefaultReader): return readableStreamDefaultReader
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableStreamBYOBReader: ReadableStreamBYOBReader = value.fromJSValue() {
            return .readableStreamBYOBReader(readableStreamBYOBReader)
        }
        if let readableStreamDefaultReader: ReadableStreamDefaultReader = value.fromJSValue() {
            return .readableStreamDefaultReader(readableStreamDefaultReader)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader):
            return readableStreamBYOBReader.jsValue
        case let .readableStreamDefaultReader(readableStreamDefaultReader):
            return readableStreamDefaultReader.jsValue
        }
    }
}

public protocol Any_RenderingContext: ConvertibleToJSValue {}
extension CanvasRenderingContext2D: Any_RenderingContext {}
extension GPUCanvasContext: Any_RenderingContext {}
extension ImageBitmapRenderingContext: Any_RenderingContext {}
extension WebGL2RenderingContext: Any_RenderingContext {}
extension WebGLRenderingContext: Any_RenderingContext {}

public enum RenderingContext: JSValueCompatible, Any_RenderingContext {
    case canvasRenderingContext2D(CanvasRenderingContext2D)
    case gpuCanvasContext(GPUCanvasContext)
    case imageBitmapRenderingContext(ImageBitmapRenderingContext)
    case webGL2RenderingContext(WebGL2RenderingContext)
    case webGLRenderingContext(WebGLRenderingContext)

    var canvasRenderingContext2D: CanvasRenderingContext2D? {
        switch self {
        case let .canvasRenderingContext2D(canvasRenderingContext2D): return canvasRenderingContext2D
        default: return nil
        }
    }

    var gpuCanvasContext: GPUCanvasContext? {
        switch self {
        case let .gpuCanvasContext(gpuCanvasContext): return gpuCanvasContext
        default: return nil
        }
    }

    var imageBitmapRenderingContext: ImageBitmapRenderingContext? {
        switch self {
        case let .imageBitmapRenderingContext(imageBitmapRenderingContext): return imageBitmapRenderingContext
        default: return nil
        }
    }

    var webGL2RenderingContext: WebGL2RenderingContext? {
        switch self {
        case let .webGL2RenderingContext(webGL2RenderingContext): return webGL2RenderingContext
        default: return nil
        }
    }

    var webGLRenderingContext: WebGLRenderingContext? {
        switch self {
        case let .webGLRenderingContext(webGLRenderingContext): return webGLRenderingContext
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasRenderingContext2D: CanvasRenderingContext2D = value.fromJSValue() {
            return .canvasRenderingContext2D(canvasRenderingContext2D)
        }
        if let gpuCanvasContext: GPUCanvasContext = value.fromJSValue() {
            return .gpuCanvasContext(gpuCanvasContext)
        }
        if let imageBitmapRenderingContext: ImageBitmapRenderingContext = value.fromJSValue() {
            return .imageBitmapRenderingContext(imageBitmapRenderingContext)
        }
        if let webGL2RenderingContext: WebGL2RenderingContext = value.fromJSValue() {
            return .webGL2RenderingContext(webGL2RenderingContext)
        }
        if let webGLRenderingContext: WebGLRenderingContext = value.fromJSValue() {
            return .webGLRenderingContext(webGLRenderingContext)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasRenderingContext2D(canvasRenderingContext2D):
            return canvasRenderingContext2D.jsValue
        case let .gpuCanvasContext(gpuCanvasContext):
            return gpuCanvasContext.jsValue
        case let .imageBitmapRenderingContext(imageBitmapRenderingContext):
            return imageBitmapRenderingContext.jsValue
        case let .webGL2RenderingContext(webGL2RenderingContext):
            return webGL2RenderingContext.jsValue
        case let .webGLRenderingContext(webGLRenderingContext):
            return webGLRenderingContext.jsValue
        }
    }
}

public protocol Any_RequestInfo: ConvertibleToJSValue {}
extension Request: Any_RequestInfo {}
extension String: Any_RequestInfo {}

public enum RequestInfo: JSValueCompatible, Any_RequestInfo {
    case request(Request)
    case string(String)

    var request: Request? {
        switch self {
        case let .request(request): return request
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let request: Request = value.fromJSValue() {
            return .request(request)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .request(request):
            return request.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_String_or_WorkerOptions: ConvertibleToJSValue {}
extension String: Any_String_or_WorkerOptions {}
extension WorkerOptions: Any_String_or_WorkerOptions {}

public enum String_or_WorkerOptions: JSValueCompatible, Any_String_or_WorkerOptions {
    case string(String)
    case workerOptions(WorkerOptions)

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var workerOptions: WorkerOptions? {
        switch self {
        case let .workerOptions(workerOptions): return workerOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let workerOptions: WorkerOptions = value.fromJSValue() {
            return .workerOptions(workerOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .workerOptions(workerOptions):
            return workerOptions.jsValue
        }
    }
}

public protocol Any_String_or_record_String_to_String_or_seq_of_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_record_String_to_String_or_seq_of_seq_of_String {}
extension Dictionary: Any_String_or_record_String_to_String_or_seq_of_seq_of_String where Key == String, Value == String {}
extension Array: Any_String_or_record_String_to_String_or_seq_of_seq_of_String where Element == [String] {}

public enum String_or_record_String_to_String_or_seq_of_seq_of_String: JSValueCompatible, Any_String_or_record_String_to_String_or_seq_of_seq_of_String {
    case string(String)
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_Double: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_Double {}
extension Array: Any_String_or_seq_of_Double where Element == Double {}

public enum String_or_seq_of_Double: JSValueCompatible, Any_String_or_seq_of_Double {
    case string(String)
    case seq_of_Double([Double])

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var seq_of_Double: [Double]? {
        switch self {
        case let .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_TexImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_TexImageSource {}
extension HTMLImageElement: Any_TexImageSource {}
extension HTMLVideoElement: Any_TexImageSource {}
extension ImageBitmap: Any_TexImageSource {}
extension ImageData: Any_TexImageSource {}
extension OffscreenCanvas: Any_TexImageSource {}
extension VideoFrame: Any_TexImageSource {}

public enum TexImageSource: JSValueCompatible, Any_TexImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlImageElement(HTMLImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case imageData(ImageData)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    var htmlImageElement: HTMLImageElement? {
        switch self {
        case let .htmlImageElement(htmlImageElement): return htmlImageElement
        default: return nil
        }
    }

    var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlImageElement: HTMLImageElement = value.fromJSValue() {
            return .htmlImageElement(htmlImageElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlImageElement(htmlImageElement):
            return htmlImageElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_TimerHandler: ConvertibleToJSValue {}
extension JSFunction: Any_TimerHandler {}
extension String: Any_TimerHandler {}

public enum TimerHandler: JSValueCompatible, Any_TimerHandler {
    case jsFunction(JSFunction)
    case string(String)

    var jsFunction: JSFunction? {
        switch self {
        case let .jsFunction(jsFunction): return jsFunction
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let jsFunction: JSFunction = value.fromJSValue() {
            return .jsFunction(jsFunction)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .jsFunction(jsFunction):
            return jsFunction.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Uint32List: ConvertibleToJSValue {}
extension Uint32Array: Any_Uint32List {}
extension Array: Any_Uint32List where Element == GLuint {}

public enum Uint32List: JSValueCompatible, Any_Uint32List {
    case uint32Array(Uint32Array)
    case seq_of_GLuint([GLuint])

    var uint32Array: Uint32Array? {
        switch self {
        case let .uint32Array(uint32Array): return uint32Array
        default: return nil
        }
    }

    var seq_of_GLuint: [GLuint]? {
        switch self {
        case let .seq_of_GLuint(seq_of_GLuint): return seq_of_GLuint
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let uint32Array: Uint32Array = value.fromJSValue() {
            return .uint32Array(uint32Array)
        }
        if let seq_of_GLuint: [GLuint] = value.fromJSValue() {
            return .seq_of_GLuint(seq_of_GLuint)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .uint32Array(uint32Array):
            return uint32Array.jsValue
        case let .seq_of_GLuint(seq_of_GLuint):
            return seq_of_GLuint.jsValue
        }
    }
}

public protocol Any_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Blob: Any_XMLHttpRequestBodyInit {}
extension BufferSource: Any_XMLHttpRequestBodyInit {}
extension FormData: Any_XMLHttpRequestBodyInit {}
extension String: Any_XMLHttpRequestBodyInit {}
extension URLSearchParams: Any_XMLHttpRequestBodyInit {}

public enum XMLHttpRequestBodyInit: JSValueCompatible, Any_XMLHttpRequestBodyInit {
    case blob(Blob)
    case bufferSource(BufferSource)
    case formData(FormData)
    case string(String)
    case urlSearchParams(URLSearchParams)

    var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    var urlSearchParams: URLSearchParams? {
        switch self {
        case let .urlSearchParams(urlSearchParams): return urlSearchParams
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let urlSearchParams: URLSearchParams = value.fromJSValue() {
            return .urlSearchParams(urlSearchParams)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        case let .urlSearchParams(urlSearchParams):
            return urlSearchParams.jsValue
        }
    }
}

public protocol Any_nullable_Double_or_seq_of_nullable_Double: ConvertibleToJSValue {}
extension Optional: Any_nullable_Double_or_seq_of_nullable_Double where Wrapped == Double {}
extension Array: Any_nullable_Double_or_seq_of_nullable_Double where Element == Double? {}

public enum nullable_Double_or_seq_of_nullable_Double: JSValueCompatible, Any_nullable_Double_or_seq_of_nullable_Double {
    case nullable_Double(Double?)
    case seq_of_nullable_Double([Double?])

    var nullable_Double: Double?? {
        switch self {
        case let .nullable_Double(nullable_Double): return nullable_Double
        default: return nil
        }
    }

    var seq_of_nullable_Double: [Double?]? {
        switch self {
        case let .seq_of_nullable_Double(seq_of_nullable_Double): return seq_of_nullable_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let nullable_Double: Double? = value.fromJSValue() {
            return .nullable_Double(nullable_Double)
        }
        if let seq_of_nullable_Double: [Double?] = value.fromJSValue() {
            return .seq_of_nullable_Double(seq_of_nullable_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .nullable_Double(nullable_Double):
            return nullable_Double.jsValue
        case let .seq_of_nullable_Double(seq_of_nullable_Double):
            return seq_of_nullable_Double.jsValue
        }
    }
}
