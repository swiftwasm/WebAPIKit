// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptKit
import WebAPIBase

#if canImport(JavaScriptEventLoop)
    import JavaScriptEventLoop
#endif
#if canImport(_Concurrency)
    import _Concurrency
#endif

public class Gamepad: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Gamepad].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { self.jsObject = jsObject }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var index: Int32 { jsObject[Strings.index].fromJSValue()! }

    @inlinable public var connected: Bool { jsObject[Strings.connected].fromJSValue()! }

    @inlinable public var timestamp: DOMHighResTimeStamp { jsObject[Strings.timestamp].fromJSValue()! }

    @inlinable public var mapping: GamepadMappingType { jsObject[Strings.mapping].fromJSValue()! }

    @inlinable public var axes: [Double] { jsObject[Strings.axes].fromJSValue()! }

    @inlinable public var buttons: [GamepadButton] { jsObject[Strings.buttons].fromJSValue()! }

    @inlinable public var touches: [GamepadTouch] { jsObject[Strings.touches].fromJSValue()! }

    @inlinable public var vibrationActuator: GamepadHapticActuator {
        jsObject[Strings.vibrationActuator].fromJSValue()!
    }

    @inlinable public var hand: GamepadHand { jsObject[Strings.hand].fromJSValue()! }

    @inlinable public var hapticActuators: [GamepadHapticActuator] { jsObject[Strings.hapticActuators].fromJSValue()! }

    @inlinable public var pose: GamepadPose? { jsObject[Strings.pose].fromJSValue() }
}

public class GamepadButton: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GamepadButton].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { self.jsObject = jsObject }

    @inlinable public var pressed: Bool { jsObject[Strings.pressed].fromJSValue()! }

    @inlinable public var touched: Bool { jsObject[Strings.touched].fromJSValue()! }

    @inlinable public var value: Double { jsObject[Strings.value].fromJSValue()! }
}

open class GamepadEffectParameters: JSDictionaryCompatible {
    public let jsObject: JSObject

    public convenience init(
        duration: UInt64? = nil,
        startDelay: UInt64? = nil,
        strongMagnitude: Double? = nil,
        weakMagnitude: Double? = nil,
        leftTrigger: Double? = nil,
        rightTrigger: Double? = nil
    ) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.duration] = _toJSValue(duration)
        object[Strings.startDelay] = _toJSValue(startDelay)
        object[Strings.strongMagnitude] = _toJSValue(strongMagnitude)
        object[Strings.weakMagnitude] = _toJSValue(weakMagnitude)
        object[Strings.leftTrigger] = _toJSValue(leftTrigger)
        object[Strings.rightTrigger] = _toJSValue(rightTrigger)

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { self.jsObject = object }

    @inlinable public var duration: UInt64 {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }
    @inlinable public var startDelay: UInt64 {
        get { jsObject[Strings.startDelay].fromJSValue()! }
        set { jsObject[Strings.startDelay] = _toJSValue(newValue) }
    }
    @inlinable public var strongMagnitude: Double {
        get { jsObject[Strings.strongMagnitude].fromJSValue()! }
        set { jsObject[Strings.strongMagnitude] = _toJSValue(newValue) }
    }
    @inlinable public var weakMagnitude: Double {
        get { jsObject[Strings.weakMagnitude].fromJSValue()! }
        set { jsObject[Strings.weakMagnitude] = _toJSValue(newValue) }
    }
    @inlinable public var leftTrigger: Double {
        get { jsObject[Strings.leftTrigger].fromJSValue()! }
        set { jsObject[Strings.leftTrigger] = _toJSValue(newValue) }
    }
    @inlinable public var rightTrigger: Double {
        get { jsObject[Strings.rightTrigger].fromJSValue()! }
        set { jsObject[Strings.rightTrigger] = _toJSValue(newValue) }
    }
}
public class GamepadEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.GamepadEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: GamepadEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var gamepad: Gamepad { jsObject[Strings.gamepad].fromJSValue()! }
}

open class GamepadEventInit: EventInit {

    public convenience init(gamepad: Gamepad) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.gamepad] = _toJSValue(gamepad)

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var gamepad: Gamepad {
        get { jsObject[Strings.gamepad].fromJSValue()! }
        set { jsObject[Strings.gamepad] = _toJSValue(newValue) }
    }
}
public enum GamepadHand: JSString, JSValueCompatible {
    case _empty = ""
    case left = "left"
    case right = "right"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { self.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GamepadHapticActuator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GamepadHapticActuator].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { self.jsObject = jsObject }

    @inlinable public var effects: [GamepadHapticEffectType] { jsObject[Strings.effects].fromJSValue()! }

    @inlinable final public func playEffect(
        type: GamepadHapticEffectType,
        params: GamepadEffectParameters? = nil
    ) -> JSPromise {
        let this = jsObject
        return this[Strings.playEffect].function!(this: this, arguments: [_toJSValue(type), _toJSValue(params)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public func playEffect(
            type: GamepadHapticEffectType,
            params: GamepadEffectParameters? = nil
        ) async throws(JSException) -> GamepadHapticsResult {
            let this = jsObject
            let _promise: JSPromise = this[Strings.playEffect].function!(
                this: this,
                arguments: [_toJSValue(type), _toJSValue(params)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public func reset() -> JSPromise {
        let this = jsObject
        return this[Strings.reset].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public func reset()
            async throws(JSException) -> GamepadHapticsResult
        {
            let this = jsObject
            let _promise: JSPromise = this[Strings.reset].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public func pulse(value: Double, duration: Double) -> JSPromise {
        let this = jsObject
        return this[Strings.pulse].function!(this: this, arguments: [_toJSValue(value), _toJSValue(duration)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public func pulse(
            value: Double,
            duration: Double
        ) async throws(JSException) -> Bool {
            let this = jsObject
            let _promise: JSPromise = this[Strings.pulse].function!(
                this: this,
                arguments: [_toJSValue(value), _toJSValue(duration)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

public enum GamepadHapticEffectType: JSString, JSValueCompatible {
    case dualRumble = "dual-rumble"
    case triggerRumble = "trigger-rumble"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { self.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GamepadHapticsResult: JSString, JSValueCompatible {
    case complete = "complete"
    case preempted = "preempted"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { self.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GamepadMappingType: JSString, JSValueCompatible {
    case _empty = ""
    case standard = "standard"
    case xrStandard = "xr-standard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { self.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GamepadPose: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GamepadPose].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { self.jsObject = jsObject }

    @inlinable public var hasOrientation: Bool { jsObject[Strings.hasOrientation].fromJSValue()! }

    @inlinable public var hasPosition: Bool { jsObject[Strings.hasPosition].fromJSValue()! }

    @inlinable public var position: Float32Array? { jsObject[Strings.position].fromJSValue() }

    @inlinable public var linearVelocity: Float32Array? { jsObject[Strings.linearVelocity].fromJSValue() }

    @inlinable public var linearAcceleration: Float32Array? { jsObject[Strings.linearAcceleration].fromJSValue() }

    @inlinable public var orientation: Float32Array? { jsObject[Strings.orientation].fromJSValue() }

    @inlinable public var angularVelocity: Float32Array? { jsObject[Strings.angularVelocity].fromJSValue() }

    @inlinable public var angularAcceleration: Float32Array? { jsObject[Strings.angularAcceleration].fromJSValue() }
}

open class GamepadTouch: JSDictionaryCompatible {
    public let jsObject: JSObject

    public convenience init(
        touchId: UInt32? = nil,
        surfaceId: UInt8? = nil,
        position: DOMPointReadOnly? = nil,
        surfaceDimensions: DOMRectReadOnly?
    ) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.touchId] = _toJSValue(touchId)
        object[Strings.surfaceId] = _toJSValue(surfaceId)
        object[Strings.position] = _toJSValue(position)
        object[Strings.surfaceDimensions] = _toJSValue(surfaceDimensions)

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { self.jsObject = object }

    @inlinable public var touchId: UInt32 {
        get { jsObject[Strings.touchId].fromJSValue()! }
        set { jsObject[Strings.touchId] = _toJSValue(newValue) }
    }
    @inlinable public var surfaceId: UInt8 {
        get { jsObject[Strings.surfaceId].fromJSValue()! }
        set { jsObject[Strings.surfaceId] = _toJSValue(newValue) }
    }
    @inlinable public var position: DOMPointReadOnly {
        get { jsObject[Strings.position].fromJSValue()! }
        set { jsObject[Strings.position] = _toJSValue(newValue) }
    }
    @inlinable public var surfaceDimensions: DOMRectReadOnly? {
        get { jsObject[Strings.surfaceDimensions].fromJSValue() }
        set { jsObject[Strings.surfaceDimensions] = _toJSValue(newValue) }
    }
}
extension Navigator {

    @inlinable final public func getGamepads() -> [Gamepad?] {
        let this = jsObject
        return this[Strings.getGamepads].function!(this: this, arguments: []).fromJSValue()!
    }
}

extension WindowEventHandlers {
    @inlinable public var ongamepadconnected: EventHandler {
        get {
            guard let function = jsObject[Strings.ongamepadconnected].function else { return nil }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[Strings.ongamepadconnected] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ongamepadconnected] = .null
            }
        }
    }

    @inlinable public var ongamepaddisconnected: EventHandler {
        get {
            guard let function = jsObject[Strings.ongamepaddisconnected].function else { return nil }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[Strings.ongamepaddisconnected] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ongamepaddisconnected] = .null
            }
        }
    }
}
@usableFromInline enum Strings {
    @usableFromInline static let _self: JSString = "self"
    @usableFromInline static let `Gamepad`: JSString = "Gamepad"
    @usableFromInline static let `GamepadButton`: JSString = "GamepadButton"
    @usableFromInline static let `GamepadEvent`: JSString = "GamepadEvent"
    @usableFromInline static let `GamepadHapticActuator`: JSString = "GamepadHapticActuator"
    @usableFromInline static let `GamepadPose`: JSString = "GamepadPose"
    @usableFromInline static let `Navigator`: JSString = "Navigator"
    @usableFromInline static let `Object`: JSString = "Object"
    @usableFromInline static let `angularAcceleration`: JSString = "angularAcceleration"
    @usableFromInline static let `angularVelocity`: JSString = "angularVelocity"
    @usableFromInline static let `axes`: JSString = "axes"
    @usableFromInline static let `buttons`: JSString = "buttons"
    @usableFromInline static let `connected`: JSString = "connected"
    @usableFromInline static let `duration`: JSString = "duration"
    @usableFromInline static let `effects`: JSString = "effects"
    @usableFromInline static let `gamepad`: JSString = "gamepad"
    @usableFromInline static let `getGamepads`: JSString = "getGamepads"
    @usableFromInline static let `hand`: JSString = "hand"
    @usableFromInline static let `hapticActuators`: JSString = "hapticActuators"
    @usableFromInline static let `hasOrientation`: JSString = "hasOrientation"
    @usableFromInline static let `hasPosition`: JSString = "hasPosition"
    @usableFromInline static let `id`: JSString = "id"
    @usableFromInline static let `index`: JSString = "index"
    @usableFromInline static let `leftTrigger`: JSString = "leftTrigger"
    @usableFromInline static let `linearAcceleration`: JSString = "linearAcceleration"
    @usableFromInline static let `linearVelocity`: JSString = "linearVelocity"
    @usableFromInline static let `mapping`: JSString = "mapping"
    @usableFromInline static let `ongamepadconnected`: JSString = "ongamepadconnected"
    @usableFromInline static let `ongamepaddisconnected`: JSString = "ongamepaddisconnected"
    @usableFromInline static let `orientation`: JSString = "orientation"
    @usableFromInline static let `playEffect`: JSString = "playEffect"
    @usableFromInline static let `pose`: JSString = "pose"
    @usableFromInline static let `position`: JSString = "position"
    @usableFromInline static let `pressed`: JSString = "pressed"
    @usableFromInline static let `pulse`: JSString = "pulse"
    @usableFromInline static let `reset`: JSString = "reset"
    @usableFromInline static let `rightTrigger`: JSString = "rightTrigger"
    @usableFromInline static let `startDelay`: JSString = "startDelay"
    @usableFromInline static let `strongMagnitude`: JSString = "strongMagnitude"
    @usableFromInline static let `surfaceDimensions`: JSString = "surfaceDimensions"
    @usableFromInline static let `surfaceId`: JSString = "surfaceId"
    @usableFromInline static let `timestamp`: JSString = "timestamp"
    @usableFromInline static let `toString`: JSString = "toString"
    @usableFromInline static let `touchId`: JSString = "touchId"
    @usableFromInline static let `touched`: JSString = "touched"
    @usableFromInline static let `touches`: JSString = "touches"
    @usableFromInline static let `value`: JSString = "value"
    @usableFromInline static let `vibrationActuator`: JSString = "vibrationActuator"
    @usableFromInline static let `weakMagnitude`: JSString = "weakMagnitude"
}
