// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptKit
import WebAnimations
import WebAPIBase
import WebAudio

public typealias GLenum = UInt32
public typealias GLboolean = Bool
public typealias GLbitfield = UInt32
public typealias GLbyte = Int8
public typealias GLshort = Int16
public typealias GLint = Int32
public typealias GLsizei = Int32
public typealias GLsizeiptr = Int64
public typealias GLubyte = UInt8
public typealias GLushort = UInt16
public typealias GLuint = UInt32
public typealias GLfloat = Float
public typealias GLclampf = Float

public class WebGLActiveInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WebGLActiveInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: Strings.size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: Strings.type)
        _name = ReadonlyAttribute(jsObject: jsObject, name: Strings.name)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var size: GLint

    @ReadonlyAttribute
    public var type: GLenum

    @ReadonlyAttribute
    public var name: String
}

public class WebGLBuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLBuffer].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLContextAttributes: BridgedDictionary {
    public convenience init(alpha: Bool, depth: Bool, stencil: Bool, antialias: Bool, premultipliedAlpha: Bool, preserveDrawingBuffer: Bool, powerPreference: WebGLPowerPreference, failIfMajorPerformanceCaveat: Bool, desynchronized: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = alpha.jsValue
        object[Strings.depth] = depth.jsValue
        object[Strings.stencil] = stencil.jsValue
        object[Strings.antialias] = antialias.jsValue
        object[Strings.premultipliedAlpha] = premultipliedAlpha.jsValue
        object[Strings.preserveDrawingBuffer] = preserveDrawingBuffer.jsValue
        object[Strings.powerPreference] = powerPreference.jsValue
        object[Strings.failIfMajorPerformanceCaveat] = failIfMajorPerformanceCaveat.jsValue
        object[Strings.desynchronized] = desynchronized.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: Strings.alpha)
        _depth = ReadWriteAttribute(jsObject: object, name: Strings.depth)
        _stencil = ReadWriteAttribute(jsObject: object, name: Strings.stencil)
        _antialias = ReadWriteAttribute(jsObject: object, name: Strings.antialias)
        _premultipliedAlpha = ReadWriteAttribute(jsObject: object, name: Strings.premultipliedAlpha)
        _preserveDrawingBuffer = ReadWriteAttribute(jsObject: object, name: Strings.preserveDrawingBuffer)
        _powerPreference = ReadWriteAttribute(jsObject: object, name: Strings.powerPreference)
        _failIfMajorPerformanceCaveat = ReadWriteAttribute(jsObject: object, name: Strings.failIfMajorPerformanceCaveat)
        _desynchronized = ReadWriteAttribute(jsObject: object, name: Strings.desynchronized)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool

    @ReadWriteAttribute
    public var depth: Bool

    @ReadWriteAttribute
    public var stencil: Bool

    @ReadWriteAttribute
    public var antialias: Bool

    @ReadWriteAttribute
    public var premultipliedAlpha: Bool

    @ReadWriteAttribute
    public var preserveDrawingBuffer: Bool

    @ReadWriteAttribute
    public var powerPreference: WebGLPowerPreference

    @ReadWriteAttribute
    public var failIfMajorPerformanceCaveat: Bool

    @ReadWriteAttribute
    public var desynchronized: Bool
}

public class WebGLContextEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLContextEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _statusMessage = ReadonlyAttribute(jsObject: jsObject, name: Strings.statusMessage)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInit: WebGLContextEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [type.jsValue, eventInit?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var statusMessage: String
}

public class WebGLContextEventInit: BridgedDictionary {
    public convenience init(statusMessage: String) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.statusMessage] = statusMessage.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _statusMessage = ReadWriteAttribute(jsObject: object, name: Strings.statusMessage)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var statusMessage: String
}

public class WebGLFramebuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLFramebuffer].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

open class WebGLObject: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[Strings.WebGLObject].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public enum WebGLPowerPreference: JSString, JSValueCompatible {
    case `default` = "default"
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class WebGLProgram: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLProgram].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLRenderbuffer: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLRenderbuffer].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLRenderingContext: JSBridgedClass, WebGLRenderingContextBase, WebGLRenderingContextOverloads {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WebGLRenderingContext].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public protocol WebGLRenderingContextBase: JSBridgedClass {}
public extension WebGLRenderingContextBase {
    @inlinable static var DEPTH_BUFFER_BIT: GLenum { 0x0000_0100 }

    @inlinable static var STENCIL_BUFFER_BIT: GLenum { 0x0000_0400 }

    @inlinable static var COLOR_BUFFER_BIT: GLenum { 0x0000_4000 }

    @inlinable static var POINTS: GLenum { 0x0000 }

    @inlinable static var LINES: GLenum { 0x0001 }

    @inlinable static var LINE_LOOP: GLenum { 0x0002 }

    @inlinable static var LINE_STRIP: GLenum { 0x0003 }

    @inlinable static var TRIANGLES: GLenum { 0x0004 }

    @inlinable static var TRIANGLE_STRIP: GLenum { 0x0005 }

    @inlinable static var TRIANGLE_FAN: GLenum { 0x0006 }

    @inlinable static var ZERO: GLenum { 0 }

    @inlinable static var ONE: GLenum { 1 }

    @inlinable static var SRC_COLOR: GLenum { 0x0300 }

    @inlinable static var ONE_MINUS_SRC_COLOR: GLenum { 0x0301 }

    @inlinable static var SRC_ALPHA: GLenum { 0x0302 }

    @inlinable static var ONE_MINUS_SRC_ALPHA: GLenum { 0x0303 }

    @inlinable static var DST_ALPHA: GLenum { 0x0304 }

    @inlinable static var ONE_MINUS_DST_ALPHA: GLenum { 0x0305 }

    @inlinable static var DST_COLOR: GLenum { 0x0306 }

    @inlinable static var ONE_MINUS_DST_COLOR: GLenum { 0x0307 }

    @inlinable static var SRC_ALPHA_SATURATE: GLenum { 0x0308 }

    @inlinable static var FUNC_ADD: GLenum { 0x8006 }

    @inlinable static var BLEND_EQUATION: GLenum { 0x8009 }

    @inlinable static var BLEND_EQUATION_RGB: GLenum { 0x8009 }

    @inlinable static var BLEND_EQUATION_ALPHA: GLenum { 0x883D }

    @inlinable static var FUNC_SUBTRACT: GLenum { 0x800A }

    @inlinable static var FUNC_REVERSE_SUBTRACT: GLenum { 0x800B }

    @inlinable static var BLEND_DST_RGB: GLenum { 0x80C8 }

    @inlinable static var BLEND_SRC_RGB: GLenum { 0x80C9 }

    @inlinable static var BLEND_DST_ALPHA: GLenum { 0x80CA }

    @inlinable static var BLEND_SRC_ALPHA: GLenum { 0x80CB }

    @inlinable static var CONSTANT_COLOR: GLenum { 0x8001 }

    @inlinable static var ONE_MINUS_CONSTANT_COLOR: GLenum { 0x8002 }

    @inlinable static var CONSTANT_ALPHA: GLenum { 0x8003 }

    @inlinable static var ONE_MINUS_CONSTANT_ALPHA: GLenum { 0x8004 }

    @inlinable static var BLEND_COLOR: GLenum { 0x8005 }

    @inlinable static var ARRAY_BUFFER: GLenum { 0x8892 }

    @inlinable static var ELEMENT_ARRAY_BUFFER: GLenum { 0x8893 }

    @inlinable static var ARRAY_BUFFER_BINDING: GLenum { 0x8894 }

    @inlinable static var ELEMENT_ARRAY_BUFFER_BINDING: GLenum { 0x8895 }

    @inlinable static var STREAM_DRAW: GLenum { 0x88E0 }

    @inlinable static var STATIC_DRAW: GLenum { 0x88E4 }

    @inlinable static var DYNAMIC_DRAW: GLenum { 0x88E8 }

    @inlinable static var BUFFER_SIZE: GLenum { 0x8764 }

    @inlinable static var BUFFER_USAGE: GLenum { 0x8765 }

    @inlinable static var CURRENT_VERTEX_ATTRIB: GLenum { 0x8626 }

    @inlinable static var FRONT: GLenum { 0x0404 }

    @inlinable static var BACK: GLenum { 0x0405 }

    @inlinable static var FRONT_AND_BACK: GLenum { 0x0408 }

    @inlinable static var CULL_FACE: GLenum { 0x0B44 }

    @inlinable static var BLEND: GLenum { 0x0BE2 }

    @inlinable static var DITHER: GLenum { 0x0BD0 }

    @inlinable static var STENCIL_TEST: GLenum { 0x0B90 }

    @inlinable static var DEPTH_TEST: GLenum { 0x0B71 }

    @inlinable static var SCISSOR_TEST: GLenum { 0x0C11 }

    @inlinable static var POLYGON_OFFSET_FILL: GLenum { 0x8037 }

    @inlinable static var SAMPLE_ALPHA_TO_COVERAGE: GLenum { 0x809E }

    @inlinable static var SAMPLE_COVERAGE: GLenum { 0x80A0 }

    @inlinable static var NO_ERROR: GLenum { 0 }

    @inlinable static var INVALID_ENUM: GLenum { 0x0500 }

    @inlinable static var INVALID_VALUE: GLenum { 0x0501 }

    @inlinable static var INVALID_OPERATION: GLenum { 0x0502 }

    @inlinable static var OUT_OF_MEMORY: GLenum { 0x0505 }

    @inlinable static var CW: GLenum { 0x0900 }

    @inlinable static var CCW: GLenum { 0x0901 }

    @inlinable static var LINE_WIDTH: GLenum { 0x0B21 }

    @inlinable static var ALIASED_POINT_SIZE_RANGE: GLenum { 0x846D }

    @inlinable static var ALIASED_LINE_WIDTH_RANGE: GLenum { 0x846E }

    @inlinable static var CULL_FACE_MODE: GLenum { 0x0B45 }

    @inlinable static var FRONT_FACE: GLenum { 0x0B46 }

    @inlinable static var DEPTH_RANGE: GLenum { 0x0B70 }

    @inlinable static var DEPTH_WRITEMASK: GLenum { 0x0B72 }

    @inlinable static var DEPTH_CLEAR_VALUE: GLenum { 0x0B73 }

    @inlinable static var DEPTH_FUNC: GLenum { 0x0B74 }

    @inlinable static var STENCIL_CLEAR_VALUE: GLenum { 0x0B91 }

    @inlinable static var STENCIL_FUNC: GLenum { 0x0B92 }

    @inlinable static var STENCIL_FAIL: GLenum { 0x0B94 }

    @inlinable static var STENCIL_PASS_DEPTH_FAIL: GLenum { 0x0B95 }

    @inlinable static var STENCIL_PASS_DEPTH_PASS: GLenum { 0x0B96 }

    @inlinable static var STENCIL_REF: GLenum { 0x0B97 }

    @inlinable static var STENCIL_VALUE_MASK: GLenum { 0x0B93 }

    @inlinable static var STENCIL_WRITEMASK: GLenum { 0x0B98 }

    @inlinable static var STENCIL_BACK_FUNC: GLenum { 0x8800 }

    @inlinable static var STENCIL_BACK_FAIL: GLenum { 0x8801 }

    @inlinable static var STENCIL_BACK_PASS_DEPTH_FAIL: GLenum { 0x8802 }

    @inlinable static var STENCIL_BACK_PASS_DEPTH_PASS: GLenum { 0x8803 }

    @inlinable static var STENCIL_BACK_REF: GLenum { 0x8CA3 }

    @inlinable static var STENCIL_BACK_VALUE_MASK: GLenum { 0x8CA4 }

    @inlinable static var STENCIL_BACK_WRITEMASK: GLenum { 0x8CA5 }

    @inlinable static var VIEWPORT: GLenum { 0x0BA2 }

    @inlinable static var SCISSOR_BOX: GLenum { 0x0C10 }

    @inlinable static var COLOR_CLEAR_VALUE: GLenum { 0x0C22 }

    @inlinable static var COLOR_WRITEMASK: GLenum { 0x0C23 }

    @inlinable static var UNPACK_ALIGNMENT: GLenum { 0x0CF5 }

    @inlinable static var PACK_ALIGNMENT: GLenum { 0x0D05 }

    @inlinable static var MAX_TEXTURE_SIZE: GLenum { 0x0D33 }

    @inlinable static var MAX_VIEWPORT_DIMS: GLenum { 0x0D3A }

    @inlinable static var SUBPIXEL_BITS: GLenum { 0x0D50 }

    @inlinable static var RED_BITS: GLenum { 0x0D52 }

    @inlinable static var GREEN_BITS: GLenum { 0x0D53 }

    @inlinable static var BLUE_BITS: GLenum { 0x0D54 }

    @inlinable static var ALPHA_BITS: GLenum { 0x0D55 }

    @inlinable static var DEPTH_BITS: GLenum { 0x0D56 }

    @inlinable static var STENCIL_BITS: GLenum { 0x0D57 }

    @inlinable static var POLYGON_OFFSET_UNITS: GLenum { 0x2A00 }

    @inlinable static var POLYGON_OFFSET_FACTOR: GLenum { 0x8038 }

    @inlinable static var TEXTURE_BINDING_2D: GLenum { 0x8069 }

    @inlinable static var SAMPLE_BUFFERS: GLenum { 0x80A8 }

    @inlinable static var SAMPLES: GLenum { 0x80A9 }

    @inlinable static var SAMPLE_COVERAGE_VALUE: GLenum { 0x80AA }

    @inlinable static var SAMPLE_COVERAGE_INVERT: GLenum { 0x80AB }

    @inlinable static var COMPRESSED_TEXTURE_FORMATS: GLenum { 0x86A3 }

    @inlinable static var DONT_CARE: GLenum { 0x1100 }

    @inlinable static var FASTEST: GLenum { 0x1101 }

    @inlinable static var NICEST: GLenum { 0x1102 }

    @inlinable static var GENERATE_MIPMAP_HINT: GLenum { 0x8192 }

    @inlinable static var BYTE: GLenum { 0x1400 }

    @inlinable static var UNSIGNED_BYTE: GLenum { 0x1401 }

    @inlinable static var SHORT: GLenum { 0x1402 }

    @inlinable static var UNSIGNED_SHORT: GLenum { 0x1403 }

    @inlinable static var INT: GLenum { 0x1404 }

    @inlinable static var UNSIGNED_INT: GLenum { 0x1405 }

    @inlinable static var FLOAT: GLenum { 0x1406 }

    @inlinable static var DEPTH_COMPONENT: GLenum { 0x1902 }

    @inlinable static var ALPHA: GLenum { 0x1906 }

    @inlinable static var RGB: GLenum { 0x1907 }

    @inlinable static var RGBA: GLenum { 0x1908 }

    @inlinable static var LUMINANCE: GLenum { 0x1909 }

    @inlinable static var LUMINANCE_ALPHA: GLenum { 0x190A }

    @inlinable static var UNSIGNED_SHORT_4_4_4_4: GLenum { 0x8033 }

    @inlinable static var UNSIGNED_SHORT_5_5_5_1: GLenum { 0x8034 }

    @inlinable static var UNSIGNED_SHORT_5_6_5: GLenum { 0x8363 }

    @inlinable static var FRAGMENT_SHADER: GLenum { 0x8B30 }

    @inlinable static var VERTEX_SHADER: GLenum { 0x8B31 }

    @inlinable static var MAX_VERTEX_ATTRIBS: GLenum { 0x8869 }

    @inlinable static var MAX_VERTEX_UNIFORM_VECTORS: GLenum { 0x8DFB }

    @inlinable static var MAX_VARYING_VECTORS: GLenum { 0x8DFC }

    @inlinable static var MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum { 0x8B4D }

    @inlinable static var MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum { 0x8B4C }

    @inlinable static var MAX_TEXTURE_IMAGE_UNITS: GLenum { 0x8872 }

    @inlinable static var MAX_FRAGMENT_UNIFORM_VECTORS: GLenum { 0x8DFD }

    @inlinable static var SHADER_TYPE: GLenum { 0x8B4F }

    @inlinable static var DELETE_STATUS: GLenum { 0x8B80 }

    @inlinable static var LINK_STATUS: GLenum { 0x8B82 }

    @inlinable static var VALIDATE_STATUS: GLenum { 0x8B83 }

    @inlinable static var ATTACHED_SHADERS: GLenum { 0x8B85 }

    @inlinable static var ACTIVE_UNIFORMS: GLenum { 0x8B86 }

    @inlinable static var ACTIVE_ATTRIBUTES: GLenum { 0x8B89 }

    @inlinable static var SHADING_LANGUAGE_VERSION: GLenum { 0x8B8C }

    @inlinable static var CURRENT_PROGRAM: GLenum { 0x8B8D }

    @inlinable static var NEVER: GLenum { 0x0200 }

    @inlinable static var LESS: GLenum { 0x0201 }

    @inlinable static var EQUAL: GLenum { 0x0202 }

    @inlinable static var LEQUAL: GLenum { 0x0203 }

    @inlinable static var GREATER: GLenum { 0x0204 }

    @inlinable static var NOTEQUAL: GLenum { 0x0205 }

    @inlinable static var GEQUAL: GLenum { 0x0206 }

    @inlinable static var ALWAYS: GLenum { 0x0207 }

    @inlinable static var KEEP: GLenum { 0x1E00 }

    @inlinable static var REPLACE: GLenum { 0x1E01 }

    @inlinable static var INCR: GLenum { 0x1E02 }

    @inlinable static var DECR: GLenum { 0x1E03 }

    @inlinable static var INVERT: GLenum { 0x150A }

    @inlinable static var INCR_WRAP: GLenum { 0x8507 }

    @inlinable static var DECR_WRAP: GLenum { 0x8508 }

    @inlinable static var VENDOR: GLenum { 0x1F00 }

    @inlinable static var RENDERER: GLenum { 0x1F01 }

    @inlinable static var VERSION: GLenum { 0x1F02 }

    @inlinable static var NEAREST: GLenum { 0x2600 }

    @inlinable static var LINEAR: GLenum { 0x2601 }

    @inlinable static var NEAREST_MIPMAP_NEAREST: GLenum { 0x2700 }

    @inlinable static var LINEAR_MIPMAP_NEAREST: GLenum { 0x2701 }

    @inlinable static var NEAREST_MIPMAP_LINEAR: GLenum { 0x2702 }

    @inlinable static var LINEAR_MIPMAP_LINEAR: GLenum { 0x2703 }

    @inlinable static var TEXTURE_MAG_FILTER: GLenum { 0x2800 }

    @inlinable static var TEXTURE_MIN_FILTER: GLenum { 0x2801 }

    @inlinable static var TEXTURE_WRAP_S: GLenum { 0x2802 }

    @inlinable static var TEXTURE_WRAP_T: GLenum { 0x2803 }

    @inlinable static var TEXTURE_2D: GLenum { 0x0DE1 }

    @inlinable static var TEXTURE: GLenum { 0x1702 }

    @inlinable static var TEXTURE_CUBE_MAP: GLenum { 0x8513 }

    @inlinable static var TEXTURE_BINDING_CUBE_MAP: GLenum { 0x8514 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_X: GLenum { 0x8515 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum { 0x8516 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum { 0x8517 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum { 0x8518 }

    @inlinable static var TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum { 0x8519 }

    @inlinable static var TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum { 0x851A }

    @inlinable static var MAX_CUBE_MAP_TEXTURE_SIZE: GLenum { 0x851C }

    @inlinable static var TEXTURE0: GLenum { 0x84C0 }

    @inlinable static var TEXTURE1: GLenum { 0x84C1 }

    @inlinable static var TEXTURE2: GLenum { 0x84C2 }

    @inlinable static var TEXTURE3: GLenum { 0x84C3 }

    @inlinable static var TEXTURE4: GLenum { 0x84C4 }

    @inlinable static var TEXTURE5: GLenum { 0x84C5 }

    @inlinable static var TEXTURE6: GLenum { 0x84C6 }

    @inlinable static var TEXTURE7: GLenum { 0x84C7 }

    @inlinable static var TEXTURE8: GLenum { 0x84C8 }

    @inlinable static var TEXTURE9: GLenum { 0x84C9 }

    @inlinable static var TEXTURE10: GLenum { 0x84CA }

    @inlinable static var TEXTURE11: GLenum { 0x84CB }

    @inlinable static var TEXTURE12: GLenum { 0x84CC }

    @inlinable static var TEXTURE13: GLenum { 0x84CD }

    @inlinable static var TEXTURE14: GLenum { 0x84CE }

    @inlinable static var TEXTURE15: GLenum { 0x84CF }

    @inlinable static var TEXTURE16: GLenum { 0x84D0 }

    @inlinable static var TEXTURE17: GLenum { 0x84D1 }

    @inlinable static var TEXTURE18: GLenum { 0x84D2 }

    @inlinable static var TEXTURE19: GLenum { 0x84D3 }

    @inlinable static var TEXTURE20: GLenum { 0x84D4 }

    @inlinable static var TEXTURE21: GLenum { 0x84D5 }

    @inlinable static var TEXTURE22: GLenum { 0x84D6 }

    @inlinable static var TEXTURE23: GLenum { 0x84D7 }

    @inlinable static var TEXTURE24: GLenum { 0x84D8 }

    @inlinable static var TEXTURE25: GLenum { 0x84D9 }

    @inlinable static var TEXTURE26: GLenum { 0x84DA }

    @inlinable static var TEXTURE27: GLenum { 0x84DB }

    @inlinable static var TEXTURE28: GLenum { 0x84DC }

    @inlinable static var TEXTURE29: GLenum { 0x84DD }

    @inlinable static var TEXTURE30: GLenum { 0x84DE }

    @inlinable static var TEXTURE31: GLenum { 0x84DF }

    @inlinable static var ACTIVE_TEXTURE: GLenum { 0x84E0 }

    @inlinable static var REPEAT: GLenum { 0x2901 }

    @inlinable static var CLAMP_TO_EDGE: GLenum { 0x812F }

    @inlinable static var MIRRORED_REPEAT: GLenum { 0x8370 }

    @inlinable static var FLOAT_VEC2: GLenum { 0x8B50 }

    @inlinable static var FLOAT_VEC3: GLenum { 0x8B51 }

    @inlinable static var FLOAT_VEC4: GLenum { 0x8B52 }

    @inlinable static var INT_VEC2: GLenum { 0x8B53 }

    @inlinable static var INT_VEC3: GLenum { 0x8B54 }

    @inlinable static var INT_VEC4: GLenum { 0x8B55 }

    @inlinable static var BOOL: GLenum { 0x8B56 }

    @inlinable static var BOOL_VEC2: GLenum { 0x8B57 }

    @inlinable static var BOOL_VEC3: GLenum { 0x8B58 }

    @inlinable static var BOOL_VEC4: GLenum { 0x8B59 }

    @inlinable static var FLOAT_MAT2: GLenum { 0x8B5A }

    @inlinable static var FLOAT_MAT3: GLenum { 0x8B5B }

    @inlinable static var FLOAT_MAT4: GLenum { 0x8B5C }

    @inlinable static var SAMPLER_2D: GLenum { 0x8B5E }

    @inlinable static var SAMPLER_CUBE: GLenum { 0x8B60 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_ENABLED: GLenum { 0x8622 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_SIZE: GLenum { 0x8623 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_STRIDE: GLenum { 0x8624 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_TYPE: GLenum { 0x8625 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum { 0x886A }

    @inlinable static var VERTEX_ATTRIB_ARRAY_POINTER: GLenum { 0x8645 }

    @inlinable static var VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum { 0x889F }

    @inlinable static var IMPLEMENTATION_COLOR_READ_TYPE: GLenum { 0x8B9A }

    @inlinable static var IMPLEMENTATION_COLOR_READ_FORMAT: GLenum { 0x8B9B }

    @inlinable static var COMPILE_STATUS: GLenum { 0x8B81 }

    @inlinable static var LOW_FLOAT: GLenum { 0x8DF0 }

    @inlinable static var MEDIUM_FLOAT: GLenum { 0x8DF1 }

    @inlinable static var HIGH_FLOAT: GLenum { 0x8DF2 }

    @inlinable static var LOW_INT: GLenum { 0x8DF3 }

    @inlinable static var MEDIUM_INT: GLenum { 0x8DF4 }

    @inlinable static var HIGH_INT: GLenum { 0x8DF5 }

    @inlinable static var FRAMEBUFFER: GLenum { 0x8D40 }

    @inlinable static var RENDERBUFFER: GLenum { 0x8D41 }

    @inlinable static var RGBA4: GLenum { 0x8056 }

    @inlinable static var RGB5_A1: GLenum { 0x8057 }

    @inlinable static var RGB565: GLenum { 0x8D62 }

    @inlinable static var DEPTH_COMPONENT16: GLenum { 0x81A5 }

    @inlinable static var STENCIL_INDEX8: GLenum { 0x8D48 }

    @inlinable static var DEPTH_STENCIL: GLenum { 0x84F9 }

    @inlinable static var RENDERBUFFER_WIDTH: GLenum { 0x8D42 }

    @inlinable static var RENDERBUFFER_HEIGHT: GLenum { 0x8D43 }

    @inlinable static var RENDERBUFFER_INTERNAL_FORMAT: GLenum { 0x8D44 }

    @inlinable static var RENDERBUFFER_RED_SIZE: GLenum { 0x8D50 }

    @inlinable static var RENDERBUFFER_GREEN_SIZE: GLenum { 0x8D51 }

    @inlinable static var RENDERBUFFER_BLUE_SIZE: GLenum { 0x8D52 }

    @inlinable static var RENDERBUFFER_ALPHA_SIZE: GLenum { 0x8D53 }

    @inlinable static var RENDERBUFFER_DEPTH_SIZE: GLenum { 0x8D54 }

    @inlinable static var RENDERBUFFER_STENCIL_SIZE: GLenum { 0x8D55 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum { 0x8CD0 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum { 0x8CD1 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum { 0x8CD2 }

    @inlinable static var FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum { 0x8CD3 }

    @inlinable static var COLOR_ATTACHMENT0: GLenum { 0x8CE0 }

    @inlinable static var DEPTH_ATTACHMENT: GLenum { 0x8D00 }

    @inlinable static var STENCIL_ATTACHMENT: GLenum { 0x8D20 }

    @inlinable static var DEPTH_STENCIL_ATTACHMENT: GLenum { 0x821A }

    @inlinable static var NONE: GLenum { 0 }

    @inlinable static var FRAMEBUFFER_COMPLETE: GLenum { 0x8CD5 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum { 0x8CD6 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum { 0x8CD7 }

    @inlinable static var FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum { 0x8CD9 }

    @inlinable static var FRAMEBUFFER_UNSUPPORTED: GLenum { 0x8CDD }

    @inlinable static var FRAMEBUFFER_BINDING: GLenum { 0x8CA6 }

    @inlinable static var RENDERBUFFER_BINDING: GLenum { 0x8CA7 }

    @inlinable static var MAX_RENDERBUFFER_SIZE: GLenum { 0x84E8 }

    @inlinable static var INVALID_FRAMEBUFFER_OPERATION: GLenum { 0x0506 }

    @inlinable static var UNPACK_FLIP_Y_WEBGL: GLenum { 0x9240 }

    @inlinable static var UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum { 0x9241 }

    @inlinable static var CONTEXT_LOST_WEBGL: GLenum { 0x9242 }

    @inlinable static var UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum { 0x9243 }

    @inlinable static var BROWSER_DEFAULT_WEBGL: GLenum { 0x9244 }

    @inlinable var canvas: HTMLCanvasElement_or_OffscreenCanvas { jsObject[Strings.canvas].fromJSValue()! }

    @inlinable var drawingBufferWidth: GLsizei { jsObject[Strings.drawingBufferWidth].fromJSValue()! }

    @inlinable var drawingBufferHeight: GLsizei { jsObject[Strings.drawingBufferHeight].fromJSValue()! }

    @inlinable func getContextAttributes() -> WebGLContextAttributes? {
        let this = jsObject
        return this[Strings.getContextAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func isContextLost() -> Bool {
        let this = jsObject
        return this[Strings.isContextLost].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getSupportedExtensions() -> [String]? {
        let this = jsObject
        return this[Strings.getSupportedExtensions].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getExtension(name: String) -> JSObject? {
        let this = jsObject
        return this[Strings.getExtension].function!(this: this, arguments: [name.jsValue]).fromJSValue()!
    }

    @inlinable func activeTexture(texture: GLenum) {
        let this = jsObject
        _ = this[Strings.activeTexture].function!(this: this, arguments: [texture.jsValue])
    }

    @inlinable func attachShader(program: WebGLProgram, shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.attachShader].function!(this: this, arguments: [program.jsValue, shader.jsValue])
    }

    @inlinable func bindAttribLocation(program: WebGLProgram, index: GLuint, name: String) {
        let this = jsObject
        _ = this[Strings.bindAttribLocation].function!(this: this, arguments: [program.jsValue, index.jsValue, name.jsValue])
    }

    @inlinable func bindBuffer(target: GLenum, buffer: WebGLBuffer?) {
        let this = jsObject
        _ = this[Strings.bindBuffer].function!(this: this, arguments: [target.jsValue, buffer.jsValue])
    }

    @inlinable func bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer?) {
        let this = jsObject
        _ = this[Strings.bindFramebuffer].function!(this: this, arguments: [target.jsValue, framebuffer.jsValue])
    }

    @inlinable func bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.bindRenderbuffer].function!(this: this, arguments: [target.jsValue, renderbuffer.jsValue])
    }

    @inlinable func bindTexture(target: GLenum, texture: WebGLTexture?) {
        let this = jsObject
        _ = this[Strings.bindTexture].function!(this: this, arguments: [target.jsValue, texture.jsValue])
    }

    @inlinable func blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf) {
        let this = jsObject
        _ = this[Strings.blendColor].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func blendEquation(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.blendEquation].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) {
        let this = jsObject
        _ = this[Strings.blendEquationSeparate].function!(this: this, arguments: [modeRGB.jsValue, modeAlpha.jsValue])
    }

    @inlinable func blendFunc(sfactor: GLenum, dfactor: GLenum) {
        let this = jsObject
        _ = this[Strings.blendFunc].function!(this: this, arguments: [sfactor.jsValue, dfactor.jsValue])
    }

    @inlinable func blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) {
        let this = jsObject
        _ = this[Strings.blendFuncSeparate].function!(this: this, arguments: [srcRGB.jsValue, dstRGB.jsValue, srcAlpha.jsValue, dstAlpha.jsValue])
    }

    @inlinable func checkFramebufferStatus(target: GLenum) -> GLenum {
        let this = jsObject
        return this[Strings.checkFramebufferStatus].function!(this: this, arguments: [target.jsValue]).fromJSValue()!
    }

    @inlinable func clear(mask: GLbitfield) {
        let this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [mask.jsValue])
    }

    @inlinable func clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf) {
        let this = jsObject
        _ = this[Strings.clearColor].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func clearDepth(depth: GLclampf) {
        let this = jsObject
        _ = this[Strings.clearDepth].function!(this: this, arguments: [depth.jsValue])
    }

    @inlinable func clearStencil(s: GLint) {
        let this = jsObject
        _ = this[Strings.clearStencil].function!(this: this, arguments: [s.jsValue])
    }

    @inlinable func colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {
        let this = jsObject
        _ = this[Strings.colorMask].function!(this: this, arguments: [red.jsValue, green.jsValue, blue.jsValue, alpha.jsValue])
    }

    @inlinable func compileShader(shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.compileShader].function!(this: this, arguments: [shader.jsValue])
    }

    @inlinable func copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = x.jsValue
        let _arg4 = y.jsValue
        let _arg5 = width.jsValue
        let _arg6 = height.jsValue
        let _arg7 = border.jsValue
        let this = jsObject
        _ = this[Strings.copyTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = x.jsValue
        let _arg5 = y.jsValue
        let _arg6 = width.jsValue
        let _arg7 = height.jsValue
        let this = jsObject
        _ = this[Strings.copyTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func createBuffer() -> WebGLBuffer? {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createFramebuffer() -> WebGLFramebuffer? {
        let this = jsObject
        return this[Strings.createFramebuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createProgram() -> WebGLProgram? {
        let this = jsObject
        return this[Strings.createProgram].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createRenderbuffer() -> WebGLRenderbuffer? {
        let this = jsObject
        return this[Strings.createRenderbuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func createShader(type: GLenum) -> WebGLShader? {
        let this = jsObject
        return this[Strings.createShader].function!(this: this, arguments: [type.jsValue]).fromJSValue()!
    }

    @inlinable func createTexture() -> WebGLTexture? {
        let this = jsObject
        return this[Strings.createTexture].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func cullFace(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.cullFace].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func deleteBuffer(buffer: WebGLBuffer?) {
        let this = jsObject
        _ = this[Strings.deleteBuffer].function!(this: this, arguments: [buffer.jsValue])
    }

    @inlinable func deleteFramebuffer(framebuffer: WebGLFramebuffer?) {
        let this = jsObject
        _ = this[Strings.deleteFramebuffer].function!(this: this, arguments: [framebuffer.jsValue])
    }

    @inlinable func deleteProgram(program: WebGLProgram?) {
        let this = jsObject
        _ = this[Strings.deleteProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.deleteRenderbuffer].function!(this: this, arguments: [renderbuffer.jsValue])
    }

    @inlinable func deleteShader(shader: WebGLShader?) {
        let this = jsObject
        _ = this[Strings.deleteShader].function!(this: this, arguments: [shader.jsValue])
    }

    @inlinable func deleteTexture(texture: WebGLTexture?) {
        let this = jsObject
        _ = this[Strings.deleteTexture].function!(this: this, arguments: [texture.jsValue])
    }

    @inlinable func depthFunc(func: GLenum) {
        let this = jsObject
        _ = this[Strings.depthFunc].function!(this: this, arguments: [`func`.jsValue])
    }

    @inlinable func depthMask(flag: GLboolean) {
        let this = jsObject
        _ = this[Strings.depthMask].function!(this: this, arguments: [flag.jsValue])
    }

    @inlinable func depthRange(zNear: GLclampf, zFar: GLclampf) {
        let this = jsObject
        _ = this[Strings.depthRange].function!(this: this, arguments: [zNear.jsValue, zFar.jsValue])
    }

    @inlinable func detachShader(program: WebGLProgram, shader: WebGLShader) {
        let this = jsObject
        _ = this[Strings.detachShader].function!(this: this, arguments: [program.jsValue, shader.jsValue])
    }

    @inlinable func disable(cap: GLenum) {
        let this = jsObject
        _ = this[Strings.disable].function!(this: this, arguments: [cap.jsValue])
    }

    @inlinable func disableVertexAttribArray(index: GLuint) {
        let this = jsObject
        _ = this[Strings.disableVertexAttribArray].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable func drawArrays(mode: GLenum, first: GLint, count: GLsizei) {
        let this = jsObject
        _ = this[Strings.drawArrays].function!(this: this, arguments: [mode.jsValue, first.jsValue, count.jsValue])
    }

    @inlinable func drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr) {
        let this = jsObject
        _ = this[Strings.drawElements].function!(this: this, arguments: [mode.jsValue, count.jsValue, type.jsValue, offset.jsValue])
    }

    @inlinable func enable(cap: GLenum) {
        let this = jsObject
        _ = this[Strings.enable].function!(this: this, arguments: [cap.jsValue])
    }

    @inlinable func enableVertexAttribArray(index: GLuint) {
        let this = jsObject
        _ = this[Strings.enableVertexAttribArray].function!(this: this, arguments: [index.jsValue])
    }

    @inlinable func finish() {
        let this = jsObject
        _ = this[Strings.finish].function!(this: this, arguments: [])
    }

    @inlinable func flush() {
        let this = jsObject
        _ = this[Strings.flush].function!(this: this, arguments: [])
    }

    @inlinable func framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer?) {
        let this = jsObject
        _ = this[Strings.framebufferRenderbuffer].function!(this: this, arguments: [target.jsValue, attachment.jsValue, renderbuffertarget.jsValue, renderbuffer.jsValue])
    }

    @inlinable func framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture?, level: GLint) {
        let this = jsObject
        _ = this[Strings.framebufferTexture2D].function!(this: this, arguments: [target.jsValue, attachment.jsValue, textarget.jsValue, texture.jsValue, level.jsValue])
    }

    @inlinable func frontFace(mode: GLenum) {
        let this = jsObject
        _ = this[Strings.frontFace].function!(this: this, arguments: [mode.jsValue])
    }

    @inlinable func generateMipmap(target: GLenum) {
        let this = jsObject
        _ = this[Strings.generateMipmap].function!(this: this, arguments: [target.jsValue])
    }

    @inlinable func getActiveAttrib(program: WebGLProgram, index: GLuint) -> WebGLActiveInfo? {
        let this = jsObject
        return this[Strings.getActiveAttrib].function!(this: this, arguments: [program.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func getActiveUniform(program: WebGLProgram, index: GLuint) -> WebGLActiveInfo? {
        let this = jsObject
        return this[Strings.getActiveUniform].function!(this: this, arguments: [program.jsValue, index.jsValue]).fromJSValue()!
    }

    @inlinable func getAttachedShaders(program: WebGLProgram) -> [WebGLShader]? {
        let this = jsObject
        return this[Strings.getAttachedShaders].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func getAttribLocation(program: WebGLProgram, name: String) -> GLint {
        let this = jsObject
        return this[Strings.getAttribLocation].function!(this: this, arguments: [program.jsValue, name.jsValue]).fromJSValue()!
    }

    @inlinable func getBufferParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getBufferParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getParameter(pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getParameter].function!(this: this, arguments: [pname.jsValue]).fromJSValue()!
    }

    @inlinable func getError() -> GLenum {
        let this = jsObject
        return this[Strings.getError].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable func getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getFramebufferAttachmentParameter].function!(this: this, arguments: [target.jsValue, attachment.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getProgramParameter(program: WebGLProgram, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getProgramParameter].function!(this: this, arguments: [program.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getProgramInfoLog(program: WebGLProgram) -> String? {
        let this = jsObject
        return this[Strings.getProgramInfoLog].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func getRenderbufferParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getRenderbufferParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderParameter(shader: WebGLShader, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getShaderParameter].function!(this: this, arguments: [shader.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum) -> WebGLShaderPrecisionFormat? {
        let this = jsObject
        return this[Strings.getShaderPrecisionFormat].function!(this: this, arguments: [shadertype.jsValue, precisiontype.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderInfoLog(shader: WebGLShader) -> String? {
        let this = jsObject
        return this[Strings.getShaderInfoLog].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func getShaderSource(shader: WebGLShader) -> String? {
        let this = jsObject
        return this[Strings.getShaderSource].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func getTexParameter(target: GLenum, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getTexParameter].function!(this: this, arguments: [target.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getUniform(program: WebGLProgram, location: WebGLUniformLocation) -> JSValue {
        let this = jsObject
        return this[Strings.getUniform].function!(this: this, arguments: [program.jsValue, location.jsValue]).fromJSValue()!
    }

    @inlinable func getUniformLocation(program: WebGLProgram, name: String) -> WebGLUniformLocation? {
        let this = jsObject
        return this[Strings.getUniformLocation].function!(this: this, arguments: [program.jsValue, name.jsValue]).fromJSValue()!
    }

    @inlinable func getVertexAttrib(index: GLuint, pname: GLenum) -> JSValue {
        let this = jsObject
        return this[Strings.getVertexAttrib].function!(this: this, arguments: [index.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func getVertexAttribOffset(index: GLuint, pname: GLenum) -> GLintptr {
        let this = jsObject
        return this[Strings.getVertexAttribOffset].function!(this: this, arguments: [index.jsValue, pname.jsValue]).fromJSValue()!
    }

    @inlinable func hint(target: GLenum, mode: GLenum) {
        let this = jsObject
        _ = this[Strings.hint].function!(this: this, arguments: [target.jsValue, mode.jsValue])
    }

    @inlinable func isBuffer(buffer: WebGLBuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isBuffer].function!(this: this, arguments: [buffer.jsValue]).fromJSValue()!
    }

    @inlinable func isEnabled(cap: GLenum) -> GLboolean {
        let this = jsObject
        return this[Strings.isEnabled].function!(this: this, arguments: [cap.jsValue]).fromJSValue()!
    }

    @inlinable func isFramebuffer(framebuffer: WebGLFramebuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isFramebuffer].function!(this: this, arguments: [framebuffer.jsValue]).fromJSValue()!
    }

    @inlinable func isProgram(program: WebGLProgram?) -> GLboolean {
        let this = jsObject
        return this[Strings.isProgram].function!(this: this, arguments: [program.jsValue]).fromJSValue()!
    }

    @inlinable func isRenderbuffer(renderbuffer: WebGLRenderbuffer?) -> GLboolean {
        let this = jsObject
        return this[Strings.isRenderbuffer].function!(this: this, arguments: [renderbuffer.jsValue]).fromJSValue()!
    }

    @inlinable func isShader(shader: WebGLShader?) -> GLboolean {
        let this = jsObject
        return this[Strings.isShader].function!(this: this, arguments: [shader.jsValue]).fromJSValue()!
    }

    @inlinable func isTexture(texture: WebGLTexture?) -> GLboolean {
        let this = jsObject
        return this[Strings.isTexture].function!(this: this, arguments: [texture.jsValue]).fromJSValue()!
    }

    @inlinable func lineWidth(width: GLfloat) {
        let this = jsObject
        _ = this[Strings.lineWidth].function!(this: this, arguments: [width.jsValue])
    }

    @inlinable func linkProgram(program: WebGLProgram) {
        let this = jsObject
        _ = this[Strings.linkProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func pixelStorei(pname: GLenum, param: GLint) {
        let this = jsObject
        _ = this[Strings.pixelStorei].function!(this: this, arguments: [pname.jsValue, param.jsValue])
    }

    @inlinable func polygonOffset(factor: GLfloat, units: GLfloat) {
        let this = jsObject
        _ = this[Strings.polygonOffset].function!(this: this, arguments: [factor.jsValue, units.jsValue])
    }

    @inlinable func renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.renderbufferStorage].function!(this: this, arguments: [target.jsValue, internalformat.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func sampleCoverage(value: GLclampf, invert: GLboolean) {
        let this = jsObject
        _ = this[Strings.sampleCoverage].function!(this: this, arguments: [value.jsValue, invert.jsValue])
    }

    @inlinable func scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.scissor].function!(this: this, arguments: [x.jsValue, y.jsValue, width.jsValue, height.jsValue])
    }

    @inlinable func shaderSource(shader: WebGLShader, source: String) {
        let this = jsObject
        _ = this[Strings.shaderSource].function!(this: this, arguments: [shader.jsValue, source.jsValue])
    }

    @inlinable func stencilFunc(func: GLenum, ref: GLint, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilFunc].function!(this: this, arguments: [`func`.jsValue, ref.jsValue, mask.jsValue])
    }

    @inlinable func stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilFuncSeparate].function!(this: this, arguments: [face.jsValue, `func`.jsValue, ref.jsValue, mask.jsValue])
    }

    @inlinable func stencilMask(mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilMask].function!(this: this, arguments: [mask.jsValue])
    }

    @inlinable func stencilMaskSeparate(face: GLenum, mask: GLuint) {
        let this = jsObject
        _ = this[Strings.stencilMaskSeparate].function!(this: this, arguments: [face.jsValue, mask.jsValue])
    }

    @inlinable func stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) {
        let this = jsObject
        _ = this[Strings.stencilOp].function!(this: this, arguments: [fail.jsValue, zfail.jsValue, zpass.jsValue])
    }

    @inlinable func stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum) {
        let this = jsObject
        _ = this[Strings.stencilOpSeparate].function!(this: this, arguments: [face.jsValue, fail.jsValue, zfail.jsValue, zpass.jsValue])
    }

    @inlinable func texParameterf(target: GLenum, pname: GLenum, param: GLfloat) {
        let this = jsObject
        _ = this[Strings.texParameterf].function!(this: this, arguments: [target.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func texParameteri(target: GLenum, pname: GLenum, param: GLint) {
        let this = jsObject
        _ = this[Strings.texParameteri].function!(this: this, arguments: [target.jsValue, pname.jsValue, param.jsValue])
    }

    @inlinable func uniform1f(location: WebGLUniformLocation?, x: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform1f].function!(this: this, arguments: [location.jsValue, x.jsValue])
    }

    @inlinable func uniform2f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform2f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func uniform3f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform3f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func uniform4f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {
        let this = jsObject
        _ = this[Strings.uniform4f].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func uniform1i(location: WebGLUniformLocation?, x: GLint) {
        let this = jsObject
        _ = this[Strings.uniform1i].function!(this: this, arguments: [location.jsValue, x.jsValue])
    }

    @inlinable func uniform2i(location: WebGLUniformLocation?, x: GLint, y: GLint) {
        let this = jsObject
        _ = this[Strings.uniform2i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func uniform3i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint) {
        let this = jsObject
        _ = this[Strings.uniform3i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func uniform4i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint, w: GLint) {
        let this = jsObject
        _ = this[Strings.uniform4i].function!(this: this, arguments: [location.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func useProgram(program: WebGLProgram?) {
        let this = jsObject
        _ = this[Strings.useProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func validateProgram(program: WebGLProgram) {
        let this = jsObject
        _ = this[Strings.validateProgram].function!(this: this, arguments: [program.jsValue])
    }

    @inlinable func vertexAttrib1f(index: GLuint, x: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib1f].function!(this: this, arguments: [index.jsValue, x.jsValue])
    }

    @inlinable func vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib2f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue])
    }

    @inlinable func vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib3f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable func vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {
        let this = jsObject
        _ = this[Strings.vertexAttrib4f].function!(this: this, arguments: [index.jsValue, x.jsValue, y.jsValue, z.jsValue, w.jsValue])
    }

    @inlinable func vertexAttrib1fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib1fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib2fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib2fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib3fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib3fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttrib4fv(index: GLuint, values: Float32List) {
        let this = jsObject
        _ = this[Strings.vertexAttrib4fv].function!(this: this, arguments: [index.jsValue, values.jsValue])
    }

    @inlinable func vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr) {
        let _arg0 = index.jsValue
        let _arg1 = size.jsValue
        let _arg2 = type.jsValue
        let _arg3 = normalized.jsValue
        let _arg4 = stride.jsValue
        let _arg5 = offset.jsValue
        let this = jsObject
        _ = this[Strings.vertexAttribPointer].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        let this = jsObject
        _ = this[Strings.viewport].function!(this: this, arguments: [x.jsValue, y.jsValue, width.jsValue, height.jsValue])
    }
}

public protocol WebGLRenderingContextOverloads: JSBridgedClass {}
public extension WebGLRenderingContextOverloads {
    @inlinable func bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, size.jsValue, usage.jsValue])
    }

    @inlinable func bufferData(target: GLenum, data: BufferSource?, usage: GLenum) {
        let this = jsObject
        _ = this[Strings.bufferData].function!(this: this, arguments: [target.jsValue, data.jsValue, usage.jsValue])
    }

    @inlinable func bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource) {
        let this = jsObject
        _ = this[Strings.bufferSubData].function!(this: this, arguments: [target.jsValue, offset.jsValue, data.jsValue])
    }

    @inlinable func compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = data.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = data.jsValue
        let this = jsObject
        _ = this[Strings.compressedTexSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7])
    }

    @inlinable func readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = width.jsValue
        let _arg3 = height.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.readPixels].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = width.jsValue
        let _arg4 = height.jsValue
        let _arg5 = border.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = internalformat.jsValue
        let _arg3 = format.jsValue
        let _arg4 = type.jsValue
        let _arg5 = source.jsValue
        let this = jsObject
        _ = this[Strings.texImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = width.jsValue
        let _arg5 = height.jsValue
        let _arg6 = format.jsValue
        let _arg7 = type.jsValue
        let _arg8 = pixels.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8])
    }

    @inlinable func texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource) {
        let _arg0 = target.jsValue
        let _arg1 = level.jsValue
        let _arg2 = xoffset.jsValue
        let _arg3 = yoffset.jsValue
        let _arg4 = format.jsValue
        let _arg5 = type.jsValue
        let _arg6 = source.jsValue
        let this = jsObject
        _ = this[Strings.texSubImage2D].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6])
    }

    @inlinable func uniform1fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform1fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform2fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform2fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform3fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform3fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform4fv(location: WebGLUniformLocation?, v: Float32List) {
        let this = jsObject
        _ = this[Strings.uniform4fv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform1iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform1iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform2iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform2iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform3iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform3iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniform4iv(location: WebGLUniformLocation?, v: Int32List) {
        let this = jsObject
        _ = this[Strings.uniform4iv].function!(this: this, arguments: [location.jsValue, v.jsValue])
    }

    @inlinable func uniformMatrix2fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix2fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }

    @inlinable func uniformMatrix3fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix3fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }

    @inlinable func uniformMatrix4fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List) {
        let this = jsObject
        _ = this[Strings.uniformMatrix4fv].function!(this: this, arguments: [location.jsValue, transpose.jsValue, value.jsValue])
    }
}

public class WebGLShader: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLShader].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLShaderPrecisionFormat: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WebGLShaderPrecisionFormat].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rangeMin = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeMin)
        _rangeMax = ReadonlyAttribute(jsObject: jsObject, name: Strings.rangeMax)
        _precision = ReadonlyAttribute(jsObject: jsObject, name: Strings.precision)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var rangeMin: GLint

    @ReadonlyAttribute
    public var rangeMax: GLint

    @ReadonlyAttribute
    public var precision: GLint
}

public class WebGLTexture: WebGLObject {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WebGLTexture].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class WebGLUniformLocation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WebGLUniformLocation].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

/* variadic generics please */
@propertyWrapper public final class ClosureAttribute0<ReturnType>
    where ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: () -> ReturnType {
        get { ClosureAttribute0[name, in: jsObject] }
        set { ClosureAttribute0[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> () -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function().fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure { _ in
                newValue().jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute0Optional<ReturnType>
    where ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (() -> ReturnType)? {
        get { ClosureAttribute0Optional[name, in: jsObject] }
        set { ClosureAttribute0Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (() -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function().fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure { _ in
                    newValue().jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute0OptionalVoid {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (() -> Void)? {
        get { ClosureAttribute0OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute0OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (() -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function() }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure { _ in
                    newValue()
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute0Void {
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: () -> Void {
        get { ClosureAttribute0Void[name, in: jsObject] }
        set { ClosureAttribute0Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> () -> Void {
        get {
            let function = jsObject[name].function!
            return { function() }
        }
        set {
            jsObject[name] = JSClosure { _ in
                newValue()
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute1<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> ReturnType {
        get { ClosureAttribute1[name, in: jsObject] }
        set { ClosureAttribute1[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Optional<A0, ReturnType>
    where A0: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> ReturnType)? {
        get { ClosureAttribute1Optional[name, in: jsObject] }
        set { ClosureAttribute1Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1OptionalVoid<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0) -> Void)? {
        get { ClosureAttribute1OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute1OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute1Void<A0>
    where A0: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0) -> Void {
        get { ClosureAttribute1Void[name, in: jsObject] }
        set { ClosureAttribute1Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute2<A0, A1, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1) -> ReturnType {
        get { ClosureAttribute2[name, in: jsObject] }
        set { ClosureAttribute2[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute2Optional<A0, A1, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1) -> ReturnType)? {
        get { ClosureAttribute2Optional[name, in: jsObject] }
        set { ClosureAttribute2Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute2OptionalVoid<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1) -> Void)? {
        get { ClosureAttribute2OptionalVoid[name, in: jsObject] }
        set { ClosureAttribute2OptionalVoid[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1) -> Void)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                    return .undefined
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute2Void<A0, A1>
    where A0: JSValueCompatible, A1: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1) -> Void {
        get { ClosureAttribute2Void[name, in: jsObject] }
        set { ClosureAttribute2Void[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1) -> Void {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue) }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                return .undefined
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute3<A0, A1, A2, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1, A2) -> ReturnType {
        get { ClosureAttribute3[name, in: jsObject] }
        set { ClosureAttribute3[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1, A2) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue, $2.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute3Optional<A0, A1, A2, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1, A2) -> ReturnType)? {
        get { ClosureAttribute3Optional[name, in: jsObject] }
        set { ClosureAttribute3Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1, A2) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue, $2.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@propertyWrapper public final class ClosureAttribute5<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: (A0, A1, A2, A3, A4) -> ReturnType {
        get { ClosureAttribute5[name, in: jsObject] }
        set { ClosureAttribute5[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> (A0, A1, A2, A3, A4) -> ReturnType {
        get {
            let function = jsObject[name].function!
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            jsObject[name] = JSClosure {
                newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
            }.jsValue
        }
    }
}

@propertyWrapper public final class ClosureAttribute5Optional<A0, A1, A2, A3, A4, ReturnType>
    where A0: JSValueCompatible, A1: JSValueCompatible, A2: JSValueCompatible, A3: JSValueCompatible, A4: JSValueCompatible, ReturnType: JSValueCompatible
{
    @usableFromInline let jsObject: JSObject
    @usableFromInline let name: JSString

    public init(jsObject: JSObject, name: JSString) {
        self.jsObject = jsObject
        self.name = name
    }

    @inlinable public var wrappedValue: ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get { ClosureAttribute5Optional[name, in: jsObject] }
        set { ClosureAttribute5Optional[name, in: jsObject] = newValue }
    }

    @inlinable public static subscript(name: JSString, in jsObject: JSObject) -> ((A0, A1, A2, A3, A4) -> ReturnType)? {
        get {
            guard let function = jsObject[name].function else {
                return nil
            }
            return { function($0.jsValue, $1.jsValue, $2.jsValue, $3.jsValue, $4.jsValue).fromJSValue()! }
        }
        set {
            if let newValue = newValue {
                jsObject[name] = JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!, $0[2].fromJSValue()!, $0[3].fromJSValue()!, $0[4].fromJSValue()!).jsValue
                }.jsValue
            } else {
                jsObject[name] = .null
            }
        }
    }
}

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let AbortController: JSString = "AbortController"
    @usableFromInline static let AbortSignal: JSString = "AbortSignal"
    @usableFromInline static let AbstractRange: JSString = "AbstractRange"
    @usableFromInline static let AddSearchProvider: JSString = "AddSearchProvider"
    @usableFromInline static let AnalyserNode: JSString = "AnalyserNode"
    @usableFromInline static let Animation: JSString = "Animation"
    @usableFromInline static let AnimationEffect: JSString = "AnimationEffect"
    @usableFromInline static let AnimationTimeline: JSString = "AnimationTimeline"
    @usableFromInline static let Attr: JSString = "Attr"
    @usableFromInline static let AudioBuffer: JSString = "AudioBuffer"
    @usableFromInline static let AudioBufferSourceNode: JSString = "AudioBufferSourceNode"
    @usableFromInline static let AudioContext: JSString = "AudioContext"
    @usableFromInline static let AudioData: JSString = "AudioData"
    @usableFromInline static let AudioDecoder: JSString = "AudioDecoder"
    @usableFromInline static let AudioDestinationNode: JSString = "AudioDestinationNode"
    @usableFromInline static let AudioEncoder: JSString = "AudioEncoder"
    @usableFromInline static let AudioListener: JSString = "AudioListener"
    @usableFromInline static let AudioNode: JSString = "AudioNode"
    @usableFromInline static let AudioParam: JSString = "AudioParam"
    @usableFromInline static let AudioParamMap: JSString = "AudioParamMap"
    @usableFromInline static let AudioProcessingEvent: JSString = "AudioProcessingEvent"
    @usableFromInline static let AudioScheduledSourceNode: JSString = "AudioScheduledSourceNode"
    @usableFromInline static let AudioTrack: JSString = "AudioTrack"
    @usableFromInline static let AudioTrackList: JSString = "AudioTrackList"
    @usableFromInline static let AudioWorklet: JSString = "AudioWorklet"
    @usableFromInline static let AudioWorkletNode: JSString = "AudioWorkletNode"
    @usableFromInline static let BarProp: JSString = "BarProp"
    @usableFromInline static let BaseAudioContext: JSString = "BaseAudioContext"
    @usableFromInline static let BeforeUnloadEvent: JSString = "BeforeUnloadEvent"
    @usableFromInline static let BiquadFilterNode: JSString = "BiquadFilterNode"
    @usableFromInline static let Blob: JSString = "Blob"
    @usableFromInline static let BlobEvent: JSString = "BlobEvent"
    @usableFromInline static let BroadcastChannel: JSString = "BroadcastChannel"
    @usableFromInline static let ByteLengthQueuingStrategy: JSString = "ByteLengthQueuingStrategy"
    @usableFromInline static let CDATASection: JSString = "CDATASection"
    @usableFromInline static let CSSPseudoElement: JSString = "CSSPseudoElement"
    @usableFromInline static let Cache: JSString = "Cache"
    @usableFromInline static let CacheStorage: JSString = "CacheStorage"
    @usableFromInline static let CanvasFilter: JSString = "CanvasFilter"
    @usableFromInline static let CanvasGradient: JSString = "CanvasGradient"
    @usableFromInline static let CanvasPattern: JSString = "CanvasPattern"
    @usableFromInline static let CanvasRenderingContext2D: JSString = "CanvasRenderingContext2D"
    @usableFromInline static let CaretPosition: JSString = "CaretPosition"
    @usableFromInline static let ChannelMergerNode: JSString = "ChannelMergerNode"
    @usableFromInline static let ChannelSplitterNode: JSString = "ChannelSplitterNode"
    @usableFromInline static let CharacterData: JSString = "CharacterData"
    @usableFromInline static let CloseEvent: JSString = "CloseEvent"
    @usableFromInline static let Comment: JSString = "Comment"
    @usableFromInline static let CompositionEvent: JSString = "CompositionEvent"
    @usableFromInline static let ConstantSourceNode: JSString = "ConstantSourceNode"
    @usableFromInline static let ConvolverNode: JSString = "ConvolverNode"
    @usableFromInline static let CountQueuingStrategy: JSString = "CountQueuingStrategy"
    @usableFromInline static let CustomElementRegistry: JSString = "CustomElementRegistry"
    @usableFromInline static let CustomEvent: JSString = "CustomEvent"
    @usableFromInline static let DOMException: JSString = "DOMException"
    @usableFromInline static let DOMImplementation: JSString = "DOMImplementation"
    @usableFromInline static let DOMMatrix: JSString = "DOMMatrix"
    @usableFromInline static let DOMMatrixReadOnly: JSString = "DOMMatrixReadOnly"
    @usableFromInline static let DOMParser: JSString = "DOMParser"
    @usableFromInline static let DOMPoint: JSString = "DOMPoint"
    @usableFromInline static let DOMPointReadOnly: JSString = "DOMPointReadOnly"
    @usableFromInline static let DOMQuad: JSString = "DOMQuad"
    @usableFromInline static let DOMRect: JSString = "DOMRect"
    @usableFromInline static let DOMRectList: JSString = "DOMRectList"
    @usableFromInline static let DOMRectReadOnly: JSString = "DOMRectReadOnly"
    @usableFromInline static let DOMStringList: JSString = "DOMStringList"
    @usableFromInline static let DOMStringMap: JSString = "DOMStringMap"
    @usableFromInline static let DOMTokenList: JSString = "DOMTokenList"
    @usableFromInline static let DataTransfer: JSString = "DataTransfer"
    @usableFromInline static let DataTransferItem: JSString = "DataTransferItem"
    @usableFromInline static let DataTransferItemList: JSString = "DataTransferItemList"
    @usableFromInline static let DelayNode: JSString = "DelayNode"
    @usableFromInline static let Document: JSString = "Document"
    @usableFromInline static let DocumentFragment: JSString = "DocumentFragment"
    @usableFromInline static let DocumentTimeline: JSString = "DocumentTimeline"
    @usableFromInline static let DocumentType: JSString = "DocumentType"
    @usableFromInline static let DragEvent: JSString = "DragEvent"
    @usableFromInline static let DynamicsCompressorNode: JSString = "DynamicsCompressorNode"
    @usableFromInline static let Element: JSString = "Element"
    @usableFromInline static let ElementInternals: JSString = "ElementInternals"
    @usableFromInline static let EncodedAudioChunk: JSString = "EncodedAudioChunk"
    @usableFromInline static let EncodedVideoChunk: JSString = "EncodedVideoChunk"
    @usableFromInline static let ErrorEvent: JSString = "ErrorEvent"
    @usableFromInline static let Event: JSString = "Event"
    @usableFromInline static let EventSource: JSString = "EventSource"
    @usableFromInline static let EventTarget: JSString = "EventTarget"
    @usableFromInline static let External: JSString = "External"
    @usableFromInline static let File: JSString = "File"
    @usableFromInline static let FileList: JSString = "FileList"
    @usableFromInline static let FileReader: JSString = "FileReader"
    @usableFromInline static let FocusEvent: JSString = "FocusEvent"
    @usableFromInline static let FormData: JSString = "FormData"
    @usableFromInline static let FormDataEvent: JSString = "FormDataEvent"
    @usableFromInline static let GainNode: JSString = "GainNode"
    @usableFromInline static let HTMLAllCollection: JSString = "HTMLAllCollection"
    @usableFromInline static let HTMLAnchorElement: JSString = "HTMLAnchorElement"
    @usableFromInline static let HTMLAreaElement: JSString = "HTMLAreaElement"
    @usableFromInline static let HTMLAudioElement: JSString = "HTMLAudioElement"
    @usableFromInline static let HTMLBRElement: JSString = "HTMLBRElement"
    @usableFromInline static let HTMLBaseElement: JSString = "HTMLBaseElement"
    @usableFromInline static let HTMLBodyElement: JSString = "HTMLBodyElement"
    @usableFromInline static let HTMLButtonElement: JSString = "HTMLButtonElement"
    @usableFromInline static let HTMLCanvasElement: JSString = "HTMLCanvasElement"
    @usableFromInline static let HTMLCollection: JSString = "HTMLCollection"
    @usableFromInline static let HTMLDListElement: JSString = "HTMLDListElement"
    @usableFromInline static let HTMLDataElement: JSString = "HTMLDataElement"
    @usableFromInline static let HTMLDataListElement: JSString = "HTMLDataListElement"
    @usableFromInline static let HTMLDetailsElement: JSString = "HTMLDetailsElement"
    @usableFromInline static let HTMLDialogElement: JSString = "HTMLDialogElement"
    @usableFromInline static let HTMLDirectoryElement: JSString = "HTMLDirectoryElement"
    @usableFromInline static let HTMLDivElement: JSString = "HTMLDivElement"
    @usableFromInline static let HTMLElement: JSString = "HTMLElement"
    @usableFromInline static let HTMLEmbedElement: JSString = "HTMLEmbedElement"
    @usableFromInline static let HTMLFieldSetElement: JSString = "HTMLFieldSetElement"
    @usableFromInline static let HTMLFontElement: JSString = "HTMLFontElement"
    @usableFromInline static let HTMLFormControlsCollection: JSString = "HTMLFormControlsCollection"
    @usableFromInline static let HTMLFormElement: JSString = "HTMLFormElement"
    @usableFromInline static let HTMLFrameElement: JSString = "HTMLFrameElement"
    @usableFromInline static let HTMLFrameSetElement: JSString = "HTMLFrameSetElement"
    @usableFromInline static let HTMLHRElement: JSString = "HTMLHRElement"
    @usableFromInline static let HTMLHeadElement: JSString = "HTMLHeadElement"
    @usableFromInline static let HTMLHeadingElement: JSString = "HTMLHeadingElement"
    @usableFromInline static let HTMLHtmlElement: JSString = "HTMLHtmlElement"
    @usableFromInline static let HTMLIFrameElement: JSString = "HTMLIFrameElement"
    @usableFromInline static let HTMLImageElement: JSString = "HTMLImageElement"
    @usableFromInline static let HTMLInputElement: JSString = "HTMLInputElement"
    @usableFromInline static let HTMLLIElement: JSString = "HTMLLIElement"
    @usableFromInline static let HTMLLabelElement: JSString = "HTMLLabelElement"
    @usableFromInline static let HTMLLegendElement: JSString = "HTMLLegendElement"
    @usableFromInline static let HTMLLinkElement: JSString = "HTMLLinkElement"
    @usableFromInline static let HTMLMapElement: JSString = "HTMLMapElement"
    @usableFromInline static let HTMLMarqueeElement: JSString = "HTMLMarqueeElement"
    @usableFromInline static let HTMLMediaElement: JSString = "HTMLMediaElement"
    @usableFromInline static let HTMLMenuElement: JSString = "HTMLMenuElement"
    @usableFromInline static let HTMLMetaElement: JSString = "HTMLMetaElement"
    @usableFromInline static let HTMLMeterElement: JSString = "HTMLMeterElement"
    @usableFromInline static let HTMLModElement: JSString = "HTMLModElement"
    @usableFromInline static let HTMLOListElement: JSString = "HTMLOListElement"
    @usableFromInline static let HTMLObjectElement: JSString = "HTMLObjectElement"
    @usableFromInline static let HTMLOptGroupElement: JSString = "HTMLOptGroupElement"
    @usableFromInline static let HTMLOptionElement: JSString = "HTMLOptionElement"
    @usableFromInline static let HTMLOptionsCollection: JSString = "HTMLOptionsCollection"
    @usableFromInline static let HTMLOutputElement: JSString = "HTMLOutputElement"
    @usableFromInline static let HTMLParagraphElement: JSString = "HTMLParagraphElement"
    @usableFromInline static let HTMLParamElement: JSString = "HTMLParamElement"
    @usableFromInline static let HTMLPictureElement: JSString = "HTMLPictureElement"
    @usableFromInline static let HTMLPreElement: JSString = "HTMLPreElement"
    @usableFromInline static let HTMLProgressElement: JSString = "HTMLProgressElement"
    @usableFromInline static let HTMLQuoteElement: JSString = "HTMLQuoteElement"
    @usableFromInline static let HTMLScriptElement: JSString = "HTMLScriptElement"
    @usableFromInline static let HTMLSelectElement: JSString = "HTMLSelectElement"
    @usableFromInline static let HTMLSlotElement: JSString = "HTMLSlotElement"
    @usableFromInline static let HTMLSourceElement: JSString = "HTMLSourceElement"
    @usableFromInline static let HTMLSpanElement: JSString = "HTMLSpanElement"
    @usableFromInline static let HTMLStyleElement: JSString = "HTMLStyleElement"
    @usableFromInline static let HTMLTableCaptionElement: JSString = "HTMLTableCaptionElement"
    @usableFromInline static let HTMLTableCellElement: JSString = "HTMLTableCellElement"
    @usableFromInline static let HTMLTableColElement: JSString = "HTMLTableColElement"
    @usableFromInline static let HTMLTableElement: JSString = "HTMLTableElement"
    @usableFromInline static let HTMLTableRowElement: JSString = "HTMLTableRowElement"
    @usableFromInline static let HTMLTableSectionElement: JSString = "HTMLTableSectionElement"
    @usableFromInline static let HTMLTemplateElement: JSString = "HTMLTemplateElement"
    @usableFromInline static let HTMLTextAreaElement: JSString = "HTMLTextAreaElement"
    @usableFromInline static let HTMLTimeElement: JSString = "HTMLTimeElement"
    @usableFromInline static let HTMLTitleElement: JSString = "HTMLTitleElement"
    @usableFromInline static let HTMLTrackElement: JSString = "HTMLTrackElement"
    @usableFromInline static let HTMLUListElement: JSString = "HTMLUListElement"
    @usableFromInline static let HTMLUnknownElement: JSString = "HTMLUnknownElement"
    @usableFromInline static let HTMLVideoElement: JSString = "HTMLVideoElement"
    @usableFromInline static let HashChangeEvent: JSString = "HashChangeEvent"
    @usableFromInline static let Headers: JSString = "Headers"
    @usableFromInline static let History: JSString = "History"
    @usableFromInline static let IIRFilterNode: JSString = "IIRFilterNode"
    @usableFromInline static let ImageBitmap: JSString = "ImageBitmap"
    @usableFromInline static let ImageBitmapRenderingContext: JSString = "ImageBitmapRenderingContext"
    @usableFromInline static let ImageData: JSString = "ImageData"
    @usableFromInline static let ImageDecoder: JSString = "ImageDecoder"
    @usableFromInline static let ImageTrack: JSString = "ImageTrack"
    @usableFromInline static let ImageTrackList: JSString = "ImageTrackList"
    @usableFromInline static let InputDeviceInfo: JSString = "InputDeviceInfo"
    @usableFromInline static let InputEvent: JSString = "InputEvent"
    @usableFromInline static let IsSearchProviderInstalled: JSString = "IsSearchProviderInstalled"
    @usableFromInline static let KeyboardEvent: JSString = "KeyboardEvent"
    @usableFromInline static let KeyframeEffect: JSString = "KeyframeEffect"
    @usableFromInline static let Location: JSString = "Location"
    @usableFromInline static let MediaDeviceInfo: JSString = "MediaDeviceInfo"
    @usableFromInline static let MediaDevices: JSString = "MediaDevices"
    @usableFromInline static let MediaElementAudioSourceNode: JSString = "MediaElementAudioSourceNode"
    @usableFromInline static let MediaError: JSString = "MediaError"
    @usableFromInline static let MediaQueryList: JSString = "MediaQueryList"
    @usableFromInline static let MediaQueryListEvent: JSString = "MediaQueryListEvent"
    @usableFromInline static let MediaRecorder: JSString = "MediaRecorder"
    @usableFromInline static let MediaRecorderErrorEvent: JSString = "MediaRecorderErrorEvent"
    @usableFromInline static let MediaStream: JSString = "MediaStream"
    @usableFromInline static let MediaStreamAudioDestinationNode: JSString = "MediaStreamAudioDestinationNode"
    @usableFromInline static let MediaStreamAudioSourceNode: JSString = "MediaStreamAudioSourceNode"
    @usableFromInline static let MediaStreamTrack: JSString = "MediaStreamTrack"
    @usableFromInline static let MediaStreamTrackAudioSourceNode: JSString = "MediaStreamTrackAudioSourceNode"
    @usableFromInline static let MediaStreamTrackEvent: JSString = "MediaStreamTrackEvent"
    @usableFromInline static let MessageChannel: JSString = "MessageChannel"
    @usableFromInline static let MessageEvent: JSString = "MessageEvent"
    @usableFromInline static let MessagePort: JSString = "MessagePort"
    @usableFromInline static let MimeType: JSString = "MimeType"
    @usableFromInline static let MimeTypeArray: JSString = "MimeTypeArray"
    @usableFromInline static let MouseEvent: JSString = "MouseEvent"
    @usableFromInline static let MutationEvent: JSString = "MutationEvent"
    @usableFromInline static let MutationObserver: JSString = "MutationObserver"
    @usableFromInline static let MutationRecord: JSString = "MutationRecord"
    @usableFromInline static let NamedNodeMap: JSString = "NamedNodeMap"
    @usableFromInline static let NavigationPreloadManager: JSString = "NavigationPreloadManager"
    @usableFromInline static let Navigator: JSString = "Navigator"
    @usableFromInline static let Node: JSString = "Node"
    @usableFromInline static let NodeIterator: JSString = "NodeIterator"
    @usableFromInline static let NodeList: JSString = "NodeList"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let OfflineAudioCompletionEvent: JSString = "OfflineAudioCompletionEvent"
    @usableFromInline static let OfflineAudioContext: JSString = "OfflineAudioContext"
    @usableFromInline static let OffscreenCanvas: JSString = "OffscreenCanvas"
    @usableFromInline static let OffscreenCanvasRenderingContext2D: JSString = "OffscreenCanvasRenderingContext2D"
    @usableFromInline static let OscillatorNode: JSString = "OscillatorNode"
    @usableFromInline static let OverconstrainedError: JSString = "OverconstrainedError"
    @usableFromInline static let PageTransitionEvent: JSString = "PageTransitionEvent"
    @usableFromInline static let PannerNode: JSString = "PannerNode"
    @usableFromInline static let Path2D: JSString = "Path2D"
    @usableFromInline static let Performance: JSString = "Performance"
    @usableFromInline static let PeriodicWave: JSString = "PeriodicWave"
    @usableFromInline static let Plugin: JSString = "Plugin"
    @usableFromInline static let PluginArray: JSString = "PluginArray"
    @usableFromInline static let PopStateEvent: JSString = "PopStateEvent"
    @usableFromInline static let ProcessingInstruction: JSString = "ProcessingInstruction"
    @usableFromInline static let ProgressEvent: JSString = "ProgressEvent"
    @usableFromInline static let PromiseRejectionEvent: JSString = "PromiseRejectionEvent"
    @usableFromInline static let Q: JSString = "Q"
    @usableFromInline static let RadioNodeList: JSString = "RadioNodeList"
    @usableFromInline static let Range: JSString = "Range"
    @usableFromInline static let ReadableByteStreamController: JSString = "ReadableByteStreamController"
    @usableFromInline static let ReadableStream: JSString = "ReadableStream"
    @usableFromInline static let ReadableStreamBYOBReader: JSString = "ReadableStreamBYOBReader"
    @usableFromInline static let ReadableStreamBYOBRequest: JSString = "ReadableStreamBYOBRequest"
    @usableFromInline static let ReadableStreamDefaultController: JSString = "ReadableStreamDefaultController"
    @usableFromInline static let ReadableStreamDefaultReader: JSString = "ReadableStreamDefaultReader"
    @usableFromInline static let Request: JSString = "Request"
    @usableFromInline static let Response: JSString = "Response"
    @usableFromInline static let Screen: JSString = "Screen"
    @usableFromInline static let ScriptProcessorNode: JSString = "ScriptProcessorNode"
    @usableFromInline static let ServiceWorker: JSString = "ServiceWorker"
    @usableFromInline static let ServiceWorkerContainer: JSString = "ServiceWorkerContainer"
    @usableFromInline static let ServiceWorkerRegistration: JSString = "ServiceWorkerRegistration"
    @usableFromInline static let ShadowRoot: JSString = "ShadowRoot"
    @usableFromInline static let SharedWorker: JSString = "SharedWorker"
    @usableFromInline static let StaticRange: JSString = "StaticRange"
    @usableFromInline static let StereoPannerNode: JSString = "StereoPannerNode"
    @usableFromInline static let Storage: JSString = "Storage"
    @usableFromInline static let StorageEvent: JSString = "StorageEvent"
    @usableFromInline static let SubmitEvent: JSString = "SubmitEvent"
    @usableFromInline static let Text: JSString = "Text"
    @usableFromInline static let TextMetrics: JSString = "TextMetrics"
    @usableFromInline static let TextTrack: JSString = "TextTrack"
    @usableFromInline static let TextTrackCue: JSString = "TextTrackCue"
    @usableFromInline static let TextTrackCueList: JSString = "TextTrackCueList"
    @usableFromInline static let TextTrackList: JSString = "TextTrackList"
    @usableFromInline static let TimeRanges: JSString = "TimeRanges"
    @usableFromInline static let TrackEvent: JSString = "TrackEvent"
    @usableFromInline static let TransformStream: JSString = "TransformStream"
    @usableFromInline static let TransformStreamDefaultController: JSString = "TransformStreamDefaultController"
    @usableFromInline static let TreeWalker: JSString = "TreeWalker"
    @usableFromInline static let UIEvent: JSString = "UIEvent"
    @usableFromInline static let URL: JSString = "URL"
    @usableFromInline static let URLSearchParams: JSString = "URLSearchParams"
    @usableFromInline static let ValidityState: JSString = "ValidityState"
    @usableFromInline static let VideoColorSpace: JSString = "VideoColorSpace"
    @usableFromInline static let VideoDecoder: JSString = "VideoDecoder"
    @usableFromInline static let VideoEncoder: JSString = "VideoEncoder"
    @usableFromInline static let VideoFrame: JSString = "VideoFrame"
    @usableFromInline static let VideoTrack: JSString = "VideoTrack"
    @usableFromInline static let VideoTrackList: JSString = "VideoTrackList"
    @usableFromInline static let WaveShaperNode: JSString = "WaveShaperNode"
    @usableFromInline static let WebGLActiveInfo: JSString = "WebGLActiveInfo"
    @usableFromInline static let WebGLBuffer: JSString = "WebGLBuffer"
    @usableFromInline static let WebGLContextEvent: JSString = "WebGLContextEvent"
    @usableFromInline static let WebGLFramebuffer: JSString = "WebGLFramebuffer"
    @usableFromInline static let WebGLObject: JSString = "WebGLObject"
    @usableFromInline static let WebGLProgram: JSString = "WebGLProgram"
    @usableFromInline static let WebGLRenderbuffer: JSString = "WebGLRenderbuffer"
    @usableFromInline static let WebGLRenderingContext: JSString = "WebGLRenderingContext"
    @usableFromInline static let WebGLShader: JSString = "WebGLShader"
    @usableFromInline static let WebGLShaderPrecisionFormat: JSString = "WebGLShaderPrecisionFormat"
    @usableFromInline static let WebGLTexture: JSString = "WebGLTexture"
    @usableFromInline static let WebGLUniformLocation: JSString = "WebGLUniformLocation"
    @usableFromInline static let WebSocket: JSString = "WebSocket"
    @usableFromInline static let WheelEvent: JSString = "WheelEvent"
    @usableFromInline static let Window: JSString = "Window"
    @usableFromInline static let Worker: JSString = "Worker"
    @usableFromInline static let Worklet: JSString = "Worklet"
    @usableFromInline static let WritableStream: JSString = "WritableStream"
    @usableFromInline static let WritableStreamDefaultController: JSString = "WritableStreamDefaultController"
    @usableFromInline static let WritableStreamDefaultWriter: JSString = "WritableStreamDefaultWriter"
    @usableFromInline static let XMLDocument: JSString = "XMLDocument"
    @usableFromInline static let XMLHttpRequest: JSString = "XMLHttpRequest"
    @usableFromInline static let XMLHttpRequestEventTarget: JSString = "XMLHttpRequestEventTarget"
    @usableFromInline static let XMLHttpRequestUpload: JSString = "XMLHttpRequestUpload"
    @usableFromInline static let XPathEvaluator: JSString = "XPathEvaluator"
    @usableFromInline static let XPathExpression: JSString = "XPathExpression"
    @usableFromInline static let XPathResult: JSString = "XPathResult"
    @usableFromInline static let XSLTProcessor: JSString = "XSLTProcessor"
    @usableFromInline static let a: JSString = "a"
    @usableFromInline static let aLink: JSString = "aLink"
    @usableFromInline static let abbr: JSString = "abbr"
    @usableFromInline static let abort: JSString = "abort"
    @usableFromInline static let aborted: JSString = "aborted"
    @usableFromInline static let accept: JSString = "accept"
    @usableFromInline static let acceptCharset: JSString = "acceptCharset"
    @usableFromInline static let accessKey: JSString = "accessKey"
    @usableFromInline static let accessKeyLabel: JSString = "accessKeyLabel"
    @usableFromInline static let action: JSString = "action"
    @usableFromInline static let active: JSString = "active"
    @usableFromInline static let activeCues: JSString = "activeCues"
    @usableFromInline static let activeElement: JSString = "activeElement"
    @usableFromInline static let activeTexture: JSString = "activeTexture"
    @usableFromInline static let actualBoundingBoxAscent: JSString = "actualBoundingBoxAscent"
    @usableFromInline static let actualBoundingBoxDescent: JSString = "actualBoundingBoxDescent"
    @usableFromInline static let actualBoundingBoxLeft: JSString = "actualBoundingBoxLeft"
    @usableFromInline static let actualBoundingBoxRight: JSString = "actualBoundingBoxRight"
    @usableFromInline static let add: JSString = "add"
    @usableFromInline static let addAll: JSString = "addAll"
    @usableFromInline static let addColorStop: JSString = "addColorStop"
    @usableFromInline static let addCue: JSString = "addCue"
    @usableFromInline static let addModule: JSString = "addModule"
    @usableFromInline static let addPath: JSString = "addPath"
    @usableFromInline static let addTextTrack: JSString = "addTextTrack"
    @usableFromInline static let addTrack: JSString = "addTrack"
    @usableFromInline static let addedNodes: JSString = "addedNodes"
    @usableFromInline static let adoptNode: JSString = "adoptNode"
    @usableFromInline static let advanced: JSString = "advanced"
    @usableFromInline static let after: JSString = "after"
    @usableFromInline static let alert: JSString = "alert"
    @usableFromInline static let align: JSString = "align"
    @usableFromInline static let alinkColor: JSString = "alinkColor"
    @usableFromInline static let all: JSString = "all"
    @usableFromInline static let allocationSize: JSString = "allocationSize"
    @usableFromInline static let allow: JSString = "allow"
    @usableFromInline static let allowFullscreen: JSString = "allowFullscreen"
    @usableFromInline static let alpha: JSString = "alpha"
    @usableFromInline static let alphaSideData: JSString = "alphaSideData"
    @usableFromInline static let alphabeticBaseline: JSString = "alphabeticBaseline"
    @usableFromInline static let alt: JSString = "alt"
    @usableFromInline static let altKey: JSString = "altKey"
    @usableFromInline static let ancestorOrigins: JSString = "ancestorOrigins"
    @usableFromInline static let anchors: JSString = "anchors"
    @usableFromInline static let animate: JSString = "animate"
    @usableFromInline static let animated: JSString = "animated"
    @usableFromInline static let antialias: JSString = "antialias"
    @usableFromInline static let appCodeName: JSString = "appCodeName"
    @usableFromInline static let appName: JSString = "appName"
    @usableFromInline static let appVersion: JSString = "appVersion"
    @usableFromInline static let append: JSString = "append"
    @usableFromInline static let appendChild: JSString = "appendChild"
    @usableFromInline static let appendData: JSString = "appendData"
    @usableFromInline static let applets: JSString = "applets"
    @usableFromInline static let applyConstraints: JSString = "applyConstraints"
    @usableFromInline static let arc: JSString = "arc"
    @usableFromInline static let arcTo: JSString = "arcTo"
    @usableFromInline static let archive: JSString = "archive"
    @usableFromInline static let areas: JSString = "areas"
    @usableFromInline static let ariaAtomic: JSString = "ariaAtomic"
    @usableFromInline static let ariaAutoComplete: JSString = "ariaAutoComplete"
    @usableFromInline static let ariaBusy: JSString = "ariaBusy"
    @usableFromInline static let ariaChecked: JSString = "ariaChecked"
    @usableFromInline static let ariaColCount: JSString = "ariaColCount"
    @usableFromInline static let ariaColIndex: JSString = "ariaColIndex"
    @usableFromInline static let ariaColIndexText: JSString = "ariaColIndexText"
    @usableFromInline static let ariaColSpan: JSString = "ariaColSpan"
    @usableFromInline static let ariaCurrent: JSString = "ariaCurrent"
    @usableFromInline static let ariaDescription: JSString = "ariaDescription"
    @usableFromInline static let ariaDisabled: JSString = "ariaDisabled"
    @usableFromInline static let ariaExpanded: JSString = "ariaExpanded"
    @usableFromInline static let ariaHasPopup: JSString = "ariaHasPopup"
    @usableFromInline static let ariaHidden: JSString = "ariaHidden"
    @usableFromInline static let ariaInvalid: JSString = "ariaInvalid"
    @usableFromInline static let ariaKeyShortcuts: JSString = "ariaKeyShortcuts"
    @usableFromInline static let ariaLabel: JSString = "ariaLabel"
    @usableFromInline static let ariaLevel: JSString = "ariaLevel"
    @usableFromInline static let ariaLive: JSString = "ariaLive"
    @usableFromInline static let ariaModal: JSString = "ariaModal"
    @usableFromInline static let ariaMultiLine: JSString = "ariaMultiLine"
    @usableFromInline static let ariaMultiSelectable: JSString = "ariaMultiSelectable"
    @usableFromInline static let ariaOrientation: JSString = "ariaOrientation"
    @usableFromInline static let ariaPlaceholder: JSString = "ariaPlaceholder"
    @usableFromInline static let ariaPosInSet: JSString = "ariaPosInSet"
    @usableFromInline static let ariaPressed: JSString = "ariaPressed"
    @usableFromInline static let ariaReadOnly: JSString = "ariaReadOnly"
    @usableFromInline static let ariaRequired: JSString = "ariaRequired"
    @usableFromInline static let ariaRoleDescription: JSString = "ariaRoleDescription"
    @usableFromInline static let ariaRowCount: JSString = "ariaRowCount"
    @usableFromInline static let ariaRowIndex: JSString = "ariaRowIndex"
    @usableFromInline static let ariaRowIndexText: JSString = "ariaRowIndexText"
    @usableFromInline static let ariaRowSpan: JSString = "ariaRowSpan"
    @usableFromInline static let ariaSelected: JSString = "ariaSelected"
    @usableFromInline static let ariaSetSize: JSString = "ariaSetSize"
    @usableFromInline static let ariaSort: JSString = "ariaSort"
    @usableFromInline static let ariaValueMax: JSString = "ariaValueMax"
    @usableFromInline static let ariaValueMin: JSString = "ariaValueMin"
    @usableFromInline static let ariaValueNow: JSString = "ariaValueNow"
    @usableFromInline static let ariaValueText: JSString = "ariaValueText"
    @usableFromInline static let arrayBuffer: JSString = "arrayBuffer"
    @usableFromInline static let `as`: JSString = "as"
    @usableFromInline static let aspectRatio: JSString = "aspectRatio"
    @usableFromInline static let assert: JSString = "assert"
    @usableFromInline static let assign: JSString = "assign"
    @usableFromInline static let assignedElements: JSString = "assignedElements"
    @usableFromInline static let assignedNodes: JSString = "assignedNodes"
    @usableFromInline static let assignedSlot: JSString = "assignedSlot"
    @usableFromInline static let async: JSString = "async"
    @usableFromInline static let atob: JSString = "atob"
    @usableFromInline static let attachInternals: JSString = "attachInternals"
    @usableFromInline static let attachShader: JSString = "attachShader"
    @usableFromInline static let attachShadow: JSString = "attachShadow"
    @usableFromInline static let attack: JSString = "attack"
    @usableFromInline static let attrChange: JSString = "attrChange"
    @usableFromInline static let attrName: JSString = "attrName"
    @usableFromInline static let attributeFilter: JSString = "attributeFilter"
    @usableFromInline static let attributeName: JSString = "attributeName"
    @usableFromInline static let attributeNamespace: JSString = "attributeNamespace"
    @usableFromInline static let attributeOldValue: JSString = "attributeOldValue"
    @usableFromInline static let attributes: JSString = "attributes"
    @usableFromInline static let audio: JSString = "audio"
    @usableFromInline static let audioBitrateMode: JSString = "audioBitrateMode"
    @usableFromInline static let audioBitsPerSecond: JSString = "audioBitsPerSecond"
    @usableFromInline static let audioTracks: JSString = "audioTracks"
    @usableFromInline static let audioWorklet: JSString = "audioWorklet"
    @usableFromInline static let autoAllocateChunkSize: JSString = "autoAllocateChunkSize"
    @usableFromInline static let autoGainControl: JSString = "autoGainControl"
    @usableFromInline static let autocapitalize: JSString = "autocapitalize"
    @usableFromInline static let autocomplete: JSString = "autocomplete"
    @usableFromInline static let autofocus: JSString = "autofocus"
    @usableFromInline static let automationRate: JSString = "automationRate"
    @usableFromInline static let autoplay: JSString = "autoplay"
    @usableFromInline static let availHeight: JSString = "availHeight"
    @usableFromInline static let availWidth: JSString = "availWidth"
    @usableFromInline static let axis: JSString = "axis"
    @usableFromInline static let b: JSString = "b"
    @usableFromInline static let back: JSString = "back"
    @usableFromInline static let background: JSString = "background"
    @usableFromInline static let badInput: JSString = "badInput"
    @usableFromInline static let baseLatency: JSString = "baseLatency"
    @usableFromInline static let baseURI: JSString = "baseURI"
    @usableFromInline static let before: JSString = "before"
    @usableFromInline static let beginPath: JSString = "beginPath"
    @usableFromInline static let behavior: JSString = "behavior"
    @usableFromInline static let bezierCurveTo: JSString = "bezierCurveTo"
    @usableFromInline static let bgColor: JSString = "bgColor"
    @usableFromInline static let binaryType: JSString = "binaryType"
    @usableFromInline static let bindAttribLocation: JSString = "bindAttribLocation"
    @usableFromInline static let bindBuffer: JSString = "bindBuffer"
    @usableFromInline static let bindFramebuffer: JSString = "bindFramebuffer"
    @usableFromInline static let bindRenderbuffer: JSString = "bindRenderbuffer"
    @usableFromInline static let bindTexture: JSString = "bindTexture"
    @usableFromInline static let bitrate: JSString = "bitrate"
    @usableFromInline static let bitrateMode: JSString = "bitrateMode"
    @usableFromInline static let bitsPerSecond: JSString = "bitsPerSecond"
    @usableFromInline static let blendColor: JSString = "blendColor"
    @usableFromInline static let blendEquation: JSString = "blendEquation"
    @usableFromInline static let blendEquationSeparate: JSString = "blendEquationSeparate"
    @usableFromInline static let blendFunc: JSString = "blendFunc"
    @usableFromInline static let blendFuncSeparate: JSString = "blendFuncSeparate"
    @usableFromInline static let blob: JSString = "blob"
    @usableFromInline static let block: JSString = "block"
    @usableFromInline static let blocking: JSString = "blocking"
    @usableFromInline static let blur: JSString = "blur"
    @usableFromInline static let body: JSString = "body"
    @usableFromInline static let bodyUsed: JSString = "bodyUsed"
    @usableFromInline static let booleanValue: JSString = "booleanValue"
    @usableFromInline static let border: JSString = "border"
    @usableFromInline static let bottom: JSString = "bottom"
    @usableFromInline static let box: JSString = "box"
    @usableFromInline static let btoa: JSString = "btoa"
    @usableFromInline static let bubbles: JSString = "bubbles"
    @usableFromInline static let buffer: JSString = "buffer"
    @usableFromInline static let bufferData: JSString = "bufferData"
    @usableFromInline static let bufferSize: JSString = "bufferSize"
    @usableFromInline static let bufferSubData: JSString = "bufferSubData"
    @usableFromInline static let buffered: JSString = "buffered"
    @usableFromInline static let bufferedAmount: JSString = "bufferedAmount"
    @usableFromInline static let button: JSString = "button"
    @usableFromInline static let buttons: JSString = "buttons"
    @usableFromInline static let byobRequest: JSString = "byobRequest"
    @usableFromInline static let byteLength: JSString = "byteLength"
    @usableFromInline static let c: JSString = "c"
    @usableFromInline static let cache: JSString = "cache"
    @usableFromInline static let cacheName: JSString = "cacheName"
    @usableFromInline static let caches: JSString = "caches"
    @usableFromInline static let canPlayType: JSString = "canPlayType"
    @usableFromInline static let cancel: JSString = "cancel"
    @usableFromInline static let cancelAndHoldAtTime: JSString = "cancelAndHoldAtTime"
    @usableFromInline static let cancelAnimationFrame: JSString = "cancelAnimationFrame"
    @usableFromInline static let cancelBubble: JSString = "cancelBubble"
    @usableFromInline static let cancelScheduledValues: JSString = "cancelScheduledValues"
    @usableFromInline static let cancelable: JSString = "cancelable"
    @usableFromInline static let canvas: JSString = "canvas"
    @usableFromInline static let caption: JSString = "caption"
    @usableFromInline static let capture: JSString = "capture"
    @usableFromInline static let captureEvents: JSString = "captureEvents"
    @usableFromInline static let caretPositionFromPoint: JSString = "caretPositionFromPoint"
    @usableFromInline static let cellIndex: JSString = "cellIndex"
    @usableFromInline static let cellPadding: JSString = "cellPadding"
    @usableFromInline static let cellSpacing: JSString = "cellSpacing"
    @usableFromInline static let cells: JSString = "cells"
    @usableFromInline static let ch: JSString = "ch"
    @usableFromInline static let chOff: JSString = "chOff"
    @usableFromInline static let channelCount: JSString = "channelCount"
    @usableFromInline static let channelCountMode: JSString = "channelCountMode"
    @usableFromInline static let channelInterpretation: JSString = "channelInterpretation"
    @usableFromInline static let charCode: JSString = "charCode"
    @usableFromInline static let characterData: JSString = "characterData"
    @usableFromInline static let characterDataOldValue: JSString = "characterDataOldValue"
    @usableFromInline static let characterSet: JSString = "characterSet"
    @usableFromInline static let charset: JSString = "charset"
    @usableFromInline static let checkFramebufferStatus: JSString = "checkFramebufferStatus"
    @usableFromInline static let checkValidity: JSString = "checkValidity"
    @usableFromInline static let checked: JSString = "checked"
    @usableFromInline static let childElementCount: JSString = "childElementCount"
    @usableFromInline static let childList: JSString = "childList"
    @usableFromInline static let childNodes: JSString = "childNodes"
    @usableFromInline static let children: JSString = "children"
    @usableFromInline static let cite: JSString = "cite"
    @usableFromInline static let classList: JSString = "classList"
    @usableFromInline static let className: JSString = "className"
    @usableFromInline static let clear: JSString = "clear"
    @usableFromInline static let clearColor: JSString = "clearColor"
    @usableFromInline static let clearData: JSString = "clearData"
    @usableFromInline static let clearDepth: JSString = "clearDepth"
    @usableFromInline static let clearInterval: JSString = "clearInterval"
    @usableFromInline static let clearParameters: JSString = "clearParameters"
    @usableFromInline static let clearRect: JSString = "clearRect"
    @usableFromInline static let clearStencil: JSString = "clearStencil"
    @usableFromInline static let clearTimeout: JSString = "clearTimeout"
    @usableFromInline static let click: JSString = "click"
    @usableFromInline static let clientHeight: JSString = "clientHeight"
    @usableFromInline static let clientId: JSString = "clientId"
    @usableFromInline static let clientInformation: JSString = "clientInformation"
    @usableFromInline static let clientLeft: JSString = "clientLeft"
    @usableFromInline static let clientTop: JSString = "clientTop"
    @usableFromInline static let clientWidth: JSString = "clientWidth"
    @usableFromInline static let clientX: JSString = "clientX"
    @usableFromInline static let clientY: JSString = "clientY"
    @usableFromInline static let clip: JSString = "clip"
    @usableFromInline static let clone: JSString = "clone"
    @usableFromInline static let cloneContents: JSString = "cloneContents"
    @usableFromInline static let cloneNode: JSString = "cloneNode"
    @usableFromInline static let cloneRange: JSString = "cloneRange"
    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let closePath: JSString = "closePath"
    @usableFromInline static let closed: JSString = "closed"
    @usableFromInline static let closest: JSString = "closest"
    @usableFromInline static let code: JSString = "code"
    @usableFromInline static let codeBase: JSString = "codeBase"
    @usableFromInline static let codeType: JSString = "codeType"
    @usableFromInline static let codec: JSString = "codec"
    @usableFromInline static let codedHeight: JSString = "codedHeight"
    @usableFromInline static let codedRect: JSString = "codedRect"
    @usableFromInline static let codedWidth: JSString = "codedWidth"
    @usableFromInline static let colSpan: JSString = "colSpan"
    @usableFromInline static let collapse: JSString = "collapse"
    @usableFromInline static let collapsed: JSString = "collapsed"
    @usableFromInline static let colno: JSString = "colno"
    @usableFromInline static let color: JSString = "color"
    @usableFromInline static let colorDepth: JSString = "colorDepth"
    @usableFromInline static let colorMask: JSString = "colorMask"
    @usableFromInline static let colorSpace: JSString = "colorSpace"
    @usableFromInline static let colorSpaceConversion: JSString = "colorSpaceConversion"
    @usableFromInline static let cols: JSString = "cols"
    @usableFromInline static let commit: JSString = "commit"
    @usableFromInline static let commitStyles: JSString = "commitStyles"
    @usableFromInline static let commonAncestorContainer: JSString = "commonAncestorContainer"
    @usableFromInline static let compact: JSString = "compact"
    @usableFromInline static let compareBoundaryPoints: JSString = "compareBoundaryPoints"
    @usableFromInline static let compareDocumentPosition: JSString = "compareDocumentPosition"
    @usableFromInline static let comparePoint: JSString = "comparePoint"
    @usableFromInline static let compatMode: JSString = "compatMode"
    @usableFromInline static let compileShader: JSString = "compileShader"
    @usableFromInline static let complete: JSString = "complete"
    @usableFromInline static let completeFramesOnly: JSString = "completeFramesOnly"
    @usableFromInline static let completed: JSString = "completed"
    @usableFromInline static let composed: JSString = "composed"
    @usableFromInline static let composedPath: JSString = "composedPath"
    @usableFromInline static let composite: JSString = "composite"
    @usableFromInline static let compressedTexImage2D: JSString = "compressedTexImage2D"
    @usableFromInline static let compressedTexSubImage2D: JSString = "compressedTexSubImage2D"
    @usableFromInline static let computedOffset: JSString = "computedOffset"
    @usableFromInline static let coneInnerAngle: JSString = "coneInnerAngle"
    @usableFromInline static let coneOuterAngle: JSString = "coneOuterAngle"
    @usableFromInline static let coneOuterGain: JSString = "coneOuterGain"
    @usableFromInline static let config: JSString = "config"
    @usableFromInline static let configure: JSString = "configure"
    @usableFromInline static let confirm: JSString = "confirm"
    @usableFromInline static let connect: JSString = "connect"
    @usableFromInline static let console: JSString = "console"
    @usableFromInline static let constraint: JSString = "constraint"
    @usableFromInline static let contains: JSString = "contains"
    @usableFromInline static let content: JSString = "content"
    @usableFromInline static let contentDocument: JSString = "contentDocument"
    @usableFromInline static let contentEditable: JSString = "contentEditable"
    @usableFromInline static let contentType: JSString = "contentType"
    @usableFromInline static let contentWindow: JSString = "contentWindow"
    @usableFromInline static let context: JSString = "context"
    @usableFromInline static let contextTime: JSString = "contextTime"
    @usableFromInline static let control: JSString = "control"
    @usableFromInline static let controller: JSString = "controller"
    @usableFromInline static let controls: JSString = "controls"
    @usableFromInline static let convertPointFromNode: JSString = "convertPointFromNode"
    @usableFromInline static let convertQuadFromNode: JSString = "convertQuadFromNode"
    @usableFromInline static let convertRectFromNode: JSString = "convertRectFromNode"
    @usableFromInline static let convertToBlob: JSString = "convertToBlob"
    @usableFromInline static let cookie: JSString = "cookie"
    @usableFromInline static let cookieEnabled: JSString = "cookieEnabled"
    @usableFromInline static let coords: JSString = "coords"
    @usableFromInline static let copyFromChannel: JSString = "copyFromChannel"
    @usableFromInline static let copyTexImage2D: JSString = "copyTexImage2D"
    @usableFromInline static let copyTexSubImage2D: JSString = "copyTexSubImage2D"
    @usableFromInline static let copyTo: JSString = "copyTo"
    @usableFromInline static let copyToChannel: JSString = "copyToChannel"
    @usableFromInline static let count: JSString = "count"
    @usableFromInline static let countReset: JSString = "countReset"
    @usableFromInline static let createAnalyser: JSString = "createAnalyser"
    @usableFromInline static let createAttribute: JSString = "createAttribute"
    @usableFromInline static let createAttributeNS: JSString = "createAttributeNS"
    @usableFromInline static let createBiquadFilter: JSString = "createBiquadFilter"
    @usableFromInline static let createBuffer: JSString = "createBuffer"
    @usableFromInline static let createBufferSource: JSString = "createBufferSource"
    @usableFromInline static let createCDATASection: JSString = "createCDATASection"
    @usableFromInline static let createCaption: JSString = "createCaption"
    @usableFromInline static let createChannelMerger: JSString = "createChannelMerger"
    @usableFromInline static let createChannelSplitter: JSString = "createChannelSplitter"
    @usableFromInline static let createComment: JSString = "createComment"
    @usableFromInline static let createConicGradient: JSString = "createConicGradient"
    @usableFromInline static let createConstantSource: JSString = "createConstantSource"
    @usableFromInline static let createConvolver: JSString = "createConvolver"
    @usableFromInline static let createDelay: JSString = "createDelay"
    @usableFromInline static let createDocument: JSString = "createDocument"
    @usableFromInline static let createDocumentFragment: JSString = "createDocumentFragment"
    @usableFromInline static let createDocumentType: JSString = "createDocumentType"
    @usableFromInline static let createDynamicsCompressor: JSString = "createDynamicsCompressor"
    @usableFromInline static let createElement: JSString = "createElement"
    @usableFromInline static let createElementNS: JSString = "createElementNS"
    @usableFromInline static let createEvent: JSString = "createEvent"
    @usableFromInline static let createFramebuffer: JSString = "createFramebuffer"
    @usableFromInline static let createGain: JSString = "createGain"
    @usableFromInline static let createHTMLDocument: JSString = "createHTMLDocument"
    @usableFromInline static let createIIRFilter: JSString = "createIIRFilter"
    @usableFromInline static let createImageBitmap: JSString = "createImageBitmap"
    @usableFromInline static let createImageData: JSString = "createImageData"
    @usableFromInline static let createLinearGradient: JSString = "createLinearGradient"
    @usableFromInline static let createMediaElementSource: JSString = "createMediaElementSource"
    @usableFromInline static let createMediaStreamDestination: JSString = "createMediaStreamDestination"
    @usableFromInline static let createMediaStreamSource: JSString = "createMediaStreamSource"
    @usableFromInline static let createMediaStreamTrackSource: JSString = "createMediaStreamTrackSource"
    @usableFromInline static let createObjectURL: JSString = "createObjectURL"
    @usableFromInline static let createOscillator: JSString = "createOscillator"
    @usableFromInline static let createPanner: JSString = "createPanner"
    @usableFromInline static let createPattern: JSString = "createPattern"
    @usableFromInline static let createPeriodicWave: JSString = "createPeriodicWave"
    @usableFromInline static let createProcessingInstruction: JSString = "createProcessingInstruction"
    @usableFromInline static let createProgram: JSString = "createProgram"
    @usableFromInline static let createRadialGradient: JSString = "createRadialGradient"
    @usableFromInline static let createRange: JSString = "createRange"
    @usableFromInline static let createRenderbuffer: JSString = "createRenderbuffer"
    @usableFromInline static let createScriptProcessor: JSString = "createScriptProcessor"
    @usableFromInline static let createShader: JSString = "createShader"
    @usableFromInline static let createStereoPanner: JSString = "createStereoPanner"
    @usableFromInline static let createTBody: JSString = "createTBody"
    @usableFromInline static let createTFoot: JSString = "createTFoot"
    @usableFromInline static let createTHead: JSString = "createTHead"
    @usableFromInline static let createTextNode: JSString = "createTextNode"
    @usableFromInline static let createTexture: JSString = "createTexture"
    @usableFromInline static let createWaveShaper: JSString = "createWaveShaper"
    @usableFromInline static let credentials: JSString = "credentials"
    @usableFromInline static let crossOrigin: JSString = "crossOrigin"
    @usableFromInline static let crossOriginIsolated: JSString = "crossOriginIsolated"
    @usableFromInline static let ctrlKey: JSString = "ctrlKey"
    @usableFromInline static let cues: JSString = "cues"
    @usableFromInline static let cullFace: JSString = "cullFace"
    @usableFromInline static let currentIteration: JSString = "currentIteration"
    @usableFromInline static let currentNode: JSString = "currentNode"
    @usableFromInline static let currentScript: JSString = "currentScript"
    @usableFromInline static let currentSrc: JSString = "currentSrc"
    @usableFromInline static let currentTarget: JSString = "currentTarget"
    @usableFromInline static let currentTime: JSString = "currentTime"
    @usableFromInline static let curve: JSString = "curve"
    @usableFromInline static let customElements: JSString = "customElements"
    @usableFromInline static let customError: JSString = "customError"
    @usableFromInline static let d: JSString = "d"
    @usableFromInline static let data: JSString = "data"
    @usableFromInline static let dataTransfer: JSString = "dataTransfer"
    @usableFromInline static let dataset: JSString = "dataset"
    @usableFromInline static let dateTime: JSString = "dateTime"
    @usableFromInline static let debug: JSString = "debug"
    @usableFromInline static let declare: JSString = "declare"
    @usableFromInline static let decode: JSString = "decode"
    @usableFromInline static let decodeQueueSize: JSString = "decodeQueueSize"
    @usableFromInline static let decoderConfig: JSString = "decoderConfig"
    @usableFromInline static let decoding: JSString = "decoding"
    @usableFromInline static let `default`: JSString = "default"
    @usableFromInline static let defaultChecked: JSString = "defaultChecked"
    @usableFromInline static let defaultMuted: JSString = "defaultMuted"
    @usableFromInline static let defaultPlaybackRate: JSString = "defaultPlaybackRate"
    @usableFromInline static let defaultPrevented: JSString = "defaultPrevented"
    @usableFromInline static let defaultSelected: JSString = "defaultSelected"
    @usableFromInline static let defaultValue: JSString = "defaultValue"
    @usableFromInline static let defaultView: JSString = "defaultView"
    @usableFromInline static let `defer`: JSString = "defer"
    @usableFromInline static let define: JSString = "define"
    @usableFromInline static let delay: JSString = "delay"
    @usableFromInline static let delayTime: JSString = "delayTime"
    @usableFromInline static let delegatesFocus: JSString = "delegatesFocus"
    @usableFromInline static let delete: JSString = "delete"
    @usableFromInline static let deleteBuffer: JSString = "deleteBuffer"
    @usableFromInline static let deleteCaption: JSString = "deleteCaption"
    @usableFromInline static let deleteCell: JSString = "deleteCell"
    @usableFromInline static let deleteContents: JSString = "deleteContents"
    @usableFromInline static let deleteData: JSString = "deleteData"
    @usableFromInline static let deleteFramebuffer: JSString = "deleteFramebuffer"
    @usableFromInline static let deleteProgram: JSString = "deleteProgram"
    @usableFromInline static let deleteRenderbuffer: JSString = "deleteRenderbuffer"
    @usableFromInline static let deleteRow: JSString = "deleteRow"
    @usableFromInline static let deleteShader: JSString = "deleteShader"
    @usableFromInline static let deleteTFoot: JSString = "deleteTFoot"
    @usableFromInline static let deleteTHead: JSString = "deleteTHead"
    @usableFromInline static let deleteTexture: JSString = "deleteTexture"
    @usableFromInline static let deltaMode: JSString = "deltaMode"
    @usableFromInline static let deltaX: JSString = "deltaX"
    @usableFromInline static let deltaY: JSString = "deltaY"
    @usableFromInline static let deltaZ: JSString = "deltaZ"
    @usableFromInline static let depth: JSString = "depth"
    @usableFromInline static let depthFunc: JSString = "depthFunc"
    @usableFromInline static let depthMask: JSString = "depthMask"
    @usableFromInline static let depthRange: JSString = "depthRange"
    @usableFromInline static let description: JSString = "description"
    @usableFromInline static let designMode: JSString = "designMode"
    @usableFromInline static let desiredHeight: JSString = "desiredHeight"
    @usableFromInline static let desiredSize: JSString = "desiredSize"
    @usableFromInline static let desiredWidth: JSString = "desiredWidth"
    @usableFromInline static let destination: JSString = "destination"
    @usableFromInline static let desynchronized: JSString = "desynchronized"
    @usableFromInline static let detach: JSString = "detach"
    @usableFromInline static let detachShader: JSString = "detachShader"
    @usableFromInline static let detail: JSString = "detail"
    @usableFromInline static let detune: JSString = "detune"
    @usableFromInline static let deviceId: JSString = "deviceId"
    @usableFromInline static let devicePixelRatio: JSString = "devicePixelRatio"
    @usableFromInline static let dir: JSString = "dir"
    @usableFromInline static let dirName: JSString = "dirName"
    @usableFromInline static let direction: JSString = "direction"
    @usableFromInline static let dirxml: JSString = "dirxml"
    @usableFromInline static let disable: JSString = "disable"
    @usableFromInline static let disableNormalization: JSString = "disableNormalization"
    @usableFromInline static let disableVertexAttribArray: JSString = "disableVertexAttribArray"
    @usableFromInline static let disabled: JSString = "disabled"
    @usableFromInline static let disconnect: JSString = "disconnect"
    @usableFromInline static let dispatchEvent: JSString = "dispatchEvent"
    @usableFromInline static let displayAspectHeight: JSString = "displayAspectHeight"
    @usableFromInline static let displayAspectWidth: JSString = "displayAspectWidth"
    @usableFromInline static let displayHeight: JSString = "displayHeight"
    @usableFromInline static let displayWidth: JSString = "displayWidth"
    @usableFromInline static let distanceModel: JSString = "distanceModel"
    @usableFromInline static let doctype: JSString = "doctype"
    @usableFromInline static let document: JSString = "document"
    @usableFromInline static let documentElement: JSString = "documentElement"
    @usableFromInline static let documentURI: JSString = "documentURI"
    @usableFromInline static let domain: JSString = "domain"
    @usableFromInline static let done: JSString = "done"
    @usableFromInline static let download: JSString = "download"
    @usableFromInline static let draggable: JSString = "draggable"
    @usableFromInline static let drawArrays: JSString = "drawArrays"
    @usableFromInline static let drawElements: JSString = "drawElements"
    @usableFromInline static let drawFocusIfNeeded: JSString = "drawFocusIfNeeded"
    @usableFromInline static let drawImage: JSString = "drawImage"
    @usableFromInline static let drawingBufferHeight: JSString = "drawingBufferHeight"
    @usableFromInline static let drawingBufferWidth: JSString = "drawingBufferWidth"
    @usableFromInline static let dropEffect: JSString = "dropEffect"
    @usableFromInline static let duration: JSString = "duration"
    @usableFromInline static let e: JSString = "e"
    @usableFromInline static let easing: JSString = "easing"
    @usableFromInline static let echoCancellation: JSString = "echoCancellation"
    @usableFromInline static let effect: JSString = "effect"
    @usableFromInline static let effectAllowed: JSString = "effectAllowed"
    @usableFromInline static let element: JSString = "element"
    @usableFromInline static let elementFromPoint: JSString = "elementFromPoint"
    @usableFromInline static let elements: JSString = "elements"
    @usableFromInline static let elementsFromPoint: JSString = "elementsFromPoint"
    @usableFromInline static let ellipse: JSString = "ellipse"
    @usableFromInline static let emHeightAscent: JSString = "emHeightAscent"
    @usableFromInline static let emHeightDescent: JSString = "emHeightDescent"
    @usableFromInline static let embeds: JSString = "embeds"
    @usableFromInline static let enable: JSString = "enable"
    @usableFromInline static let enableVertexAttribArray: JSString = "enableVertexAttribArray"
    @usableFromInline static let enabled: JSString = "enabled"
    @usableFromInline static let enabledPlugin: JSString = "enabledPlugin"
    @usableFromInline static let encode: JSString = "encode"
    @usableFromInline static let encodeQueueSize: JSString = "encodeQueueSize"
    @usableFromInline static let encoding: JSString = "encoding"
    @usableFromInline static let enctype: JSString = "enctype"
    @usableFromInline static let end: JSString = "end"
    @usableFromInline static let endContainer: JSString = "endContainer"
    @usableFromInline static let endDelay: JSString = "endDelay"
    @usableFromInline static let endOffset: JSString = "endOffset"
    @usableFromInline static let endTime: JSString = "endTime"
    @usableFromInline static let ended: JSString = "ended"
    @usableFromInline static let endings: JSString = "endings"
    @usableFromInline static let enqueue: JSString = "enqueue"
    @usableFromInline static let enterKeyHint: JSString = "enterKeyHint"
    @usableFromInline static let enumerateDevices: JSString = "enumerateDevices"
    @usableFromInline static let error: JSString = "error"
    @usableFromInline static let evaluate: JSString = "evaluate"
    @usableFromInline static let event: JSString = "event"
    @usableFromInline static let eventPhase: JSString = "eventPhase"
    @usableFromInline static let exact: JSString = "exact"
    @usableFromInline static let execCommand: JSString = "execCommand"
    @usableFromInline static let exponentialRampToValueAtTime: JSString = "exponentialRampToValueAtTime"
    @usableFromInline static let extends: JSString = "extends"
    @usableFromInline static let extensions: JSString = "extensions"
    @usableFromInline static let external: JSString = "external"
    @usableFromInline static let extractContents: JSString = "extractContents"
    @usableFromInline static let f: JSString = "f"
    @usableFromInline static let face: JSString = "face"
    @usableFromInline static let facingMode: JSString = "facingMode"
    @usableFromInline static let failIfMajorPerformanceCaveat: JSString = "failIfMajorPerformanceCaveat"
    @usableFromInline static let fastSeek: JSString = "fastSeek"
    @usableFromInline static let feedback: JSString = "feedback"
    @usableFromInline static let feedforward: JSString = "feedforward"
    @usableFromInline static let fetch: JSString = "fetch"
    @usableFromInline static let fftSize: JSString = "fftSize"
    @usableFromInline static let fgColor: JSString = "fgColor"
    @usableFromInline static let filename: JSString = "filename"
    @usableFromInline static let files: JSString = "files"
    @usableFromInline static let fill: JSString = "fill"
    @usableFromInline static let fillRect: JSString = "fillRect"
    @usableFromInline static let fillStyle: JSString = "fillStyle"
    @usableFromInline static let fillText: JSString = "fillText"
    @usableFromInline static let filter: JSString = "filter"
    @usableFromInline static let finish: JSString = "finish"
    @usableFromInline static let finished: JSString = "finished"
    @usableFromInline static let firstChild: JSString = "firstChild"
    @usableFromInline static let firstElementChild: JSString = "firstElementChild"
    @usableFromInline static let flatten: JSString = "flatten"
    @usableFromInline static let flipX: JSString = "flipX"
    @usableFromInline static let flipY: JSString = "flipY"
    @usableFromInline static let flush: JSString = "flush"
    @usableFromInline static let focus: JSString = "focus"
    @usableFromInline static let font: JSString = "font"
    @usableFromInline static let fontBoundingBoxAscent: JSString = "fontBoundingBoxAscent"
    @usableFromInline static let fontBoundingBoxDescent: JSString = "fontBoundingBoxDescent"
    @usableFromInline static let fontKerning: JSString = "fontKerning"
    @usableFromInline static let fontStretch: JSString = "fontStretch"
    @usableFromInline static let fontVariantCaps: JSString = "fontVariantCaps"
    @usableFromInline static let form: JSString = "form"
    @usableFromInline static let formAction: JSString = "formAction"
    @usableFromInline static let formData: JSString = "formData"
    @usableFromInline static let formEnctype: JSString = "formEnctype"
    @usableFromInline static let formMethod: JSString = "formMethod"
    @usableFromInline static let formNoValidate: JSString = "formNoValidate"
    @usableFromInline static let formTarget: JSString = "formTarget"
    @usableFromInline static let format: JSString = "format"
    @usableFromInline static let forms: JSString = "forms"
    @usableFromInline static let forward: JSString = "forward"
    @usableFromInline static let forwardX: JSString = "forwardX"
    @usableFromInline static let forwardY: JSString = "forwardY"
    @usableFromInline static let forwardZ: JSString = "forwardZ"
    @usableFromInline static let frame: JSString = "frame"
    @usableFromInline static let frameBorder: JSString = "frameBorder"
    @usableFromInline static let frameCount: JSString = "frameCount"
    @usableFromInline static let frameElement: JSString = "frameElement"
    @usableFromInline static let frameIndex: JSString = "frameIndex"
    @usableFromInline static let frameOffset: JSString = "frameOffset"
    @usableFromInline static let frameRate: JSString = "frameRate"
    @usableFromInline static let framebufferRenderbuffer: JSString = "framebufferRenderbuffer"
    @usableFromInline static let framebufferTexture2D: JSString = "framebufferTexture2D"
    @usableFromInline static let framerate: JSString = "framerate"
    @usableFromInline static let frames: JSString = "frames"
    @usableFromInline static let frequency: JSString = "frequency"
    @usableFromInline static let frequencyBinCount: JSString = "frequencyBinCount"
    @usableFromInline static let fromBox: JSString = "fromBox"
    @usableFromInline static let fromFloat32Array: JSString = "fromFloat32Array"
    @usableFromInline static let fromFloat64Array: JSString = "fromFloat64Array"
    @usableFromInline static let fromMatrix: JSString = "fromMatrix"
    @usableFromInline static let fromPoint: JSString = "fromPoint"
    @usableFromInline static let fromQuad: JSString = "fromQuad"
    @usableFromInline static let fromRect: JSString = "fromRect"
    @usableFromInline static let frontFace: JSString = "frontFace"
    @usableFromInline static let fullRange: JSString = "fullRange"
    @usableFromInline static let gain: JSString = "gain"
    @usableFromInline static let generateMipmap: JSString = "generateMipmap"
    @usableFromInline static let get: JSString = "get"
    @usableFromInline static let getActiveAttrib: JSString = "getActiveAttrib"
    @usableFromInline static let getActiveUniform: JSString = "getActiveUniform"
    @usableFromInline static let getAll: JSString = "getAll"
    @usableFromInline static let getAllResponseHeaders: JSString = "getAllResponseHeaders"
    @usableFromInline static let getAnimations: JSString = "getAnimations"
    @usableFromInline static let getAsFile: JSString = "getAsFile"
    @usableFromInline static let getAttachedShaders: JSString = "getAttachedShaders"
    @usableFromInline static let getAttribLocation: JSString = "getAttribLocation"
    @usableFromInline static let getAttribute: JSString = "getAttribute"
    @usableFromInline static let getAttributeNS: JSString = "getAttributeNS"
    @usableFromInline static let getAttributeNames: JSString = "getAttributeNames"
    @usableFromInline static let getAttributeNode: JSString = "getAttributeNode"
    @usableFromInline static let getAttributeNodeNS: JSString = "getAttributeNodeNS"
    @usableFromInline static let getAudioTracks: JSString = "getAudioTracks"
    @usableFromInline static let getBoundingClientRect: JSString = "getBoundingClientRect"
    @usableFromInline static let getBounds: JSString = "getBounds"
    @usableFromInline static let getBoxQuads: JSString = "getBoxQuads"
    @usableFromInline static let getBufferParameter: JSString = "getBufferParameter"
    @usableFromInline static let getByteFrequencyData: JSString = "getByteFrequencyData"
    @usableFromInline static let getByteTimeDomainData: JSString = "getByteTimeDomainData"
    @usableFromInline static let getCapabilities: JSString = "getCapabilities"
    @usableFromInline static let getChannelData: JSString = "getChannelData"
    @usableFromInline static let getClientRect: JSString = "getClientRect"
    @usableFromInline static let getClientRects: JSString = "getClientRects"
    @usableFromInline static let getComputedTiming: JSString = "getComputedTiming"
    @usableFromInline static let getConstraints: JSString = "getConstraints"
    @usableFromInline static let getContextAttributes: JSString = "getContextAttributes"
    @usableFromInline static let getCueById: JSString = "getCueById"
    @usableFromInline static let getData: JSString = "getData"
    @usableFromInline static let getElementById: JSString = "getElementById"
    @usableFromInline static let getElementsByClassName: JSString = "getElementsByClassName"
    @usableFromInline static let getElementsByName: JSString = "getElementsByName"
    @usableFromInline static let getElementsByTagName: JSString = "getElementsByTagName"
    @usableFromInline static let getElementsByTagNameNS: JSString = "getElementsByTagNameNS"
    @usableFromInline static let getError: JSString = "getError"
    @usableFromInline static let getExtension: JSString = "getExtension"
    @usableFromInline static let getFloatFrequencyData: JSString = "getFloatFrequencyData"
    @usableFromInline static let getFloatTimeDomainData: JSString = "getFloatTimeDomainData"
    @usableFromInline static let getFramebufferAttachmentParameter: JSString = "getFramebufferAttachmentParameter"
    @usableFromInline static let getFrequencyResponse: JSString = "getFrequencyResponse"
    @usableFromInline static let getImageData: JSString = "getImageData"
    @usableFromInline static let getKeyframes: JSString = "getKeyframes"
    @usableFromInline static let getLineDash: JSString = "getLineDash"
    @usableFromInline static let getModifierState: JSString = "getModifierState"
    @usableFromInline static let getNamedItemNS: JSString = "getNamedItemNS"
    @usableFromInline static let getOutputTimestamp: JSString = "getOutputTimestamp"
    @usableFromInline static let getParameter: JSString = "getParameter"
    @usableFromInline static let getProgramInfoLog: JSString = "getProgramInfoLog"
    @usableFromInline static let getProgramParameter: JSString = "getProgramParameter"
    @usableFromInline static let getReader: JSString = "getReader"
    @usableFromInline static let getRegistration: JSString = "getRegistration"
    @usableFromInline static let getRegistrations: JSString = "getRegistrations"
    @usableFromInline static let getRenderbufferParameter: JSString = "getRenderbufferParameter"
    @usableFromInline static let getResponseHeader: JSString = "getResponseHeader"
    @usableFromInline static let getRootNode: JSString = "getRootNode"
    @usableFromInline static let getSVGDocument: JSString = "getSVGDocument"
    @usableFromInline static let getSettings: JSString = "getSettings"
    @usableFromInline static let getShaderInfoLog: JSString = "getShaderInfoLog"
    @usableFromInline static let getShaderParameter: JSString = "getShaderParameter"
    @usableFromInline static let getShaderPrecisionFormat: JSString = "getShaderPrecisionFormat"
    @usableFromInline static let getShaderSource: JSString = "getShaderSource"
    @usableFromInline static let getStartDate: JSString = "getStartDate"
    @usableFromInline static let getState: JSString = "getState"
    @usableFromInline static let getSupportedConstraints: JSString = "getSupportedConstraints"
    @usableFromInline static let getSupportedExtensions: JSString = "getSupportedExtensions"
    @usableFromInline static let getTexParameter: JSString = "getTexParameter"
    @usableFromInline static let getTiming: JSString = "getTiming"
    @usableFromInline static let getTrackById: JSString = "getTrackById"
    @usableFromInline static let getTracks: JSString = "getTracks"
    @usableFromInline static let getTransform: JSString = "getTransform"
    @usableFromInline static let getUniform: JSString = "getUniform"
    @usableFromInline static let getUniformLocation: JSString = "getUniformLocation"
    @usableFromInline static let getUserMedia: JSString = "getUserMedia"
    @usableFromInline static let getVertexAttrib: JSString = "getVertexAttrib"
    @usableFromInline static let getVertexAttribOffset: JSString = "getVertexAttribOffset"
    @usableFromInline static let getVideoTracks: JSString = "getVideoTracks"
    @usableFromInline static let getWriter: JSString = "getWriter"
    @usableFromInline static let globalAlpha: JSString = "globalAlpha"
    @usableFromInline static let globalCompositeOperation: JSString = "globalCompositeOperation"
    @usableFromInline static let go: JSString = "go"
    @usableFromInline static let group: JSString = "group"
    @usableFromInline static let groupCollapsed: JSString = "groupCollapsed"
    @usableFromInline static let groupEnd: JSString = "groupEnd"
    @usableFromInline static let groupId: JSString = "groupId"
    @usableFromInline static let handled: JSString = "handled"
    @usableFromInline static let hangingBaseline: JSString = "hangingBaseline"
    @usableFromInline static let hardwareAcceleration: JSString = "hardwareAcceleration"
    @usableFromInline static let hardwareConcurrency: JSString = "hardwareConcurrency"
    @usableFromInline static let has: JSString = "has"
    @usableFromInline static let hasAttribute: JSString = "hasAttribute"
    @usableFromInline static let hasAttributeNS: JSString = "hasAttributeNS"
    @usableFromInline static let hasAttributes: JSString = "hasAttributes"
    @usableFromInline static let hasChildNodes: JSString = "hasChildNodes"
    @usableFromInline static let hasFeature: JSString = "hasFeature"
    @usableFromInline static let hasFocus: JSString = "hasFocus"
    @usableFromInline static let hash: JSString = "hash"
    @usableFromInline static let head: JSString = "head"
    @usableFromInline static let headerValue: JSString = "headerValue"
    @usableFromInline static let headers: JSString = "headers"
    @usableFromInline static let height: JSString = "height"
    @usableFromInline static let hidden: JSString = "hidden"
    @usableFromInline static let high: JSString = "high"
    @usableFromInline static let highWaterMark: JSString = "highWaterMark"
    @usableFromInline static let hint: JSString = "hint"
    @usableFromInline static let history: JSString = "history"
    @usableFromInline static let host: JSString = "host"
    @usableFromInline static let hostname: JSString = "hostname"
    @usableFromInline static let href: JSString = "href"
    @usableFromInline static let hreflang: JSString = "hreflang"
    @usableFromInline static let hspace: JSString = "hspace"
    @usableFromInline static let htmlFor: JSString = "htmlFor"
    @usableFromInline static let httpEquiv: JSString = "httpEquiv"
    @usableFromInline static let id: JSString = "id"
    @usableFromInline static let ideal: JSString = "ideal"
    @usableFromInline static let ideographicBaseline: JSString = "ideographicBaseline"
    @usableFromInline static let ignoreMethod: JSString = "ignoreMethod"
    @usableFromInline static let ignoreSearch: JSString = "ignoreSearch"
    @usableFromInline static let ignoreVary: JSString = "ignoreVary"
    @usableFromInline static let imag: JSString = "imag"
    @usableFromInline static let image: JSString = "image"
    @usableFromInline static let imageOrientation: JSString = "imageOrientation"
    @usableFromInline static let imageSizes: JSString = "imageSizes"
    @usableFromInline static let imageSmoothingEnabled: JSString = "imageSmoothingEnabled"
    @usableFromInline static let imageSmoothingQuality: JSString = "imageSmoothingQuality"
    @usableFromInline static let imageSrcset: JSString = "imageSrcset"
    @usableFromInline static let images: JSString = "images"
    @usableFromInline static let implementation: JSString = "implementation"
    @usableFromInline static let importNode: JSString = "importNode"
    @usableFromInline static let importStylesheet: JSString = "importStylesheet"
    @usableFromInline static let inBandMetadataTrackDispatchType: JSString = "inBandMetadataTrackDispatchType"
    @usableFromInline static let includeUncontrolled: JSString = "includeUncontrolled"
    @usableFromInline static let indeterminate: JSString = "indeterminate"
    @usableFromInline static let index: JSString = "index"
    @usableFromInline static let inert: JSString = "inert"
    @usableFromInline static let info: JSString = "info"
    @usableFromInline static let initCompositionEvent: JSString = "initCompositionEvent"
    @usableFromInline static let initCustomEvent: JSString = "initCustomEvent"
    @usableFromInline static let initEvent: JSString = "initEvent"
    @usableFromInline static let initKeyboardEvent: JSString = "initKeyboardEvent"
    @usableFromInline static let initMessageEvent: JSString = "initMessageEvent"
    @usableFromInline static let initMouseEvent: JSString = "initMouseEvent"
    @usableFromInline static let initMutationEvent: JSString = "initMutationEvent"
    @usableFromInline static let initStorageEvent: JSString = "initStorageEvent"
    @usableFromInline static let initUIEvent: JSString = "initUIEvent"
    @usableFromInline static let inline: JSString = "inline"
    @usableFromInline static let innerHeight: JSString = "innerHeight"
    @usableFromInline static let innerText: JSString = "innerText"
    @usableFromInline static let innerWidth: JSString = "innerWidth"
    @usableFromInline static let inputBuffer: JSString = "inputBuffer"
    @usableFromInline static let inputEncoding: JSString = "inputEncoding"
    @usableFromInline static let inputMode: JSString = "inputMode"
    @usableFromInline static let inputType: JSString = "inputType"
    @usableFromInline static let insertAdjacentElement: JSString = "insertAdjacentElement"
    @usableFromInline static let insertAdjacentText: JSString = "insertAdjacentText"
    @usableFromInline static let insertBefore: JSString = "insertBefore"
    @usableFromInline static let insertCell: JSString = "insertCell"
    @usableFromInline static let insertData: JSString = "insertData"
    @usableFromInline static let insertNode: JSString = "insertNode"
    @usableFromInline static let insertRow: JSString = "insertRow"
    @usableFromInline static let installing: JSString = "installing"
    @usableFromInline static let integrity: JSString = "integrity"
    @usableFromInline static let intersectsNode: JSString = "intersectsNode"
    @usableFromInline static let invalidIteratorState: JSString = "invalidIteratorState"
    @usableFromInline static let inverse: JSString = "inverse"
    @usableFromInline static let invertSelf: JSString = "invertSelf"
    @usableFromInline static let `is`: JSString = "is"
    @usableFromInline static let is2D: JSString = "is2D"
    @usableFromInline static let isBuffer: JSString = "isBuffer"
    @usableFromInline static let isComposing: JSString = "isComposing"
    @usableFromInline static let isConfigSupported: JSString = "isConfigSupported"
    @usableFromInline static let isConnected: JSString = "isConnected"
    @usableFromInline static let isContentEditable: JSString = "isContentEditable"
    @usableFromInline static let isContextLost: JSString = "isContextLost"
    @usableFromInline static let isDefaultNamespace: JSString = "isDefaultNamespace"
    @usableFromInline static let isEnabled: JSString = "isEnabled"
    @usableFromInline static let isEqualNode: JSString = "isEqualNode"
    @usableFromInline static let isFramebuffer: JSString = "isFramebuffer"
    @usableFromInline static let isHistoryNavigation: JSString = "isHistoryNavigation"
    @usableFromInline static let isIdentity: JSString = "isIdentity"
    @usableFromInline static let isMap: JSString = "isMap"
    @usableFromInline static let isPointInPath: JSString = "isPointInPath"
    @usableFromInline static let isPointInRange: JSString = "isPointInRange"
    @usableFromInline static let isPointInStroke: JSString = "isPointInStroke"
    @usableFromInline static let isProgram: JSString = "isProgram"
    @usableFromInline static let isReloadNavigation: JSString = "isReloadNavigation"
    @usableFromInline static let isRenderbuffer: JSString = "isRenderbuffer"
    @usableFromInline static let isSameNode: JSString = "isSameNode"
    @usableFromInline static let isSecureContext: JSString = "isSecureContext"
    @usableFromInline static let isShader: JSString = "isShader"
    @usableFromInline static let isTexture: JSString = "isTexture"
    @usableFromInline static let isTrusted: JSString = "isTrusted"
    @usableFromInline static let isTypeSupported: JSString = "isTypeSupported"
    @usableFromInline static let isVisible: JSString = "isVisible"
    @usableFromInline static let item: JSString = "item"
    @usableFromInline static let items: JSString = "items"
    @usableFromInline static let iterateNext: JSString = "iterateNext"
    @usableFromInline static let iterationStart: JSString = "iterationStart"
    @usableFromInline static let iterations: JSString = "iterations"
    @usableFromInline static let javaEnabled: JSString = "javaEnabled"
    @usableFromInline static let json: JSString = "json"
    @usableFromInline static let keepalive: JSString = "keepalive"
    @usableFromInline static let key: JSString = "key"
    @usableFromInline static let keyCode: JSString = "keyCode"
    @usableFromInline static let keyFrame: JSString = "keyFrame"
    @usableFromInline static let keys: JSString = "keys"
    @usableFromInline static let kind: JSString = "kind"
    @usableFromInline static let knee: JSString = "knee"
    @usableFromInline static let label: JSString = "label"
    @usableFromInline static let labels: JSString = "labels"
    @usableFromInline static let lang: JSString = "lang"
    @usableFromInline static let language: JSString = "language"
    @usableFromInline static let languages: JSString = "languages"
    @usableFromInline static let lastChild: JSString = "lastChild"
    @usableFromInline static let lastElementChild: JSString = "lastElementChild"
    @usableFromInline static let lastEventId: JSString = "lastEventId"
    @usableFromInline static let lastModified: JSString = "lastModified"
    @usableFromInline static let latency: JSString = "latency"
    @usableFromInline static let latencyHint: JSString = "latencyHint"
    @usableFromInline static let latencyMode: JSString = "latencyMode"
    @usableFromInline static let layout: JSString = "layout"
    @usableFromInline static let left: JSString = "left"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let lengthComputable: JSString = "lengthComputable"
    @usableFromInline static let letterSpacing: JSString = "letterSpacing"
    @usableFromInline static let lineCap: JSString = "lineCap"
    @usableFromInline static let lineDashOffset: JSString = "lineDashOffset"
    @usableFromInline static let lineJoin: JSString = "lineJoin"
    @usableFromInline static let lineTo: JSString = "lineTo"
    @usableFromInline static let lineWidth: JSString = "lineWidth"
    @usableFromInline static let linearRampToValueAtTime: JSString = "linearRampToValueAtTime"
    @usableFromInline static let lineno: JSString = "lineno"
    @usableFromInline static let link: JSString = "link"
    @usableFromInline static let linkColor: JSString = "linkColor"
    @usableFromInline static let linkProgram: JSString = "linkProgram"
    @usableFromInline static let links: JSString = "links"
    @usableFromInline static let list: JSString = "list"
    @usableFromInline static let listener: JSString = "listener"
    @usableFromInline static let load: JSString = "load"
    @usableFromInline static let loaded: JSString = "loaded"
    @usableFromInline static let loading: JSString = "loading"
    @usableFromInline static let localName: JSString = "localName"
    @usableFromInline static let localStorage: JSString = "localStorage"
    @usableFromInline static let location: JSString = "location"
    @usableFromInline static let locationbar: JSString = "locationbar"
    @usableFromInline static let locked: JSString = "locked"
    @usableFromInline static let log: JSString = "log"
    @usableFromInline static let longDesc: JSString = "longDesc"
    @usableFromInline static let lookupNamespaceURI: JSString = "lookupNamespaceURI"
    @usableFromInline static let lookupPrefix: JSString = "lookupPrefix"
    @usableFromInline static let loop: JSString = "loop"
    @usableFromInline static let loopEnd: JSString = "loopEnd"
    @usableFromInline static let loopStart: JSString = "loopStart"
    @usableFromInline static let low: JSString = "low"
    @usableFromInline static let lowsrc: JSString = "lowsrc"
    @usableFromInline static let m11: JSString = "m11"
    @usableFromInline static let m12: JSString = "m12"
    @usableFromInline static let m13: JSString = "m13"
    @usableFromInline static let m14: JSString = "m14"
    @usableFromInline static let m21: JSString = "m21"
    @usableFromInline static let m22: JSString = "m22"
    @usableFromInline static let m23: JSString = "m23"
    @usableFromInline static let m24: JSString = "m24"
    @usableFromInline static let m31: JSString = "m31"
    @usableFromInline static let m32: JSString = "m32"
    @usableFromInline static let m33: JSString = "m33"
    @usableFromInline static let m34: JSString = "m34"
    @usableFromInline static let m41: JSString = "m41"
    @usableFromInline static let m42: JSString = "m42"
    @usableFromInline static let m43: JSString = "m43"
    @usableFromInline static let m44: JSString = "m44"
    @usableFromInline static let marginHeight: JSString = "marginHeight"
    @usableFromInline static let marginWidth: JSString = "marginWidth"
    @usableFromInline static let match: JSString = "match"
    @usableFromInline static let matchAll: JSString = "matchAll"
    @usableFromInline static let matchMedia: JSString = "matchMedia"
    @usableFromInline static let matches: JSString = "matches"
    @usableFromInline static let matrix: JSString = "matrix"
    @usableFromInline static let matrixTransform: JSString = "matrixTransform"
    @usableFromInline static let max: JSString = "max"
    @usableFromInline static let maxChannelCount: JSString = "maxChannelCount"
    @usableFromInline static let maxDecibels: JSString = "maxDecibels"
    @usableFromInline static let maxDelayTime: JSString = "maxDelayTime"
    @usableFromInline static let maxDistance: JSString = "maxDistance"
    @usableFromInline static let maxLength: JSString = "maxLength"
    @usableFromInline static let maxValue: JSString = "maxValue"
    @usableFromInline static let measureText: JSString = "measureText"
    @usableFromInline static let media: JSString = "media"
    @usableFromInline static let mediaDevices: JSString = "mediaDevices"
    @usableFromInline static let mediaElement: JSString = "mediaElement"
    @usableFromInline static let mediaStream: JSString = "mediaStream"
    @usableFromInline static let mediaStreamTrack: JSString = "mediaStreamTrack"
    @usableFromInline static let menubar: JSString = "menubar"
    @usableFromInline static let message: JSString = "message"
    @usableFromInline static let metaKey: JSString = "metaKey"
    @usableFromInline static let method: JSString = "method"
    @usableFromInline static let mimeType: JSString = "mimeType"
    @usableFromInline static let mimeTypes: JSString = "mimeTypes"
    @usableFromInline static let min: JSString = "min"
    @usableFromInline static let minDecibels: JSString = "minDecibels"
    @usableFromInline static let minLength: JSString = "minLength"
    @usableFromInline static let minValue: JSString = "minValue"
    @usableFromInline static let miterLimit: JSString = "miterLimit"
    @usableFromInline static let mode: JSString = "mode"
    @usableFromInline static let modifierAltGraph: JSString = "modifierAltGraph"
    @usableFromInline static let modifierCapsLock: JSString = "modifierCapsLock"
    @usableFromInline static let modifierFn: JSString = "modifierFn"
    @usableFromInline static let modifierFnLock: JSString = "modifierFnLock"
    @usableFromInline static let modifierHyper: JSString = "modifierHyper"
    @usableFromInline static let modifierNumLock: JSString = "modifierNumLock"
    @usableFromInline static let modifierScrollLock: JSString = "modifierScrollLock"
    @usableFromInline static let modifierSuper: JSString = "modifierSuper"
    @usableFromInline static let modifierSymbol: JSString = "modifierSymbol"
    @usableFromInline static let modifierSymbolLock: JSString = "modifierSymbolLock"
    @usableFromInline static let moveBy: JSString = "moveBy"
    @usableFromInline static let moveTo: JSString = "moveTo"
    @usableFromInline static let multiple: JSString = "multiple"
    @usableFromInline static let multiply: JSString = "multiply"
    @usableFromInline static let multiplySelf: JSString = "multiplySelf"
    @usableFromInline static let muted: JSString = "muted"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let namedItem: JSString = "namedItem"
    @usableFromInline static let namespaceURI: JSString = "namespaceURI"
    @usableFromInline static let naturalHeight: JSString = "naturalHeight"
    @usableFromInline static let naturalWidth: JSString = "naturalWidth"
    @usableFromInline static let navigationPreload: JSString = "navigationPreload"
    @usableFromInline static let navigator: JSString = "navigator"
    @usableFromInline static let networkState: JSString = "networkState"
    @usableFromInline static let newURL: JSString = "newURL"
    @usableFromInline static let newValue: JSString = "newValue"
    @usableFromInline static let nextElementSibling: JSString = "nextElementSibling"
    @usableFromInline static let nextNode: JSString = "nextNode"
    @usableFromInline static let nextSibling: JSString = "nextSibling"
    @usableFromInline static let noHref: JSString = "noHref"
    @usableFromInline static let noModule: JSString = "noModule"
    @usableFromInline static let noResize: JSString = "noResize"
    @usableFromInline static let noShade: JSString = "noShade"
    @usableFromInline static let noValidate: JSString = "noValidate"
    @usableFromInline static let noWrap: JSString = "noWrap"
    @usableFromInline static let nodeName: JSString = "nodeName"
    @usableFromInline static let nodeType: JSString = "nodeType"
    @usableFromInline static let nodeValue: JSString = "nodeValue"
    @usableFromInline static let noiseSuppression: JSString = "noiseSuppression"
    @usableFromInline static let nonce: JSString = "nonce"
    @usableFromInline static let normalize: JSString = "normalize"
    @usableFromInline static let now: JSString = "now"
    @usableFromInline static let numberOfChannels: JSString = "numberOfChannels"
    @usableFromInline static let numberOfFrames: JSString = "numberOfFrames"
    @usableFromInline static let numberOfInputs: JSString = "numberOfInputs"
    @usableFromInline static let numberOfOutputs: JSString = "numberOfOutputs"
    @usableFromInline static let numberValue: JSString = "numberValue"
    @usableFromInline static let observe: JSString = "observe"
    @usableFromInline static let offset: JSString = "offset"
    @usableFromInline static let offsetHeight: JSString = "offsetHeight"
    @usableFromInline static let offsetLeft: JSString = "offsetLeft"
    @usableFromInline static let offsetNode: JSString = "offsetNode"
    @usableFromInline static let offsetParent: JSString = "offsetParent"
    @usableFromInline static let offsetTop: JSString = "offsetTop"
    @usableFromInline static let offsetWidth: JSString = "offsetWidth"
    @usableFromInline static let offsetX: JSString = "offsetX"
    @usableFromInline static let offsetY: JSString = "offsetY"
    @usableFromInline static let ok: JSString = "ok"
    @usableFromInline static let oldURL: JSString = "oldURL"
    @usableFromInline static let oldValue: JSString = "oldValue"
    @usableFromInline static let onLine: JSString = "onLine"
    @usableFromInline static let onabort: JSString = "onabort"
    @usableFromInline static let onaddtrack: JSString = "onaddtrack"
    @usableFromInline static let onafterprint: JSString = "onafterprint"
    @usableFromInline static let onaudioprocess: JSString = "onaudioprocess"
    @usableFromInline static let onauxclick: JSString = "onauxclick"
    @usableFromInline static let onbeforeprint: JSString = "onbeforeprint"
    @usableFromInline static let onbeforeunload: JSString = "onbeforeunload"
    @usableFromInline static let onblur: JSString = "onblur"
    @usableFromInline static let oncancel: JSString = "oncancel"
    @usableFromInline static let oncanplay: JSString = "oncanplay"
    @usableFromInline static let oncanplaythrough: JSString = "oncanplaythrough"
    @usableFromInline static let once: JSString = "once"
    @usableFromInline static let onchange: JSString = "onchange"
    @usableFromInline static let onclick: JSString = "onclick"
    @usableFromInline static let onclose: JSString = "onclose"
    @usableFromInline static let oncomplete: JSString = "oncomplete"
    @usableFromInline static let oncontextlost: JSString = "oncontextlost"
    @usableFromInline static let oncontextmenu: JSString = "oncontextmenu"
    @usableFromInline static let oncontextrestored: JSString = "oncontextrestored"
    @usableFromInline static let oncontrollerchange: JSString = "oncontrollerchange"
    @usableFromInline static let oncopy: JSString = "oncopy"
    @usableFromInline static let oncuechange: JSString = "oncuechange"
    @usableFromInline static let oncut: JSString = "oncut"
    @usableFromInline static let ondataavailable: JSString = "ondataavailable"
    @usableFromInline static let ondblclick: JSString = "ondblclick"
    @usableFromInline static let ondevicechange: JSString = "ondevicechange"
    @usableFromInline static let ondrag: JSString = "ondrag"
    @usableFromInline static let ondragend: JSString = "ondragend"
    @usableFromInline static let ondragenter: JSString = "ondragenter"
    @usableFromInline static let ondragleave: JSString = "ondragleave"
    @usableFromInline static let ondragover: JSString = "ondragover"
    @usableFromInline static let ondragstart: JSString = "ondragstart"
    @usableFromInline static let ondrop: JSString = "ondrop"
    @usableFromInline static let ondurationchange: JSString = "ondurationchange"
    @usableFromInline static let onemptied: JSString = "onemptied"
    @usableFromInline static let onended: JSString = "onended"
    @usableFromInline static let onenter: JSString = "onenter"
    @usableFromInline static let onerror: JSString = "onerror"
    @usableFromInline static let onexit: JSString = "onexit"
    @usableFromInline static let onfinish: JSString = "onfinish"
    @usableFromInline static let onfocus: JSString = "onfocus"
    @usableFromInline static let onformdata: JSString = "onformdata"
    @usableFromInline static let onhashchange: JSString = "onhashchange"
    @usableFromInline static let oninput: JSString = "oninput"
    @usableFromInline static let oninvalid: JSString = "oninvalid"
    @usableFromInline static let onkeydown: JSString = "onkeydown"
    @usableFromInline static let onkeypress: JSString = "onkeypress"
    @usableFromInline static let onkeyup: JSString = "onkeyup"
    @usableFromInline static let onlanguagechange: JSString = "onlanguagechange"
    @usableFromInline static let onload: JSString = "onload"
    @usableFromInline static let onloadeddata: JSString = "onloadeddata"
    @usableFromInline static let onloadedmetadata: JSString = "onloadedmetadata"
    @usableFromInline static let onloadend: JSString = "onloadend"
    @usableFromInline static let onloadstart: JSString = "onloadstart"
    @usableFromInline static let onmessage: JSString = "onmessage"
    @usableFromInline static let onmessageerror: JSString = "onmessageerror"
    @usableFromInline static let onmousedown: JSString = "onmousedown"
    @usableFromInline static let onmouseenter: JSString = "onmouseenter"
    @usableFromInline static let onmouseleave: JSString = "onmouseleave"
    @usableFromInline static let onmousemove: JSString = "onmousemove"
    @usableFromInline static let onmouseout: JSString = "onmouseout"
    @usableFromInline static let onmouseover: JSString = "onmouseover"
    @usableFromInline static let onmouseup: JSString = "onmouseup"
    @usableFromInline static let onmute: JSString = "onmute"
    @usableFromInline static let onoffline: JSString = "onoffline"
    @usableFromInline static let ononline: JSString = "ononline"
    @usableFromInline static let onopen: JSString = "onopen"
    @usableFromInline static let onpagehide: JSString = "onpagehide"
    @usableFromInline static let onpageshow: JSString = "onpageshow"
    @usableFromInline static let onpaste: JSString = "onpaste"
    @usableFromInline static let onpause: JSString = "onpause"
    @usableFromInline static let onplay: JSString = "onplay"
    @usableFromInline static let onplaying: JSString = "onplaying"
    @usableFromInline static let onpopstate: JSString = "onpopstate"
    @usableFromInline static let onprocessorerror: JSString = "onprocessorerror"
    @usableFromInline static let onprogress: JSString = "onprogress"
    @usableFromInline static let onratechange: JSString = "onratechange"
    @usableFromInline static let onreadystatechange: JSString = "onreadystatechange"
    @usableFromInline static let onrejectionhandled: JSString = "onrejectionhandled"
    @usableFromInline static let onremove: JSString = "onremove"
    @usableFromInline static let onremovetrack: JSString = "onremovetrack"
    @usableFromInline static let onreset: JSString = "onreset"
    @usableFromInline static let onresize: JSString = "onresize"
    @usableFromInline static let onresume: JSString = "onresume"
    @usableFromInline static let onscroll: JSString = "onscroll"
    @usableFromInline static let onsecuritypolicyviolation: JSString = "onsecuritypolicyviolation"
    @usableFromInline static let onseeked: JSString = "onseeked"
    @usableFromInline static let onseeking: JSString = "onseeking"
    @usableFromInline static let onselect: JSString = "onselect"
    @usableFromInline static let onslotchange: JSString = "onslotchange"
    @usableFromInline static let onstalled: JSString = "onstalled"
    @usableFromInline static let onstart: JSString = "onstart"
    @usableFromInline static let onstatechange: JSString = "onstatechange"
    @usableFromInline static let onstop: JSString = "onstop"
    @usableFromInline static let onstorage: JSString = "onstorage"
    @usableFromInline static let onsubmit: JSString = "onsubmit"
    @usableFromInline static let onsuspend: JSString = "onsuspend"
    @usableFromInline static let ontimeout: JSString = "ontimeout"
    @usableFromInline static let ontimeupdate: JSString = "ontimeupdate"
    @usableFromInline static let ontoggle: JSString = "ontoggle"
    @usableFromInline static let onunhandledrejection: JSString = "onunhandledrejection"
    @usableFromInline static let onunload: JSString = "onunload"
    @usableFromInline static let onunmute: JSString = "onunmute"
    @usableFromInline static let onupdatefound: JSString = "onupdatefound"
    @usableFromInline static let onvisibilitychange: JSString = "onvisibilitychange"
    @usableFromInline static let onvolumechange: JSString = "onvolumechange"
    @usableFromInline static let onwaiting: JSString = "onwaiting"
    @usableFromInline static let onwebkitanimationend: JSString = "onwebkitanimationend"
    @usableFromInline static let onwebkitanimationiteration: JSString = "onwebkitanimationiteration"
    @usableFromInline static let onwebkitanimationstart: JSString = "onwebkitanimationstart"
    @usableFromInline static let onwebkittransitionend: JSString = "onwebkittransitionend"
    @usableFromInline static let onwheel: JSString = "onwheel"
    @usableFromInline static let open: JSString = "open"
    @usableFromInline static let opener: JSString = "opener"
    @usableFromInline static let optimizeForLatency: JSString = "optimizeForLatency"
    @usableFromInline static let optimum: JSString = "optimum"
    @usableFromInline static let options: JSString = "options"
    @usableFromInline static let orientationX: JSString = "orientationX"
    @usableFromInline static let orientationY: JSString = "orientationY"
    @usableFromInline static let orientationZ: JSString = "orientationZ"
    @usableFromInline static let origin: JSString = "origin"
    @usableFromInline static let originAgentCluster: JSString = "originAgentCluster"
    @usableFromInline static let originTime: JSString = "originTime"
    @usableFromInline static let oscpu: JSString = "oscpu"
    @usableFromInline static let outerHeight: JSString = "outerHeight"
    @usableFromInline static let outerText: JSString = "outerText"
    @usableFromInline static let outerWidth: JSString = "outerWidth"
    @usableFromInline static let output: JSString = "output"
    @usableFromInline static let outputBuffer: JSString = "outputBuffer"
    @usableFromInline static let outputChannelCount: JSString = "outputChannelCount"
    @usableFromInline static let outputLatency: JSString = "outputLatency"
    @usableFromInline static let overrideMimeType: JSString = "overrideMimeType"
    @usableFromInline static let oversample: JSString = "oversample"
    @usableFromInline static let ownerDocument: JSString = "ownerDocument"
    @usableFromInline static let ownerElement: JSString = "ownerElement"
    @usableFromInline static let p1: JSString = "p1"
    @usableFromInline static let p2: JSString = "p2"
    @usableFromInline static let p3: JSString = "p3"
    @usableFromInline static let p4: JSString = "p4"
    @usableFromInline static let pageX: JSString = "pageX"
    @usableFromInline static let pageXOffset: JSString = "pageXOffset"
    @usableFromInline static let pageY: JSString = "pageY"
    @usableFromInline static let pageYOffset: JSString = "pageYOffset"
    @usableFromInline static let pan: JSString = "pan"
    @usableFromInline static let panTiltZoom: JSString = "panTiltZoom"
    @usableFromInline static let panningModel: JSString = "panningModel"
    @usableFromInline static let parameterData: JSString = "parameterData"
    @usableFromInline static let parameters: JSString = "parameters"
    @usableFromInline static let parent: JSString = "parent"
    @usableFromInline static let parentElement: JSString = "parentElement"
    @usableFromInline static let parentNode: JSString = "parentNode"
    @usableFromInline static let parseFromString: JSString = "parseFromString"
    @usableFromInline static let passive: JSString = "passive"
    @usableFromInline static let password: JSString = "password"
    @usableFromInline static let pathname: JSString = "pathname"
    @usableFromInline static let pattern: JSString = "pattern"
    @usableFromInline static let patternMismatch: JSString = "patternMismatch"
    @usableFromInline static let pause: JSString = "pause"
    @usableFromInline static let pauseOnExit: JSString = "pauseOnExit"
    @usableFromInline static let paused: JSString = "paused"
    @usableFromInline static let pdfViewerEnabled: JSString = "pdfViewerEnabled"
    @usableFromInline static let pending: JSString = "pending"
    @usableFromInline static let performance: JSString = "performance"
    @usableFromInline static let performanceTime: JSString = "performanceTime"
    @usableFromInline static let periodicWave: JSString = "periodicWave"
    @usableFromInline static let persist: JSString = "persist"
    @usableFromInline static let persisted: JSString = "persisted"
    @usableFromInline static let personalbar: JSString = "personalbar"
    @usableFromInline static let phase: JSString = "phase"
    @usableFromInline static let ping: JSString = "ping"
    @usableFromInline static let pipeThrough: JSString = "pipeThrough"
    @usableFromInline static let pipeTo: JSString = "pipeTo"
    @usableFromInline static let pixelDepth: JSString = "pixelDepth"
    @usableFromInline static let pixelStorei: JSString = "pixelStorei"
    @usableFromInline static let placeholder: JSString = "placeholder"
    @usableFromInline static let planeIndex: JSString = "planeIndex"
    @usableFromInline static let platform: JSString = "platform"
    @usableFromInline static let play: JSString = "play"
    @usableFromInline static let playState: JSString = "playState"
    @usableFromInline static let playbackRate: JSString = "playbackRate"
    @usableFromInline static let playbackTime: JSString = "playbackTime"
    @usableFromInline static let played: JSString = "played"
    @usableFromInline static let playsInline: JSString = "playsInline"
    @usableFromInline static let plugins: JSString = "plugins"
    @usableFromInline static let pointerBeforeReferenceNode: JSString = "pointerBeforeReferenceNode"
    @usableFromInline static let polygonOffset: JSString = "polygonOffset"
    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let port1: JSString = "port1"
    @usableFromInline static let port2: JSString = "port2"
    @usableFromInline static let ports: JSString = "ports"
    @usableFromInline static let position: JSString = "position"
    @usableFromInline static let positionX: JSString = "positionX"
    @usableFromInline static let positionY: JSString = "positionY"
    @usableFromInline static let positionZ: JSString = "positionZ"
    @usableFromInline static let postMessage: JSString = "postMessage"
    @usableFromInline static let poster: JSString = "poster"
    @usableFromInline static let powerPreference: JSString = "powerPreference"
    @usableFromInline static let preMultiplySelf: JSString = "preMultiplySelf"
    @usableFromInline static let precision: JSString = "precision"
    @usableFromInline static let preferAnimation: JSString = "preferAnimation"
    @usableFromInline static let prefix: JSString = "prefix"
    @usableFromInline static let preload: JSString = "preload"
    @usableFromInline static let preloadResponse: JSString = "preloadResponse"
    @usableFromInline static let premultipliedAlpha: JSString = "premultipliedAlpha"
    @usableFromInline static let premultiplyAlpha: JSString = "premultiplyAlpha"
    @usableFromInline static let prepend: JSString = "prepend"
    @usableFromInline static let preserveDrawingBuffer: JSString = "preserveDrawingBuffer"
    @usableFromInline static let preservesPitch: JSString = "preservesPitch"
    @usableFromInline static let prevValue: JSString = "prevValue"
    @usableFromInline static let preventAbort: JSString = "preventAbort"
    @usableFromInline static let preventCancel: JSString = "preventCancel"
    @usableFromInline static let preventClose: JSString = "preventClose"
    @usableFromInline static let preventDefault: JSString = "preventDefault"
    @usableFromInline static let preventScroll: JSString = "preventScroll"
    @usableFromInline static let previousElementSibling: JSString = "previousElementSibling"
    @usableFromInline static let previousNode: JSString = "previousNode"
    @usableFromInline static let previousSibling: JSString = "previousSibling"
    @usableFromInline static let primaries: JSString = "primaries"
    @usableFromInline static let print: JSString = "print"
    @usableFromInline static let processorOptions: JSString = "processorOptions"
    @usableFromInline static let product: JSString = "product"
    @usableFromInline static let productSub: JSString = "productSub"
    @usableFromInline static let progress: JSString = "progress"
    @usableFromInline static let promise: JSString = "promise"
    @usableFromInline static let prompt: JSString = "prompt"
    @usableFromInline static let `protocol`: JSString = "protocol"
    @usableFromInline static let pseudo: JSString = "pseudo"
    @usableFromInline static let pseudoElement: JSString = "pseudoElement"
    @usableFromInline static let publicId: JSString = "publicId"
    @usableFromInline static let pull: JSString = "pull"
    @usableFromInline static let pushState: JSString = "pushState"
    @usableFromInline static let put: JSString = "put"
    @usableFromInline static let putImageData: JSString = "putImageData"
    @usableFromInline static let quadraticCurveTo: JSString = "quadraticCurveTo"
    @usableFromInline static let quality: JSString = "quality"
    @usableFromInline static let queryCommandEnabled: JSString = "queryCommandEnabled"
    @usableFromInline static let queryCommandIndeterm: JSString = "queryCommandIndeterm"
    @usableFromInline static let queryCommandState: JSString = "queryCommandState"
    @usableFromInline static let queryCommandSupported: JSString = "queryCommandSupported"
    @usableFromInline static let queryCommandValue: JSString = "queryCommandValue"
    @usableFromInline static let querySelector: JSString = "querySelector"
    @usableFromInline static let querySelectorAll: JSString = "querySelectorAll"
    @usableFromInline static let rangeMax: JSString = "rangeMax"
    @usableFromInline static let rangeMin: JSString = "rangeMin"
    @usableFromInline static let rangeOverflow: JSString = "rangeOverflow"
    @usableFromInline static let rangeUnderflow: JSString = "rangeUnderflow"
    @usableFromInline static let ratio: JSString = "ratio"
    @usableFromInline static let read: JSString = "read"
    @usableFromInline static let readAsArrayBuffer: JSString = "readAsArrayBuffer"
    @usableFromInline static let readAsBinaryString: JSString = "readAsBinaryString"
    @usableFromInline static let readAsDataURL: JSString = "readAsDataURL"
    @usableFromInline static let readAsText: JSString = "readAsText"
    @usableFromInline static let readOnly: JSString = "readOnly"
    @usableFromInline static let readPixels: JSString = "readPixels"
    @usableFromInline static let readable: JSString = "readable"
    @usableFromInline static let readableType: JSString = "readableType"
    @usableFromInline static let ready: JSString = "ready"
    @usableFromInline static let readyState: JSString = "readyState"
    @usableFromInline static let real: JSString = "real"
    @usableFromInline static let reason: JSString = "reason"
    @usableFromInline static let rect: JSString = "rect"
    @usableFromInline static let redirect: JSString = "redirect"
    @usableFromInline static let redirected: JSString = "redirected"
    @usableFromInline static let reduction: JSString = "reduction"
    @usableFromInline static let refDistance: JSString = "refDistance"
    @usableFromInline static let referenceNode: JSString = "referenceNode"
    @usableFromInline static let referrer: JSString = "referrer"
    @usableFromInline static let referrerPolicy: JSString = "referrerPolicy"
    @usableFromInline static let refresh: JSString = "refresh"
    @usableFromInline static let register: JSString = "register"
    @usableFromInline static let registerProtocolHandler: JSString = "registerProtocolHandler"
    @usableFromInline static let rel: JSString = "rel"
    @usableFromInline static let relList: JSString = "relList"
    @usableFromInline static let relatedNode: JSString = "relatedNode"
    @usableFromInline static let relatedTarget: JSString = "relatedTarget"
    @usableFromInline static let relativeTo: JSString = "relativeTo"
    @usableFromInline static let release: JSString = "release"
    @usableFromInline static let releaseEvents: JSString = "releaseEvents"
    @usableFromInline static let releaseLock: JSString = "releaseLock"
    @usableFromInline static let reload: JSString = "reload"
    @usableFromInline static let remove: JSString = "remove"
    @usableFromInline static let removeAttribute: JSString = "removeAttribute"
    @usableFromInline static let removeAttributeNS: JSString = "removeAttributeNS"
    @usableFromInline static let removeAttributeNode: JSString = "removeAttributeNode"
    @usableFromInline static let removeChild: JSString = "removeChild"
    @usableFromInline static let removeCue: JSString = "removeCue"
    @usableFromInline static let removeNamedItem: JSString = "removeNamedItem"
    @usableFromInline static let removeNamedItemNS: JSString = "removeNamedItemNS"
    @usableFromInline static let removeParameter: JSString = "removeParameter"
    @usableFromInline static let removeTrack: JSString = "removeTrack"
    @usableFromInline static let removedNodes: JSString = "removedNodes"
    @usableFromInline static let renderbufferStorage: JSString = "renderbufferStorage"
    @usableFromInline static let renderedBuffer: JSString = "renderedBuffer"
    @usableFromInline static let `repeat`: JSString = "repeat"
    @usableFromInline static let repetitionCount: JSString = "repetitionCount"
    @usableFromInline static let replace: JSString = "replace"
    @usableFromInline static let replaceChild: JSString = "replaceChild"
    @usableFromInline static let replaceChildren: JSString = "replaceChildren"
    @usableFromInline static let replaceData: JSString = "replaceData"
    @usableFromInline static let replaceState: JSString = "replaceState"
    @usableFromInline static let replaceWith: JSString = "replaceWith"
    @usableFromInline static let replacesClientId: JSString = "replacesClientId"
    @usableFromInline static let reportError: JSString = "reportError"
    @usableFromInline static let reportValidity: JSString = "reportValidity"
    @usableFromInline static let request: JSString = "request"
    @usableFromInline static let requestData: JSString = "requestData"
    @usableFromInline static let requestSubmit: JSString = "requestSubmit"
    @usableFromInline static let required: JSString = "required"
    @usableFromInline static let reset: JSString = "reset"
    @usableFromInline static let resetTransform: JSString = "resetTransform"
    @usableFromInline static let resizeBy: JSString = "resizeBy"
    @usableFromInline static let resizeHeight: JSString = "resizeHeight"
    @usableFromInline static let resizeMode: JSString = "resizeMode"
    @usableFromInline static let resizeQuality: JSString = "resizeQuality"
    @usableFromInline static let resizeTo: JSString = "resizeTo"
    @usableFromInline static let resizeWidth: JSString = "resizeWidth"
    @usableFromInline static let respond: JSString = "respond"
    @usableFromInline static let respondWithNewView: JSString = "respondWithNewView"
    @usableFromInline static let response: JSString = "response"
    @usableFromInline static let responseText: JSString = "responseText"
    @usableFromInline static let responseType: JSString = "responseType"
    @usableFromInline static let responseURL: JSString = "responseURL"
    @usableFromInline static let responseXML: JSString = "responseXML"
    @usableFromInline static let restore: JSString = "restore"
    @usableFromInline static let result: JSString = "result"
    @usableFromInline static let resultType: JSString = "resultType"
    @usableFromInline static let resultingClientId: JSString = "resultingClientId"
    @usableFromInline static let resume: JSString = "resume"
    @usableFromInline static let returnValue: JSString = "returnValue"
    @usableFromInline static let rev: JSString = "rev"
    @usableFromInline static let reverse: JSString = "reverse"
    @usableFromInline static let reversed: JSString = "reversed"
    @usableFromInline static let revokeObjectURL: JSString = "revokeObjectURL"
    @usableFromInline static let right: JSString = "right"
    @usableFromInline static let role: JSString = "role"
    @usableFromInline static let rolloffFactor: JSString = "rolloffFactor"
    @usableFromInline static let root: JSString = "root"
    @usableFromInline static let rotate: JSString = "rotate"
    @usableFromInline static let rotateAxisAngle: JSString = "rotateAxisAngle"
    @usableFromInline static let rotateAxisAngleSelf: JSString = "rotateAxisAngleSelf"
    @usableFromInline static let rotateFromVector: JSString = "rotateFromVector"
    @usableFromInline static let rotateFromVectorSelf: JSString = "rotateFromVectorSelf"
    @usableFromInline static let rotateSelf: JSString = "rotateSelf"
    @usableFromInline static let roundRect: JSString = "roundRect"
    @usableFromInline static let rowIndex: JSString = "rowIndex"
    @usableFromInline static let rowSpan: JSString = "rowSpan"
    @usableFromInline static let rows: JSString = "rows"
    @usableFromInline static let rules: JSString = "rules"
    @usableFromInline static let sampleCoverage: JSString = "sampleCoverage"
    @usableFromInline static let sampleRate: JSString = "sampleRate"
    @usableFromInline static let sampleSize: JSString = "sampleSize"
    @usableFromInline static let sandbox: JSString = "sandbox"
    @usableFromInline static let save: JSString = "save"
    @usableFromInline static let scalabilityMode: JSString = "scalabilityMode"
    @usableFromInline static let scale: JSString = "scale"
    @usableFromInline static let scale3d: JSString = "scale3d"
    @usableFromInline static let scale3dSelf: JSString = "scale3dSelf"
    @usableFromInline static let scaleNonUniform: JSString = "scaleNonUniform"
    @usableFromInline static let scaleSelf: JSString = "scaleSelf"
    @usableFromInline static let scheme: JSString = "scheme"
    @usableFromInline static let scissor: JSString = "scissor"
    @usableFromInline static let scope: JSString = "scope"
    @usableFromInline static let screen: JSString = "screen"
    @usableFromInline static let screenLeft: JSString = "screenLeft"
    @usableFromInline static let screenTop: JSString = "screenTop"
    @usableFromInline static let screenX: JSString = "screenX"
    @usableFromInline static let screenY: JSString = "screenY"
    @usableFromInline static let scriptURL: JSString = "scriptURL"
    @usableFromInline static let scripts: JSString = "scripts"
    @usableFromInline static let scroll: JSString = "scroll"
    @usableFromInline static let scrollAmount: JSString = "scrollAmount"
    @usableFromInline static let scrollBy: JSString = "scrollBy"
    @usableFromInline static let scrollDelay: JSString = "scrollDelay"
    @usableFromInline static let scrollHeight: JSString = "scrollHeight"
    @usableFromInline static let scrollIntoView: JSString = "scrollIntoView"
    @usableFromInline static let scrollLeft: JSString = "scrollLeft"
    @usableFromInline static let scrollPathIntoView: JSString = "scrollPathIntoView"
    @usableFromInline static let scrollRestoration: JSString = "scrollRestoration"
    @usableFromInline static let scrollTo: JSString = "scrollTo"
    @usableFromInline static let scrollTop: JSString = "scrollTop"
    @usableFromInline static let scrollWidth: JSString = "scrollWidth"
    @usableFromInline static let scrollX: JSString = "scrollX"
    @usableFromInline static let scrollY: JSString = "scrollY"
    @usableFromInline static let scrollbars: JSString = "scrollbars"
    @usableFromInline static let scrolling: JSString = "scrolling"
    @usableFromInline static let scrollingElement: JSString = "scrollingElement"
    @usableFromInline static let search: JSString = "search"
    @usableFromInline static let searchParams: JSString = "searchParams"
    @usableFromInline static let sectionRowIndex: JSString = "sectionRowIndex"
    @usableFromInline static let seekable: JSString = "seekable"
    @usableFromInline static let seeking: JSString = "seeking"
    @usableFromInline static let select: JSString = "select"
    @usableFromInline static let selectNode: JSString = "selectNode"
    @usableFromInline static let selectNodeContents: JSString = "selectNodeContents"
    @usableFromInline static let selected: JSString = "selected"
    @usableFromInline static let selectedIndex: JSString = "selectedIndex"
    @usableFromInline static let selectedOptions: JSString = "selectedOptions"
    @usableFromInline static let selectedTrack: JSString = "selectedTrack"
    @usableFromInline static let selectionDirection: JSString = "selectionDirection"
    @usableFromInline static let selectionEnd: JSString = "selectionEnd"
    @usableFromInline static let selectionStart: JSString = "selectionStart"
    @usableFromInline static let send: JSString = "send"
    @usableFromInline static let serviceWorker: JSString = "serviceWorker"
    @usableFromInline static let sessionStorage: JSString = "sessionStorage"
    @usableFromInline static let set: JSString = "set"
    @usableFromInline static let setAttribute: JSString = "setAttribute"
    @usableFromInline static let setAttributeNS: JSString = "setAttributeNS"
    @usableFromInline static let setAttributeNode: JSString = "setAttributeNode"
    @usableFromInline static let setAttributeNodeNS: JSString = "setAttributeNodeNS"
    @usableFromInline static let setCustomValidity: JSString = "setCustomValidity"
    @usableFromInline static let setData: JSString = "setData"
    @usableFromInline static let setDragImage: JSString = "setDragImage"
    @usableFromInline static let setEnd: JSString = "setEnd"
    @usableFromInline static let setEndAfter: JSString = "setEndAfter"
    @usableFromInline static let setEndBefore: JSString = "setEndBefore"
    @usableFromInline static let setFormValue: JSString = "setFormValue"
    @usableFromInline static let setHeaderValue: JSString = "setHeaderValue"
    @usableFromInline static let setInterval: JSString = "setInterval"
    @usableFromInline static let setKeyframes: JSString = "setKeyframes"
    @usableFromInline static let setLineDash: JSString = "setLineDash"
    @usableFromInline static let setMatrixValue: JSString = "setMatrixValue"
    @usableFromInline static let setNamedItem: JSString = "setNamedItem"
    @usableFromInline static let setNamedItemNS: JSString = "setNamedItemNS"
    @usableFromInline static let setOrientation: JSString = "setOrientation"
    @usableFromInline static let setParameter: JSString = "setParameter"
    @usableFromInline static let setPeriodicWave: JSString = "setPeriodicWave"
    @usableFromInline static let setPosition: JSString = "setPosition"
    @usableFromInline static let setRangeText: JSString = "setRangeText"
    @usableFromInline static let setRequestHeader: JSString = "setRequestHeader"
    @usableFromInline static let setSelectionRange: JSString = "setSelectionRange"
    @usableFromInline static let setStart: JSString = "setStart"
    @usableFromInline static let setStartAfter: JSString = "setStartAfter"
    @usableFromInline static let setStartBefore: JSString = "setStartBefore"
    @usableFromInline static let setTargetAtTime: JSString = "setTargetAtTime"
    @usableFromInline static let setTimeout: JSString = "setTimeout"
    @usableFromInline static let setTransform: JSString = "setTransform"
    @usableFromInline static let setValidity: JSString = "setValidity"
    @usableFromInline static let setValueAtTime: JSString = "setValueAtTime"
    @usableFromInline static let setValueCurveAtTime: JSString = "setValueCurveAtTime"
    @usableFromInline static let shaderSource: JSString = "shaderSource"
    @usableFromInline static let shadowBlur: JSString = "shadowBlur"
    @usableFromInline static let shadowColor: JSString = "shadowColor"
    @usableFromInline static let shadowOffsetX: JSString = "shadowOffsetX"
    @usableFromInline static let shadowOffsetY: JSString = "shadowOffsetY"
    @usableFromInline static let shadowRoot: JSString = "shadowRoot"
    @usableFromInline static let shape: JSString = "shape"
    @usableFromInline static let shiftKey: JSString = "shiftKey"
    @usableFromInline static let show: JSString = "show"
    @usableFromInline static let showModal: JSString = "showModal"
    @usableFromInline static let showPicker: JSString = "showPicker"
    @usableFromInline static let signal: JSString = "signal"
    @usableFromInline static let singleNodeValue: JSString = "singleNodeValue"
    @usableFromInline static let size: JSString = "size"
    @usableFromInline static let sizes: JSString = "sizes"
    @usableFromInline static let skewX: JSString = "skewX"
    @usableFromInline static let skewXSelf: JSString = "skewXSelf"
    @usableFromInline static let skewY: JSString = "skewY"
    @usableFromInline static let skewYSelf: JSString = "skewYSelf"
    @usableFromInline static let slice: JSString = "slice"
    @usableFromInline static let slot: JSString = "slot"
    @usableFromInline static let slotAssignment: JSString = "slotAssignment"
    @usableFromInline static let smoothingTimeConstant: JSString = "smoothingTimeConstant"
    @usableFromInline static let snapshotItem: JSString = "snapshotItem"
    @usableFromInline static let snapshotLength: JSString = "snapshotLength"
    @usableFromInline static let sort: JSString = "sort"
    @usableFromInline static let source: JSString = "source"
    @usableFromInline static let span: JSString = "span"
    @usableFromInline static let specified: JSString = "specified"
    @usableFromInline static let spellcheck: JSString = "spellcheck"
    @usableFromInline static let splitText: JSString = "splitText"
    @usableFromInline static let src: JSString = "src"
    @usableFromInline static let srcElement: JSString = "srcElement"
    @usableFromInline static let srcdoc: JSString = "srcdoc"
    @usableFromInline static let srclang: JSString = "srclang"
    @usableFromInline static let srcset: JSString = "srcset"
    @usableFromInline static let standby: JSString = "standby"
    @usableFromInline static let start: JSString = "start"
    @usableFromInline static let startContainer: JSString = "startContainer"
    @usableFromInline static let startMessages: JSString = "startMessages"
    @usableFromInline static let startOffset: JSString = "startOffset"
    @usableFromInline static let startRendering: JSString = "startRendering"
    @usableFromInline static let startTime: JSString = "startTime"
    @usableFromInline static let state: JSString = "state"
    @usableFromInline static let status: JSString = "status"
    @usableFromInline static let statusMessage: JSString = "statusMessage"
    @usableFromInline static let statusText: JSString = "statusText"
    @usableFromInline static let statusbar: JSString = "statusbar"
    @usableFromInline static let stencil: JSString = "stencil"
    @usableFromInline static let stencilFunc: JSString = "stencilFunc"
    @usableFromInline static let stencilFuncSeparate: JSString = "stencilFuncSeparate"
    @usableFromInline static let stencilMask: JSString = "stencilMask"
    @usableFromInline static let stencilMaskSeparate: JSString = "stencilMaskSeparate"
    @usableFromInline static let stencilOp: JSString = "stencilOp"
    @usableFromInline static let stencilOpSeparate: JSString = "stencilOpSeparate"
    @usableFromInline static let step: JSString = "step"
    @usableFromInline static let stepDown: JSString = "stepDown"
    @usableFromInline static let stepMismatch: JSString = "stepMismatch"
    @usableFromInline static let stepUp: JSString = "stepUp"
    @usableFromInline static let stop: JSString = "stop"
    @usableFromInline static let stopImmediatePropagation: JSString = "stopImmediatePropagation"
    @usableFromInline static let stopPropagation: JSString = "stopPropagation"
    @usableFromInline static let storageArea: JSString = "storageArea"
    @usableFromInline static let stream: JSString = "stream"
    @usableFromInline static let stride: JSString = "stride"
    @usableFromInline static let stringValue: JSString = "stringValue"
    @usableFromInline static let stroke: JSString = "stroke"
    @usableFromInline static let strokeRect: JSString = "strokeRect"
    @usableFromInline static let strokeStyle: JSString = "strokeStyle"
    @usableFromInline static let strokeText: JSString = "strokeText"
    @usableFromInline static let structuredClone: JSString = "structuredClone"
    @usableFromInline static let submit: JSString = "submit"
    @usableFromInline static let submitter: JSString = "submitter"
    @usableFromInline static let substringData: JSString = "substringData"
    @usableFromInline static let subtree: JSString = "subtree"
    @usableFromInline static let suffixes: JSString = "suffixes"
    @usableFromInline static let summary: JSString = "summary"
    @usableFromInline static let supported: JSString = "supported"
    @usableFromInline static let supports: JSString = "supports"
    @usableFromInline static let surroundContents: JSString = "surroundContents"
    @usableFromInline static let suspend: JSString = "suspend"
    @usableFromInline static let svc: JSString = "svc"
    @usableFromInline static let systemId: JSString = "systemId"
    @usableFromInline static let tBodies: JSString = "tBodies"
    @usableFromInline static let tFoot: JSString = "tFoot"
    @usableFromInline static let tHead: JSString = "tHead"
    @usableFromInline static let tabIndex: JSString = "tabIndex"
    @usableFromInline static let table: JSString = "table"
    @usableFromInline static let tagName: JSString = "tagName"
    @usableFromInline static let taintEnabled: JSString = "taintEnabled"
    @usableFromInline static let takeRecords: JSString = "takeRecords"
    @usableFromInline static let target: JSString = "target"
    @usableFromInline static let targetOrigin: JSString = "targetOrigin"
    @usableFromInline static let tee: JSString = "tee"
    @usableFromInline static let temporalLayerId: JSString = "temporalLayerId"
    @usableFromInline static let terminate: JSString = "terminate"
    @usableFromInline static let texImage2D: JSString = "texImage2D"
    @usableFromInline static let texParameterf: JSString = "texParameterf"
    @usableFromInline static let texParameteri: JSString = "texParameteri"
    @usableFromInline static let texSubImage2D: JSString = "texSubImage2D"
    @usableFromInline static let text: JSString = "text"
    @usableFromInline static let textAlign: JSString = "textAlign"
    @usableFromInline static let textBaseline: JSString = "textBaseline"
    @usableFromInline static let textContent: JSString = "textContent"
    @usableFromInline static let textLength: JSString = "textLength"
    @usableFromInline static let textRendering: JSString = "textRendering"
    @usableFromInline static let textTracks: JSString = "textTracks"
    @usableFromInline static let threshold: JSString = "threshold"
    @usableFromInline static let throwIfAborted: JSString = "throwIfAborted"
    @usableFromInline static let time: JSString = "time"
    @usableFromInline static let timeEnd: JSString = "timeEnd"
    @usableFromInline static let timeLog: JSString = "timeLog"
    @usableFromInline static let timeOrigin: JSString = "timeOrigin"
    @usableFromInline static let timeStamp: JSString = "timeStamp"
    @usableFromInline static let timecode: JSString = "timecode"
    @usableFromInline static let timeline: JSString = "timeline"
    @usableFromInline static let timeout: JSString = "timeout"
    @usableFromInline static let timestamp: JSString = "timestamp"
    @usableFromInline static let title: JSString = "title"
    @usableFromInline static let toBox: JSString = "toBox"
    @usableFromInline static let toDataURL: JSString = "toDataURL"
    @usableFromInline static let toFloat32Array: JSString = "toFloat32Array"
    @usableFromInline static let toFloat64Array: JSString = "toFloat64Array"
    @usableFromInline static let toJSON: JSString = "toJSON"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let toggle: JSString = "toggle"
    @usableFromInline static let toggleAttribute: JSString = "toggleAttribute"
    @usableFromInline static let tooLong: JSString = "tooLong"
    @usableFromInline static let tooShort: JSString = "tooShort"
    @usableFromInline static let toolbar: JSString = "toolbar"
    @usableFromInline static let top: JSString = "top"
    @usableFromInline static let total: JSString = "total"
    @usableFromInline static let trace: JSString = "trace"
    @usableFromInline static let track: JSString = "track"
    @usableFromInline static let tracks: JSString = "tracks"
    @usableFromInline static let transfer: JSString = "transfer"
    @usableFromInline static let transferControlToOffscreen: JSString = "transferControlToOffscreen"
    @usableFromInline static let transferFromImageBitmap: JSString = "transferFromImageBitmap"
    @usableFromInline static let transferToImageBitmap: JSString = "transferToImageBitmap"
    @usableFromInline static let transform: JSString = "transform"
    @usableFromInline static let transformPoint: JSString = "transformPoint"
    @usableFromInline static let transformToDocument: JSString = "transformToDocument"
    @usableFromInline static let transformToFragment: JSString = "transformToFragment"
    @usableFromInline static let translate: JSString = "translate"
    @usableFromInline static let translateSelf: JSString = "translateSelf"
    @usableFromInline static let trueSpeed: JSString = "trueSpeed"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let typeMismatch: JSString = "typeMismatch"
    @usableFromInline static let types: JSString = "types"
    @usableFromInline static let uniform1f: JSString = "uniform1f"
    @usableFromInline static let uniform1fv: JSString = "uniform1fv"
    @usableFromInline static let uniform1i: JSString = "uniform1i"
    @usableFromInline static let uniform1iv: JSString = "uniform1iv"
    @usableFromInline static let uniform2f: JSString = "uniform2f"
    @usableFromInline static let uniform2fv: JSString = "uniform2fv"
    @usableFromInline static let uniform2i: JSString = "uniform2i"
    @usableFromInline static let uniform2iv: JSString = "uniform2iv"
    @usableFromInline static let uniform3f: JSString = "uniform3f"
    @usableFromInline static let uniform3fv: JSString = "uniform3fv"
    @usableFromInline static let uniform3i: JSString = "uniform3i"
    @usableFromInline static let uniform3iv: JSString = "uniform3iv"
    @usableFromInline static let uniform4f: JSString = "uniform4f"
    @usableFromInline static let uniform4fv: JSString = "uniform4fv"
    @usableFromInline static let uniform4i: JSString = "uniform4i"
    @usableFromInline static let uniform4iv: JSString = "uniform4iv"
    @usableFromInline static let uniformMatrix2fv: JSString = "uniformMatrix2fv"
    @usableFromInline static let uniformMatrix3fv: JSString = "uniformMatrix3fv"
    @usableFromInline static let uniformMatrix4fv: JSString = "uniformMatrix4fv"
    @usableFromInline static let unregister: JSString = "unregister"
    @usableFromInline static let unregisterProtocolHandler: JSString = "unregisterProtocolHandler"
    @usableFromInline static let upX: JSString = "upX"
    @usableFromInline static let upY: JSString = "upY"
    @usableFromInline static let upZ: JSString = "upZ"
    @usableFromInline static let update: JSString = "update"
    @usableFromInline static let updatePlaybackRate: JSString = "updatePlaybackRate"
    @usableFromInline static let updateTiming: JSString = "updateTiming"
    @usableFromInline static let updateViaCache: JSString = "updateViaCache"
    @usableFromInline static let upgrade: JSString = "upgrade"
    @usableFromInline static let upload: JSString = "upload"
    @usableFromInline static let url: JSString = "url"
    @usableFromInline static let useMap: JSString = "useMap"
    @usableFromInline static let useProgram: JSString = "useProgram"
    @usableFromInline static let userAgent: JSString = "userAgent"
    @usableFromInline static let username: JSString = "username"
    @usableFromInline static let vAlign: JSString = "vAlign"
    @usableFromInline static let vLink: JSString = "vLink"
    @usableFromInline static let valid: JSString = "valid"
    @usableFromInline static let validateProgram: JSString = "validateProgram"
    @usableFromInline static let validationMessage: JSString = "validationMessage"
    @usableFromInline static let validity: JSString = "validity"
    @usableFromInline static let value: JSString = "value"
    @usableFromInline static let valueAsDate: JSString = "valueAsDate"
    @usableFromInline static let valueAsNumber: JSString = "valueAsNumber"
    @usableFromInline static let valueMissing: JSString = "valueMissing"
    @usableFromInline static let valueType: JSString = "valueType"
    @usableFromInline static let vendor: JSString = "vendor"
    @usableFromInline static let vendorSub: JSString = "vendorSub"
    @usableFromInline static let version: JSString = "version"
    @usableFromInline static let vertexAttrib1f: JSString = "vertexAttrib1f"
    @usableFromInline static let vertexAttrib1fv: JSString = "vertexAttrib1fv"
    @usableFromInline static let vertexAttrib2f: JSString = "vertexAttrib2f"
    @usableFromInline static let vertexAttrib2fv: JSString = "vertexAttrib2fv"
    @usableFromInline static let vertexAttrib3f: JSString = "vertexAttrib3f"
    @usableFromInline static let vertexAttrib3fv: JSString = "vertexAttrib3fv"
    @usableFromInline static let vertexAttrib4f: JSString = "vertexAttrib4f"
    @usableFromInline static let vertexAttrib4fv: JSString = "vertexAttrib4fv"
    @usableFromInline static let vertexAttribPointer: JSString = "vertexAttribPointer"
    @usableFromInline static let video: JSString = "video"
    @usableFromInline static let videoBitsPerSecond: JSString = "videoBitsPerSecond"
    @usableFromInline static let videoHeight: JSString = "videoHeight"
    @usableFromInline static let videoTracks: JSString = "videoTracks"
    @usableFromInline static let videoWidth: JSString = "videoWidth"
    @usableFromInline static let view: JSString = "view"
    @usableFromInline static let viewport: JSString = "viewport"
    @usableFromInline static let visibilityState: JSString = "visibilityState"
    @usableFromInline static let visible: JSString = "visible"
    @usableFromInline static let visibleRect: JSString = "visibleRect"
    @usableFromInline static let vlinkColor: JSString = "vlinkColor"
    @usableFromInline static let volume: JSString = "volume"
    @usableFromInline static let vspace: JSString = "vspace"
    @usableFromInline static let w: JSString = "w"
    @usableFromInline static let waiting: JSString = "waiting"
    @usableFromInline static let warn: JSString = "warn"
    @usableFromInline static let wasClean: JSString = "wasClean"
    @usableFromInline static let webkitMatchesSelector: JSString = "webkitMatchesSelector"
    @usableFromInline static let whatToShow: JSString = "whatToShow"
    @usableFromInline static let whenDefined: JSString = "whenDefined"
    @usableFromInline static let which: JSString = "which"
    @usableFromInline static let wholeText: JSString = "wholeText"
    @usableFromInline static let width: JSString = "width"
    @usableFromInline static let willReadFrequently: JSString = "willReadFrequently"
    @usableFromInline static let willValidate: JSString = "willValidate"
    @usableFromInline static let window: JSString = "window"
    @usableFromInline static let withCredentials: JSString = "withCredentials"
    @usableFromInline static let wordSpacing: JSString = "wordSpacing"
    @usableFromInline static let wrap: JSString = "wrap"
    @usableFromInline static let writable: JSString = "writable"
    @usableFromInline static let writableType: JSString = "writableType"
    @usableFromInline static let write: JSString = "write"
    @usableFromInline static let writeln: JSString = "writeln"
    @usableFromInline static let x: JSString = "x"
    @usableFromInline static let y: JSString = "y"
    @usableFromInline static let z: JSString = "z"
}

public protocol Any_ArrayBuffer_or_String: ConvertibleToJSValue {}
extension ArrayBuffer: Any_ArrayBuffer_or_String {}
extension String: Any_ArrayBuffer_or_String {}

public enum ArrayBuffer_or_String: JSValueCompatible, Any_ArrayBuffer_or_String {
    case arrayBuffer(ArrayBuffer)
    case string(String)

    public var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_AudioContextLatencyCategory_or_Double: ConvertibleToJSValue {}
extension AudioContextLatencyCategory: Any_AudioContextLatencyCategory_or_Double {}
extension Double: Any_AudioContextLatencyCategory_or_Double {}

public enum AudioContextLatencyCategory_or_Double: JSValueCompatible, Any_AudioContextLatencyCategory_or_Double {
    case audioContextLatencyCategory(AudioContextLatencyCategory)
    case double(Double)

    public var audioContextLatencyCategory: AudioContextLatencyCategory? {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory): return audioContextLatencyCategory
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioContextLatencyCategory: AudioContextLatencyCategory = value.fromJSValue() {
            return .audioContextLatencyCategory(audioContextLatencyCategory)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory):
            return audioContextLatencyCategory.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_AudioTrack_or_TextTrack_or_VideoTrack: ConvertibleToJSValue {}
extension AudioTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension TextTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension VideoTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}

public enum AudioTrack_or_TextTrack_or_VideoTrack: JSValueCompatible, Any_AudioTrack_or_TextTrack_or_VideoTrack {
    case audioTrack(AudioTrack)
    case textTrack(TextTrack)
    case videoTrack(VideoTrack)

    public var audioTrack: AudioTrack? {
        switch self {
        case let .audioTrack(audioTrack): return audioTrack
        default: return nil
        }
    }

    public var textTrack: TextTrack? {
        switch self {
        case let .textTrack(textTrack): return textTrack
        default: return nil
        }
    }

    public var videoTrack: VideoTrack? {
        switch self {
        case let .videoTrack(videoTrack): return videoTrack
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioTrack: AudioTrack = value.fromJSValue() {
            return .audioTrack(audioTrack)
        }
        if let textTrack: TextTrack = value.fromJSValue() {
            return .textTrack(textTrack)
        }
        if let videoTrack: VideoTrack = value.fromJSValue() {
            return .videoTrack(videoTrack)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioTrack(audioTrack):
            return audioTrack.jsValue
        case let .textTrack(textTrack):
            return textTrack.jsValue
        case let .videoTrack(videoTrack):
            return videoTrack.jsValue
        }
    }
}

public protocol Any_BlobPart: ConvertibleToJSValue {}
extension Blob: Any_BlobPart {}
extension BufferSource: Any_BlobPart {}
extension String: Any_BlobPart {}

public enum BlobPart: JSValueCompatible, Any_BlobPart {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Bool_or_MediaTrackConstraints: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_MediaTrackConstraints {}
extension MediaTrackConstraints: Any_Bool_or_MediaTrackConstraints {}

public enum Bool_or_MediaTrackConstraints: JSValueCompatible, Any_Bool_or_MediaTrackConstraints {
    case bool(Bool)
    case mediaTrackConstraints(MediaTrackConstraints)

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var mediaTrackConstraints: MediaTrackConstraints? {
        switch self {
        case let .mediaTrackConstraints(mediaTrackConstraints): return mediaTrackConstraints
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let mediaTrackConstraints: MediaTrackConstraints = value.fromJSValue() {
            return .mediaTrackConstraints(mediaTrackConstraints)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .mediaTrackConstraints(mediaTrackConstraints):
            return mediaTrackConstraints.jsValue
        }
    }
}

public protocol Any_Bool_or_ScrollIntoViewOptions: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_ScrollIntoViewOptions {}
extension ScrollIntoViewOptions: Any_Bool_or_ScrollIntoViewOptions {}

public enum Bool_or_ScrollIntoViewOptions: JSValueCompatible, Any_Bool_or_ScrollIntoViewOptions {
    case bool(Bool)
    case scrollIntoViewOptions(ScrollIntoViewOptions)

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var scrollIntoViewOptions: ScrollIntoViewOptions? {
        switch self {
        case let .scrollIntoViewOptions(scrollIntoViewOptions): return scrollIntoViewOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let scrollIntoViewOptions: ScrollIntoViewOptions = value.fromJSValue() {
            return .scrollIntoViewOptions(scrollIntoViewOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .scrollIntoViewOptions(scrollIntoViewOptions):
            return scrollIntoViewOptions.jsValue
        }
    }
}

public protocol Any_BufferSource: ConvertibleToJSValue {}
extension ArrayBuffer: Any_BufferSource {}
extension ArrayBufferView: Any_BufferSource {}

public enum BufferSource: JSValueCompatible, Any_BufferSource {
    case arrayBuffer(ArrayBuffer)
    case arrayBufferView(ArrayBufferView)

    public var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    public var arrayBufferView: ArrayBufferView? {
        switch self {
        case let .arrayBufferView(arrayBufferView): return arrayBufferView
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let arrayBufferView: ArrayBufferView = value.fromJSValue() {
            return .arrayBufferView(arrayBufferView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .arrayBufferView(arrayBufferView):
            return arrayBufferView.jsValue
        }
    }
}

public protocol Any_CSSPseudoElement_or_Element: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_CSSPseudoElement_or_Element {}
extension Element: Any_CSSPseudoElement_or_Element {}

public enum CSSPseudoElement_or_Element: JSValueCompatible, Any_CSSPseudoElement_or_Element {
    case cssPseudoElement(CSSPseudoElement)
    case element(Element)

    public var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .element(element):
            return element.jsValue
        }
    }
}

public protocol Any_CanvasFilterInput_or_seq_of_CanvasFilterInput: ConvertibleToJSValue {}
extension CanvasFilterInput: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {}
extension Array: Any_CanvasFilterInput_or_seq_of_CanvasFilterInput where Element == CanvasFilterInput {}

public enum CanvasFilterInput_or_seq_of_CanvasFilterInput: JSValueCompatible, Any_CanvasFilterInput_or_seq_of_CanvasFilterInput {
    case canvasFilterInput(CanvasFilterInput)
    case seq_of_CanvasFilterInput([CanvasFilterInput])

    public var canvasFilterInput: CanvasFilterInput? {
        switch self {
        case let .canvasFilterInput(canvasFilterInput): return canvasFilterInput
        default: return nil
        }
    }

    public var seq_of_CanvasFilterInput: [CanvasFilterInput]? {
        switch self {
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput): return seq_of_CanvasFilterInput
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilterInput: CanvasFilterInput = value.fromJSValue() {
            return .canvasFilterInput(canvasFilterInput)
        }
        if let seq_of_CanvasFilterInput: [CanvasFilterInput] = value.fromJSValue() {
            return .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilterInput(canvasFilterInput):
            return canvasFilterInput.jsValue
        case let .seq_of_CanvasFilterInput(seq_of_CanvasFilterInput):
            return seq_of_CanvasFilterInput.jsValue
        }
    }
}

public protocol Any_CanvasFilter_or_String: ConvertibleToJSValue {}
extension CanvasFilter: Any_CanvasFilter_or_String {}
extension String: Any_CanvasFilter_or_String {}

public enum CanvasFilter_or_String: JSValueCompatible, Any_CanvasFilter_or_String {
    case canvasFilter(CanvasFilter)
    case string(String)

    public var canvasFilter: CanvasFilter? {
        switch self {
        case let .canvasFilter(canvasFilter): return canvasFilter
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasFilter: CanvasFilter = value.fromJSValue() {
            return .canvasFilter(canvasFilter)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasFilter(canvasFilter):
            return canvasFilter.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CanvasGradient_or_CanvasPattern_or_String: ConvertibleToJSValue {}
extension CanvasGradient: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension CanvasPattern: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension String: Any_CanvasGradient_or_CanvasPattern_or_String {}

public enum CanvasGradient_or_CanvasPattern_or_String: JSValueCompatible, Any_CanvasGradient_or_CanvasPattern_or_String {
    case canvasGradient(CanvasGradient)
    case canvasPattern(CanvasPattern)
    case string(String)

    public var canvasGradient: CanvasGradient? {
        switch self {
        case let .canvasGradient(canvasGradient): return canvasGradient
        default: return nil
        }
    }

    public var canvasPattern: CanvasPattern? {
        switch self {
        case let .canvasPattern(canvasPattern): return canvasPattern
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let canvasGradient: CanvasGradient = value.fromJSValue() {
            return .canvasGradient(canvasGradient)
        }
        if let canvasPattern: CanvasPattern = value.fromJSValue() {
            return .canvasPattern(canvasPattern)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .canvasGradient(canvasGradient):
            return canvasGradient.jsValue
        case let .canvasPattern(canvasPattern):
            return canvasPattern.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CanvasImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_CanvasImageSource {}
extension HTMLOrSVGImageElement: Any_CanvasImageSource {}
extension HTMLVideoElement: Any_CanvasImageSource {}
extension ImageBitmap: Any_CanvasImageSource {}
extension OffscreenCanvas: Any_CanvasImageSource {}
extension VideoFrame: Any_CanvasImageSource {}

public enum CanvasImageSource: JSValueCompatible, Any_CanvasImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlOrSVGImageElement(HTMLOrSVGImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var htmlOrSVGImageElement: HTMLOrSVGImageElement? {
        switch self {
        case let .htmlOrSVGImageElement(htmlOrSVGImageElement): return htmlOrSVGImageElement
        default: return nil
        }
    }

    public var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    public var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlOrSVGImageElement: HTMLOrSVGImageElement = value.fromJSValue() {
            return .htmlOrSVGImageElement(htmlOrSVGImageElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlOrSVGImageElement(htmlOrSVGImageElement):
            return htmlOrSVGImageElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto: ConvertibleToJSValue {}
extension CompositeOperationOrAuto: Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto {}
extension Array: Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto where Element == CompositeOperationOrAuto {}

public enum CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto: JSValueCompatible, Any_CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto {
    case compositeOperationOrAuto(CompositeOperationOrAuto)
    case seq_of_CompositeOperationOrAuto([CompositeOperationOrAuto])

    public var compositeOperationOrAuto: CompositeOperationOrAuto? {
        switch self {
        case let .compositeOperationOrAuto(compositeOperationOrAuto): return compositeOperationOrAuto
        default: return nil
        }
    }

    public var seq_of_CompositeOperationOrAuto: [CompositeOperationOrAuto]? {
        switch self {
        case let .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto): return seq_of_CompositeOperationOrAuto
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let compositeOperationOrAuto: CompositeOperationOrAuto = value.fromJSValue() {
            return .compositeOperationOrAuto(compositeOperationOrAuto)
        }
        if let seq_of_CompositeOperationOrAuto: [CompositeOperationOrAuto] = value.fromJSValue() {
            return .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .compositeOperationOrAuto(compositeOperationOrAuto):
            return compositeOperationOrAuto.jsValue
        case let .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto):
            return seq_of_CompositeOperationOrAuto.jsValue
        }
    }
}

public protocol Any_ConstrainBoolean: ConvertibleToJSValue {}
extension Bool: Any_ConstrainBoolean {}
extension ConstrainBooleanParameters: Any_ConstrainBoolean {}

public enum ConstrainBoolean: JSValueCompatible, Any_ConstrainBoolean {
    case bool(Bool)
    case constrainBooleanParameters(ConstrainBooleanParameters)

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var constrainBooleanParameters: ConstrainBooleanParameters? {
        switch self {
        case let .constrainBooleanParameters(constrainBooleanParameters): return constrainBooleanParameters
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let constrainBooleanParameters: ConstrainBooleanParameters = value.fromJSValue() {
            return .constrainBooleanParameters(constrainBooleanParameters)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .constrainBooleanParameters(constrainBooleanParameters):
            return constrainBooleanParameters.jsValue
        }
    }
}

public protocol Any_ConstrainDOMString: ConvertibleToJSValue {}
extension ConstrainDOMStringParameters: Any_ConstrainDOMString {}
extension String: Any_ConstrainDOMString {}
extension Array: Any_ConstrainDOMString where Element == String {}

public enum ConstrainDOMString: JSValueCompatible, Any_ConstrainDOMString {
    case constrainDOMStringParameters(ConstrainDOMStringParameters)
    case string(String)
    case seq_of_String([String])

    public var constrainDOMStringParameters: ConstrainDOMStringParameters? {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters): return constrainDOMStringParameters
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDOMStringParameters: ConstrainDOMStringParameters = value.fromJSValue() {
            return .constrainDOMStringParameters(constrainDOMStringParameters)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters):
            return constrainDOMStringParameters.jsValue
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_ConstrainDouble: ConvertibleToJSValue {}
extension ConstrainDoubleRange: Any_ConstrainDouble {}
extension Double: Any_ConstrainDouble {}

public enum ConstrainDouble: JSValueCompatible, Any_ConstrainDouble {
    case constrainDoubleRange(ConstrainDoubleRange)
    case double(Double)

    public var constrainDoubleRange: ConstrainDoubleRange? {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange): return constrainDoubleRange
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDoubleRange: ConstrainDoubleRange = value.fromJSValue() {
            return .constrainDoubleRange(constrainDoubleRange)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange):
            return constrainDoubleRange.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_ConstrainULong: ConvertibleToJSValue {}
extension ConstrainULongRange: Any_ConstrainULong {}
extension UInt32: Any_ConstrainULong {}

public enum ConstrainULong: JSValueCompatible, Any_ConstrainULong {
    case constrainULongRange(ConstrainULongRange)
    case uInt32(UInt32)

    public var constrainULongRange: ConstrainULongRange? {
        switch self {
        case let .constrainULongRange(constrainULongRange): return constrainULongRange
        default: return nil
        }
    }

    public var uInt32: UInt32? {
        switch self {
        case let .uInt32(uInt32): return uInt32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainULongRange: ConstrainULongRange = value.fromJSValue() {
            return .constrainULongRange(constrainULongRange)
        }
        if let uInt32: UInt32 = value.fromJSValue() {
            return .uInt32(uInt32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainULongRange(constrainULongRange):
            return constrainULongRange.jsValue
        case let .uInt32(uInt32):
            return uInt32.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)

    public var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Array: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double where Element == DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)
    case seq_of_DOMPointInit_or_Double([DOMPointInit_or_Double])

    public var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]? {
        switch self {
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double): return seq_of_DOMPointInit_or_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double] = value.fromJSValue() {
            return .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double):
            return seq_of_DOMPointInit_or_Double.jsValue
        }
    }
}

public protocol Any_Document_or_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Document: Any_Document_or_XMLHttpRequestBodyInit {}
extension XMLHttpRequestBodyInit: Any_Document_or_XMLHttpRequestBodyInit {}

public enum Document_or_XMLHttpRequestBodyInit: JSValueCompatible, Any_Document_or_XMLHttpRequestBodyInit {
    case document(Document)
    case xmlHttpRequestBodyInit(XMLHttpRequestBodyInit)

    public var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    public var xmlHttpRequestBodyInit: XMLHttpRequestBodyInit? {
        switch self {
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit): return xmlHttpRequestBodyInit
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let xmlHttpRequestBodyInit: XMLHttpRequestBodyInit = value.fromJSValue() {
            return .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .document(document):
            return document.jsValue
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit):
            return xmlHttpRequestBodyInit.jsValue
        }
    }
}

public protocol Any_Double_or_KeyframeAnimationOptions: ConvertibleToJSValue {}
extension Double: Any_Double_or_KeyframeAnimationOptions {}
extension KeyframeAnimationOptions: Any_Double_or_KeyframeAnimationOptions {}

public enum Double_or_KeyframeAnimationOptions: JSValueCompatible, Any_Double_or_KeyframeAnimationOptions {
    case double(Double)
    case keyframeAnimationOptions(KeyframeAnimationOptions)

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var keyframeAnimationOptions: KeyframeAnimationOptions? {
        switch self {
        case let .keyframeAnimationOptions(keyframeAnimationOptions): return keyframeAnimationOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeAnimationOptions: KeyframeAnimationOptions = value.fromJSValue() {
            return .keyframeAnimationOptions(keyframeAnimationOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeAnimationOptions(keyframeAnimationOptions):
            return keyframeAnimationOptions.jsValue
        }
    }
}

public protocol Any_Double_or_KeyframeEffectOptions: ConvertibleToJSValue {}
extension Double: Any_Double_or_KeyframeEffectOptions {}
extension KeyframeEffectOptions: Any_Double_or_KeyframeEffectOptions {}

public enum Double_or_KeyframeEffectOptions: JSValueCompatible, Any_Double_or_KeyframeEffectOptions {
    case double(Double)
    case keyframeEffectOptions(KeyframeEffectOptions)

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var keyframeEffectOptions: KeyframeEffectOptions? {
        switch self {
        case let .keyframeEffectOptions(keyframeEffectOptions): return keyframeEffectOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeEffectOptions: KeyframeEffectOptions = value.fromJSValue() {
            return .keyframeEffectOptions(keyframeEffectOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeEffectOptions(keyframeEffectOptions):
            return keyframeEffectOptions.jsValue
        }
    }
}

public protocol Any_Double_or_String: ConvertibleToJSValue {}
extension Double: Any_Double_or_String {}
extension String: Any_Double_or_String {}

public enum Double_or_String: JSValueCompatible, Any_Double_or_String {
    case double(Double)
    case string(String)

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_ElementCreationOptions_or_String: ConvertibleToJSValue {}
extension ElementCreationOptions: Any_ElementCreationOptions_or_String {}
extension String: Any_ElementCreationOptions_or_String {}

public enum ElementCreationOptions_or_String: JSValueCompatible, Any_ElementCreationOptions_or_String {
    case elementCreationOptions(ElementCreationOptions)
    case string(String)

    public var elementCreationOptions: ElementCreationOptions? {
        switch self {
        case let .elementCreationOptions(elementCreationOptions): return elementCreationOptions
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let elementCreationOptions: ElementCreationOptions = value.fromJSValue() {
            return .elementCreationOptions(elementCreationOptions)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .elementCreationOptions(elementCreationOptions):
            return elementCreationOptions.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Element_or_HTMLCollection: ConvertibleToJSValue {}
extension Element: Any_Element_or_HTMLCollection {}
extension HTMLCollection: Any_Element_or_HTMLCollection {}

public enum Element_or_HTMLCollection: JSValueCompatible, Any_Element_or_HTMLCollection {
    case element(Element)
    case htmlCollection(HTMLCollection)

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var htmlCollection: HTMLCollection? {
        switch self {
        case let .htmlCollection(htmlCollection): return htmlCollection
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let htmlCollection: HTMLCollection = value.fromJSValue() {
            return .htmlCollection(htmlCollection)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .htmlCollection(htmlCollection):
            return htmlCollection.jsValue
        }
    }
}

public protocol Any_Element_or_RadioNodeList: ConvertibleToJSValue {}
extension Element: Any_Element_or_RadioNodeList {}
extension RadioNodeList: Any_Element_or_RadioNodeList {}

public enum Element_or_RadioNodeList: JSValueCompatible, Any_Element_or_RadioNodeList {
    case element(Element)
    case radioNodeList(RadioNodeList)

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var radioNodeList: RadioNodeList? {
        switch self {
        case let .radioNodeList(radioNodeList): return radioNodeList
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let radioNodeList: RadioNodeList = value.fromJSValue() {
            return .radioNodeList(radioNodeList)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .radioNodeList(radioNodeList):
            return radioNodeList.jsValue
        }
    }
}

public protocol Any_Element_or_Text: ConvertibleToJSValue {}
extension Element: Any_Element_or_Text {}
extension Text: Any_Element_or_Text {}

public enum Element_or_Text: JSValueCompatible, Any_Element_or_Text {
    case element(Element)
    case text(Text)

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_Event_or_String: ConvertibleToJSValue {}
extension Event: Any_Event_or_String {}
extension String: Any_Event_or_String {}

public enum Event_or_String: JSValueCompatible, Any_Event_or_String {
    case event(Event)
    case string(String)

    public var event: Event? {
        switch self {
        case let .event(event): return event
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let event: Event = value.fromJSValue() {
            return .event(event)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .event(event):
            return event.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_File_or_FormData_or_String: ConvertibleToJSValue {}
extension File: Any_File_or_FormData_or_String {}
extension FormData: Any_File_or_FormData_or_String {}
extension String: Any_File_or_FormData_or_String {}

public enum File_or_FormData_or_String: JSValueCompatible, Any_File_or_FormData_or_String {
    case file(File)
    case formData(FormData)
    case string(String)

    public var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    public var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Float32List: ConvertibleToJSValue {}
extension Float32Array: Any_Float32List {}
extension Array: Any_Float32List where Element == GLfloat {}

public enum Float32List: JSValueCompatible, Any_Float32List {
    case float32Array(Float32Array)
    case seq_of_GLfloat([GLfloat])

    public var float32Array: Float32Array? {
        switch self {
        case let .float32Array(float32Array): return float32Array
        default: return nil
        }
    }

    public var seq_of_GLfloat: [GLfloat]? {
        switch self {
        case let .seq_of_GLfloat(seq_of_GLfloat): return seq_of_GLfloat
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let float32Array: Float32Array = value.fromJSValue() {
            return .float32Array(float32Array)
        }
        if let seq_of_GLfloat: [GLfloat] = value.fromJSValue() {
            return .seq_of_GLfloat(seq_of_GLfloat)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .float32Array(float32Array):
            return float32Array.jsValue
        case let .seq_of_GLfloat(seq_of_GLfloat):
            return seq_of_GLfloat.jsValue
        }
    }
}

public protocol Any_FormDataEntryValue: ConvertibleToJSValue {}
extension File: Any_FormDataEntryValue {}
extension String: Any_FormDataEntryValue {}

public enum FormDataEntryValue: JSValueCompatible, Any_FormDataEntryValue {
    case file(File)
    case string(String)

    public var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_GeometryNode: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_GeometryNode {}
extension Document: Any_GeometryNode {}
extension Element: Any_GeometryNode {}
extension Text: Any_GeometryNode {}

public enum GeometryNode: JSValueCompatible, Any_GeometryNode {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)

    public var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    public var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .document(document):
            return document.jsValue
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLElement_or_Int32: ConvertibleToJSValue {}
extension HTMLElement: Any_HTMLElement_or_Int32 {}
extension Int32: Any_HTMLElement_or_Int32 {}

public enum HTMLElement_or_Int32: JSValueCompatible, Any_HTMLElement_or_Int32 {
    case htmlElement(HTMLElement)
    case int32(Int32)

    public var htmlElement: HTMLElement? {
        switch self {
        case let .htmlElement(htmlElement): return htmlElement
        default: return nil
        }
    }

    public var int32: Int32? {
        switch self {
        case let .int32(int32): return int32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlElement: HTMLElement = value.fromJSValue() {
            return .htmlElement(htmlElement)
        }
        if let int32: Int32 = value.fromJSValue() {
            return .int32(int32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlElement(htmlElement):
            return htmlElement.jsValue
        case let .int32(int32):
            return int32.jsValue
        }
    }
}

public protocol Any_HTMLOptGroupElement_or_HTMLOptionElement: ConvertibleToJSValue {}
extension HTMLOptGroupElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}
extension HTMLOptionElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}

public enum HTMLOptGroupElement_or_HTMLOptionElement: JSValueCompatible, Any_HTMLOptGroupElement_or_HTMLOptionElement {
    case htmlOptGroupElement(HTMLOptGroupElement)
    case htmlOptionElement(HTMLOptionElement)

    public var htmlOptGroupElement: HTMLOptGroupElement? {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement
        default: return nil
        }
    }

    public var htmlOptionElement: HTMLOptionElement? {
        switch self {
        case let .htmlOptionElement(htmlOptionElement): return htmlOptionElement
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlOptGroupElement: HTMLOptGroupElement = value.fromJSValue() {
            return .htmlOptGroupElement(htmlOptGroupElement)
        }
        if let htmlOptionElement: HTMLOptionElement = value.fromJSValue() {
            return .htmlOptionElement(htmlOptionElement)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement):
            return htmlOptGroupElement.jsValue
        case let .htmlOptionElement(htmlOptionElement):
            return htmlOptionElement.jsValue
        }
    }
}

public protocol Any_HeadersInit: ConvertibleToJSValue {}
extension Dictionary: Any_HeadersInit where Key == String, Value == String {}
extension Array: Any_HeadersInit where Element == [String] {}

public enum HeadersInit: JSValueCompatible, Any_HeadersInit {
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    public var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    public var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_ImageBitmapSource: ConvertibleToJSValue {}
extension Blob: Any_ImageBitmapSource {}
extension CanvasImageSource: Any_ImageBitmapSource {}
extension ImageData: Any_ImageBitmapSource {}

public enum ImageBitmapSource: JSValueCompatible, Any_ImageBitmapSource {
    case blob(Blob)
    case canvasImageSource(CanvasImageSource)
    case imageData(ImageData)

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var canvasImageSource: CanvasImageSource? {
        switch self {
        case let .canvasImageSource(canvasImageSource): return canvasImageSource
        default: return nil
        }
    }

    public var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let canvasImageSource: CanvasImageSource = value.fromJSValue() {
            return .canvasImageSource(canvasImageSource)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .canvasImageSource(canvasImageSource):
            return canvasImageSource.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        }
    }
}

public protocol Any_ImageBufferSource: ConvertibleToJSValue {}
extension BufferSource: Any_ImageBufferSource {}
extension ReadableStream: Any_ImageBufferSource {}

public enum ImageBufferSource: JSValueCompatible, Any_ImageBufferSource {
    case bufferSource(BufferSource)
    case readableStream(ReadableStream)

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var readableStream: ReadableStream? {
        switch self {
        case let .readableStream(readableStream): return readableStream
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let readableStream: ReadableStream = value.fromJSValue() {
            return .readableStream(readableStream)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .readableStream(readableStream):
            return readableStream.jsValue
        }
    }
}

public protocol Any_Int32List: ConvertibleToJSValue {}
extension Int32Array: Any_Int32List {}
extension Array: Any_Int32List where Element == GLint {}

public enum Int32List: JSValueCompatible, Any_Int32List {
    case int32Array(Int32Array)
    case seq_of_GLint([GLint])

    public var int32Array: Int32Array? {
        switch self {
        case let .int32Array(int32Array): return int32Array
        default: return nil
        }
    }

    public var seq_of_GLint: [GLint]? {
        switch self {
        case let .seq_of_GLint(seq_of_GLint): return seq_of_GLint
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let int32Array: Int32Array = value.fromJSValue() {
            return .int32Array(int32Array)
        }
        if let seq_of_GLint: [GLint] = value.fromJSValue() {
            return .seq_of_GLint(seq_of_GLint)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .int32Array(int32Array):
            return int32Array.jsValue
        case let .seq_of_GLint(seq_of_GLint):
            return seq_of_GLint.jsValue
        }
    }
}

public protocol Any_MessageEventSource: ConvertibleToJSValue {}
extension MessagePort: Any_MessageEventSource {}
extension ServiceWorker: Any_MessageEventSource {}
extension WindowProxy: Any_MessageEventSource {}

public enum MessageEventSource: JSValueCompatible, Any_MessageEventSource {
    case messagePort(MessagePort)
    case serviceWorker(ServiceWorker)
    case windowProxy(WindowProxy)

    public var messagePort: MessagePort? {
        switch self {
        case let .messagePort(messagePort): return messagePort
        default: return nil
        }
    }

    public var serviceWorker: ServiceWorker? {
        switch self {
        case let .serviceWorker(serviceWorker): return serviceWorker
        default: return nil
        }
    }

    public var windowProxy: WindowProxy? {
        switch self {
        case let .windowProxy(windowProxy): return windowProxy
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let messagePort: MessagePort = value.fromJSValue() {
            return .messagePort(messagePort)
        }
        if let serviceWorker: ServiceWorker = value.fromJSValue() {
            return .serviceWorker(serviceWorker)
        }
        if let windowProxy: WindowProxy = value.fromJSValue() {
            return .windowProxy(windowProxy)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .messagePort(messagePort):
            return messagePort.jsValue
        case let .serviceWorker(serviceWorker):
            return serviceWorker.jsValue
        case let .windowProxy(windowProxy):
            return windowProxy.jsValue
        }
    }
}

public protocol Any_Node_or_String: ConvertibleToJSValue {}
extension Node: Any_Node_or_String {}
extension String: Any_Node_or_String {}

public enum Node_or_String: JSValueCompatible, Any_Node_or_String {
    case node(Node)
    case string(String)

    public var node: Node? {
        switch self {
        case let .node(node): return node
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let node: Node = value.fromJSValue() {
            return .node(node)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .node(node):
            return node.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Path2D_or_String: ConvertibleToJSValue {}
extension Path2D: Any_Path2D_or_String {}
extension String: Any_Path2D_or_String {}

public enum Path2D_or_String: JSValueCompatible, Any_Path2D_or_String {
    case path2D(Path2D)
    case string(String)

    public var path2D: Path2D? {
        switch self {
        case let .path2D(path2D): return path2D
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let path2D: Path2D = value.fromJSValue() {
            return .path2D(path2D)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .path2D(path2D):
            return path2D.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_ReadableStreamController: ConvertibleToJSValue {}
extension ReadableByteStreamController: Any_ReadableStreamController {}
extension ReadableStreamDefaultController: Any_ReadableStreamController {}

public enum ReadableStreamController: JSValueCompatible, Any_ReadableStreamController {
    case readableByteStreamController(ReadableByteStreamController)
    case readableStreamDefaultController(ReadableStreamDefaultController)

    public var readableByteStreamController: ReadableByteStreamController? {
        switch self {
        case let .readableByteStreamController(readableByteStreamController): return readableByteStreamController
        default: return nil
        }
    }

    public var readableStreamDefaultController: ReadableStreamDefaultController? {
        switch self {
        case let .readableStreamDefaultController(readableStreamDefaultController): return readableStreamDefaultController
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableByteStreamController: ReadableByteStreamController = value.fromJSValue() {
            return .readableByteStreamController(readableByteStreamController)
        }
        if let readableStreamDefaultController: ReadableStreamDefaultController = value.fromJSValue() {
            return .readableStreamDefaultController(readableStreamDefaultController)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableByteStreamController(readableByteStreamController):
            return readableByteStreamController.jsValue
        case let .readableStreamDefaultController(readableStreamDefaultController):
            return readableStreamDefaultController.jsValue
        }
    }
}

public protocol Any_ReadableStreamReader: ConvertibleToJSValue {}
extension ReadableStreamBYOBReader: Any_ReadableStreamReader {}
extension ReadableStreamDefaultReader: Any_ReadableStreamReader {}

public enum ReadableStreamReader: JSValueCompatible, Any_ReadableStreamReader {
    case readableStreamBYOBReader(ReadableStreamBYOBReader)
    case readableStreamDefaultReader(ReadableStreamDefaultReader)

    public var readableStreamBYOBReader: ReadableStreamBYOBReader? {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader): return readableStreamBYOBReader
        default: return nil
        }
    }

    public var readableStreamDefaultReader: ReadableStreamDefaultReader? {
        switch self {
        case let .readableStreamDefaultReader(readableStreamDefaultReader): return readableStreamDefaultReader
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableStreamBYOBReader: ReadableStreamBYOBReader = value.fromJSValue() {
            return .readableStreamBYOBReader(readableStreamBYOBReader)
        }
        if let readableStreamDefaultReader: ReadableStreamDefaultReader = value.fromJSValue() {
            return .readableStreamDefaultReader(readableStreamDefaultReader)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader):
            return readableStreamBYOBReader.jsValue
        case let .readableStreamDefaultReader(readableStreamDefaultReader):
            return readableStreamDefaultReader.jsValue
        }
    }
}

public protocol Any_RequestInfo: ConvertibleToJSValue {}
extension Request: Any_RequestInfo {}
extension String: Any_RequestInfo {}

public enum RequestInfo: JSValueCompatible, Any_RequestInfo {
    case request(Request)
    case string(String)

    public var request: Request? {
        switch self {
        case let .request(request): return request
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let request: Request = value.fromJSValue() {
            return .request(request)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .request(request):
            return request.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_String_or_WorkerOptions: ConvertibleToJSValue {}
extension String: Any_String_or_WorkerOptions {}
extension WorkerOptions: Any_String_or_WorkerOptions {}

public enum String_or_WorkerOptions: JSValueCompatible, Any_String_or_WorkerOptions {
    case string(String)
    case workerOptions(WorkerOptions)

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var workerOptions: WorkerOptions? {
        switch self {
        case let .workerOptions(workerOptions): return workerOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let workerOptions: WorkerOptions = value.fromJSValue() {
            return .workerOptions(workerOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .workerOptions(workerOptions):
            return workerOptions.jsValue
        }
    }
}

public protocol Any_String_or_record_String_to_String_or_seq_of_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_record_String_to_String_or_seq_of_seq_of_String {}
extension Dictionary: Any_String_or_record_String_to_String_or_seq_of_seq_of_String where Key == String, Value == String {}
extension Array: Any_String_or_record_String_to_String_or_seq_of_seq_of_String where Element == [String] {}

public enum String_or_record_String_to_String_or_seq_of_seq_of_String: JSValueCompatible, Any_String_or_record_String_to_String_or_seq_of_seq_of_String {
    case string(String)
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    public var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_Double: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_Double {}
extension Array: Any_String_or_seq_of_Double where Element == Double {}

public enum String_or_seq_of_Double: JSValueCompatible, Any_String_or_seq_of_Double {
    case string(String)
    case seq_of_Double([Double])

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_Double: [Double]? {
        switch self {
        case let .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_TexImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_TexImageSource {}
extension HTMLImageElement: Any_TexImageSource {}
extension HTMLVideoElement: Any_TexImageSource {}
extension ImageBitmap: Any_TexImageSource {}
extension ImageData: Any_TexImageSource {}
extension OffscreenCanvas: Any_TexImageSource {}
extension VideoFrame: Any_TexImageSource {}

public enum TexImageSource: JSValueCompatible, Any_TexImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlImageElement(HTMLImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case imageData(ImageData)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var htmlImageElement: HTMLImageElement? {
        switch self {
        case let .htmlImageElement(htmlImageElement): return htmlImageElement
        default: return nil
        }
    }

    public var htmlVideoElement: HTMLVideoElement? {
        switch self {
        case let .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }

    public var imageBitmap: ImageBitmap? {
        switch self {
        case let .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }

    public var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public var videoFrame: VideoFrame? {
        switch self {
        case let .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlImageElement: HTMLImageElement = value.fromJSValue() {
            return .htmlImageElement(htmlImageElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlImageElement(htmlImageElement):
            return htmlImageElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_TimerHandler: ConvertibleToJSValue {}
extension JSFunction: Any_TimerHandler {}
extension String: Any_TimerHandler {}

public enum TimerHandler: JSValueCompatible, Any_TimerHandler {
    case jsFunction(JSFunction)
    case string(String)

    public var jsFunction: JSFunction? {
        switch self {
        case let .jsFunction(jsFunction): return jsFunction
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let jsFunction: JSFunction = value.fromJSValue() {
            return .jsFunction(jsFunction)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .jsFunction(jsFunction):
            return jsFunction.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Blob: Any_XMLHttpRequestBodyInit {}
extension BufferSource: Any_XMLHttpRequestBodyInit {}
extension FormData: Any_XMLHttpRequestBodyInit {}
extension String: Any_XMLHttpRequestBodyInit {}
extension URLSearchParams: Any_XMLHttpRequestBodyInit {}

public enum XMLHttpRequestBodyInit: JSValueCompatible, Any_XMLHttpRequestBodyInit {
    case blob(Blob)
    case bufferSource(BufferSource)
    case formData(FormData)
    case string(String)
    case urlSearchParams(URLSearchParams)

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var urlSearchParams: URLSearchParams? {
        switch self {
        case let .urlSearchParams(urlSearchParams): return urlSearchParams
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let urlSearchParams: URLSearchParams = value.fromJSValue() {
            return .urlSearchParams(urlSearchParams)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        case let .urlSearchParams(urlSearchParams):
            return urlSearchParams.jsValue
        }
    }
}

public protocol Any_nullable_Double_or_seq_of_nullable_Double: ConvertibleToJSValue {}
extension Optional: Any_nullable_Double_or_seq_of_nullable_Double where Wrapped == Double {}
extension Array: Any_nullable_Double_or_seq_of_nullable_Double where Element == Double? {}

public enum nullable_Double_or_seq_of_nullable_Double: JSValueCompatible, Any_nullable_Double_or_seq_of_nullable_Double {
    case nullable_Double(Double?)
    case seq_of_nullable_Double([Double?])

    public var nullable_Double: Double?? {
        switch self {
        case let .nullable_Double(nullable_Double): return nullable_Double
        default: return nil
        }
    }

    public var seq_of_nullable_Double: [Double?]? {
        switch self {
        case let .seq_of_nullable_Double(seq_of_nullable_Double): return seq_of_nullable_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let nullable_Double: Double? = value.fromJSValue() {
            return .nullable_Double(nullable_Double)
        }
        if let seq_of_nullable_Double: [Double?] = value.fromJSValue() {
            return .seq_of_nullable_Double(seq_of_nullable_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .nullable_Double(nullable_Double):
            return nullable_Double.jsValue
        case let .seq_of_nullable_Double(seq_of_nullable_Double):
            return seq_of_nullable_Double.jsValue
        }
    }
}
