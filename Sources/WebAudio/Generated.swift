// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptKit
import WebAPIBase

public class AnalyserNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AnalyserNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _fftSize = ReadWriteAttribute(jsObject: jsObject, name: Strings.fftSize)
        _frequencyBinCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequencyBinCount)
        _minDecibels = ReadWriteAttribute(jsObject: jsObject, name: Strings.minDecibels)
        _maxDecibels = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxDecibels)
        _smoothingTimeConstant = ReadWriteAttribute(jsObject: jsObject, name: Strings.smoothingTimeConstant)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: AnalyserOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @inlinable public func getFloatFrequencyData(array: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFloatFrequencyData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getByteFrequencyData(array: Uint8Array) {
        let this = jsObject
        _ = this[Strings.getByteFrequencyData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getFloatTimeDomainData(array: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFloatTimeDomainData].function!(this: this, arguments: [array.jsValue])
    }

    @inlinable public func getByteTimeDomainData(array: Uint8Array) {
        let this = jsObject
        _ = this[Strings.getByteTimeDomainData].function!(this: this, arguments: [array.jsValue])
    }

    @ReadWriteAttribute
    public var fftSize: UInt32

    @ReadonlyAttribute
    public var frequencyBinCount: UInt32

    @ReadWriteAttribute
    public var minDecibels: Double

    @ReadWriteAttribute
    public var maxDecibels: Double

    @ReadWriteAttribute
    public var smoothingTimeConstant: Double
}

public class AnalyserOptions: BridgedDictionary {
    public convenience init(fftSize: UInt32, maxDecibels: Double, minDecibels: Double, smoothingTimeConstant: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.fftSize] = fftSize.jsValue
        object[Strings.maxDecibels] = maxDecibels.jsValue
        object[Strings.minDecibels] = minDecibels.jsValue
        object[Strings.smoothingTimeConstant] = smoothingTimeConstant.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _fftSize = ReadWriteAttribute(jsObject: object, name: Strings.fftSize)
        _maxDecibels = ReadWriteAttribute(jsObject: object, name: Strings.maxDecibels)
        _minDecibels = ReadWriteAttribute(jsObject: object, name: Strings.minDecibels)
        _smoothingTimeConstant = ReadWriteAttribute(jsObject: object, name: Strings.smoothingTimeConstant)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var fftSize: UInt32

    @ReadWriteAttribute
    public var maxDecibels: Double

    @ReadWriteAttribute
    public var minDecibels: Double

    @ReadWriteAttribute
    public var smoothingTimeConstant: Double
}

public class AudioBuffer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleRate)
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: Strings.duration)
        _numberOfChannels = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfChannels)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(options: AudioBufferOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [options.jsValue]))
    }

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var duration: Double

    @ReadonlyAttribute
    public var numberOfChannels: UInt32

    @inlinable public func getChannelData(channel: UInt32) -> Float32Array {
        let this = jsObject
        return this[Strings.getChannelData].function!(this: this, arguments: [channel.jsValue]).fromJSValue()!
    }

    @inlinable public func copyFromChannel(destination: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.copyFromChannel].function!(this: this, arguments: [destination.jsValue, channelNumber.jsValue, bufferOffset?.jsValue ?? .undefined])
    }

    @inlinable public func copyToChannel(source: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.copyToChannel].function!(this: this, arguments: [source.jsValue, channelNumber.jsValue, bufferOffset?.jsValue ?? .undefined])
    }
}

public class AudioBufferOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.length] = length.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _length = ReadWriteAttribute(jsObject: object, name: Strings.length)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var sampleRate: Float
}

public class AudioBufferSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioBufferSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: jsObject, name: Strings.buffer)
        _playbackRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.playbackRate)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: Strings.loop)
        _loopStart = ReadWriteAttribute(jsObject: jsObject, name: Strings.loopStart)
        _loopEnd = ReadWriteAttribute(jsObject: jsObject, name: Strings.loopEnd)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: AudioBufferSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadonlyAttribute
    public var playbackRate: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @ReadWriteAttribute
    public var loop: Bool

    @ReadWriteAttribute
    public var loopStart: Double

    @ReadWriteAttribute
    public var loopEnd: Double

    // XXX: member 'start' is ignored
}

public class AudioBufferSourceOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, detune: Float, loop: Bool, loopEnd: Double, loopStart: Double, playbackRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.loop] = loop.jsValue
        object[Strings.loopEnd] = loopEnd.jsValue
        object[Strings.loopStart] = loopStart.jsValue
        object[Strings.playbackRate] = playbackRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _loop = ReadWriteAttribute(jsObject: object, name: Strings.loop)
        _loopEnd = ReadWriteAttribute(jsObject: object, name: Strings.loopEnd)
        _loopStart = ReadWriteAttribute(jsObject: object, name: Strings.loopStart)
        _playbackRate = ReadWriteAttribute(jsObject: object, name: Strings.playbackRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var loop: Bool

    @ReadWriteAttribute
    public var loopEnd: Double

    @ReadWriteAttribute
    public var loopStart: Double

    @ReadWriteAttribute
    public var playbackRate: Float
}

public class AudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioContext].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _baseLatency = ReadonlyAttribute(jsObject: jsObject, name: Strings.baseLatency)
        _outputLatency = ReadonlyAttribute(jsObject: jsObject, name: Strings.outputLatency)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(contextOptions: AudioContextOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [contextOptions?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var baseLatency: Double

    @ReadonlyAttribute
    public var outputLatency: Double

    @inlinable public func getOutputTimestamp() -> AudioTimestamp {
        let this = jsObject
        return this[Strings.getOutputTimestamp].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func suspend() -> JSPromise {
        let this = jsObject
        return this[Strings.suspend].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.suspend].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func createMediaElementSource(mediaElement: HTMLMediaElement) -> MediaElementAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaElementSource].function!(this: this, arguments: [mediaElement.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamSource(mediaStream: MediaStream) -> MediaStreamAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaStreamSource].function!(this: this, arguments: [mediaStream.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack) -> MediaStreamTrackAudioSourceNode {
        let this = jsObject
        return this[Strings.createMediaStreamTrackSource].function!(this: this, arguments: [mediaStreamTrack.jsValue]).fromJSValue()!
    }

    @inlinable public func createMediaStreamDestination() -> MediaStreamAudioDestinationNode {
        let this = jsObject
        return this[Strings.createMediaStreamDestination].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum AudioContextLatencyCategory: JSString, JSValueCompatible {
    case balanced = "balanced"
    case interactive = "interactive"
    case playback = "playback"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioContextOptions: BridgedDictionary {
    public convenience init(latencyHint: AudioContextLatencyCategory_or_Double, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.latencyHint] = latencyHint.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _latencyHint = ReadWriteAttribute(jsObject: object, name: Strings.latencyHint)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var latencyHint: AudioContextLatencyCategory_or_Double

    @ReadWriteAttribute
    public var sampleRate: Float
}

public enum AudioContextState: JSString, JSValueCompatible {
    case suspended = "suspended"
    case running = "running"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioDestinationNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _maxChannelCount = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxChannelCount)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var maxChannelCount: UInt32
}

public class AudioListener: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioListener].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _positionX = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionX)
        _positionY = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionY)
        _positionZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionZ)
        _forwardX = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardX)
        _forwardY = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardY)
        _forwardZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.forwardZ)
        _upX = ReadonlyAttribute(jsObject: jsObject, name: Strings.upX)
        _upY = ReadonlyAttribute(jsObject: jsObject, name: Strings.upY)
        _upZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.upZ)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var positionX: AudioParam

    @ReadonlyAttribute
    public var positionY: AudioParam

    @ReadonlyAttribute
    public var positionZ: AudioParam

    @ReadonlyAttribute
    public var forwardX: AudioParam

    @ReadonlyAttribute
    public var forwardY: AudioParam

    @ReadonlyAttribute
    public var forwardZ: AudioParam

    @ReadonlyAttribute
    public var upX: AudioParam

    @ReadonlyAttribute
    public var upY: AudioParam

    @ReadonlyAttribute
    public var upZ: AudioParam

    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setPosition].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable public func setOrientation(x: Float, y: Float, z: Float, xUp: Float, yUp: Float, zUp: Float) {
        let _arg0 = x.jsValue
        let _arg1 = y.jsValue
        let _arg2 = z.jsValue
        let _arg3 = xUp.jsValue
        let _arg4 = yUp.jsValue
        let _arg5 = zUp.jsValue
        let this = jsObject
        _ = this[Strings.setOrientation].function!(this: this, arguments: [_arg0, _arg1, _arg2, _arg3, _arg4, _arg5])
    }
}

public class AudioNode: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _context = ReadonlyAttribute(jsObject: jsObject, name: Strings.context)
        _numberOfInputs = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfInputs)
        _numberOfOutputs = ReadonlyAttribute(jsObject: jsObject, name: Strings.numberOfOutputs)
        _channelCount = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelCount)
        _channelCountMode = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelCountMode)
        _channelInterpretation = ReadWriteAttribute(jsObject: jsObject, name: Strings.channelInterpretation)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func connect(destinationNode: AudioNode, output: UInt32? = nil, input: UInt32? = nil) -> Self {
        let this = jsObject
        return this[Strings.connect].function!(this: this, arguments: [destinationNode.jsValue, output?.jsValue ?? .undefined, input?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func connect(destinationParam: AudioParam, output: UInt32? = nil) {
        let this = jsObject
        _ = this[Strings.connect].function!(this: this, arguments: [destinationParam.jsValue, output?.jsValue ?? .undefined])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func disconnect(output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [output.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue, output.jsValue])
    }

    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32, input: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationNode.jsValue, output.jsValue, input.jsValue])
    }

    @inlinable public func disconnect(destinationParam: AudioParam) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationParam.jsValue])
    }

    @inlinable public func disconnect(destinationParam: AudioParam, output: UInt32) {
        let this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [destinationParam.jsValue, output.jsValue])
    }

    @ReadonlyAttribute
    public var context: BaseAudioContext

    @ReadonlyAttribute
    public var numberOfInputs: UInt32

    @ReadonlyAttribute
    public var numberOfOutputs: UInt32

    @ReadWriteAttribute
    public var channelCount: UInt32

    @ReadWriteAttribute
    public var channelCountMode: ChannelCountMode

    @ReadWriteAttribute
    public var channelInterpretation: ChannelInterpretation
}

public class AudioNodeOptions: BridgedDictionary {
    public convenience init(channelCount: UInt32, channelCountMode: ChannelCountMode, channelInterpretation: ChannelInterpretation) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.channelCount] = channelCount.jsValue
        object[Strings.channelCountMode] = channelCountMode.jsValue
        object[Strings.channelInterpretation] = channelInterpretation.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _channelCount = ReadWriteAttribute(jsObject: object, name: Strings.channelCount)
        _channelCountMode = ReadWriteAttribute(jsObject: object, name: Strings.channelCountMode)
        _channelInterpretation = ReadWriteAttribute(jsObject: object, name: Strings.channelInterpretation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var channelCount: UInt32

    @ReadWriteAttribute
    public var channelCountMode: ChannelCountMode

    @ReadWriteAttribute
    public var channelInterpretation: ChannelInterpretation
}

public class AudioParam: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioParam].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: Strings.value)
        _automationRate = ReadWriteAttribute(jsObject: jsObject, name: Strings.automationRate)
        _defaultValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.defaultValue)
        _minValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.minValue)
        _maxValue = ReadonlyAttribute(jsObject: jsObject, name: Strings.maxValue)
        self.jsObject = jsObject
    }

    @ReadWriteAttribute
    public var value: Float

    @ReadWriteAttribute
    public var automationRate: AutomationRate

    @ReadonlyAttribute
    public var defaultValue: Float

    @ReadonlyAttribute
    public var minValue: Float

    @ReadonlyAttribute
    public var maxValue: Float

    @inlinable public func setValueAtTime(value: Float, startTime: Double) -> Self {
        let this = jsObject
        return this[Strings.setValueAtTime].function!(this: this, arguments: [value.jsValue, startTime.jsValue]).fromJSValue()!
    }

    @inlinable public func linearRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[Strings.linearRampToValueAtTime].function!(this: this, arguments: [value.jsValue, endTime.jsValue]).fromJSValue()!
    }

    @inlinable public func exponentialRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[Strings.exponentialRampToValueAtTime].function!(this: this, arguments: [value.jsValue, endTime.jsValue]).fromJSValue()!
    }

    @inlinable public func setTargetAtTime(target: Float, startTime: Double, timeConstant: Float) -> Self {
        let this = jsObject
        return this[Strings.setTargetAtTime].function!(this: this, arguments: [target.jsValue, startTime.jsValue, timeConstant.jsValue]).fromJSValue()!
    }

    @inlinable public func setValueCurveAtTime(values: [Float], startTime: Double, duration: Double) -> Self {
        let this = jsObject
        return this[Strings.setValueCurveAtTime].function!(this: this, arguments: [values.jsValue, startTime.jsValue, duration.jsValue]).fromJSValue()!
    }

    @inlinable public func cancelScheduledValues(cancelTime: Double) -> Self {
        let this = jsObject
        return this[Strings.cancelScheduledValues].function!(this: this, arguments: [cancelTime.jsValue]).fromJSValue()!
    }

    @inlinable public func cancelAndHoldAtTime(cancelTime: Double) -> Self {
        let this = jsObject
        return this[Strings.cancelAndHoldAtTime].function!(this: this, arguments: [cancelTime.jsValue]).fromJSValue()!
    }
}

public class AudioParamDescriptor: BridgedDictionary {
    public convenience init(name: String, defaultValue: Float, minValue: Float, maxValue: Float, automationRate: AutomationRate) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.name] = name.jsValue
        object[Strings.defaultValue] = defaultValue.jsValue
        object[Strings.minValue] = minValue.jsValue
        object[Strings.maxValue] = maxValue.jsValue
        object[Strings.automationRate] = automationRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _name = ReadWriteAttribute(jsObject: object, name: Strings.name)
        _defaultValue = ReadWriteAttribute(jsObject: object, name: Strings.defaultValue)
        _minValue = ReadWriteAttribute(jsObject: object, name: Strings.minValue)
        _maxValue = ReadWriteAttribute(jsObject: object, name: Strings.maxValue)
        _automationRate = ReadWriteAttribute(jsObject: object, name: Strings.automationRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var defaultValue: Float

    @ReadWriteAttribute
    public var minValue: Float

    @ReadWriteAttribute
    public var maxValue: Float

    @ReadWriteAttribute
    public var automationRate: AutomationRate
}

public class AudioParamMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioParamMap].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Map-like!
}

public class AudioProcessingEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioProcessingEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _playbackTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.playbackTime)
        _inputBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.inputBuffer)
        _outputBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.outputBuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: AudioProcessingEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var playbackTime: Double

    @ReadonlyAttribute
    public var inputBuffer: AudioBuffer

    @ReadonlyAttribute
    public var outputBuffer: AudioBuffer
}

public class AudioProcessingEventInit: BridgedDictionary {
    public convenience init(playbackTime: Double, inputBuffer: AudioBuffer, outputBuffer: AudioBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.playbackTime] = playbackTime.jsValue
        object[Strings.inputBuffer] = inputBuffer.jsValue
        object[Strings.outputBuffer] = outputBuffer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _playbackTime = ReadWriteAttribute(jsObject: object, name: Strings.playbackTime)
        _inputBuffer = ReadWriteAttribute(jsObject: object, name: Strings.inputBuffer)
        _outputBuffer = ReadWriteAttribute(jsObject: object, name: Strings.outputBuffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var playbackTime: Double

    @ReadWriteAttribute
    public var inputBuffer: AudioBuffer

    @ReadWriteAttribute
    public var outputBuffer: AudioBuffer
}

public class AudioScheduledSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioScheduledSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onended = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onended)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onended: EventHandler

    @inlinable public func start(when: Double? = nil) {
        let this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [when?.jsValue ?? .undefined])
    }

    @inlinable public func stop(when: Double? = nil) {
        let this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [when?.jsValue ?? .undefined])
    }
}

public class AudioTimestamp: BridgedDictionary {
    public convenience init(contextTime: Double, performanceTime: DOMHighResTimeStamp) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.contextTime] = contextTime.jsValue
        object[Strings.performanceTime] = performanceTime.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _contextTime = ReadWriteAttribute(jsObject: object, name: Strings.contextTime)
        _performanceTime = ReadWriteAttribute(jsObject: object, name: Strings.performanceTime)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var contextTime: Double

    @ReadWriteAttribute
    public var performanceTime: DOMHighResTimeStamp
}

public class AudioWorklet: Worklet {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioWorklet].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class AudioWorkletNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.AudioWorkletNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _parameters = ReadonlyAttribute(jsObject: jsObject, name: Strings.parameters)
        _port = ReadonlyAttribute(jsObject: jsObject, name: Strings.port)
        _onprocessorerror = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onprocessorerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, name: String, options: AudioWorkletNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, name.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var parameters: AudioParamMap

    @ReadonlyAttribute
    public var port: MessagePort

    @ClosureAttribute1Optional
    public var onprocessorerror: EventHandler
}

public class AudioWorkletNodeOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32, numberOfOutputs: UInt32, outputChannelCount: [UInt32], parameterData: [String: Double], processorOptions: JSObject) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfInputs] = numberOfInputs.jsValue
        object[Strings.numberOfOutputs] = numberOfOutputs.jsValue
        object[Strings.outputChannelCount] = outputChannelCount.jsValue
        object[Strings.parameterData] = parameterData.jsValue
        object[Strings.processorOptions] = processorOptions.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfInputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfInputs)
        _numberOfOutputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfOutputs)
        _outputChannelCount = ReadWriteAttribute(jsObject: object, name: Strings.outputChannelCount)
        _parameterData = ReadWriteAttribute(jsObject: object, name: Strings.parameterData)
        _processorOptions = ReadWriteAttribute(jsObject: object, name: Strings.processorOptions)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfInputs: UInt32

    @ReadWriteAttribute
    public var numberOfOutputs: UInt32

    @ReadWriteAttribute
    public var outputChannelCount: [UInt32]

    @ReadWriteAttribute
    public var parameterData: [String: Double]

    @ReadWriteAttribute
    public var processorOptions: JSObject
}

public enum AutomationRate: JSString, JSValueCompatible {
    case aRate = "a-rate"
    case kRate = "k-rate"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class BaseAudioContext: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.BaseAudioContext].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _destination = ReadonlyAttribute(jsObject: jsObject, name: Strings.destination)
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: Strings.sampleRate)
        _currentTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.currentTime)
        _listener = ReadonlyAttribute(jsObject: jsObject, name: Strings.listener)
        _state = ReadonlyAttribute(jsObject: jsObject, name: Strings.state)
        _audioWorklet = ReadonlyAttribute(jsObject: jsObject, name: Strings.audioWorklet)
        _onstatechange = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var destination: AudioDestinationNode

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var currentTime: Double

    @ReadonlyAttribute
    public var listener: AudioListener

    @ReadonlyAttribute
    public var state: AudioContextState

    @ReadonlyAttribute
    public var audioWorklet: AudioWorklet

    @ClosureAttribute1Optional
    public var onstatechange: EventHandler

    @inlinable public func createAnalyser() -> AnalyserNode {
        let this = jsObject
        return this[Strings.createAnalyser].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createBiquadFilter() -> BiquadFilterNode {
        let this = jsObject
        return this[Strings.createBiquadFilter].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createBuffer(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) -> AudioBuffer {
        let this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: [numberOfChannels.jsValue, length.jsValue, sampleRate.jsValue]).fromJSValue()!
    }

    @inlinable public func createBufferSource() -> AudioBufferSourceNode {
        let this = jsObject
        return this[Strings.createBufferSource].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createChannelMerger(numberOfInputs: UInt32? = nil) -> ChannelMergerNode {
        let this = jsObject
        return this[Strings.createChannelMerger].function!(this: this, arguments: [numberOfInputs?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createChannelSplitter(numberOfOutputs: UInt32? = nil) -> ChannelSplitterNode {
        let this = jsObject
        return this[Strings.createChannelSplitter].function!(this: this, arguments: [numberOfOutputs?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createConstantSource() -> ConstantSourceNode {
        let this = jsObject
        return this[Strings.createConstantSource].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createConvolver() -> ConvolverNode {
        let this = jsObject
        return this[Strings.createConvolver].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createDelay(maxDelayTime: Double? = nil) -> DelayNode {
        let this = jsObject
        return this[Strings.createDelay].function!(this: this, arguments: [maxDelayTime?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createDynamicsCompressor() -> DynamicsCompressorNode {
        let this = jsObject
        return this[Strings.createDynamicsCompressor].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createGain() -> GainNode {
        let this = jsObject
        return this[Strings.createGain].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createIIRFilter(feedforward: [Double], feedback: [Double]) -> IIRFilterNode {
        let this = jsObject
        return this[Strings.createIIRFilter].function!(this: this, arguments: [feedforward.jsValue, feedback.jsValue]).fromJSValue()!
    }

    @inlinable public func createOscillator() -> OscillatorNode {
        let this = jsObject
        return this[Strings.createOscillator].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createPanner() -> PannerNode {
        let this = jsObject
        return this[Strings.createPanner].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createPeriodicWave(real: [Float], imag: [Float], constraints: PeriodicWaveConstraints? = nil) -> PeriodicWave {
        let this = jsObject
        return this[Strings.createPeriodicWave].function!(this: this, arguments: [real.jsValue, imag.jsValue, constraints?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createScriptProcessor(bufferSize: UInt32? = nil, numberOfInputChannels: UInt32? = nil, numberOfOutputChannels: UInt32? = nil) -> ScriptProcessorNode {
        let this = jsObject
        return this[Strings.createScriptProcessor].function!(this: this, arguments: [bufferSize?.jsValue ?? .undefined, numberOfInputChannels?.jsValue ?? .undefined, numberOfOutputChannels?.jsValue ?? .undefined]).fromJSValue()!
    }

    @inlinable public func createStereoPanner() -> StereoPannerNode {
        let this = jsObject
        return this[Strings.createStereoPanner].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createWaveShaper() -> WaveShaperNode {
        let this = jsObject
        return this[Strings.createWaveShaper].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'decodeAudioData' is ignored

    // XXX: member 'decodeAudioData' is ignored
}

public class BiquadFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.BiquadFilterNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _frequency = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequency)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        _Q = ReadonlyAttribute(jsObject: jsObject, name: Strings.Q)
        _gain = ReadonlyAttribute(jsObject: jsObject, name: Strings.gain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: BiquadFilterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var type: BiquadFilterType

    @ReadonlyAttribute
    public var frequency: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @ReadonlyAttribute
    public var Q: AudioParam

    @ReadonlyAttribute
    public var gain: AudioParam

    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFrequencyResponse].function!(this: this, arguments: [frequencyHz.jsValue, magResponse.jsValue, phaseResponse.jsValue])
    }
}

public class BiquadFilterOptions: BridgedDictionary {
    public convenience init(type: BiquadFilterType, Q: Float, detune: Float, frequency: Float, gain: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.Q] = Q.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.frequency] = frequency.jsValue
        object[Strings.gain] = gain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _Q = ReadWriteAttribute(jsObject: object, name: Strings.Q)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _frequency = ReadWriteAttribute(jsObject: object, name: Strings.frequency)
        _gain = ReadWriteAttribute(jsObject: object, name: Strings.gain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: BiquadFilterType

    @ReadWriteAttribute
    public var Q: Float

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var frequency: Float

    @ReadWriteAttribute
    public var gain: Float
}

public enum BiquadFilterType: JSString, JSValueCompatible {
    case lowpass = "lowpass"
    case highpass = "highpass"
    case bandpass = "bandpass"
    case lowshelf = "lowshelf"
    case highshelf = "highshelf"
    case peaking = "peaking"
    case notch = "notch"
    case allpass = "allpass"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ChannelCountMode: JSString, JSValueCompatible {
    case max = "max"
    case clampedMax = "clamped-max"
    case explicit = "explicit"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ChannelInterpretation: JSString, JSValueCompatible {
    case speakers = "speakers"
    case discrete = "discrete"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ChannelMergerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.ChannelMergerNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ChannelMergerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class ChannelMergerOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfInputs] = numberOfInputs.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfInputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfInputs)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfInputs: UInt32
}

public class ChannelSplitterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.ChannelSplitterNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ChannelSplitterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class ChannelSplitterOptions: BridgedDictionary {
    public convenience init(numberOfOutputs: UInt32) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfOutputs] = numberOfOutputs.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfOutputs = ReadWriteAttribute(jsObject: object, name: Strings.numberOfOutputs)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfOutputs: UInt32
}

public class ConstantSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.ConstantSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _offset = ReadonlyAttribute(jsObject: jsObject, name: Strings.offset)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ConstantSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var offset: AudioParam
}

public class ConstantSourceOptions: BridgedDictionary {
    public convenience init(offset: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = offset.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: Strings.offset)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Float
}

public class ConvolverNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.ConvolverNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: jsObject, name: Strings.buffer)
        _normalize = ReadWriteAttribute(jsObject: jsObject, name: Strings.normalize)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: ConvolverOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var normalize: Bool
}

public class ConvolverOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, disableNormalization: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = buffer.jsValue
        object[Strings.disableNormalization] = disableNormalization.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: Strings.buffer)
        _disableNormalization = ReadWriteAttribute(jsObject: object, name: Strings.disableNormalization)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: AudioBuffer?

    @ReadWriteAttribute
    public var disableNormalization: Bool
}

public class DelayNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.DelayNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _delayTime = ReadonlyAttribute(jsObject: jsObject, name: Strings.delayTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: DelayOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var delayTime: AudioParam
}

public class DelayOptions: BridgedDictionary {
    public convenience init(maxDelayTime: Double, delayTime: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.maxDelayTime] = maxDelayTime.jsValue
        object[Strings.delayTime] = delayTime.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _maxDelayTime = ReadWriteAttribute(jsObject: object, name: Strings.maxDelayTime)
        _delayTime = ReadWriteAttribute(jsObject: object, name: Strings.delayTime)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var maxDelayTime: Double

    @ReadWriteAttribute
    public var delayTime: Double
}

public enum DistanceModelType: JSString, JSValueCompatible {
    case linear = "linear"
    case inverse = "inverse"
    case exponential = "exponential"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DynamicsCompressorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.DynamicsCompressorNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _threshold = ReadonlyAttribute(jsObject: jsObject, name: Strings.threshold)
        _knee = ReadonlyAttribute(jsObject: jsObject, name: Strings.knee)
        _ratio = ReadonlyAttribute(jsObject: jsObject, name: Strings.ratio)
        _reduction = ReadonlyAttribute(jsObject: jsObject, name: Strings.reduction)
        _attack = ReadonlyAttribute(jsObject: jsObject, name: Strings.attack)
        _release = ReadonlyAttribute(jsObject: jsObject, name: Strings.release)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: DynamicsCompressorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var threshold: AudioParam

    @ReadonlyAttribute
    public var knee: AudioParam

    @ReadonlyAttribute
    public var ratio: AudioParam

    @ReadonlyAttribute
    public var reduction: Float

    @ReadonlyAttribute
    public var attack: AudioParam

    @ReadonlyAttribute
    public var release: AudioParam
}

public class DynamicsCompressorOptions: BridgedDictionary {
    public convenience init(attack: Float, knee: Float, ratio: Float, release: Float, threshold: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.attack] = attack.jsValue
        object[Strings.knee] = knee.jsValue
        object[Strings.ratio] = ratio.jsValue
        object[Strings.release] = release.jsValue
        object[Strings.threshold] = threshold.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _attack = ReadWriteAttribute(jsObject: object, name: Strings.attack)
        _knee = ReadWriteAttribute(jsObject: object, name: Strings.knee)
        _ratio = ReadWriteAttribute(jsObject: object, name: Strings.ratio)
        _release = ReadWriteAttribute(jsObject: object, name: Strings.release)
        _threshold = ReadWriteAttribute(jsObject: object, name: Strings.threshold)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var attack: Float

    @ReadWriteAttribute
    public var knee: Float

    @ReadWriteAttribute
    public var ratio: Float

    @ReadWriteAttribute
    public var release: Float

    @ReadWriteAttribute
    public var threshold: Float
}

public class GainNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.GainNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _gain = ReadonlyAttribute(jsObject: jsObject, name: Strings.gain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: GainOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var gain: AudioParam
}

public class GainOptions: BridgedDictionary {
    public convenience init(gain: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.gain] = gain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _gain = ReadWriteAttribute(jsObject: object, name: Strings.gain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var gain: Float
}

public class IIRFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.IIRFilterNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: IIRFilterOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options.jsValue]))
    }

    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[Strings.getFrequencyResponse].function!(this: this, arguments: [frequencyHz.jsValue, magResponse.jsValue, phaseResponse.jsValue])
    }
}

public class IIRFilterOptions: BridgedDictionary {
    public convenience init(feedforward: [Double], feedback: [Double]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.feedforward] = feedforward.jsValue
        object[Strings.feedback] = feedback.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _feedforward = ReadWriteAttribute(jsObject: object, name: Strings.feedforward)
        _feedback = ReadWriteAttribute(jsObject: object, name: Strings.feedback)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var feedforward: [Double]

    @ReadWriteAttribute
    public var feedback: [Double]
}

public class MediaElementAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.MediaElementAudioSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mediaElement = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaElement)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaElementAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options.jsValue]))
    }

    @ReadonlyAttribute
    public var mediaElement: HTMLMediaElement
}

public class MediaElementAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaElement: HTMLMediaElement) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaElement] = mediaElement.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaElement = ReadWriteAttribute(jsObject: object, name: Strings.mediaElement)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaElement: HTMLMediaElement
}

public class MediaStreamAudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.MediaStreamAudioDestinationNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _stream = ReadonlyAttribute(jsObject: jsObject, name: Strings.stream)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: AudioNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var stream: MediaStream
}

public class MediaStreamAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.MediaStreamAudioSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mediaStream = ReadonlyAttribute(jsObject: jsObject, name: Strings.mediaStream)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaStreamAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options.jsValue]))
    }

    @ReadonlyAttribute
    public var mediaStream: MediaStream
}

public class MediaStreamAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStream: MediaStream) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaStream] = mediaStream.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaStream = ReadWriteAttribute(jsObject: object, name: Strings.mediaStream)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaStream: MediaStream
}

public class MediaStreamTrackAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.MediaStreamTrackAudioSourceNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: AudioContext, options: MediaStreamTrackAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options.jsValue]))
    }
}

public class MediaStreamTrackAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStreamTrack: MediaStreamTrack) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mediaStreamTrack] = mediaStreamTrack.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mediaStreamTrack = ReadWriteAttribute(jsObject: object, name: Strings.mediaStreamTrack)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mediaStreamTrack: MediaStreamTrack
}

public class OfflineAudioCompletionEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.OfflineAudioCompletionEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _renderedBuffer = ReadonlyAttribute(jsObject: jsObject, name: Strings.renderedBuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: OfflineAudioCompletionEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [type.jsValue, eventInitDict.jsValue]))
    }

    @ReadonlyAttribute
    public var renderedBuffer: AudioBuffer
}

public class OfflineAudioCompletionEventInit: BridgedDictionary {
    public convenience init(renderedBuffer: AudioBuffer) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.renderedBuffer] = renderedBuffer.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _renderedBuffer = ReadWriteAttribute(jsObject: object, name: Strings.renderedBuffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var renderedBuffer: AudioBuffer
}

public class OfflineAudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.OfflineAudioContext].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: Strings.length)
        _oncomplete = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.oncomplete)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(contextOptions: OfflineAudioContextOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [contextOptions.jsValue]))
    }

    @inlinable public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [numberOfChannels.jsValue, length.jsValue, sampleRate.jsValue]))
    }

    @inlinable public func startRendering() -> JSPromise {
        let this = jsObject
        return this[Strings.startRendering].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func startRendering() async throws -> AudioBuffer {
        let this = jsObject
        let _promise: JSPromise = this[Strings.startRendering].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func suspend(suspendTime: Double) -> JSPromise {
        let this = jsObject
        return this[Strings.suspend].function!(this: this, arguments: [suspendTime.jsValue]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend(suspendTime: Double) async throws {
        let this = jsObject
        let _promise: JSPromise = this[Strings.suspend].function!(this: this, arguments: [suspendTime.jsValue]).fromJSValue()!
        _ = try await _promise.value
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ClosureAttribute1Optional
    public var oncomplete: EventHandler
}

public class OfflineAudioContextOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.numberOfChannels] = numberOfChannels.jsValue
        object[Strings.length] = length.jsValue
        object[Strings.sampleRate] = sampleRate.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: Strings.numberOfChannels)
        _length = ReadWriteAttribute(jsObject: object, name: Strings.length)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: Strings.sampleRate)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var sampleRate: Float
}

public class OscillatorNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.OscillatorNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadWriteAttribute(jsObject: jsObject, name: Strings.type)
        _frequency = ReadonlyAttribute(jsObject: jsObject, name: Strings.frequency)
        _detune = ReadonlyAttribute(jsObject: jsObject, name: Strings.detune)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: OscillatorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var type: OscillatorType

    @ReadonlyAttribute
    public var frequency: AudioParam

    @ReadonlyAttribute
    public var detune: AudioParam

    @inlinable public func setPeriodicWave(periodicWave: PeriodicWave) {
        let this = jsObject
        _ = this[Strings.setPeriodicWave].function!(this: this, arguments: [periodicWave.jsValue])
    }
}

public class OscillatorOptions: BridgedDictionary {
    public convenience init(type: OscillatorType, frequency: Float, detune: Float, periodicWave: PeriodicWave) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = type.jsValue
        object[Strings.frequency] = frequency.jsValue
        object[Strings.detune] = detune.jsValue
        object[Strings.periodicWave] = periodicWave.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: Strings.type)
        _frequency = ReadWriteAttribute(jsObject: object, name: Strings.frequency)
        _detune = ReadWriteAttribute(jsObject: object, name: Strings.detune)
        _periodicWave = ReadWriteAttribute(jsObject: object, name: Strings.periodicWave)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: OscillatorType

    @ReadWriteAttribute
    public var frequency: Float

    @ReadWriteAttribute
    public var detune: Float

    @ReadWriteAttribute
    public var periodicWave: PeriodicWave
}

public enum OscillatorType: JSString, JSValueCompatible {
    case sine = "sine"
    case square = "square"
    case sawtooth = "sawtooth"
    case triangle = "triangle"
    case custom = "custom"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum OverSampleType: JSString, JSValueCompatible {
    case none = "none"
    case _2x = "2x"
    case _4x = "4x"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.PannerNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _panningModel = ReadWriteAttribute(jsObject: jsObject, name: Strings.panningModel)
        _positionX = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionX)
        _positionY = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionY)
        _positionZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.positionZ)
        _orientationX = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationX)
        _orientationY = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationY)
        _orientationZ = ReadonlyAttribute(jsObject: jsObject, name: Strings.orientationZ)
        _distanceModel = ReadWriteAttribute(jsObject: jsObject, name: Strings.distanceModel)
        _refDistance = ReadWriteAttribute(jsObject: jsObject, name: Strings.refDistance)
        _maxDistance = ReadWriteAttribute(jsObject: jsObject, name: Strings.maxDistance)
        _rolloffFactor = ReadWriteAttribute(jsObject: jsObject, name: Strings.rolloffFactor)
        _coneInnerAngle = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneInnerAngle)
        _coneOuterAngle = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneOuterAngle)
        _coneOuterGain = ReadWriteAttribute(jsObject: jsObject, name: Strings.coneOuterGain)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: PannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var panningModel: PanningModelType

    @ReadonlyAttribute
    public var positionX: AudioParam

    @ReadonlyAttribute
    public var positionY: AudioParam

    @ReadonlyAttribute
    public var positionZ: AudioParam

    @ReadonlyAttribute
    public var orientationX: AudioParam

    @ReadonlyAttribute
    public var orientationY: AudioParam

    @ReadonlyAttribute
    public var orientationZ: AudioParam

    @ReadWriteAttribute
    public var distanceModel: DistanceModelType

    @ReadWriteAttribute
    public var refDistance: Double

    @ReadWriteAttribute
    public var maxDistance: Double

    @ReadWriteAttribute
    public var rolloffFactor: Double

    @ReadWriteAttribute
    public var coneInnerAngle: Double

    @ReadWriteAttribute
    public var coneOuterAngle: Double

    @ReadWriteAttribute
    public var coneOuterGain: Double

    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setPosition].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }

    @inlinable public func setOrientation(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[Strings.setOrientation].function!(this: this, arguments: [x.jsValue, y.jsValue, z.jsValue])
    }
}

public class PannerOptions: BridgedDictionary {
    public convenience init(panningModel: PanningModelType, distanceModel: DistanceModelType, positionX: Float, positionY: Float, positionZ: Float, orientationX: Float, orientationY: Float, orientationZ: Float, refDistance: Double, maxDistance: Double, rolloffFactor: Double, coneInnerAngle: Double, coneOuterAngle: Double, coneOuterGain: Double) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.panningModel] = panningModel.jsValue
        object[Strings.distanceModel] = distanceModel.jsValue
        object[Strings.positionX] = positionX.jsValue
        object[Strings.positionY] = positionY.jsValue
        object[Strings.positionZ] = positionZ.jsValue
        object[Strings.orientationX] = orientationX.jsValue
        object[Strings.orientationY] = orientationY.jsValue
        object[Strings.orientationZ] = orientationZ.jsValue
        object[Strings.refDistance] = refDistance.jsValue
        object[Strings.maxDistance] = maxDistance.jsValue
        object[Strings.rolloffFactor] = rolloffFactor.jsValue
        object[Strings.coneInnerAngle] = coneInnerAngle.jsValue
        object[Strings.coneOuterAngle] = coneOuterAngle.jsValue
        object[Strings.coneOuterGain] = coneOuterGain.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _panningModel = ReadWriteAttribute(jsObject: object, name: Strings.panningModel)
        _distanceModel = ReadWriteAttribute(jsObject: object, name: Strings.distanceModel)
        _positionX = ReadWriteAttribute(jsObject: object, name: Strings.positionX)
        _positionY = ReadWriteAttribute(jsObject: object, name: Strings.positionY)
        _positionZ = ReadWriteAttribute(jsObject: object, name: Strings.positionZ)
        _orientationX = ReadWriteAttribute(jsObject: object, name: Strings.orientationX)
        _orientationY = ReadWriteAttribute(jsObject: object, name: Strings.orientationY)
        _orientationZ = ReadWriteAttribute(jsObject: object, name: Strings.orientationZ)
        _refDistance = ReadWriteAttribute(jsObject: object, name: Strings.refDistance)
        _maxDistance = ReadWriteAttribute(jsObject: object, name: Strings.maxDistance)
        _rolloffFactor = ReadWriteAttribute(jsObject: object, name: Strings.rolloffFactor)
        _coneInnerAngle = ReadWriteAttribute(jsObject: object, name: Strings.coneInnerAngle)
        _coneOuterAngle = ReadWriteAttribute(jsObject: object, name: Strings.coneOuterAngle)
        _coneOuterGain = ReadWriteAttribute(jsObject: object, name: Strings.coneOuterGain)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var panningModel: PanningModelType

    @ReadWriteAttribute
    public var distanceModel: DistanceModelType

    @ReadWriteAttribute
    public var positionX: Float

    @ReadWriteAttribute
    public var positionY: Float

    @ReadWriteAttribute
    public var positionZ: Float

    @ReadWriteAttribute
    public var orientationX: Float

    @ReadWriteAttribute
    public var orientationY: Float

    @ReadWriteAttribute
    public var orientationZ: Float

    @ReadWriteAttribute
    public var refDistance: Double

    @ReadWriteAttribute
    public var maxDistance: Double

    @ReadWriteAttribute
    public var rolloffFactor: Double

    @ReadWriteAttribute
    public var coneInnerAngle: Double

    @ReadWriteAttribute
    public var coneOuterAngle: Double

    @ReadWriteAttribute
    public var coneOuterGain: Double
}

public enum PanningModelType: JSString, JSValueCompatible {
    case equalpower = "equalpower"
    case hRTF = "HRTF"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PeriodicWave: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.PeriodicWave].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(context: BaseAudioContext, options: PeriodicWaveOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }
}

public class PeriodicWaveConstraints: BridgedDictionary {
    public convenience init(disableNormalization: Bool) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.disableNormalization] = disableNormalization.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _disableNormalization = ReadWriteAttribute(jsObject: object, name: Strings.disableNormalization)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var disableNormalization: Bool
}

public class PeriodicWaveOptions: BridgedDictionary {
    public convenience init(real: [Float], imag: [Float]) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.real] = real.jsValue
        object[Strings.imag] = imag.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _real = ReadWriteAttribute(jsObject: object, name: Strings.real)
        _imag = ReadWriteAttribute(jsObject: object, name: Strings.imag)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var real: [Float]

    @ReadWriteAttribute
    public var imag: [Float]
}

public class ScriptProcessorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.ScriptProcessorNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onaudioprocess = ClosureAttribute1Optional(jsObject: jsObject, name: Strings.onaudioprocess)
        _bufferSize = ReadonlyAttribute(jsObject: jsObject, name: Strings.bufferSize)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onaudioprocess: EventHandler

    @ReadonlyAttribute
    public var bufferSize: Int32
}

public class StereoPannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.StereoPannerNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _pan = ReadonlyAttribute(jsObject: jsObject, name: Strings.pan)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: StereoPannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadonlyAttribute
    public var pan: AudioParam
}

public class StereoPannerOptions: BridgedDictionary {
    public convenience init(pan: Float) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.pan] = pan.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _pan = ReadWriteAttribute(jsObject: object, name: Strings.pan)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var pan: Float
}

public typealias DecodeErrorCallback = (DOMException) -> Void
public typealias DecodeSuccessCallback = (AudioBuffer) -> Void
public typealias AudioWorkletProcessCallback = ([[Float32Array]], [[Float32Array]], JSObject) -> Bool
public class WaveShaperNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[Strings.WaveShaperNode].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _curve = ReadWriteAttribute(jsObject: jsObject, name: Strings.curve)
        _oversample = ReadWriteAttribute(jsObject: jsObject, name: Strings.oversample)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, options: WaveShaperOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [context.jsValue, options?.jsValue ?? .undefined]))
    }

    @ReadWriteAttribute
    public var curve: Float32Array?

    @ReadWriteAttribute
    public var oversample: OverSampleType
}

public class WaveShaperOptions: BridgedDictionary {
    public convenience init(curve: [Float], oversample: OverSampleType) {
        let object = JSObject.global[Strings.Object].function!.new()
        object[Strings.curve] = curve.jsValue
        object[Strings.oversample] = oversample.jsValue
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _curve = ReadWriteAttribute(jsObject: object, name: Strings.curve)
        _oversample = ReadWriteAttribute(jsObject: object, name: Strings.oversample)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var curve: [Float]

    @ReadWriteAttribute
    public var oversample: OverSampleType
}

@usableFromInline enum Strings {
    static let _self: JSString = "self"
    @usableFromInline static let AnalyserNode: JSString = "AnalyserNode"
    @usableFromInline static let AudioBuffer: JSString = "AudioBuffer"
    @usableFromInline static let AudioBufferSourceNode: JSString = "AudioBufferSourceNode"
    @usableFromInline static let AudioContext: JSString = "AudioContext"
    @usableFromInline static let AudioDestinationNode: JSString = "AudioDestinationNode"
    @usableFromInline static let AudioListener: JSString = "AudioListener"
    @usableFromInline static let AudioNode: JSString = "AudioNode"
    @usableFromInline static let AudioParam: JSString = "AudioParam"
    @usableFromInline static let AudioParamMap: JSString = "AudioParamMap"
    @usableFromInline static let AudioProcessingEvent: JSString = "AudioProcessingEvent"
    @usableFromInline static let AudioScheduledSourceNode: JSString = "AudioScheduledSourceNode"
    @usableFromInline static let AudioWorklet: JSString = "AudioWorklet"
    @usableFromInline static let AudioWorkletNode: JSString = "AudioWorkletNode"
    @usableFromInline static let BaseAudioContext: JSString = "BaseAudioContext"
    @usableFromInline static let BiquadFilterNode: JSString = "BiquadFilterNode"
    @usableFromInline static let ChannelMergerNode: JSString = "ChannelMergerNode"
    @usableFromInline static let ChannelSplitterNode: JSString = "ChannelSplitterNode"
    @usableFromInline static let ConstantSourceNode: JSString = "ConstantSourceNode"
    @usableFromInline static let ConvolverNode: JSString = "ConvolverNode"
    @usableFromInline static let DelayNode: JSString = "DelayNode"
    @usableFromInline static let DynamicsCompressorNode: JSString = "DynamicsCompressorNode"
    @usableFromInline static let GainNode: JSString = "GainNode"
    @usableFromInline static let IIRFilterNode: JSString = "IIRFilterNode"
    @usableFromInline static let MediaElementAudioSourceNode: JSString = "MediaElementAudioSourceNode"
    @usableFromInline static let MediaStreamAudioDestinationNode: JSString = "MediaStreamAudioDestinationNode"
    @usableFromInline static let MediaStreamAudioSourceNode: JSString = "MediaStreamAudioSourceNode"
    @usableFromInline static let MediaStreamTrackAudioSourceNode: JSString = "MediaStreamTrackAudioSourceNode"
    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let OfflineAudioCompletionEvent: JSString = "OfflineAudioCompletionEvent"
    @usableFromInline static let OfflineAudioContext: JSString = "OfflineAudioContext"
    @usableFromInline static let OscillatorNode: JSString = "OscillatorNode"
    @usableFromInline static let PannerNode: JSString = "PannerNode"
    @usableFromInline static let PeriodicWave: JSString = "PeriodicWave"
    @usableFromInline static let Q: JSString = "Q"
    @usableFromInline static let ScriptProcessorNode: JSString = "ScriptProcessorNode"
    @usableFromInline static let StereoPannerNode: JSString = "StereoPannerNode"
    @usableFromInline static let WaveShaperNode: JSString = "WaveShaperNode"
    @usableFromInline static let attack: JSString = "attack"
    @usableFromInline static let audioWorklet: JSString = "audioWorklet"
    @usableFromInline static let automationRate: JSString = "automationRate"
    @usableFromInline static let baseLatency: JSString = "baseLatency"
    @usableFromInline static let buffer: JSString = "buffer"
    @usableFromInline static let bufferSize: JSString = "bufferSize"
    @usableFromInline static let cancelAndHoldAtTime: JSString = "cancelAndHoldAtTime"
    @usableFromInline static let cancelScheduledValues: JSString = "cancelScheduledValues"
    @usableFromInline static let channelCount: JSString = "channelCount"
    @usableFromInline static let channelCountMode: JSString = "channelCountMode"
    @usableFromInline static let channelInterpretation: JSString = "channelInterpretation"
    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let coneInnerAngle: JSString = "coneInnerAngle"
    @usableFromInline static let coneOuterAngle: JSString = "coneOuterAngle"
    @usableFromInline static let coneOuterGain: JSString = "coneOuterGain"
    @usableFromInline static let connect: JSString = "connect"
    @usableFromInline static let context: JSString = "context"
    @usableFromInline static let contextTime: JSString = "contextTime"
    @usableFromInline static let copyFromChannel: JSString = "copyFromChannel"
    @usableFromInline static let copyToChannel: JSString = "copyToChannel"
    @usableFromInline static let createAnalyser: JSString = "createAnalyser"
    @usableFromInline static let createBiquadFilter: JSString = "createBiquadFilter"
    @usableFromInline static let createBuffer: JSString = "createBuffer"
    @usableFromInline static let createBufferSource: JSString = "createBufferSource"
    @usableFromInline static let createChannelMerger: JSString = "createChannelMerger"
    @usableFromInline static let createChannelSplitter: JSString = "createChannelSplitter"
    @usableFromInline static let createConstantSource: JSString = "createConstantSource"
    @usableFromInline static let createConvolver: JSString = "createConvolver"
    @usableFromInline static let createDelay: JSString = "createDelay"
    @usableFromInline static let createDynamicsCompressor: JSString = "createDynamicsCompressor"
    @usableFromInline static let createGain: JSString = "createGain"
    @usableFromInline static let createIIRFilter: JSString = "createIIRFilter"
    @usableFromInline static let createMediaElementSource: JSString = "createMediaElementSource"
    @usableFromInline static let createMediaStreamDestination: JSString = "createMediaStreamDestination"
    @usableFromInline static let createMediaStreamSource: JSString = "createMediaStreamSource"
    @usableFromInline static let createMediaStreamTrackSource: JSString = "createMediaStreamTrackSource"
    @usableFromInline static let createOscillator: JSString = "createOscillator"
    @usableFromInline static let createPanner: JSString = "createPanner"
    @usableFromInline static let createPeriodicWave: JSString = "createPeriodicWave"
    @usableFromInline static let createScriptProcessor: JSString = "createScriptProcessor"
    @usableFromInline static let createStereoPanner: JSString = "createStereoPanner"
    @usableFromInline static let createWaveShaper: JSString = "createWaveShaper"
    @usableFromInline static let currentTime: JSString = "currentTime"
    @usableFromInline static let curve: JSString = "curve"
    @usableFromInline static let defaultValue: JSString = "defaultValue"
    @usableFromInline static let delayTime: JSString = "delayTime"
    @usableFromInline static let destination: JSString = "destination"
    @usableFromInline static let detune: JSString = "detune"
    @usableFromInline static let disableNormalization: JSString = "disableNormalization"
    @usableFromInline static let disconnect: JSString = "disconnect"
    @usableFromInline static let distanceModel: JSString = "distanceModel"
    @usableFromInline static let duration: JSString = "duration"
    @usableFromInline static let exponentialRampToValueAtTime: JSString = "exponentialRampToValueAtTime"
    @usableFromInline static let feedback: JSString = "feedback"
    @usableFromInline static let feedforward: JSString = "feedforward"
    @usableFromInline static let fftSize: JSString = "fftSize"
    @usableFromInline static let forwardX: JSString = "forwardX"
    @usableFromInline static let forwardY: JSString = "forwardY"
    @usableFromInline static let forwardZ: JSString = "forwardZ"
    @usableFromInline static let frequency: JSString = "frequency"
    @usableFromInline static let frequencyBinCount: JSString = "frequencyBinCount"
    @usableFromInline static let gain: JSString = "gain"
    @usableFromInline static let getByteFrequencyData: JSString = "getByteFrequencyData"
    @usableFromInline static let getByteTimeDomainData: JSString = "getByteTimeDomainData"
    @usableFromInline static let getChannelData: JSString = "getChannelData"
    @usableFromInline static let getFloatFrequencyData: JSString = "getFloatFrequencyData"
    @usableFromInline static let getFloatTimeDomainData: JSString = "getFloatTimeDomainData"
    @usableFromInline static let getFrequencyResponse: JSString = "getFrequencyResponse"
    @usableFromInline static let getOutputTimestamp: JSString = "getOutputTimestamp"
    @usableFromInline static let imag: JSString = "imag"
    @usableFromInline static let inputBuffer: JSString = "inputBuffer"
    @usableFromInline static let knee: JSString = "knee"
    @usableFromInline static let latencyHint: JSString = "latencyHint"
    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let linearRampToValueAtTime: JSString = "linearRampToValueAtTime"
    @usableFromInline static let listener: JSString = "listener"
    @usableFromInline static let loop: JSString = "loop"
    @usableFromInline static let loopEnd: JSString = "loopEnd"
    @usableFromInline static let loopStart: JSString = "loopStart"
    @usableFromInline static let maxChannelCount: JSString = "maxChannelCount"
    @usableFromInline static let maxDecibels: JSString = "maxDecibels"
    @usableFromInline static let maxDelayTime: JSString = "maxDelayTime"
    @usableFromInline static let maxDistance: JSString = "maxDistance"
    @usableFromInline static let maxValue: JSString = "maxValue"
    @usableFromInline static let mediaElement: JSString = "mediaElement"
    @usableFromInline static let mediaStream: JSString = "mediaStream"
    @usableFromInline static let mediaStreamTrack: JSString = "mediaStreamTrack"
    @usableFromInline static let minDecibels: JSString = "minDecibels"
    @usableFromInline static let minValue: JSString = "minValue"
    @usableFromInline static let name: JSString = "name"
    @usableFromInline static let normalize: JSString = "normalize"
    @usableFromInline static let numberOfChannels: JSString = "numberOfChannels"
    @usableFromInline static let numberOfInputs: JSString = "numberOfInputs"
    @usableFromInline static let numberOfOutputs: JSString = "numberOfOutputs"
    @usableFromInline static let offset: JSString = "offset"
    @usableFromInline static let onaudioprocess: JSString = "onaudioprocess"
    @usableFromInline static let oncomplete: JSString = "oncomplete"
    @usableFromInline static let onended: JSString = "onended"
    @usableFromInline static let onprocessorerror: JSString = "onprocessorerror"
    @usableFromInline static let onstatechange: JSString = "onstatechange"
    @usableFromInline static let orientationX: JSString = "orientationX"
    @usableFromInline static let orientationY: JSString = "orientationY"
    @usableFromInline static let orientationZ: JSString = "orientationZ"
    @usableFromInline static let outputBuffer: JSString = "outputBuffer"
    @usableFromInline static let outputChannelCount: JSString = "outputChannelCount"
    @usableFromInline static let outputLatency: JSString = "outputLatency"
    @usableFromInline static let oversample: JSString = "oversample"
    @usableFromInline static let pan: JSString = "pan"
    @usableFromInline static let panningModel: JSString = "panningModel"
    @usableFromInline static let parameterData: JSString = "parameterData"
    @usableFromInline static let parameters: JSString = "parameters"
    @usableFromInline static let performanceTime: JSString = "performanceTime"
    @usableFromInline static let periodicWave: JSString = "periodicWave"
    @usableFromInline static let playbackRate: JSString = "playbackRate"
    @usableFromInline static let playbackTime: JSString = "playbackTime"
    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let positionX: JSString = "positionX"
    @usableFromInline static let positionY: JSString = "positionY"
    @usableFromInline static let positionZ: JSString = "positionZ"
    @usableFromInline static let processorOptions: JSString = "processorOptions"
    @usableFromInline static let ratio: JSString = "ratio"
    @usableFromInline static let real: JSString = "real"
    @usableFromInline static let reduction: JSString = "reduction"
    @usableFromInline static let refDistance: JSString = "refDistance"
    @usableFromInline static let release: JSString = "release"
    @usableFromInline static let renderedBuffer: JSString = "renderedBuffer"
    @usableFromInline static let resume: JSString = "resume"
    @usableFromInline static let rolloffFactor: JSString = "rolloffFactor"
    @usableFromInline static let sampleRate: JSString = "sampleRate"
    @usableFromInline static let setOrientation: JSString = "setOrientation"
    @usableFromInline static let setPeriodicWave: JSString = "setPeriodicWave"
    @usableFromInline static let setPosition: JSString = "setPosition"
    @usableFromInline static let setTargetAtTime: JSString = "setTargetAtTime"
    @usableFromInline static let setValueAtTime: JSString = "setValueAtTime"
    @usableFromInline static let setValueCurveAtTime: JSString = "setValueCurveAtTime"
    @usableFromInline static let smoothingTimeConstant: JSString = "smoothingTimeConstant"
    @usableFromInline static let start: JSString = "start"
    @usableFromInline static let startRendering: JSString = "startRendering"
    @usableFromInline static let state: JSString = "state"
    @usableFromInline static let stop: JSString = "stop"
    @usableFromInline static let stream: JSString = "stream"
    @usableFromInline static let suspend: JSString = "suspend"
    @usableFromInline static let threshold: JSString = "threshold"
    @usableFromInline static let toString: JSString = "toString"
    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let upX: JSString = "upX"
    @usableFromInline static let upY: JSString = "upY"
    @usableFromInline static let upZ: JSString = "upZ"
    @usableFromInline static let value: JSString = "value"
}

public protocol Any_AudioContextLatencyCategory_or_Double: ConvertibleToJSValue {}
extension AudioContextLatencyCategory: Any_AudioContextLatencyCategory_or_Double {}
extension Double: Any_AudioContextLatencyCategory_or_Double {}

public enum AudioContextLatencyCategory_or_Double: JSValueCompatible, Any_AudioContextLatencyCategory_or_Double {
    case audioContextLatencyCategory(AudioContextLatencyCategory)
    case double(Double)

    public var audioContextLatencyCategory: AudioContextLatencyCategory? {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory): return audioContextLatencyCategory
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioContextLatencyCategory: AudioContextLatencyCategory = value.fromJSValue() {
            return .audioContextLatencyCategory(audioContextLatencyCategory)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory):
            return audioContextLatencyCategory.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}
